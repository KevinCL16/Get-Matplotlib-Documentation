[
{
    "data": "  fruits = ['apple blueberry cherry orange'] counts = [40, 100, 30, 55] bar_labels = ['red blue _red orange'] bar_colors = ['tab:red tab:blue tab:red tab:orange']  ",
    "instruction": "  Create a bar chart using matplotlib. Use the following data to plot it:  fruits = ['apple blueberry cherry orange'],  counts = [40, 100, 30, 55].   Set the color of the bars to red, blue, red, and orange respectively, and set the labels for the bars as red, blue, _red, and orange.   Add a legend with the title \"Fruit color\". Set the y-axis label as \"fruit supply\" and the title of the chart as \"Fruit supply by kind and color\". ",
    "id": 0
},
{
    "data": "  species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), } width = 0.5  ",
    "instruction": "  Create a stacked bar chart using matplotlib. Use the following data to plot it:   species = (     'Adelie\\n $\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\mu=$3733.09g',     'Gentoo\\n $\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }. ",
    "id": 1
},
{
    "data": "  species = ('Adelie', 'Chinstrap', 'Gentoo') penguin_means = {     'Bill Depth': (18.35, 18.43, 14.98),     'Bill Length': (38.79, 48.83, 47.50),     'Flipper Length': (189.95, 195.82, 217.19), } x = np.arange(len(species)) width = 0.25 multiplier = 0  ",
    "instruction": "  To create a grouped bar chart with labels, use the following data: species = ('Adelie', 'Chinstrap', 'Gentoo') penguin_means = {     'Bill Depth': (18.35, 18.43, 14.98),     'Bill Length': (38.79, 48.83, 47.50),     'Flipper Length': (189.95, 195.82, 217.19), } Set the label locations using the variable x = np.arange(len(species)). The width of the bars can be set using the variable width = 0.25, and the initial multiplier can be set to 0. Then, create a figure and axis object using fig, ax = plt.subplots(layout='constrained'). Iterate through the penguin_means dictionary using a loop with attribute and measurement as the loop variables. Inside the loop, calculate the offset using offset = width * multiplier. Create the bar plot using rects = ax.bar(x + offset, measurement, width, label=attribute). Add labels to the bars using ax.bar_label(rects, padding=3). Increment the multiplier by 1 after each iteration. Add labels, title, x-axis tick labels, and legend to the plot using ax.set_ylabel('Length (mm)'), ax.set_title('Penguin attributes by species'), ax.set_xticks(x + width, species), ax.legend(loc='upper left', ncols=3), and ax.set_ylim(0, 250). Finally, display the plot using plt.show(). ",
    "id": 2
},
{
    "data": " np.random.seed(19680801)  people = ('Tom Dick Harry Slim Jim') y_pos = np.arange(len(people)) performance = 3 + 10 * np.random.rand(len(people)) error = np.random.rand(len(people))  ",
    "instruction": " Create a horizontal bar chart using matplotlib. Use the following data to plot it: np.random.seed(19680801), people = ('Tom Dick Harry Slim Jim'), y_pos = np.arange(len(people)), performance = 3 + 10 * np.random.rand(len(people)), error = np.random.rand(len(people)). ",
    "id": 3
},
{
    "data": "  no data preparation block exists in the given matplotlib code.  ",
    "instruction": "  To generate a broken horizontal bar plot with gaps, use the following data and settings:  - Use the `ax.broken_barh()` function to create broken bars. - Set the facecolors of the bars using the `facecolors` parameter. - Set the y-axis limits using `ax.set_ylim(5, 35)`. - Set the x-axis limits using `ax.set_xlim(0, 200)`. - Set the x-axis label using `ax.set_xlabel('seconds since start')`. - Modify the y-axis tick labels using `ax.set_yticks([15, 25], labels=['Bill', 'Jim'])`. - Make the grid lines visible using `ax.grid(True)`. - Add an annotation using `ax.annotate()` to indicate a race interruption. - Display the plot using `plt.show()`.  Please note that no specific data is provided in this code snippet. You can customize the data and formatting based on your requirements. ",
    "id": 4
},
{
    "data": " No data preparation blocks found in the provided code.  ",
    "instruction": " Use the CapStyle.demo() function from matplotlib to create a plot showcasing different cap styles for line segments. ",
    "id": 5
},
{
    "data": " np.random.seed(19680801)  dt = 0.01 t = np.arange(0, 30, dt) nse1 = np.random.randn(len(t))                 # white noise 1 nse2 = np.random.randn(len(t))                 # white noise 2  # Two signals with a coherent part at 10 Hz and a random part s1 = np.sin(2 * np.pi * 10 * t) + nse1 s2 = np.sin(2 * np.pi * 10 * t) + nse2  ",
    "instruction": " Create a plot to visualize the coherence of two signals. Use the following data: np.random.seed(19680801), dt = 0.01, t = np.arange(0, 30, dt), nse1 = np.random.randn(len(t)), nse2 = np.random.randn(len(t)), s1 = np.sin(2 * np.pi * 10 * t) + nse1, and s2 = np.sin(2 * np.pi * 10 * t) + nse2. Use the function `axs[0].plot(t, s1, t, s2)` to plot the signals and set the x-axis limit to (0, 2). Add labels 'Time (s)' for x-axis and 's1 and s2' for y-axis. Finally, use `axs[1].cohere(s1, s2, 256, 1. / dt)` to compute and plot the coherence of the two signals. Set the y-axis label as 'Coherence'. ",
    "id": 6
},
{
    "data": "  dt = 0.01 t = np.arange(0, 30, dt) np.random.seed(19680801) nse1 = np.random.randn(len(t))                 # white noise 1 nse2 = np.random.randn(len(t))                 # white noise 2 r = np.exp(-t / 0.05) cnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1 cnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2 s1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1 s2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2  ",
    "instruction": " To generate the cross spectral density (CSD) plot of two signals, t and s, use the following code snippet:  import matplotlib.pyplot as plt import numpy as np  fig, (ax1, ax2) = plt.subplots(2, 1, layout='constrained')  # Set the parameters dt = 0.01 t = np.arange(0, 30, dt) np.random.seed(19680801)  # Generate the noises nse1 = np.random.randn(len(t))                 # white noise 1 nse2 = np.random.randn(len(t))                 # white noise 2  # Generate the colored noise r = np.exp(-t / 0.05) cnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1 cnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2  # Generate the signals s1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1 s2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2  # Plotting ax1.plot(t, s1, t, s2) ax1.set_xlim(0, 5) ax1.set_xlabel('Time (s)') ax1.set_ylabel('s1 and s2') ax1.grid(True)  # Calculate and plot the CSD cxy, f = ax2.csd(s1, s2, 256, 1. / dt) ax2.set_ylabel('CSD (dB)')  # Show the plot plt.show() ",
    "id": 7
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  # example data x = np.arange(0.1, 4, 0.1) y1 = np.exp(-1.0 * x) y2 = np.exp(-0.5 * x)  # example variable error bar values y1err = 0.1 + 0.1 * np.sqrt(x) y2err = 0.1 + 0.1 * np.sqrt(x/2)   fig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3, sharex=True,                                     figsize=(12, 6))  ax0.set_title('all errorbars') ax0.errorbar(x, y1, yerr=y1err) ax0.errorbar(x, y2, yerr=y2err)  ax1.set_title('only every 6th errorbar') ax1.errorbar(x, y1, yerr=y1err, errorevery=6) ax1.errorbar(x, y2, yerr=y2err, errorevery=6)  ax2.set_title('second series shifted by 3') ax2.errorbar(x, y1, yerr=y1err, errorevery=(0, 6)) ax2.errorbar(x, y2, yerr=y2err, errorevery=(3, 6))  fig.suptitle('Errorbar subsampling') plt.show()  ",
    "instruction": "  Use the following functions from matplotlib: errorbar, subplots, set_title, set_xlabel, and suptitle, to create three plots with error bars. The first plot should display all error bars, the second plot should display only every 6th error bar, and the third plot should display the second series shifted by 3. Set the titles of the plots accordingly. Use the following data to create the plots: x = np.arange(0.1, 4, 0.1), y1 = np.exp(-1.0 * x), y2 = np.exp(-0.5 * x), y1err = 0.1 + 0.1 * np.sqrt(x), y2err = 0.1 + 0.1 * np.sqrt(x/2). ",
    "id": 8
},
{
    "data": " np.random.seed(19680801)  xdata = np.random.random([2, 10])  xdata1 = xdata[0, :] xdata2 = xdata[1, :]  xdata1.sort() xdata2.sort()  ydata1 = xdata1 ** 2 ydata2 = 1 - xdata2 ** 3  ",
    "instruction": " Create a line plot with data points using matplotlib. Plot two curves using the following data: xdata1 = np.random.random([2, 10])[0, :] xdata2 = np.random.random([2, 10])[1, :]  Sort the x data for both curves: xdata1.sort() xdata2.sort()  Create the y data points: ydata1 = xdata1 ** 2 ydata2 = 1 - xdata2 ** 3  Plot the two curves using different colors. Add markers at the locations of the x and y data points for each curve using EventCollections. Set the limits of the x and y axes to [0, 1]. Finally, set the title of the plot to 'line plot with data points'. ",
    "id": 9
},
{
    "data": "  np.random.seed(19680801)  data1 = np.random.random([6, 50])  colors1 = [f'C{i}' for i in range(6)]  lineoffsets1 = [-15, -3, 1, 1.5, 6, 10] linelengths1 = [5, 2, 1, 1, 3, 1.5]  data2 = np.random.gamma(4, size=[60, 50]) colors2 = 'black' lineoffsets2 = 1 linelengths2 = 1  ",
    "instruction": "  Create a figure with 2x2 subplots. Use the eventplot function from matplotlib to create two plots: one horizontal eventplot and one vertical eventplot. In the horizontal eventplot, use the following data: data1, colors1, lineoffsets1, and linelengths1. In the vertical eventplot, use the following data: data1, colors1, lineoffsets1, linelengths1, and set the orientation parameter to 'vertical'. Then, create another set of random data called data2 using np.random.gamma(4, size=[60, 50]). In the horizontal eventplot of the second subplot, use data2, colors2, lineoffsets2, and linelengths2. In the vertical eventplot of the second subplot, use data2, colors2, lineoffsets2, linelengths2, and set the orientation parameter to 'vertical'. Finally, display the plot. ",
    "id": 10
},
{
    "data": " np.random.seed(19680801)   def gradient_image(ax, direction=0.3, cmap_range=(0, 1), **kwargs):     '''     Draw a gradient image based on a colormap.      Parameters     ----------     ax : Axes         The axes to draw on.     direction : float         The direction of the gradient. This is a number in         range 0 (=vertical) to 1 (=horizontal).     cmap_range : float, float         The fraction (cmin, cmax) of the colormap that should be         used for the gradient, where the complete colormap is (0, 1).     **kwargs         Other parameters are passed on to `.Axes.imshow()`.         In particular, *cmap*, *extent*, and *transform* may be useful.     '''     phi = direction * np.pi / 2     v = np.array([np.cos(phi), np.sin(phi)])     X = np.array([[v @ [1, 0], v @ [1, 1]],                   [v @ [0, 0], v @ [0, 1]]])     a, b = cmap_range     X = a + (b - a) / X.max() * X     im = ax.imshow(X, interpolation='bicubic', clim=(0, 1),                    aspect='auto', **kwargs)     return im   def gradient_bar(ax, x, y, width=0.5, bottom=0):     for left, top in zip(x, y):         right = left + width         gradient_image(ax, extent=(left, right, bottom, top),                        cmap=plt.cm.Blues_r, cmap_range=(0, 0.8))   fig, ax = plt.subplots() ax.set(xlim=(0, 10), ylim=(0, 1))  # background image gradient_image(ax, direction=1, extent=(0, 1, 0, 1), transform=ax.transAxes,                cmap=plt.cm.RdYlGn, cmap_range=(0.2, 0.8), alpha=0.5)  N = 10 x = np.arange(N) + 0.15 y = np.random.rand(N) gradient_bar(ax, x, y, width=0.7)  ",
    "instruction": " Create a bar chart with gradients using matplotlib. Use the following data to plot it: np.random.seed(19680801). The code snippet provided defines two functions: gradient_image and gradient_bar. The gradient_image function draws a gradient image based on a colormap, while the gradient_bar function plots a series of bars with gradients. The code also includes a background image created using the gradient_image function. Finally, the code generates a bar chart by calling the gradient_bar function with some sample data. ",
    "id": 11
},
{
    "data": " np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots - a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  [DATA]: species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\"), weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}.  [DATA]: xlabels = ['I', 'II', 'III', 'IV', 'V'] playerA = np.array([5, 15, 22, 20, 25]) playerB = np.array([25, 32, 34, 30, 27])  [INSTRUCTION]: Create a hat graph using matplotlib. Use the following data to plot it: xlabels = ['I', 'II', 'III', 'IV', 'V'], [playerA, playerB], ['Player A', 'Player B']. ",
    "id": 12
},
{
    "data": " category_names = ['Strongly disagree', 'Disagree',                   'Neither agree nor disagree', 'Agree', 'Strongly agree'] results = {     'Question 1': [10, 15, 17, 32, 26],     'Question 2': [26, 22, 29, 10, 13],     'Question 3': [35, 37, 7, 2, 19],     'Question 4': [32, 11, 9, 15, 33],     'Question 5': [21, 29, 5, 5, 40],     'Question 6': [8, 19, 5, 30, 38] }  ",
    "instruction": " Create a stacked bar chart using matplotlib. Use the following data to plot it: category_names = ['Strongly disagree', 'Disagree', 'Neither agree nor disagree', 'Agree', 'Strongly agree'], results = {'Question 1': [10, 15, 17, 32, 26], 'Question 2': [26, 22, 29, 10, 13], 'Question 3': [35, 37, 7, 2, 19], 'Question 4': [32, 11, 9, 15, 33], 'Question 5': [21, 29, 5, 5, 40], 'Question 6': [8, 19, 5, 30, 38]}.   The stacked bar chart represents the result of a survey in which people were asked to rate their agreement to different questions on a five-element scale. Each question is represented by a category on the x-axis, and the height of each bar represents the number of responses for each rating category. ",
    "id": 13
},
{
    "data": " No data preparation blocks found in the provided code.  ",
    "instruction": " Use the JoinStyle.demo() function from matplotlib to demonstrate how Matplotlib draws the corners where two different line segments meet. ",
    "id": 14
},
{
    "data": "  x = np.linspace(0, 10, 500) y = np.sin(x)  ",
    "instruction": "  To create a plot with dashed line styles, you can use the set_dashes() and set_dash_capstyle() functions to modify the dashing of an existing line. Here is an example code snippet:  ```python import matplotlib.pyplot as plt import numpy as np  x = np.linspace(0, 10, 500) y = np.sin(x)  plt.rc('lines', linewidth=2.5) fig, ax = plt.subplots()  # Using set_dashes() and set_capstyle() to modify dashing of an existing line. line1, = ax.plot(x, y, label='Using set_dashes() and set_dash_capstyle()') line1.set_dashes([2, 2, 10, 2])  # 2pt line, 2pt break, 10pt line, 2pt break. line1.set_dash_capstyle('round')  # Using plot(..., dashes=...) to set the dashing when creating a line. line2, = ax.plot(x, y - 0.2, dashes=[6, 2], label='Using the dashes parameter')  # Using plot(..., dashes=..., gapcolor=...) to set the dashing and # alternating color when creating a line. line3, = ax.plot(x, y - 0.4, dashes=[4, 4], gapcolor='tab:pink',                  label='Using the dashes and gapcolor parameters')  ax.legend(handlelength=4) plt.show() ```  You can customize the dashed line styles by modifying the dash sequence, which is a series of on/off lengths in points. For example, [3, 1] represents 3pt long lines separated by 1pt spaces. In the code snippet provided, there are three lines with different dash sequences, showcasing different ways to set the dashing when creating a line. Note that you can also configure the dash style using a property_cycle by passing a list of dash sequences using the 'dashes' keyword. Additionally, you can set other attributes of the dash, such as the cap style and gap color, using the relevant methods or by passing the properties through a plotting function. ",
    "id": 15
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from matplotlib import patheffects  # Plot a straight diagonal line with ticked style path fig, ax = plt.subplots(figsize=(6, 6)) ax.plot([0, 1], [0, 1], label='Line',         path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])  # Plot a curved line with ticked style path nx = 101 x = np.linspace(0.0, 1.0, nx) y = 0.3*np.sin(x*8) + 0.4 ax.plot(x, y, label='Curve', path_effects=[patheffects.withTickedStroke()])  ax.legend()  plt.show()  ",
    "instruction": "  To create a plot with lines that have a ticked patheffect, you can use the functions `withTickedStroke()` and `plot()` from the `matplotlib.patheffects` module. Follow these steps:  1. Import the necessary libraries: `import matplotlib.pyplot as plt` and `import numpy as np`.  2. Create a new figure and axes: `fig, ax = plt.subplots(figsize=(6, 6))`.  3. Plot a straight diagonal line with a ticked style path using the `plot()` function. Specify the x-coordinates and y-coordinates of the line and add the label \"Line\". Use the `withTickedStroke()` function from `patheffects` as the value for the `path_effects` parameter:  ``` ax.plot([0, 1], [0, 1], label='Line', path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)]) ```  4. Plot a curved line with a ticked style path using the `plot()` function. Generate an array of x-values using `np.linspace()`, calculate corresponding y-values, and add the label \"Curve\". Use the default `withTickedStroke()` function for the `path_effects` parameter: ``` nx = 101 x = np.linspace(0.0, 1.0, nx) y = 0.3*np.sin(x*8) + 0.4 ax.plot(x, y, label='Curve', path_effects=[patheffects.withTickedStroke()]) ```  5. Add a legend to the plot: `ax.legend()`.  6. Display the plot: `plt.show()`. ",
    "id": 16
},
{
    "data": " np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   ---  [DATA]: species = (     'Adelie\\n $\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\mu=$3733.09g',     'Gentoo\\n $\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), } width = 0.5  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = (     'Adelie\\n $\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\mu=$3733.09g',     'Gentoo\\n $\\\\mu=5076.02g$', ), weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }.  ---  [DATA]: linestyle_str = [     ('solid', 'solid'),      # Same as (0, ()) or '-'     ('dotted', 'dotted'),    # Same as (0, (1, 1)) or ':'     ('dashed', 'dashed'),    # Same as '--'     ('dashdot', 'dashdot')  # Same as '-.' ]  linestyle_tuple = [     ('loosely dotted',        (0, (1, 10))),     ('dotted',                (0, (1, 1))),     ('densely dotted',        (0, (1, 1))),     ('long dash with offset', (5, (10, 3))),     ('loosely dashed',        (0, (5, 10))),     ('dashed',                (0, (5, 5))),     ('densely dashed',        (0, (5, 1))),     ('loosely dashdotted',    (0, (3, 10, 1, 10))),     ('dashdotted',            (0, (3, 5, 1, 5))),     ('densely dashdotted',    (0, (3, 1, 1, 1))),     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1))) ]  [INSTRUCTION]: Create two plots with different linestyles using matplotlib. Use the following data to plot them:  linestyle_str = [     ('solid', 'solid'),      # Same as (0, ()) or '-'     ('dotted', 'dotted'),    # Same as (0, (1, 1)) or ':'     ('dashed', 'dashed'),    # Same as '--'     ('dashdot', 'dashdot')  # Same as '-.' ]  linestyle_tuple = [     ('loosely dotted',        (0, (1, 10))),     ('dotted',                (0, (1, 1))),     ('densely dotted',        (0, (1, 1))),     ('long dash with offset', (5, (10, 3))),     ('loosely dashed',        (0, (5, 10))),     ('dashed',                (0, (5, 5))),     ('densely dashed',        (0, (5, 1))),     ('loosely dashdotted',    (0, (3, 10, 1, 10))),     ('dashdotted',            (0, (3, 5, 1, 5))),     ('densely dashdotted',    (0, (3, 1, 1, 1))),     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1))) ].  ---  Instructions for the remaining code are as follows:   Create two plots with two subplots. The first subplot should have the title \"Named linestyles\" and the second subplot should have the title \"Parametrized linestyles\". Use the function plot_linestyles to plot the linestyles on each subplot. The plot_linestyles function takes three parameters: ax, linestyles, and title. For the linestyles, use the following data:   linestyle_str = [     ('solid', 'solid'),      # Same as (0, ()) or '-'     ('dotted', 'dotted'),    # Same as (0, (1, 1)) or ':'     ('dashed', 'dashed'),    # Same as '--'     ('dashdot', 'dashdot')  # Same as '-.' ]  linestyle_tuple = [     ('loosely dotted',        (0, (1, 10))),     ('dotted',                (0, (1, 1))),     ('densely dotted',        (0, (1, 1))),     ('long dash with offset', (5, (10, 3))),     ('loosely dashed',        (0, (5, 10))),     ('dashed',                (0, (5, 5))),     ('densely dashed',        (0, (5, 1))),     ('loosely dashdotted',    (0, (3, 10, 1, 10))),     ('dashdotted',            (0, (3, 5, 1, 5))),     ('densely dashdotted',    (0, (3, 1, 1, 1))),     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1))) ].  After creating the plots, call plt.tight_layout() and plt.show() to display the plots. ",
    "id": 17
},
{
    "data": " x = np.linspace(-np.pi/2, np.pi/2, 31) y = np.cos(x)**3  # 1) remove points where y > 0.7 x2 = x[y <= 0.7] y2 = y[y <= 0.7]  # 2) mask points where y > 0.7 y3 = np.ma.masked_where(y > 0.7, y)  # 3) set to NaN where y > 0.7 y4 = y.copy() y4[y3 > 0.7] = np.nan  ",
    "instruction": " Use the following data to generate a plot showing the masked and NaN values. First, plot the original data without any masking. Then, plot the data with the points where y > 0.7 removed. Next, plot the data with the points where y > 0.7 masked. Finally, plot the data with the points where y > 0.7 set to NaN. ",
    "id": 18
},
{
    "data": "   x = np.linspace(0, 3 * np.pi, 500) y = np.sin(x) dydx = np.cos(0.5 * (x[:-1] + x[1:]))  # first derivative  points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1)  norm = plt.Normalize(dydx.min(), dydx.max()) lc = LineCollection(segments, cmap='viridis', norm=norm) lc.set_array(dydx) lc.set_linewidth(2) line = axs[0].add_collection(lc)  cmap = ListedColormap(['r g b']) norm = BoundaryNorm([-1, -0.5, 0.5, 1], cmap.N) lc = LineCollection(segments, cmap=cmap, norm=norm) lc.set_array(dydx) lc.set_linewidth(2) line = axs[1].add_collection(lc)  ",
    "instruction": "   Create a multicolored line plot using matplotlib by following these steps: 1. Define an array of x values using np.linspace() and an array of corresponding y values using np.sin(). 2. Calculate the first derivative of x using np.cos(0.5 * (x[:-1] + x[1:])) and store it in dydx. 3. Create an array of points using np.array([x, y]) and reshape it into shape (-1, 1, 2). 4. Concatenate the array points[:-1] and points[1:] along the second axis to create segments. 5. Create a continuous norm using plt.Normalize() and pass dydx.min() and dydx.max() as arguments. 6. Create a LineCollection object lc using LineCollection(segments, cmap='viridis', norm=norm). 7. Set the array of dydx values to lc using lc.set_array(dydx). 8. Set the linewidth of the line collection to 2 using lc.set_linewidth(2). 9. Add the line collection to the first subplot axs[0] using axs[0].add_collection(lc). 10. Create a boundary norm using ListedColormap(['r g b']) and normalize it using BoundaryNorm([-1, -0.5, 0.5, 1], cmap.N). 11. Create another LineCollection object lc using LineCollection(segments, cmap=cmap, norm=norm). 12. Set the array of dydx values to lc using lc.set_array(dydx). 13. Set the linewidth of the line collection to 2 using lc.set_linewidth(2). 14. Add the line collection to the second subplot axs[1] using axs[1].add_collection(lc). 15. Set the x-axis limits of the first subplot to x.min() and x.max() using axs[0].set_xlim(). 16. Set the y-axis limits of the first subplot to -1.1 and 1.1 using axs[0].set_ylim(). 17. Show the plot using plt.show(). ",
    "id": 19
},
{
    "data": "  np.random.seed(42) skills = np.random.uniform(5, 80, size=N) * 0.1 + 5 takeoff_angles = np.random.normal(0, 90, N) thrusts = np.random.uniform(size=N) successful = np.random.randint(0, 3, size=N) positions = np.random.normal(size=(N, 2)) * 5 data = zip(skills, takeoff_angles, thrusts, successful, positions) cmap = plt.colormaps['plasma']  ",
    "instruction": "  Create a plot to visualize a multivariate dataset using matplotlib. The plot should represent successful baseball throws as smiley faces. The size of the smiley faces should be mapped to the skill of the throwers, the rotation of the smiley faces should be mapped to the take-off angles, and the color of the smiley faces should be mapped to the thrusts. Use the following data to create the plot:  np.random.seed(42) skills = np.random.uniform(5, 80, size=N) * 0.1 + 5 takeoff_angles = np.random.normal(0, 90, N) thrusts = np.random.uniform(size=N) successful = np.random.randint(0, 3, size=N) positions = np.random.normal(size=(N, 2)) * 5 ",
    "id": 20
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.cbook as cbook  # Load a numpy record array from yahoo csv data with fields date, open, high, # low, close, volume, adj_close from the mpl-data/sample_data directory. The # record array stores the date as an np.datetime64 with a day unit ('D') in # the date column. price_data = cbook.get_sample_data('goog.npz')['price_data'] price_data = price_data[-250:]  # get the most recent 250 trading days  delta1 = np.diff(price_data['adj_close']) / price_data['adj_close'][:-1]  # Marker size in units of points^2 volume = (15 * price_data['volume'][:-2] / price_data['volume'][0])**2 close = 0.003 * price_data['close'][:-2] / 0.003 * price_data['open'][:-2]  ",
    "instruction": "  Create a scatter plot using matplotlib. Use the following data to plot it: price_data, delta1, volume, close. The scatter plot should have varying marker colors and sizes. Set the x-axis label as Δi, the y-axis label as Δi+1, and the title as \"Volume and percent change\". Enable grid lines in the plot and adjust the layout to be tight. ",
    "id": 21
},
{
    "data": "  np.random.seed(19680801) N = 100 r0 = 0.6 x = 0.9 * np.random.rand(N) y = 0.9 * np.random.rand(N) area = (20 * np.random.rand(N))**2 c = np.sqrt(area) r = np.sqrt(x ** 2 + y ** 2) area1 = np.ma.masked_where(r < r0, area) area2 = np.ma.masked_where(r >= r0, area)  ",
    "instruction": "  To create a scatter plot with masked data points and a line demarking the masked regions, use the following code: ```python import matplotlib.pyplot as plt import numpy as np  np.random.seed(19680801)  N = 100 r0 = 0.6 x = 0.9 * np.random.rand(N) y = 0.9 * np.random.rand(N) area = (20 * np.random.rand(N))**2 c = np.sqrt(area) r = np.sqrt(x ** 2 + y ** 2) area1 = np.ma.masked_where(r < r0, area) area2 = np.ma.masked_where(r >= r0, area)  plt.scatter(x, y, s=area1, marker='^', c=c) plt.scatter(x, y, s=area2, marker='o', c=c) theta = np.arange(0, np.pi / 2, 0.01) plt.plot(r0 * np.cos(theta), r0 * np.sin(theta))  plt.show() ```  The data used in the code is as follows: ``` np.random.seed(19680801) N = 100 r0 = 0.6 x = 0.9 * np.random.rand(N) y = 0.9 * np.random.rand(N) area = (20 * np.random.rand(N))**2 c = np.sqrt(area) r = np.sqrt(x ** 2 + y ** 2) area1 = np.ma.masked_where(r < r0, area) area2 = np.ma.masked_where(r >= r0, area) ```  This code creates a scatter plot with two different marker styles (`'^'` and `'o'`) based on masked data points. The size of each marker is determined by the `area` array, and the color is determined by the `c` array. The regions where `r < r0` are masked with the `area1` variable, and the remaining regions are masked with `area2`. Additionally, a line is plotted to demark the boundary between the masked regions, which is generated by the `theta` array. ",
    "id": 22
},
{
    "data": " np.random.seed(19680801)  x = np.random.rand(10) y = np.random.rand(10) z = np.sqrt(x**2 + y**2)  ",
    "instruction": " Use the scatter function from matplotlib to create a subplot with a layout of 2 rows and 3 columns. Use the following markers to plot the data: 1. Marker symbol: '>'. Title: 'marker='>'. 2. Marker symbol from TeX: r'$\\clubsuit$'. Title: r\"marker=r'$\\clubsuit$'\". 3. Marker symbol from custom path: verts = [[-1, -1], [1, -1], [1, 1], [-1, -1]]. Title: 'marker=verts'. 4. Regular pentagon marker: marker=(5, 0). Title: 'marker=(5, 0)'. 5. Regular 5-pointed star marker: marker=(5, 1). Title: 'marker=(5, 1)'. 6. Regular 5-pointed asterisk marker: marker=(5, 2). Title: 'marker=(5, 2)'. Make sure to share the x and y axes between subplots and set them to be the same scale. Finally, display the plot. ",
    "id": 23
},
{
    "data": " t = np.arange(0.0, 2.0, 0.01) s = 1 + np.sin(2 * np.pi * t)  ",
    "instruction": " Create a simple plot using matplotlib. Use the following data to plot it: t = np.arange(0.0, 2.0, 0.01), s = 1 + np.sin(2 * np.pi * t). ",
    "id": 24
},
{
    "data": "  t = np.arange(0.0, 2, 0.01) s = np.sin(2*np.pi*t)  ",
    "instruction": "  Use the matplotlib function fill_between to create a plot with shaded regions. Shade the region between the curve defined by t and s when s > 0 with the color green and alpha value of 0.5. Shade the region between the curve defined by t and s when s < 0 with the color red and alpha value of 0.5. ",
    "id": 25
},
{
    "data": " np.random.seed(0)  dt = 0.01  # sampling interval Fs = 1 / dt  # sampling frequency t = np.arange(0, 10, dt)  # generate noise: nse = np.random.randn(len(t)) r = np.exp(-t / 0.05) cnse = np.convolve(nse, r) * dt cnse = cnse[:len(t)]  s = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal  ",
    "instruction": " Use the following functions from matplotlib: subplot_mosaic, set_title, plot, set_xlabel, set_ylabel, magnitude_spectrum, phase_spectrum, angle_spectrum, to create a plot with multiple subplots. Use the given data to plot the signal, magnitude spectrum, log magnitude spectrum, phase spectrum, and angle spectrum. ",
    "id": 26
},
{
    "data": "  np.random.seed(19680801)  t = np.arange(0.0, 5.0, 0.1) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.3, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:  np.random.seed(19680801),  t = np.arange(0.0, 5.0, 0.1),  s = np.exp(-t) + np.sin(2 * np.pi * t) + 1,  nse = np.random.normal(0.0, 0.3, t.shape) * s. ",
    "id": 27
},
{
    "data": " np.random.seed(19680801)  x, y = np.random.randn(2, 100)  ",
    "instruction": " Use the following functions from matplotlib: xcorr and acorr, to create two plots: a cross-correlation (xcorr) plot and an auto-correlation (acorr) plot. Use the following data to create the plots: np.random.seed(19680801), x, y = np.random.randn(2, 100). ",
    "id": 28
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.transforms as mtransforms   def get_image():     delta = 0.25     x = y = np.arange(-3.0, 3.0, delta)     X, Y = np.meshgrid(x, y)     Z1 = np.exp(-X**2 - Y**2)     Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)     Z = (Z1 - Z2)     return Z   def do_plot(ax, Z, transform):     im = ax.imshow(Z, interpolation='none',                    origin='lower',                    extent=[-2, 4, -3, 2], clip_on=True)      trans_data = transform + ax.transData     im.set_transform(trans_data)      # display intended extent of the image     x1, x2, y1, y2 = im.get_extent()     ax.plot([x1, x2, x2, x1, x1], [y1, y1, y2, y2, y1], 'y--',             transform=trans_data)     ax.set_xlim(-5, 5)     ax.set_ylim(-4, 4)   # prepare image and figure fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2) Z = get_image()  # image rotation do_plot(ax1, Z, mtransforms.Affine2D().rotate_deg(30))  # image skew do_plot(ax2, Z, mtransforms.Affine2D().skew_deg(30, 15))  # scale and reflection do_plot(ax3, Z, mtransforms.Affine2D().scale(-1, .5))  # everything and a translation do_plot(ax4, Z, mtransforms.Affine2D().         rotate_deg(30).skew_deg(30, 15).scale(-1, .5).translate(.5, -1))  plt.show()  ",
    "instruction": "  To create a plot with affine transformations, use the following functions and classes from matplotlib: matplotlib.pyplot.subplots, matplotlib.transforms.Affine2D, matplotlib.axes.Axes.imshow, and matplotlib.pyplot.imshow.  1. First, create a function called \"get_image()\" that returns a numpy array.  2. Inside \"get_image()\", initialize variables delta, x, and y using np.arange() with appropriate arguments.  3. Use np.meshgrid() to create variables X and Y based on x and y.  4. Calculate Z1 and Z2 using the given mathematical expressions in \"get_image()\".  5. Calculate Z as the difference between Z1 and Z2.  6. Create a function called \"do_plot()\" that takes three arguments: \"ax\", \"Z\", and \"transform\".  7. Inside \"do_plot()\", use ax.imshow() to create an image plot with the given arguments and settings.  8. Create a variable \"trans_data\" by adding \"transform\" and \"ax.transData\".  9. Set im.set_transform() with \"trans_data\" to apply the transformation to the image.  10. Use ax.plot() to plot a dashed yellow rectangle with the given coordinates and transform it using \"trans_data\".  11. Set the x-axis limits of the plot using ax.set_xlim().  12. Set the y-axis limits of the plot using ax.set_ylim().  13. Create a figure and subplots using plt.subplots().  14. Call \"get_image()\" and store the result in Z.  15. Call \"do_plot()\" four times, each with different ax, Z, and transform arguments.  16. Finally, call plt.show() to display the plot. ",
    "id": 29
},
{
    "data": " code = np.array([     1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,     0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,     1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,     1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1])  pixel_per_bar = 4 dpi = 100  ",
    "instruction": " Create a barcode using matplotlib. Use the following data to plot it: code = np.array([     1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,     0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,     1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,     1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1]), pixel_per_bar = 4, dpi = 100. ",
    "id": 30
},
{
    "data": " t = np.linspace(0, 2 * np.pi, 1024) data2d = np.sin(t)[:, np.newaxis] * np.cos(t)[np.newaxis, :]  ",
    "instruction": " Use the following data to create an interactive adjustment of colormap range demonstration plot. Plot an image using the data by calling the function ax.imshow(data2d). Set the title of the plot to 'Pan on the colorbar to shift the color mapping\\n             Zoom on the colorbar to scale the color mapping'. Add a colorbar to the plot using the function fig.colorbar(im, ax=ax, label='Interactive colorbar'). ",
    "id": 31
},
{
    "data": "  x, y = np.meshgrid(np.arange(7), np.arange(10)) z = np.sin(0.5 * x) * np.cos(0.52 * y) mask = np.zeros_like(z, dtype=bool) mask[2, 3:5] = True mask[3:5, 4] = True mask[7, 2] = True mask[5, 0] = True mask[0, 6] = True z = np.ma.array(z, mask=mask) corner_masks = [False, True]  ",
    "instruction": "  Create a plot to illustrate the difference between corner_mask=False and corner_mask=True for masked contour plots. Use the data listed below to generate the plot: - x, y = np.meshgrid(np.arange(7), np.arange(10)) - z = np.sin(0.5 * x) * np.cos(0.52 * y) - mask = np.zeros_like(z, dtype=bool) - mask[2, 3:5] = True - mask[3:5, 4] = True - mask[7, 2] = True - mask[5, 0] = True - mask[0, 6] = True - z = np.ma.array(z, mask=mask) - corner_masks = [False, True]  Plot two contours using corner_mask=False and corner_mask=True respectively. Add grid lines and indicate masked points with red circles. ",
    "id": 32
},
{
    "data": " np.arange(-3.0, 4.001, delta), np.arange(-4.0, 3.001, delta), np.exp(-X**2 - Y**2), np.exp(-(X - 1)**2 - (Y - 1)**2), (Z1 - Z2) * 2, np.arange(-2.0, 1.601, 0.4), cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max()), cm.PRGn  ",
    "instruction": " Use the following functions from matplotlib: contourf, contour, imshow, and colorbar, to create a plot showing combinations of contouring, filled contouring, and image plotting. Use the given data to generate the plot: np.arange(-3.0, 4.001, delta), np.arange(-4.0, 3.001, delta), np.exp(-X**2 - Y**2), np.exp(-(X - 1)**2 - (Y - 1)**2), (Z1 - Z2) * 2, np.arange(-2.0, 1.601, 0.4), cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max()), and cm.PRGn. Set the extent of the image as (-3, 4, -4, 3). ",
    "id": 33
},
{
    "data": "  N = 100 x = np.linspace(-3.0, 3.0, N) y = np.linspace(-2.0, 2.0, N) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X * 10)**2 - (Y * 10)**2) z = Z1 + 50 * Z2 z[:5, :5] = -1 z = ma.masked_where(z <= 0, z)  ",
    "instruction": "  Create a contour plot with a log color scale using the matplotlib function contourf. Use the following data to plot it: N = 100, x = np.linspace(-3.0, 3.0, N), y = np.linspace(-2.0, 2.0, N), X, Y = np.meshgrid(x, y), Z1 = np.exp(-X**2 - Y**2), Z2 = np.exp(-(X * 10)**2 - (Y * 10)**2), z = Z1 + 50 * Z2, z[:5, :5] = -1, z = ma.masked_where(z <= 0, z).  The relevant context for this code snippet is the use of contourf and a log color scale. ",
    "id": 34
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np from matplotlib import patheffects  fig, ax = plt.subplots(figsize=(6, 6))  nx = 101 ny = 105  # Set up survey vectors xvec = np.linspace(0.001, 4.0, nx) yvec = np.linspace(0.001, 4.0, ny)  # Set up survey matrices.  Design disk loading and gear ratio. x1, x2 = np.meshgrid(xvec, yvec)  # Evaluate some stuff to plot obj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2 g1 = -(3*x1 + x2 - 5.5) g2 = -(x1 + 2*x2 - 4.5) g3 = 0.8 + x1**-3 - x2  cntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],                   colors='black') ax.clabel(cntr, fmt='%2.1f', use_clabeltext=True)  cg1 = ax.contour(x1, x2, g1, [0], colors='sandybrown') cg1.set(path_effects=[patheffects.withTickedStroke(angle=135)])  cg2 = ax.contour(x1, x2, g2, [0], colors='orangered') cg2.set(path_effects=[patheffects.withTickedStroke(angle=60, length=2)])  cg3 = ax.contour(x1, x2, g3, [0], colors='mediumblue') cg3.set(path_effects=[patheffects.withTickedStroke(spacing=7)])  ax.set_xlim(0, 4) ax.set_ylim(0, 4)  plt.show()  ",
    "instruction": "  Create a contour plot using `ax.contour` to visualize the solution space of an optimization problem. Use the provided data to set up the survey vectors `xvec` and `yvec` and the survey matrices `x1` and `x2`. Compute the objective function `obj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2` and the constraint functions `g1 = -(3*x1 + x2 - 5.5)`, `g2 = -(x1 + 2*x2 - 4.5)`, and `g3 = 0.8 + x1**-3 - x2`. Use `ax.clabel` to add labels to the contour lines representing the objective function. Use `ax.contour` again to plot the constraint functions `g1`, `g2`, and `g3`, with specific contour levels and colors. Apply path effects to the constraint curves to emphasize the valid and invalid sides of the constraint boundaries. Finally, set the x-axis and y-axis limits of the plot using `ax.set_xlim` and `ax.set_ylim`. ",
    "id": 35
},
{
    "data": "   txt = ax1.text(0.5, 0.5, 'test', size=30, ha='center', color='w') ax1.add_artist(     BboxImage(txt.get_window_extent, data=np.arange(256).reshape((1, -1))))  cmap_names = sorted(m for m in plt.colormaps if not m.endswith('_r'))  ncol = 2 nrow = len(cmap_names) // ncol + 1  xpad_fraction = 0.3 dx = 1 / (ncol + xpad_fraction * (ncol - 1))  ypad_fraction = 0.3 dy = 1 / (nrow + ypad_fraction * (nrow - 1))  for i, cmap_name in enumerate(cmap_names):     ix, iy = divmod(i, nrow)     bbox0 = Bbox.from_bounds(ix*dx*(1+xpad_fraction),                              1 - iy*dy*(1+ypad_fraction) - dy,                              dx, dy)     bbox = TransformedBbox(bbox0, ax2.transAxes)     ax2.add_artist(         BboxImage(bbox, cmap=cmap_name, data=np.arange(256).reshape((1, -1))))  ",
    "instruction": "   Create a BboxImage demonstration using matplotlib. The BboxImage can be used to position an image according to a bounding box. This example shows how to show an image inside a text's bounding box as well as how to manually create a bounding box for the image. Use the following data to create the plot:  txt = ax1.text(0.5, 0.5, 'test', size=30, ha='center', color='w') ax1.add_artist(BboxImage(txt.get_window_extent, data=np.arange(256).reshape((1, -1))))  cmap_names = sorted(m for m in plt.colormaps if not m.endswith('_r'))  ncol = 2 nrow = len(cmap_names) // ncol + 1  xpad_fraction = 0.3 dx = 1 / (ncol + xpad_fraction * (ncol - 1))  ypad_fraction = 0.3 dy = 1 / (nrow + ypad_fraction * (nrow - 1))  for i, cmap_name in enumerate(cmap_names):     ix, iy = divmod(i, nrow)     bbox0 = Bbox.from_bounds(ix*dx*(1+xpad_fraction),                              1 - iy*dy*(1+ypad_fraction) - dy,                              dx, dy)     bbox = TransformedBbox(bbox0, ax2.transAxes)     ax2.add_artist(BboxImage(bbox, cmap=cmap_name, data=np.arange(256).reshape((1, -1)))) ",
    "id": 36
},
{
    "data": " Z = np.arange(10000).reshape((100, 100)) ",
    "instruction": " Use the function figimage from matplotlib to create a figure with two images. Set Z as the data for both images. Set the first image position with (xo=50, yo=0) and the second image position with (xo=100, yo=100). ",
    "id": 37
},
{
    "data": "  import matplotlib.pyplot as plt  import matplotlib.cbook as cbook import matplotlib.patches as patches  with cbook.get_sample_data('grace_hopper.jpg') as image_file:     image = plt.imread(image_file)  fig, ax = plt.subplots() im = ax.imshow(image) patch = patches.Circle((260, 200), radius=200, transform=ax.transData) im.set_clip_path(patch)  ax.axis('off')  ",
    "instruction": "  To create a plot with a clipped image, follow these steps: - Import the necessary libraries: matplotlib.pyplot and matplotlib.cbook. - Use the get_sample_data function from cbook to load the image file 'grace_hopper.jpg'. - Create a figure and axis using plt.subplots. - Plot the image using ax.imshow and store the returned object in the variable im. - Create a circular patch using patches.Circle with the center coordinates (260, 200), a radius of 200, and the transform set to ax.transData. Store the returned patch object in the variable patch. - Set the clip path of the image to the created patch using im.set_clip_path(patch). - Turn off the axis using ax.axis('off'). - Finally, display the plot using plt.show(). ",
    "id": 38
},
{
    "data": "  x0, x1 = -5, 5 y0, y1 = -3, 3 x = np.linspace(x0, x1, 500) y = np.linspace(y0, y1, 500) X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) Z = (Z1 - Z2) * 2 palette = plt.cm.gray.with_extremes(over='r', under='g', bad='b') Zm = np.ma.masked_where(Z > 1.2, Z)  ",
    "instruction": "  Create two subplots using matplotlib. In the first subplot, use the 'imshow' function to plot the masked array 'Zm' with a 'bilinear' interpolation. Set the colormap to 'palette' and the color range to -1.0 to 1.0. Set the plot aspect to 'auto' and the origin to 'lower'. Set the x-axis tick labels to not be displayed. Add a colorbar to the plot with the label 'uniform'.   In the second subplot, use the 'imshow' function to plot the masked array 'Zm' with a 'nearest' interpolation. Set the colormap to 'palette' and use the 'BoundaryNorm' class to define unevenly spaced color boundaries. Use the color boundaries [-1, -0.5, -0.2, 0, 0.2, 0.5, 1] and a total of 'ncolors' from the 'palette'. Set the plot aspect to 'auto' and the origin to 'lower'. Add a colorbar to the plot with 'proportional' spacing.   Set the title of the first subplot to 'Green=low, Red=high, Blue=masked' and the title of the second subplot to 'With BoundaryNorm'. Set the title of the figure to 'imshow, with out-of-range and masked data'. Finally, display the plot. ",
    "id": 39
},
{
    "data": " interp = 'nearest'  # Linear x array for cell centers: x = np.linspace(-4, 4, 9)  # Highly nonlinear x array: x2 = x**3  y = np.linspace(-4, 4, 9)  z = np.sqrt(x[np.newaxis, :]**2 + y[:, np.newaxis]**2)  ",
    "instruction": " Use the NonUniformImage class from matplotlib to create a plot with 4 subplots. The first subplot should have an interpolation of 'nearest' and should use the data x, y, z. The second subplot should also have an interpolation of 'nearest', but should use the data x2, y, z. The third subplot should have an interpolation of 'bilinear' and should use the data x, y, z. The fourth subplot should also have an interpolation of 'bilinear', but should use the data x2, y, z. ",
    "id": 40
},
{
    "data": " np.random.seed(19680801)  X = 10*np.random.rand(5, 3)  ",
    "instruction": " Create a scatter plot using matplotlib, displaying the data from X. Customize the coordinate formatter to report the image \"z\" value of the nearest pixel given x and y. ",
    "id": 41
},
{
    "data": "  methods = [None, 'none nearest bilinear bicubic spline16',            'spline36 hanning hamming hermite kaiser quadric',            'catrom gaussian bessel mitchell sinc lanczos']  # Fixing random state for reproducibility np.random.seed(19680801)  grid = np.random.rand(4, 4)  ",
    "instruction": "  To generate the plot, first import the necessary libraries: import matplotlib.pyplot as plt import numpy as np  Then, define the following data: methods = [None, 'none nearest bilinear bicubic spline16',            'spline36 hanning hamming hermite kaiser quadric',            'catrom gaussian bessel mitchell sinc lanczos'] np.random.seed(19680801) grid = np.random.rand(4, 4)  Next, create a 3x6 grid of subplots with the following properties: fig, axs = plt.subplots(nrows=3, ncols=6, figsize=(9, 6),                         subplot_kw={'xticks': [], 'yticks': []})  For each subplot and corresponding interpolation method, perform the following steps: - Display the grid using imshow with the specified interpolation method and cmap='viridis'. - Set the title of the subplot to the string representation of the interpolation method.  Finally, adjust the layout of the subplots and display the plot using plt.tight_layout() and plt.show(). ",
    "id": 42
},
{
    "data": "  np.random.seed(19680801) npts = 200 ngridx = 100 ngridy = 200 x = np.random.uniform(-2, 2, npts) y = np.random.uniform(-2, 2, npts) z = x * np.exp(-x**2 - y**2) xi = np.linspace(-2.1, 2.1, ngridx) yi = np.linspace(-2.1, 2.1, ngridy) triang = tri.Triangulation(x, y) interpolator = tri.LinearTriInterpolator(triang, z) Xi, Yi = np.meshgrid(xi, yi) zi = interpolator(Xi, Yi)  ",
    "instruction": "  Create a contour plot of irregularly spaced data by interpolating on a grid. Use the data provided to plot the contour. First, create grid values using np.linspace. Then, linearly interpolate the data points (x, y) on the grid defined by (xi, yi). Use tri.Triangulation to define the triangulation and tri.LinearTriInterpolator for interpolation. Finally, plot the contour using ax1.contour and ax1.contourf, and add a colorbar using fig.colorbar. ",
    "id": 43
},
{
    "data": "  dx, dy = 0.05, 0.05 x = np.arange(-3.0, 3.0, dx) y = np.arange(-3.0, 3.0, dy) X, Y = np.meshgrid(x, y) extent = np.min(x), np.max(x), np.min(y), np.max(y)  ",
    "instruction": "  Use the following data to generate a plot: dx, dy = 0.05, 0.05 x = np.arange(-3.0, 3.0, dx) y = np.arange(-3.0, 3.0, dy) X, Y = np.meshgrid(x, y) extent = np.min(x), np.max(x), np.min(y), np.max(y)  Then, layer two images above one another using alpha blending. Use the following functions: `imshow` and `show` from matplotlib.pyplot. ",
    "id": 44
},
{
    "data": " a = np.diag(range(15)) ",
    "instruction": " Use the function matshow from matplotlib to visualize the 2D array a as a color-coded image. ",
    "id": 45
},
{
    "data": "  np.random.seed(19680801) Nr = 3 Nc = 2  fig, axs = plt.subplots(Nr, Nc) fig.suptitle('Multiple images')  images = [] for i in range(Nr):     for j in range(Nc):         # Generate data with a range that varies from one plot to the next.         data = ((1 + i + j) / 10) * np.random.rand(10, 20)         images.append(axs[i, j].imshow(data))         axs[i, j].label_outer()  # Find the min and max of all colors for use in setting the color scale. vmin = min(image.get_array().min() for image in images) vmax = max(image.get_array().max() for image in images) norm = colors.Normalize(vmin=vmin, vmax=vmax) for im in images:     im.set_norm(norm)  fig.colorbar(images[0], ax=axs, orientation='horizontal', fraction=.1)   # Make images respond to changes in the norm of other images (e.g. via the # 'edit axis, curves and images parameters' GUI on Qt), but be careful not to # recurse infinitely! def update(changed_image):     for im in images:         if (changed_image.get_cmap() != im.get_cmap()                 or changed_image.get_clim() != im.get_clim()):             im.set_cmap(changed_image.get_cmap())             im.set_clim(changed_image.get_clim())   for im in images:     im.callbacks.connect('changed', update)  plt.show()  ",
    "instruction": "  Create multiple images using matplotlib. Use the provided data to generate a grid of subplots with 3 rows and 2 columns. Add a title to the entire figure. Generate data for each plot, where the range of data varies from plot to plot. Use the generated data to create images and add them to the corresponding axes. Find the minimum and maximum values of the colors used in the images and set the color scale accordingly. Add a colorbar to the figure. Make sure the images respond to changes in the norm of other images, but avoid infinite recursion. ",
    "id": 46
},
{
    "data": "  w = 3 Y, X = np.mgrid[-w:w:100j, -w:w:100j] U = -1 - X**2 + Y V = 1 + X - Y**2 speed = np.sqrt(U**2 + V**2)  ",
    "instruction": "  Create a stream plot using the matplotlib function streamplot. Use the following data to generate the plot:  w = 3,  Y, X = np.mgrid[-w:w:100j, -w:w:100j],  U = -1 - X**2 + Y,  V = 1 + X - Y**2,  speed = np.sqrt(U**2 + V**2).  The stream plot will showcase the following features: 1. Varying density along a streamline. 2. Varying color along a streamline. 3. Varying line width along a streamline. 4. Controlling the starting points of the streamlines. 5. Streamlines skipping masked regions and NaN values. 6. Unbroken streamlines even when exceeding the limit of lines within a single grid cell. ",
    "id": 47
},
{
    "data": " n = 12 x = np.linspace(-1.5, 1.5, n) y = np.linspace(-1.5, 1.5, n * 2) X, Y = np.meshgrid(x, y) Qx = np.cos(Y) - np.cos(X) Qz = np.sin(Y) + np.sin(X) Z = np.sqrt(X**2 + Y**2) / 5 Z = (Z - Z.min()) / (Z.max() - Z.min()) Zm = np.ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z) cmap = plt.colormaps[plt.rcParams['image.cmap']].with_extremes(bad='y')  ",
    "instruction": " To create a QuadMesh plot, use the matplotlib function pcolormesh. Follow these steps: 1. Create a meshgrid with np.meshgrid using the x and y coordinates. 2. Calculate Qx and Qz based on the given equations. 3. Normalize Z so that it falls within the range [0, 1]. 4. Use np.ma.masked_where to create a masked array Zm based on the condition np.abs(Qz) < 0.5 * np.max(Qz). 5. Define a colormap cmap using plt.colormaps[plt.rcParams['image.cmap']].with_extremes(bad='y'). 6. Create a figure and three subplots using fig, axs = plt.subplots(nrows=1, ncols=3). 7. Plot the QuadMesh in the first subplot using axs[0].pcolormesh(Qx, Qz, Z, shading='gouraud') and set the title to \"Without masked values\". 8. Plot the QuadMesh in the second subplot using axs[1].pcolormesh(Qx, Qz, Zm, shading='gouraud', cmap=cmap) and set the title to \"With masked values\".  9. Plot the QuadMesh in the third subplot using axs[2].pcolormesh(Qx, Qz, Zm, shading='gouraud') and set the title to \"With masked values\".  10. Adjust the layout of the subplots using fig.tight_layout(). 11. Display the figure using plt.show(). ",
    "id": 48
},
{
    "data": " X = np.arange(-10, 10, 1) Y = np.arange(-10, 10, 1) U, V = np.meshgrid(X, Y)  ",
    "instruction": " Use the function quiver from matplotlib to create a quiver plot with a quiver key. Use the following data to create the plot: X = np.arange(-10, 10, 1), Y = np.arange(-10, 10, 1), U, V = np.meshgrid(X, Y). ",
    "id": 49
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np from matplotlib import cbook from matplotlib.colors import LightSource  def main():     # Test data     x, y = np.mgrid[-5:5:0.05, -5:5:0.05]     z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2))      dem = cbook.get_sample_data('jacksboro_fault_dem.npz')     elev = dem['elevation']      fig = compare(z, plt.cm.copper)     fig.suptitle('HSV Blending Looks Best with Smooth Surfaces', y=0.95)      fig = compare(elev, plt.cm.gist_earth, ve=0.05)     fig.suptitle('Overlay Blending Looks Best with Rough Surfaces', y=0.95)      plt.show()  def compare(z, cmap, ve=1):     # Create subplots and hide ticks     fig, axs = plt.subplots(ncols=2, nrows=2)     for ax in axs.flat:         ax.set(xticks=[], yticks=[])      # Illuminate the scene from the northwest     ls = LightSource(azdeg=315, altdeg=45)      axs[0, 0].imshow(z, cmap=cmap)     axs[0, 0].set(xlabel='Colormapped Data')      axs[0, 1].imshow(ls.hillshade(z, vert_exag=ve), cmap='gray')     axs[0, 1].set(xlabel='Illumination Intensity')      rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='hsv')     axs[1, 0].imshow(rgb)     axs[1, 0].set(xlabel=\"Blend Mode: 'hsv' (default)\")      rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='overlay')     axs[1, 1].imshow(rgb)     axs[1, 1].set(xlabel=\"Blend Mode: 'overlay'\")      return fig  if __name__ == '__main__':     main()  ",
    "instruction": " Use the following functions and modules from matplotlib to create shaded relief plots like Mathematica or Generic Mapping Tools: matplotlib.colors.LightSource, matplotlib.axes.Axes.imshow, and matplotlib.pyplot.imshow. The code example shows how to make shaded relief plots with smooth surfaces using the HSV blend mode, and with rough surfaces using the Overlay blend mode. Use the provided data to generate the plots:  - Test data: x, y = np.mgrid[-5:5:0.05, -5:5:0.05], z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2)) - Sample data: dem = cbook.get_sample_data('jacksboro_fault_dem.npz'), elev = dem['elevation']  Call the function compare(z, plt.cm.copper) to create a figure with subplots. Set the title of the figure as 'HSV Blending Looks Best with Smooth Surfaces'. Similarly, call the function compare(elev, plt.cm.gist_earth, ve=0.05) to create another figure with subplots. Set the title of this figure as 'Overlay Blending Looks Best with Rough Surfaces'. Finally, display the plots using plt.show(). ",
    "id": 50
},
{
    "data": "  np.random.seed(19680801) dt = 0.0005 t = np.arange(0.0, 20.5, dt) s1 = np.sin(2 * np.pi * 100 * t) s2 = 2 * np.sin(2 * np.pi * 400 * t) s2[t <= 10] = s2[12 <= t] = 0 nse = 0.01 * np.random.random(size=len(t)) x = s1 + s2 + nse NFFT = 1024 Fs = 1/dt  ",
    "instruction": "  Use the matplotlib function specgram to create a spectrogram plot. Plot the signal x against time t on the top subplot and the spectrogram on the bottom subplot. Set the xlabel of the bottom subplot as \"Time (s)\", the ylabel as \"Frequency (Hz)\", and the xlim as (0, 20). ",
    "id": 51
},
{
    "data": " np.random.seed(19680801)  x = np.random.randn(20, 20) x[5, :] = 0. x[:, 12] = 0.  ",
    "instruction": " Use the matplotlib function spy to plot the sparsity pattern of arrays. Create a 2x2 grid of subplots and use the spy function to plot the arrays using different settings. ",
    "id": 52
},
{
    "data": " import matplotlib.pyplot as plt import numpy as np  from matplotlib.tri import TriAnalyzer, Triangulation, UniformTriRefiner   # ---------------------------------------------------------------------------- # Analytical test function # ---------------------------------------------------------------------------- def experiment_res(x, y):     '''An analytic function representing experiment results.'''     x = 2 * x     r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)     theta1 = np.arctan2(0.5 - x, 0.5 - y)     r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)     theta2 = np.arctan2(-x - 0.2, -y - 0.2)     z = (4 * (np.exp((r1/10)**2) - 1) * 30 * np.cos(3 * theta1) +          (np.exp((r2/10)**2) - 1) * 30 * np.cos(5 * theta2) +          2 * (x**2 + y**2))     return (np.max(z) - z) / (np.max(z) - np.min(z))  # ---------------------------------------------------------------------------- # Generating the initial data test points and triangulation for the demo # ---------------------------------------------------------------------------- # User parameters for data test points  # Number of test data points, tested from 3 to 5000 for subdiv=3 n_test = 200  # Number of recursive subdivisions of the initial mesh for smooth plots. # Values >3 might result in a very high number of triangles for the refine # mesh: new triangles numbering = (4**subdiv)*ntri subdiv = 3  # Float > 0. adjusting the proportion of (invalid) initial triangles which will # be masked out. Enter 0 for no mask. init_mask_frac = 0.0  # Minimum circle ratio - border triangles with circle ratio below this will be # masked if they touch a border. Suggested value 0.01; use -1 to keep all # triangles. min_circle_ratio = .01  # Random points random_gen = np.random.RandomState(seed=19680801) x_test = random_gen.uniform(-1., 1., size=n_test) y_test = random_gen.uniform(-1., 1., size=n_test) z_test = experiment_res(x_test, y_test)  # meshing with Delaunay triangulation tri = Triangulation(x_test, y_test) ntri = tri.triangles.shape[0]  # Some invalid data are masked out mask_init = np.zeros(ntri, dtype=bool) masked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac)) mask_init[masked_tri] = True tri.set_mask(mask_init)   # ---------------------------------------------------------------------------- # Improving the triangulation before high-res plots: removing flat triangles # ---------------------------------------------------------------------------- # masking badly shaped triangles at the border of the triangular mesh. mask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio) tri.set_mask(mask)  # refining the data refiner = UniformTriRefiner(tri) tri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv)  # analytical 'results' for comparison z_expected = experiment_res(tri_refi.x, tri_refi.y)  # for the demo: loading the 'flat' triangles for plot flat_tri = Triangulation(x_test, y_test) flat_tri.set_mask(~mask)   # ---------------------------------------------------------------------------- # Now the plots # ---------------------------------------------------------------------------- # User options for plots plot_tri = True          # plot of base triangulation plot_masked_tri = True   # plot of excessively flat excluded triangles plot_refi_tri = False    # plot of refined triangulation plot_expected = False    # plot of analytical function values for comparison   # Graphical options for tricontouring levels = np.arange(0., 1., 0.025)  fig, ax = plt.subplots() ax.set_aspect('equal') ax.set_title('Filtering a Delaunay mesh\\n'              '(application to high-resolution tricontouring)')  # 1) plot of the refined (computed) data contours: ax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='Blues',               linewidths=[2.0, 0.5, 1.0, 0.5]) # 2) plot of the expected (analytical) data contours (dashed): if plot_expected:     ax.tricontour(tri_refi, z_expected, levels=levels, cmap='Blues',                   linestyles='--') # 3) plot of the fine mesh on which interpolation was done: if plot_refi_tri:     ax.triplot(tri_refi, color='0.97') # 4) plot of the initial 'coarse' mesh: if plot_tri:     ax.triplot(tri, color='0.7') # 4) plot of the unvalidated triangles from naive Delaunay Triangulation: if plot_masked_tri:     ax.triplot(flat_tri, color='red')  plt.show()   ",
    "instruction": " Use the following functions from matplotlib: Tricontour, Triangulation, and UniformTriRefiner, to create a high-resolution tricontour plot. Generate the initial data test points using random values within the range -1 to 1. Use the experiment_res function to calculate the z-coordinate values for each test point. Perform Delaunay triangulation on the test points. Use a matplotlib.tri.TriAnalyzer to identify and mask out flat triangles at the border of the triangular mesh. Refine the data using a matplotlib.tri.UniformTriRefiner with the specified number of subdivisions. Finally, plot the refined data contours using tricontour. ",
    "id": 53
},
{
    "data": "  ``` import matplotlib.pyplot as plt import numpy as np  import matplotlib.tri as tri   # ----------------------------------------------------------------------------- # Analytical test function # ----------------------------------------------------------------------------- def function_z(x, y):     r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)     theta1 = np.arctan2(0.5 - x, 0.5 - y)     r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)     theta2 = np.arctan2(-x - 0.2, -y - 0.2)     z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +           (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +           0.7 * (x**2 + y**2))     return (np.max(z) - z) / (np.max(z) - np.min(z))  # ----------------------------------------------------------------------------- # Creating a Triangulation # ----------------------------------------------------------------------------- # First create the x and y coordinates of the points. n_angles = 20 n_radii = 10 min_radius = 0.15 radii = np.linspace(min_radius, 0.95, n_radii)  angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += np.pi / n_angles  x = (radii * np.cos(angles)).flatten() y = (radii * np.sin(angles)).flatten() z = function_z(x, y)  # Now create the Triangulation. # (Creating a Triangulation without specifying the triangles results in the # Delaunay triangulation of the points.) triang = tri.Triangulation(x, y)  # Mask off unwanted triangles. triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),                          y[triang.triangles].mean(axis=1))                 < min_radius)  # ----------------------------------------------------------------------------- # Refine data # ----------------------------------------------------------------------------- refiner = tri.UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(z, subdiv=3) ```  ",
    "instruction": " Create a high-resolution tricontour plot using matplotlib. Use the provided data to plot it:  ``` import matplotlib.tri as tri n_angles = 20 n_radii = 10 min_radius = 0.15 radii = np.linspace(min_radius, 0.95, n_radii) angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += np.pi / n_angles x = (radii * np.cos(angles)).flatten() y = (radii * np.sin(angles)).flatten() z = function_z(x, y) triang = tri.Triangulation(x, y) triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1), y[triang.triangles].mean(axis=1)) < min_radius) refiner = tri.UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(z, subdiv=3) ```  Note: This code creates a high-resolution tricontour plot using the provided data. ",
    "id": 54
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]:  species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\") weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it:  species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\"), weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}.  [DATA]:  # ---------------------------------------------------------------------------- # Electrical potential of a dipole # ---------------------------------------------------------------------------- def dipole_potential(x, y):     '''The electric dipole potential V, at position *x*, *y*.'''     r_sq = x**2 + y**2     theta = np.arctan2(y, x)     z = np.cos(theta)/r_sq     return (np.max(z) - z) / (np.max(z) - np.min(z))  # ---------------------------------------------------------------------------- # Creating a Triangulation # ---------------------------------------------------------------------------- # First create the x and y coordinates of the points. n_angles = 30 n_radii = 10 min_radius = 0.2 radii = np.linspace(min_radius, 0.95, n_radii)  angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += np.pi / n_angles  x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() V = dipole_potential(x, y)  # Create the Triangulation; no triangles specified so Delaunay triangulation # created. triang = Triangulation(x, y)  # Mask off unwanted triangles. triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),                          y[triang.triangles].mean(axis=1))                 < min_radius)  # ---------------------------------------------------------------------------- # Refine data - interpolates the electrical potential V # ---------------------------------------------------------------------------- refiner = UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)  # ---------------------------------------------------------------------------- # Computes the electrical field (Ex, Ey) as gradient of electrical potential # ---------------------------------------------------------------------------- tci = CubicTriInterpolator(triang, -V) # Gradient requested here at the mesh nodes but could be anywhere else: (Ex, Ey) = tci.gradient(triang.x, triang.y) E_norm = np.sqrt(Ex**2 + Ey**2)  # ---------------------------------------------------------------------------- # Plot the triangulation, the potential iso-contours and the vector field # ---------------------------------------------------------------------------- fig, ax = plt.subplots() ax.set_aspect('equal') # Enforce the margins, and enlarge them to give room for the vectors. ax.use_sticky_edges = False ax.margins(0.07)  ax.triplot(triang, color='0.8')  levels = np.arange(0., 1., 0.01) ax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='hot',               linewidths=[2.0, 1.0, 1.0, 1.0]) # Plots direction of the electrical vector field ax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,           units='xy', scale=10., zorder=3, color='blue',           width=0.007, headwidth=3., headlength=4.)  ax.set_title('Gradient plot: an electrical dipole') plt.show()  [INSTRUCTION]:  Create a gradient plot of an electric dipole using matplotlib. Use the following data to plot it:  # ----------------------------------------------------------------------------  # Electrical potential of a dipole  # ---------------------------------------------------------------------------- def dipole_potential(x, y):     '''The electric dipole potential V, at position *x*, *y*.'''     r_sq = x**2 + y**2     theta = np.arctan2(y, x)     z = np.cos(theta) / r_sq     return (np.max(z) - z) / (np.max(z) - np.min(z))   # ---------------------------------------------------------------------------- # Creating a Triangulation  # ---------------------------------------------------------------------------- # First create the x and y coordinates of the points.  n_angles = 30  n_radii = 10  min_radius = 0.2  radii = np.linspace(min_radius, 0.95, n_radii)   angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)  angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)  angles[:, 1::2] += np.pi / n_angles   x = (radii * np.cos(angles)).flatten()  y = (radii * np.sin(angles)).flatten()  V = dipole_potential(x, y)   # Create the Triangulation; no triangles specified so Delaunay triangulation # created.  triang = Triangulation(x, y)   # Mask off unwanted triangles.  triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),   y[triang.triangles].mean(axis=1))                  < min_radius)   # ---------------------------------------------------------------------------- # Refine data - interpolates the electrical potential V  # ---------------------------------------------------------------------------- refiner = UniformTriRefiner(triang)  tri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)   # ---------------------------------------------------------------------------- # Computes the electrical field (Ex, Ey) as gradient of electrical potential  # ---------------------------------------------------------------------------- tci = CubicTriInterpolator(triang, -V)  # Gradient requested here at the mesh nodes but could be anywhere else:  (Ex, Ey) = tci.gradient(triang.x, triang.y)  E_norm = np.sqrt(Ex**2 + Ey**2)   # ---------------------------------------------------------------------------- # Plot the triangulation, the potential iso-contours and the vector field  # ---------------------------------------------------------------------------- fig, ax = plt.subplots()  ax.set_aspect('equal')  # Enforce the margins, and enlarge them to give room for the vectors.  ax.use_sticky_edges = False  ax.margins(0.07)   ax.triplot(triang, color='0.8')   levels = np.arange(0., 1., 0.01)  ax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='hot',                linewidths=[2.0, 1.0, 1.0, 1.0])  # Plots direction of the electrical vector field  ax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,            units='xy', scale=10., zorder=3, color='blue',            width=0.007, headwidth=3., headlength=4.)   ax.set_title('Gradient plot: an electrical dipole')  plt.show() ",
    "id": 55
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.tri as mtri  # Create triangulation. x = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5]) y = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0]) triangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7],              [5, 6, 8], [5, 8, 7], [7, 8, 9]] triang = mtri.Triangulation(x, y, triangles)  # Interpolate to regularly-spaced quad grid. z = np.cos(1.5 * x) * np.cos(1.5 * y) xi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20))  interp_lin = mtri.LinearTriInterpolator(triang, z) zi_lin = interp_lin(xi, yi)  interp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom') zi_cubic_geom = interp_cubic_geom(xi, yi)  interp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind='min_E') zi_cubic_min_E = interp_cubic_min_E(xi, yi)   ",
    "instruction": "  Use the following functions from matplotlib: tricontourf, triplot, contourf, and plot,  to create a figure with four subplots.   1. In the first subplot, plot the triangulation using the function tricontourf with the variable 'z'.     Add triangular outlines using the function triplot.  2. In the second subplot, plot the linear interpolation to a quad grid using the function contourf     with the variables 'xi' and 'yi'. Also, plot the outlines of the quad grid using the functions plot with variables 'xi' and 'yi'.  3. In the third subplot, plot the cubic interpolation to a quad grid using the function contourf     with the variables 'xi' and 'yi'. Also, plot the outlines of the quad grid using the functions plot with variables 'xi' and 'yi'.     Use the parameter 'kind' equals to 'geom' when creating the interpolator.  4. In the fourth subplot, plot the cubic interpolation to a quad grid using the function contourf     with the variables 'xi' and 'yi'. Also, plot the outlines of the quad grid using the functions plot with variables 'xi' and 'yi'.     Use the parameter 'kind' equal to 'min_E' when creating the interpolator.  Show the figure. ",
    "id": 56
},
{
    "data": " with cbook.get_sample_data('logo2.png') as file:     im = image.imread(file)  ",
    "instruction": " Use the following data to overlay an image on a plot: `im = image.imread(file)`. ",
    "id": 57
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.gridspec as gridspec  fig = plt.figure(tight_layout=True) gs = gridspec.GridSpec(2, 2)  ax = fig.add_subplot(gs[0, :]) ax.plot(np.arange(0, 1e6, 1000)) ax.set_ylabel('YLabel0') ax.set_xlabel('XLabel0')  for i in range(2):     ax = fig.add_subplot(gs[1, i])     ax.plot(np.arange(1., 0., -0.1) * 2000., np.arange(1., 0., -0.1))     ax.set_ylabel('YLabel1 %d' % i)     ax.set_xlabel('XLabel1 %d' % i)     if i == 0:         ax.tick_params(axis='x', rotation=55) fig.align_labels()  # same as fig.align_xlabels(); fig.align_ylabels()  plt.show()  ",
    "instruction": " Create a figure with a grid of 2x2 using matplotlib's GridSpec.  Add a subplot at position (0, :) and plot `np.arange(0, 1e6, 1000)` on it with ylabel 'YLabel0' and xlabel 'XLabel0'.  For each i in range(2), add a subplot at position (1, i) and plot `np.arange(1., 0., -0.1) * 2000.` against `np.arange(1., 0., -0.1)` on it.  Set the ylabel to 'YLabel1 %d' % i and the xlabel to 'XLabel1 %d' % i.  If i is 0, set the tick_params for the x-axis on this subplot to have rotation angle 55.  Finally, call fig.align_labels() to align the labels across the subplots. ",
    "id": 58
},
{
    "data": "   import matplotlib.pyplot as plt  import matplotlib.transforms as mtransforms  fig, ax = plt.subplots() ax.plot(range(10)) ax.set_yticks([2, 5, 7], labels=['really, really, really long labels'])   def on_draw(event):     bboxes = []     for label in ax.get_yticklabels():         # Bounding box in pixels         bbox_px = label.get_window_extent()         # Transform to relative figure coordinates. This is the inverse of         # transFigure.         bbox_fig = bbox_px.transformed(fig.transFigure.inverted())         bboxes.append(bbox_fig)     # the bbox that bounds all the bboxes, again in relative figure coords     bbox = mtransforms.Bbox.union(bboxes)     if fig.subplotpars.left < bbox.width:         # Move the subplot left edge more to the right         fig.subplots_adjust(left=1.1*bbox.width)  # pad a little         fig.canvas.draw()   fig.canvas.mpl_connect('draw_event', on_draw)  plt.show()  ",
    "instruction": "   Create a plot using matplotlib that includes a line plot with a range of 10, and set the y-ticks at positions 2, 5, and 7 with labels as 'really, really, really long labels'.  You can also add a draw callback function named `on_draw` that calculates bounding boxes for the y-tick labels, transforms them to relative figure coordinates, and adjusts the left edge of the subplot if necessary. ",
    "id": 59
},
{
    "data": " np.random.seed(19680801) dt = 0.001 t = np.arange(0.0, 10.0, dt) r = np.exp(-t[:1000] / 0.05) x = np.random.randn(len(t)) s = np.convolve(x, r)[:len(x)] * dt  ",
    "instruction": " To generate a plot showing Gaussian colored noise, use the following data:  np.random.seed(19680801), dt = 0.001, t = np.arange(0.0, 10.0, dt), r = np.exp(-t[:1000] / 0.05), x = np.random.randn(len(t)), s = np.convolve(x, r)[:len(x)] * dt. The plot should have a main axes with the following settings:   - x-axis limit from 0 to 1  - y-axis limit from 1.1 times the minimum value of s to 2 times the maximum value of s  - x-axis label as 'time (s)'  - y-axis label as 'current (nA)'  - title as 'Gaussian colored noise' Additionally, add two inset axes within the main plot axes.  The first inset axes should have the following settings:  - position: [0.65, 0.6, 0.2, 0.2]  - facecolor: black  - show a histogram of s with 400 bins, normalized to density  - title as 'Probability' The second inset axes should have the following settings:  - position: [0.2, 0.6, 0.2, 0.2]  - facecolor: black  - plot t[:length of r] against r  - set x-axis limit from 0 to 0.2  - title as 'Impulse response' NOTE: This example demonstrates the usage of fig.add_axes to create inset axes within the main plot axes. ",
    "id": 60
},
{
    "data": " t = np.arange(0.0, 2.0, 0.01) s = np.sin(2 * np.pi * t)  ",
    "instruction": " Create a plot using matplotlib to visualize the function `s = np.sin(2 * np.pi * t)`. Use the following data: t = np.arange(0.0, 2.0, 0.01) and s = np.sin(2 * np.pi * t). Set the grid to True with linestyle='-.', and customize the tick labels to be red and medium-sized with a width of 3. ",
    "id": 61
},
{
    "data": " \r import matplotlib.pyplot as plt\r \r from matplotlib.transforms import (Bbox, TransformedBbox,\r                                    blended_transform_factory)\r from mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\r                                                    BboxConnectorPatch,\r                                                    BboxPatch)\r \r \r def connect_bbox(bbox1, bbox2,\r                  loc1a, loc2a, loc1b, loc2b,\r                  prop_lines, prop_patches=None):\r     if prop_patches is None:\r         prop_patches = {\r             **prop_lines,\r             'alpha': prop_lines.get('alpha', 1) * 0.2,\r             'clip_on': False,\r         }\r \r     c1 = BboxConnector(\r         bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\r     c2 = BboxConnector(\r         bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\r \r     bbox_patch1 = BboxPatch(bbox1, **prop_patches)\r     bbox_patch2 = BboxPatch(bbox2, **prop_patches)\r \r     p = BboxConnectorPatch(bbox1, bbox2,\r                            loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\r                            clip_on=False,\r                            **prop_patches)\r \r     return c1, c2, bbox_patch1, bbox_patch2, p\r \r \r def zoom_effect01(ax1, ax2, xmin, xmax, **kwargs):\r     '''\r     Connect *ax1* and *ax2*. The *xmin*-to-*xmax* range in both axes will\r     be marked.\r \r     Parameters\r     ----------\r     ax1\r         The main axes.\r     ax2\r         The zoomed axes.\r     xmin, xmax\r         The limits of the colored area in both plot axes.\r     **kwargs\r         Arguments passed to the patch constructor.\r     '''\r \r     bbox = Bbox.from_extents(xmin, 0, xmax, 1)\r \r     mybbox1 = TransformedBbox(bbox, ax1.get_xaxis_transform())\r     mybbox2 = TransformedBbox(bbox, ax2.get_xaxis_transform())\r \r     prop_patches = {**kwargs, 'ec': 'none', 'alpha': 0.2}\r \r     c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\r         mybbox1, mybbox2,\r         loc1a=3, loc2a=2, loc1b=4, loc2b=1,\r         prop_lines=kwargs, prop_patches=prop_patches)\r \r     ax1.add_patch(bbox_patch1)\r     ax2.add_patch(bbox_patch2)\r     ax2.add_patch(c1)\r     ax2.add_patch(c2)\r     ax2.add_patch(p)\r \r     return c1, c2, bbox_patch1, bbox_patch2, p\r \r \r def zoom_effect02(ax1, ax2, **kwargs):\r     '''\r     ax1 : the main axes\r     ax1 : the zoomed axes\r \r     Similar to zoom_effect01.  The xmin & xmax will be taken from the\r     ax1.viewLim.\r     '''\r \r     tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\r     trans = blended_transform_factory(ax2.transData, tt)\r \r     mybbox1 = ax1.bbox\r     mybbox2 = TransformedBbox(ax1.viewLim, trans)\r \r     prop_patches = {**kwargs, 'ec': 'none', 'alpha': 0.2}\r \r     c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\r         mybbox1, mybbox2,\r         loc1a=3, loc2a=2, loc1b=4, loc2b=1,\r         prop_lines=kwargs, prop_patches=prop_patches)\r \r     ax1.add_patch(bbox_patch1)\r     ax2.add_patch(bbox_patch2)\r     ax2.add_patch(c1)\r     ax2.add_patch(c2)\r     ax2.add_patch(p)\r \r     return c1, c2, bbox_patch1, bbox_patch2, p\r \r \r axs = plt.figure().subplot_mosaic([\r     ['zoom1', 'zoom2'],\r     ['main', 'main'],\r ])\r \r axs['main'].set(xlim=(0, 5))\r zoom_effect01(axs['zoom1'], axs['main'], 0.2, 0.8)\r axs['zoom2'].set(xlim=(2, 3))\r zoom_effect02(axs['zoom2'], axs['main'])\r \r plt.show()\r \r ",
    "instruction": " Use the following functions from matplotlib: Bbox, TransformedBbox, blended_transform_factory, BboxConnector, BboxConnectorPatch, BboxPatch, plt.figure, subplot_mosaic, ax.set, ax.get_xaxis_transform, ax.bbox, TransformedBbox, ax.get_xaxis_transform, ax.transScale, ax.transLimits, ax.transAxes, plt.show to create a plot with a zoom effect. Use the provided data and function calls to generate the plot. ",
    "id": 62
},
{
    "data": " t = np.arange(-1, 2, .01) s = np.sin(2 * np.pi * t) ",
    "instruction": " Use the following functions from matplotlib: axhline, axvline, axline, axhspan, and axvspan, to create a plot with various lines and rectangles spanning the axes. Use the following data to create the plot: t = np.arange(-1, 2, .01), s = np.sin(2 * np.pi * t). ",
    "id": 63
},
{
    "data": " an = np.linspace(0, 2 * np.pi, 100)  ",
    "instruction": " Use the following data to plot a circle of radius 3 on a 2x2 grid of subplots: an = np.linspace(0, 2 * np.pi, 100). On each subplot, plot the following: - Subplot (0, 0): 3 * np.cos(an), 3 * np.sin(an). Set the title of this subplot to 'not equal, looks like ellipse'. - Subplot (0, 1): 3 * np.cos(an), 3 * np.sin(an). Set the aspect ratio to 'equal' (looks like a circle). - Subplot (1, 0): 3 * np.cos(an), 3 * np.sin(an). Set the aspect ratio to 'equal' and the x-axis limits to (-3, 3) and y-axis limits to (-3, 3). - Subplot (1, 1): 3 * np.cos(an), 3 * np.sin(an). Set the aspect ratio to 'equal box' (auto-adjusted data limits).  This code snippet demonstrates how to create plots with equal axis aspect ratios and adjust plot limits if needed. ",
    "id": 64
},
{
    "data": "  No data preparation blocks found in the provided code.  ",
    "instruction": " To generate the plot with axis label positions, you can use the following code snippet:  ``` import matplotlib.pyplot as plt  fig, ax = plt.subplots()  sc = ax.scatter([1, 2], [1, 2], c=[1, 2]) ax.set_ylabel('YLabel', loc='top') ax.set_xlabel('XLabel', loc='left') cbar = fig.colorbar(sc) cbar.set_label('ZLabel', loc='top')  plt.show() ```  The relevant context for this code snippet is: Axis Label Position. This example demonstrates how to choose axis label positions when calling `set_xlabel` and `set_ylabel`, as well as for a colorbar. ",
    "id": 65
},
{
    "data": " np.random.seed(19680801)  pts = np.random.rand(30)*.2 # Now let's make two outlier points which are far away from everything. pts[[3, 14]] += .8  # If we were to simply plot pts, we'd lose most of the interesting # details due to the outliers. So let's 'break' or 'cut-out' the y-axis # into two portions - use the top (ax1) for the outliers, and the bottom # (ax2) for the details of the majority of our data fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.subplots_adjust(hspace=0.05)  # adjust space between axes  # plot the same data on both axes ax1.plot(pts) ax2.plot(pts)  # zoom-in / limit the view to different portions of the data ax1.set_ylim(.78, 1.)  # outliers only ax2.set_ylim(0, .22)  # most of the data  # hide the spines between ax and ax2 ax1.spines.bottom.set_visible(False) ax2.spines.top.set_visible(False) ax1.xaxis.tick_top() ax1.tick_params(labeltop=False)  # don't put tick labels at the top ax2.xaxis.tick_bottom()  # Now, let's turn towards the cut-out slanted lines. # We create line objects in axes coordinates, in which (0,0), (0,1), # (1,0), and (1,1) are the four corners of the axes. # The slanted lines themselves are markers at those locations, such that the # lines keep their angle and position, independent of the axes size or scale # Finally, we need to disable clipping.  d = .5  # proportion of vertical to horizontal extent of the slanted line kwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,               linestyle='none', color='k', mec='k', mew=1, clip_on=False) ax1.plot([0, 1], [0, 0], transform=ax1.transAxes, **kwargs) ax2.plot([0, 1], [1, 1], transform=ax2.transAxes, **kwargs)   ",
    "instruction": " Create a broken axis plot using matplotlib. Use the following data to plot it: np.random.seed(19680801), pts = np.random.rand(30)*.2. ",
    "id": 66
},
{
    "data": "  np.linspace(-3, 3, 201) np.tanh(x) + 0.1 * np.cos(5 * x)  ",
    "instruction": "  Create a custom figure with a watermark using matplotlib. Use the following data to plot it:  np.linspace(-3, 3, 201) np.tanh(x) + 0.1 * np.cos(5 * x). ",
    "id": 67
},
{
    "data": " There is no data preparation block in the provided code snippet.  ",
    "instruction": " The code snippet demonstrates how to display two scales, Fahrenheit and Celsius, on the left and right y-axis of a plot. You can use the provided code to create a plot with two scales by following these steps: 1. Import the necessary libraries: import matplotlib.pyplot as plt and import numpy as np. 2. Define the function fahrenheit2celsius(temp) to convert temperatures from Fahrenheit to Celsius. 3. Define the function make_plot() to create the plot. 4. Within the make_plot() function, declare a closure function convert_ax_c_to_celsius(ax_f), which updates the second axis (ax_c) according to changes in the first axis (ax_f). 5. Create a figure and two axes (ax_f and ax_c) using fig, ax_f = plt.subplots() and ax_c = ax_f.twinx(). 6. Connect the 'ylim_changed' event of ax_f to the convert_ax_c_to_celsius function using ax_f.callbacks.connect('ylim_changed', convert_ax_c_to_celsius). 7. Plot a line graph using ax_f.plot(np.linspace(-40, 120, 100)) and set the x-axis limits using ax_f.set_xlim(0, 100). 8. Set the title of the plot to 'Two scales: Fahrenheit and Celsius' using ax_f.set_title('Two scales: Fahrenheit and Celsius'). 9. Set the y-axis labels for ax_f and ax_c using ax_f.set_ylabel('Fahrenheit') and ax_c.set_ylabel('Celsius'). 10. Display the plot using plt.show(). 11. Finally, call the make_plot() function to generate the plot. ",
    "id": 68
},
{
    "data": " t = np.arange(0.0, 2.0, 0.01) s1 = np.sin(2 * np.pi * t) s2 = np.exp(-t) s3 = s1 * s2  ",
    "instruction": " Create three adjacent subplots using matplotlib. Plot each graph using the following data: t = np.arange(0.0, 2.0, 0.01), s1 = np.sin(2 * np.pi * t), s2 = np.exp(-t), and s3 = s1 * s2. Manually set the y tick values for each subplot and set the y-axis limits accordingly. ",
    "id": 69
},
{
    "data": "   import matplotlib.pyplot as plt  fig, axs = plt.subplots(ncols=3, nrows=3) gs = axs[1, 2].get_gridspec() # remove the underlying axes for ax in axs[1:, -1]:     ax.remove() axbig = fig.add_subplot(gs[1:, -1]) axbig.annotate('Big Axes \\nGridSpec[1:, -1]', (0.1, 0.5),                xycoords='axes fraction', va='center')  fig.tight_layout()  plt.show()  ",
    "instruction": "   Combine two subplots using the subplots function and GridSpec. Remove the underlying axes using the remove method. Add a big annotation to the combined subplot using the annotate method. Use the following data:   fig, axs = plt.subplots(ncols=3, nrows=3) gs = axs[1, 2].get_gridspec() axbig = fig.add_subplot(gs[1:, -1])  Note: The plot settings and function definitions are not included in the output data, as requested. ",
    "id": 70
},
{
    "data": " `format_axes` is a function definition. ",
    "instruction": " There are no specific instructions to generate this code block, as it is a function definition block. ",
    "id": 71
},
{
    "data": "   import matplotlib.pyplot as plt  import matplotlib.gridspec as gridspec   def format_axes(fig):     for i, ax in enumerate(fig.axes):         ax.text(0.5, 0.5, 'ax%d' % (i+1), va='center', ha='center')         ax.tick_params(labelbottom=False, labelleft=False)   # gridspec inside gridspec fig = plt.figure()  gs0 = gridspec.GridSpec(1, 2, figure=fig)  gs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0])  ax1 = fig.add_subplot(gs00[:-1, :]) ax2 = fig.add_subplot(gs00[-1, :-1]) ax3 = fig.add_subplot(gs00[-1, -1])  # the following syntax does the same as the GridSpecFromSubplotSpec call above: gs01 = gs0[1].subgridspec(3, 3)  ax4 = fig.add_subplot(gs01[:, :-1]) ax5 = fig.add_subplot(gs01[:-1, -1]) ax6 = fig.add_subplot(gs01[-1, -1])  plt.suptitle('GridSpec Inside GridSpec') format_axes(fig)   ",
    "instruction": "   To create a plot with nested GridSpecs, use the following code. First, import the necessary modules:  import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec  Next, define a function to format the axes:  def format_axes(fig):     for i, ax in enumerate(fig.axes):         ax.text(0.5, 0.5, 'ax%d' % (i+1), va='center', ha='center')         ax.tick_params(labelbottom=False, labelleft=False)  Then, create the main figure and define the outer GridSpec:  fig = plt.figure() gs0 = gridspec.GridSpec(1, 2, figure=fig)  Create the first subplot GridSpec using GridSpecFromSubplotSpec:  gs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0]) ax1 = fig.add_subplot(gs00[:-1, :]) ax2 = fig.add_subplot(gs00[-1, :-1]) ax3 = fig.add_subplot(gs00[-1, -1])  Create the second subplot GridSpec using subgridspec:  gs01 = gs0[1].subgridspec(3, 3) ax4 = fig.add_subplot(gs01[:, :-1]) ax5 = fig.add_subplot(gs01[:-1, -1]) ax6 = fig.add_subplot(gs01[-1, -1])  Finally, add a title to the plot and call the format_axes function to format the axes:  plt.suptitle('GridSpec Inside GridSpec') format_axes(fig)  This code will create a plot with nested GridSpecs. ",
    "id": 72
},
{
    "data": "   t = np.arange(0.01, 5.0, 0.01) s = np.exp(-t)  ",
    "instruction": "   Create a plot with decreasing axes using matplotlib. Use the following data to plot it:  t = np.arange(0.01, 5.0, 0.01) s = np.exp(-t). Set the x-axis limit to be from 5 to 0. Set the x-axis label as 'decreasing time (s)', the y-axis label as 'voltage (mV)', and the plot title as 'Should be growing...'. Add gridlines to the plot. ",
    "id": 73
},
{
    "data": " t = np.arange(0, 10, 0.01) ",
    "instruction": " Create two subplots with shared x-axis using matplotlib. Plot np.sin(2*np.pi*t) on the first subplot and np.sin(4*np.pi*t) on the second subplot. ",
    "id": 74
},
{
    "data": " np.random.seed(19680801)  ",
    "instruction": " Use the following data to create a figure with two subplots and adjust the spacing of margins and subplots using pyplot.subplots_adjust:  np.random.seed(19680801) ",
    "id": 75
},
{
    "data": " t = np.arange(0.01, 10.0, 0.01) data1 = np.exp(t) data2 = np.sin(2 * np.pi * t)  ",
    "instruction": " Create two plots on the same axes with different left and right scales using matplotlib. Plot the data using the following arrays: t = np.arange(0.01, 10.0, 0.01), data1 = np.exp(t), data2 = np.sin(2 * np.pi * t). ",
    "id": 76
},
{
    "data": "  Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy') Z2 = np.zeros((150, 150)) ny, nx = Z.shape Z2[30:30+ny, 30:30+nx] = Z extent = (-3, 4, -4, 3) x1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9  ",
    "instruction": "  To create a zoom region inset axes plot with a rectangle showing the zoom location, use the matplotlib functions: imshow, inset_axes, and indicate_inset_zoom. Use the following data: Z, Z2, extent, x1, x2, y1, y2. ",
    "id": 77
},
{
    "data": " from collections import namedtuple  import matplotlib.pyplot as plt import numpy as np  Student = namedtuple('Student', ['name', 'grade', 'gender']) Score = namedtuple('Score', ['value', 'unit', 'percentile'])   def to_ordinal(num):     '''Convert an integer to an ordinal string, e.g. 2 -> '2nd'.'''     suffixes = {str(i): v                 for i, v in enumerate(['th', 'st', 'nd', 'rd', 'th',                                        'th', 'th', 'th', 'th', 'th'])}     v = str(num)     # special case early teens     if v in {'11', '12', '13'}:         return v + 'th'     return v + suffixes[v[-1]]   def format_score(score):     '''     Create score labels for the right y-axis as the test name followed by the     measurement unit (if any), split over two lines.     '''     return f'{score.value}\\\\\\n{score.unit}' if score.unit else str(score.value)   def plot_student_results(student, scores_by_test, cohort_size):     fig, ax1 = plt.subplots(figsize=(9, 7), layout='constrained')     fig.canvas.manager.set_window_title('Eldorado K-8 Fitness Chart')      ax1.set_title(student.name)     ax1.set_xlabel(         'Percentile Ranking Across {grade} Grade {gender}s\\\\\\n'         'Cohort Size: {cohort_size}'.format(             grade=to_ordinal(student.grade),             gender=student.gender.title(),             cohort_size=cohort_size))      test_names = list(scores_by_test.keys())     percentiles = [score.percentile for score in scores_by_test.values()]      rects = ax1.barh(test_names, percentiles, align='center', height=0.5)     # Partition the percentile values to be able to draw large numbers in     # white within the bar, and small numbers in black outside the bar.     large_percentiles = [to_ordinal(p) if p > 40 else '' for p in percentiles]     small_percentiles = [to_ordinal(p) if p <= 40 else '' for p in percentiles]     ax1.bar_label(rects, small_percentiles,                   padding=5, color='black', fontweight='bold')     ax1.bar_label(rects, large_percentiles,                   padding=-32, color='white', fontweight='bold')      ax1.set_xlim([0, 100])     ax1.set_xticks([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])     ax1.xaxis.grid(True, linestyle='--', which='major',                    color='grey', alpha=.25)     ax1.axvline(50, color='grey', alpha=0.25)  # median position      # Set the right-hand Y-axis ticks and labels     ax2 = ax1.twinx()     # Set equal limits on both yaxis so that the ticks line up     ax2.set_ylim(ax1.get_ylim())     # Set the tick locations and labels     ax2.set_yticks(         np.arange(len(scores_by_test)),         labels=[format_score(score) for score in scores_by_test.values()])      ax2.set_ylabel('Test Scores')   student = Student(name='Johnny Doe', grade=2, gender='Boy') scores_by_test = {     'Pacer Test': Score(7, 'laps', percentile=37),     'Flexed Arm\\\\\\n Hang': Score(48, 'sec', percentile=95),     'Mile Run': Score('12:52', 'min:sec', percentile=73),     'Agility': Score(17, 'sec', percentile=60),     'Push Ups': Score(14, '', percentile=16), }  plot_student_results(student, scores_by_test, cohort_size=62)  ",
    "instruction": " Create a horizontal bar chart using matplotlib. Use the following data to plot it: `student = Student(name='Johnny Doe', grade=2, gender='Boy')` and `scores_by_test = {'Pacer Test': Score(7, 'laps', percentile=37), 'Flexed Arm Hang': Score(48, 'sec', percentile=95), 'Mile Run': Score('12:52', 'min:sec', percentile=73), 'Agility': Score(17, 'sec', percentile=60), 'Push Ups': Score(14, '', percentile=16)}`. ",
    "id": 78
},
{
    "data": " np.random.seed(19680801) all_data = [np.random.normal(0, std, size=100) for std in range(1, 4)] labels = ['x1 x2 x3']  ",
    "instruction": " Create a box plot with custom fill colors using matplotlib. Use the following data to create the plot:  - np.random.seed(19680801) - all_data = [np.random.normal(0, std, size=100) for std in range(1, 4)] - labels = ['x1 x2 x3']  The plot should include two subplots: a rectangular box plot and a notched box plot. The rectangular box plot should have vertical box alignment, be filled with color, and use 'x1 x2 x3' as x-tick labels. The notched box plot should have notch shape, vertical box alignment, be filled with color, and use 'x1 x2 x3' as x-tick labels. The box plots should also have custom fill colors: 'pink', 'lightblue', and 'lightgreen'. Both subplots should have horizontal grid lines, with the y-axis representing observed values. The x-axis for both subplots should be labeled as 'Three separate samples'. ",
    "id": 79
},
{
    "data": "  np.random.seed(19680801)  all_data = [np.random.normal(0, std, 100) for std in range(6, 10)]  ",
    "instruction": " To create a comparison between a Box plot and a Violin plot, use the following data: - all_data = [np.random.normal(0, std, 100) for std in range(6, 10)]  The Box plot should have the following settings: - showmeans = False - showmedians = True  The Violin plot should have the default settings.  Make sure to add horizontal grid lines to both plots. For the x-axis, use the labels: ['x1', 'x2', 'x3', 'x4']. For the y-axis, use the label: 'Observed values'. ",
    "id": 80
},
{
    "data": "   ```python import matplotlib.pyplot as plt import numpy as np   def adjacent_values(vals, q1, q3):     upper_adjacent_value = q3 + (q3 - q1) * 1.5     upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])      lower_adjacent_value = q1 - (q3 - q1) * 1.5     lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)     return lower_adjacent_value, upper_adjacent_value   def set_axis_style(ax, labels):     ax.set_xticks(np.arange(1, len(labels) + 1), labels=labels)     ax.set_xlim(0.25, len(labels) + 0.75)     ax.set_xlabel('Sample name')   # create test data np.random.seed(19680801) data = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)]  fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True)  ax1.set_title('Default violin plot') ax1.set_ylabel('Observed values') ax1.violinplot(data)  ax2.set_title('Customized violin plot') parts = ax2.violinplot(         data, showmeans=False, showmedians=False,         showextrema=False)  for pc in parts['bodies']:     pc.set_facecolor('#D43F3A')     pc.set_edgecolor('black')     pc.set_alpha(1)  quartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1) whiskers = np.array([     adjacent_values(sorted_array, q1, q3)     for sorted_array, q1, q3 in zip(data, quartile1, quartile3)]) whiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]  inds = np.arange(1, len(medians) + 1) ax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3) ax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5) ax2.vlines(inds, whiskers_min, whiskers_max, color='k', linestyle='-', lw=1)  # set style for the axes labels = ['A B C D'] for ax in [ax1, ax2]:     set_axis_style(ax, labels)  plt.subplots_adjust(bottom=0.15, wspace=0.05) plt.show() ```  ",
    "instruction": "   To create a customized violin plot, use the following functions: `violinplot`, `vlines`, `scatter`.   First, import the necessary libraries by adding the following lines to your code: ```python import matplotlib.pyplot as plt import numpy as np ```  Next, define two helper functions: `adjacent_values` and `set_axis_style`. Copy the code block starting from `def adjacent_values(vals, q1, q3):` to the line `return lower_adjacent_value, upper_adjacent_value`. Then, copy the code block starting from `def set_axis_style(ax, labels):` to the line `ax.set_xlabel('Sample name')`.  After that, create the test data for the violin plot by adding the following line: ```python np.random.seed(19680801) data = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)] ```  Next, create the figure and axes for plotting by adding the following lines: ```python fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True) ```  For the first subplot, set the title and y-label by adding the following lines: ```python ax1.set_title('Default violin plot') ax1.set_ylabel('Observed values') ```  To create the default violin plot, add the following line: ```python ax1.violinplot(data) ```  For the second subplot, set the title by adding the following line: ```python ax2.set_title('Customized violin plot') ```  To customize the violin plot, add the following lines before creating the violin plot: ```python parts = ax2.violinplot(         data, showmeans=False, showmedians=False,         showextrema=False)  for pc in parts['bodies']:     pc.set_facecolor('#D43F3A')     pc.set_edgecolor('black')     pc.set_alpha(1) ```  Next, calculate the quartiles and whiskers for the violin plot by adding the following lines: ```python quartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1) whiskers = np.array([     adjacent_values(sorted_array, q1, q3)     for sorted_array, q1, q3 in zip(data, quartile1, quartile3)]) whiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1] ```  To add the markers and lines to the violin plot, add the following lines: ```python inds = np.arange(1, len(medians) + 1) ax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3) ax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5) ax2.vlines(inds, whiskers_min, whiskers_max, color='k', linestyle='-', lw=1) ```  To set the style for the axes, add the following lines: ```python labels = ['A B C D'] for ax in [ax1, ax2]:     set_axis_style(ax, labels) ```  Finally, adjust the bottom and horizontal space of the subplots and display the plot by adding the following lines: ```python plt.subplots_adjust(bottom=0.15, wspace=0.05) plt.show() ```  This will generate a customized violin plot with two subplots. ",
    "id": 81
},
{
    "data": " x = np.arange(0.1, 4, 0.5) y = np.exp(-x)  ",
    "instruction": " Use the errorbar function from matplotlib to create a plot with error bars. Use the following data to plot it: x = np.arange(0.1, 4, 0.5), y = np.exp(-x). ",
    "id": 82
},
{
    "data": " x = np.arange(0.1, 4, 0.5) y = np.exp(-x) error = 0.1 + 0.2 * x lower_error = 0.4 * error upper_error = error asymmetric_error = [lower_error, upper_error]  ",
    "instruction": " Create a plot with two subplots sharing the x-axis. In the first subplot, plot y as a function of x with symmetric error bars using the error values specified in the error variable. Set the title of the subplot as 'variable, symmetric error'. In the second subplot, plot y as a function of x with asymmetric error bars using the xerr parameter and the asymmetric_error variable. Set the title of the subplot as 'variable, asymmetric error'. Additionally, set the y-axis scale of the second subplot to logarithmic. ",
    "id": 83
},
{
    "data": "  x = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]) y = np.exp(-x) xerr = 0.1 yerr = 0.2 lolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool) uplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool) ls = 'dotted'  ",
    "instruction": "  Create a plot with error bars using matplotlib. Use the following data to plot it:  x = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0]) y = np.exp(-x) xerr = 0.1 yerr = 0.2 lolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool) uplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool) ls = 'dotted' Apply the following parameters to the error bars:  uplims = uplims lolims = lolims xlolims = False xuplims = False marker = 'o' markersize = 8 linestyle = 'none' Set the x-axis limits to (0, 5.5) and add a title 'Errorbar upper and lower limits'. ",
    "id": 84
},
{
    "data": "  n = 5  np.random.seed(19680801) x = np.arange(0, n, 1) y = np.random.rand(n) * 5.  xerr = np.random.rand(2, n) + 0.1 yerr = np.random.rand(2, n) + 0.2  def make_error_boxes(ax, xdata, ydata, xerror, yerror, facecolor='r',                      edgecolor='none', alpha=0.5):      errorboxes = [Rectangle((x - xe[0], y - ye[0]), xe.sum(), ye.sum())                   for x, y, xe, ye in zip(xdata, ydata, xerror.T, yerror.T)]      pc = PatchCollection(errorboxes, facecolor=facecolor, alpha=alpha,                          edgecolor=edgecolor)      ax.add_collection(pc)      artists = ax.errorbar(xdata, ydata, xerr=xerror, yerr=yerror,                           fmt='none', ecolor='k')      return artists  fig, ax = plt.subplots(1) _ = make_error_boxes(ax, x, y, xerr, yerr)  ",
    "instruction": "  Use the following data to create a box plot with error bars:  n = 5 x = np.arange(0, n, 1) y = np.random.rand(n) * 5.  xerr = np.random.rand(2, n) + 0.1 yerr = np.random.rand(2, n) + 0.2  Create a function called `make_error_boxes` that takes in an Axes object `ax`, x data `xdata`, y data `ydata`, x error `xerror`, y error `yerror`, facecolor (default is 'r'), edgecolor (default is 'none'), and alpha (default is 0.5). Inside this function, create a collection of error boxes using the Rectangle class from matplotlib.patches. Add this collection to the Axes object `ax`. Plot the error bars using the errorbar method of the Axes object `ax` and return the artists.  Create a figure and an Axes object `ax`. Call the `make_error_boxes` function with the given data and show the plot. ",
    "id": 85
},
{
    "data": " np.random.seed(19680801)  n = 100_000 x = np.random.standard_normal(n) y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n) xlim = x.min(), x.max() ylim = y.min(), y.max()  ",
    "instruction": " Create a hexagonal binned plot using matplotlib. Use the following data to plot it: np.random.seed(19680801), n = 100_000, x = np.random.standard_normal(n), y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n), xlim = x.min(), x.max(), ylim = y.min(), y.max(). ",
    "id": 86
},
{
    "data": " np.random.seed(19680801)  mu = 200 sigma = 25 n_bins = 25 data = np.random.normal(mu, sigma, size=100)  ",
    "instruction": " To create two subplots with shared x and y axes, with cumulative distributions, use the following code: ``` fig = plt.figure(figsize=(9, 4), layout='constrained') axs = fig.subplots(1, 2, sharex=True, sharey=True)  # Cumulative distributions. axs[0].ecdf(data, label='CDF') n, bins, patches = axs[0].hist(data, n_bins, density=True, histtype='step',                                cumulative=True, label='Cumulative histogram') x = np.linspace(data.min(), data.max()) y = ((1 / (np.sqrt(2 * np.pi) * sigma)) *      np.exp(-0.5 * (1 / sigma * (x - mu))**2)) y = y.cumsum() y /= y[-1] axs[0].plot(x, y, 'k--', linewidth=1.5, label='Theory')  # Complementary cumulative distributions. axs[1].ecdf(data, complementary=True, label='CCDF') axs[1].hist(data, bins=bins, density=True, histtype='step', cumulative=-1,             label='Reversed cumulative histogram') axs[1].plot(x, 1 - y, 'k--', linewidth=1.5, label='Theory')  # Label the figure. fig.suptitle('Cumulative distributions') for ax in axs:     ax.grid(True)     ax.legend()     ax.set_xlabel('Annual rainfall (mm)')     ax.set_ylabel('Probability of occurrence')     ax.label_outer()  plt.show() ```  This code creates a figure with two subplots, where the x and y axes are shared. The first subplot shows the cumulative distribution function (CDF), while the second subplot shows the complementary cumulative distribution function (CCDF). The data used for the plots is generated using `np.random.normal` with a mean of 200, a standard deviation of 25, and a sample size of 100. The cumulative histograms and the theoretical curves are plotted using the data and various plotting functions such as `ax.ecdf`, `ax.hist`, and `ax.plot`. The figure is labeled with a title and the axes are labeled as well. ",
    "id": 87
},
{
    "data": "  rng = np.random.default_rng(19680801)  # example data mu = 106  # mean of distribution sigma = 17  # standard deviation of distribution x = rng.normal(loc=mu, scale=sigma, size=420)  num_bins = 42  ",
    "instruction": "  Create a histogram of a normal distribution using the provided data. Use the `hist` function from matplotlib to plot the histogram. Set the number of bins to 42 and set the density parameter to `True` to normalize bin heights. Adjust the spacing to prevent clipping of the ylabel. ",
    "id": 88
},
{
    "data": "  np.random.seed(19680801) mu_x = 200 sigma_x = 25 x = np.random.normal(mu_x, sigma_x, size=100)  mu_w = 200 sigma_w = 10 w = np.random.normal(mu_w, sigma_w, size=100)  ",
    "instruction": "  To create a histogram with different styles, use the histogram function from matplotlib. Use the following data to generate the histogram: np.random.seed(19680801) mu_x = 200 sigma_x = 25 x = np.random.normal(mu_x, sigma_x, size=100) mu_w = 200 sigma_w = 10 w = np.random.normal(mu_w, sigma_w, size=100)  Use the following styles for the histogram: - For subplot 1 (0,0), use the \"stepfilled\" style with 20 bins, density=True, facecolor='g', and alpha=0.75. - For subplot 1 (0,1), use the \"step\" style with 20 bins, density=True, facecolor='g', and alpha=0.75. - For subplot 2 (0,0), use the \"barstacked\" style with default bins, density=True, and rwidth=0.8. Plot both x and w histograms. - For subplot 2 (1,1), use the \"bar\" style with unequal bins [100, 150, 180, 195, 205, 220, 250, 300], density=True, and rwidth=0.8.  Make sure to adjust the layout for better visualization (tight_layout). Call plt.show() to display the histogram. ",
    "id": 89
},
{
    "data": " np.random.seed(19680801)  n_bins = 10 x = np.random.randn(1000, 3)  ",
    "instruction": " Use the matplotlib function hist to create a histogram plot. This example involves multiple data sets. The plots include: 1. bars with a legend 2. stacked bar plot 3. step plot (unfilled) 4. histogram with different sample sizes. ",
    "id": 90
},
{
    "data": "  np.random.seed(19680801) number_of_bins = 20  # An example of three data sets to compare number_of_data_points = 387 labels = ['A', 'B', 'C'] data_sets = [np.random.normal(0, 1, number_of_data_points),              np.random.normal(6, 1, number_of_data_points),              np.random.normal(-3, 1, number_of_data_points)]  # Computed quantities to aid plotting hist_range = (np.min(data_sets), np.max(data_sets)) binned_data_sets = [     np.histogram(d, range=hist_range, bins=number_of_bins)[0]     for d in data_sets ] binned_maximums = np.max(binned_data_sets, axis=1) x_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))  # The bin_edges are the same for all of the histograms bin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1) heights = np.diff(bin_edges) centers = bin_edges[:-1] + heights / 2  ",
    "instruction": "  To create a plot showcasing multiple histograms, follow these instructions using matplotlib: 1. Set the random seed with `np.random.seed(19680801)`. 2. Define the number of bins as `number_of_bins = 20`. 3. Define the number of data points as `number_of_data_points = 387`. 4. Define labels for the data sets as `labels = ['A', 'B', 'C']`. 5. Create three data sets for comparison using `data_sets = [np.random.normal(0, 1, number_of_data_points), np.random.normal(6, 1, number_of_data_points), np.random.normal(-3, 1, number_of_data_points)]`. 6. Compute quantities for plotting using `hist_range = (np.min(data_sets), np.max(data_sets))`, `binned_data_sets = [np.histogram(d, range=hist_range, bins=number_of_bins)[0] for d in data_sets]`, `binned_maximums = np.max(binned_data_sets, axis=1)`, `x_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))`, `bin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1)`, `heights = np.diff(bin_edges)`, and `centers = bin_edges[:-1] + heights / 2`. 7. Create the plot by following these steps:    a. Set up the figure and axes with `fig, ax = plt.subplots()`.    b. Iterate through the `x_locations` and `binned_data_sets` using a loop.    c. For each iteration, calculate the left positions using `lefts = x_loc - 0.5 * binned_data`.    d. Plot the histograms using `ax.barh(centers, binned_data, height=heights, left=lefts)`.    e. Set the x-axis ticks using `ax.set_xticks(x_locations, labels)`.    f. Set the labels for the y-axis and x-axis using `ax.set_ylabel('Data values')` and `ax.set_xlabel('Data sets')`, respectively. 8. Display the plot using `plt.show()`. ",
    "id": 91
},
{
    "data": " np.random.seed(19680801)  fs = 10  # fontsize pos = [1, 2, 4, 5, 7, 8] data = [np.random.normal(0, std, size=100) for std in pos] ",
    "instruction": " Use the following data to create 10 custom violin plots using the function `violinplot` from matplotlib. Create subplots with 2 rows and 5 columns, with a figure size of (10, 6). For each subplot, set the title using the `set_title` function and specify the corresponding title text. Adjust the spacing between subplots using the `subplots_adjust` function. Finally, display the plot using the `show` function. ",
    "id": 92
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from matplotlib.patches import ConnectionPatch  # make figure and assign axis objects fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 5)) fig.subplots_adjust(wspace=0)  # pie chart parameters overall_ratios = [.27, .56, .17] labels = ['Approve', 'Disapprove', 'Undecided'] explode = [0.1, 0, 0] # rotate so that first wedge is split by the x-axis angle = -180 * overall_ratios[0] wedges, *_ = ax1.pie(overall_ratios, autopct='%1.1f%%', startangle=angle,                      labels=labels, explode=explode)  # bar chart parameters age_ratios = [.33, .54, .07, .06] age_labels = ['Under 35', '35-49', '50-65', 'Over 65'] bottom = 1 width = .2  # Adding from the top matches the legend. for j, (height, label) in enumerate(reversed([*zip(age_ratios, age_labels)])):     bottom -= height     bc = ax2.bar(0, height, width, bottom=bottom, color='C0', label=label,                  alpha=0.1 + 0.25 * j)     ax2.bar_label(bc, labels=[f'{height:.0%}'], label_type='center')  ax2.set_title('Age of approvers') ax2.legend() ax2.axis('off') ax2.set_xlim(- 2.5 * width, 2.5 * width)  # use ConnectionPatch to draw lines between the two plots theta1, theta2 = wedges[0].theta1, wedges[0].theta2 center, r = wedges[0].center, wedges[0].r bar_height = sum(age_ratios)  # draw top connecting line x = r * np.cos(np.pi / 180 * theta2) + center[0] y = r * np.sin(np.pi / 180 * theta2) + center[1] con = ConnectionPatch(xyA=(-width / 2, bar_height), coordsA=ax2.transData,                       xyB=(x, y), coordsB=ax1.transData) con.set_color([0, 0, 0]) con.set_linewidth(4) ax2.add_artist(con)  # draw bottom connecting line x = r * np.cos(np.pi / 180 * theta1) + center[0] y = r * np.sin(np.pi / 180 * theta1) + center[1] con = ConnectionPatch(xyA=(-width / 2, 0), coordsA=ax2.transData,                       xyB=(x, y), coordsB=ax1.transData) con.set_color([0, 0, 0]) ax2.add_artist(con) con.set_linewidth(4)  plt.show()  ",
    "instruction": "  Create a \"bar of pie\" chart using matplotlib. Use the following data to plot it:  overall_ratios = [.27, .56, .17],  labels = ['Approve', 'Disapprove', 'Undecided'],  explode = [0.1, 0, 0],  angle = -180 * overall_ratios[0],  wedges, *_ = ax1.pie(overall_ratios, autopct='%1.1f%%', startangle=angle, labels=labels, explode=explode),  age_ratios = [.33, .54, .07, .06],  age_labels = ['Under 35', '35-49', '50-65', 'Over 65'],  bottom = 1,  width = .2.  To create the plot, make a figure with two subplots, ax1 and ax2, using the figsize parameter with values (9, 5) and adjust the spacing between subplots to 0. The first subplot, ax1, is a pie chart with the overall_ratios as wedges, labels as labels, autopct='%1.1f%%', startangle=angle, and explode=explode to explode the first slice. The second subplot, ax2, is a bar chart with age_ratios as the heights of the bars, age_labels as the labels, width=width, and colors='C0'. Add a legend to ax2, set the title of ax2 to 'Age of approvers', turn off the axis of ax2, and set the x-axis limits of ax2 to (- 2.5 * width, 2.5 * width). Finally, use ConnectionPatch to draw lines between the two plots. The top line should connect the top of the bar chart in ax2 to the outer edge of the first wedge in ax1, while the bottom line should connect the bottom of the bar chart in ax2 to the outer edge of the first wedge in ax1. ",
    "id": 93
},
{
    "data": "  np.random.seed(19680801)  N = 20 theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False) radii = 10 * np.random.rand(N) width = np.pi / 4 * np.random.rand(N) colors = plt.cm.viridis(radii / 10.)  ",
    "instruction": " To create a bar chart on a polar axis, use the following code snippet: ```python import matplotlib.pyplot as plt import numpy as np  np.random.seed(19680801)  N = 20 theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False) radii = 10 * np.random.rand(N) width = np.pi / 4 * np.random.rand(N) colors = plt.cm.viridis(radii / 10.)  ax = plt.subplot(projection='polar') ax.bar(theta, radii, width=width, bottom=0.0, color=colors, alpha=0.5)  plt.show() ``` This code snippet demonstrates a bar plot on a polar axis using the `ax.bar()` function from `matplotlib.axes.Axes` and `matplotlib.pyplot`.  ",
    "id": 94
},
{
    "data": " r = np.arange(0, 2, 0.01) theta = 2 * np.pi * r  ",
    "instruction": " Use the following functions from matplotlib: plot, set_rmax, set_rticks, set_rlabel_position, and grid, to create a polar plot. Set the maximum radial value to 2, and the radial ticks to [0.5, 1, 1.5, 2]. Use the following data to create the plot: r = np.arange(0, 2, 0.01), theta = 2 * np.pi * r. ",
    "id": 95
},
{
    "data": " r = np.linspace(0, 3, 301) theta = 2 * np.pi * r angle = np.deg2rad(67.5)  ",
    "instruction": " Create a polar plot using matplotlib with two lines. Use the following data to plot it: r = np.linspace(0, 3, 301), theta = 2 * np.pi * r, angle = np.deg2rad(67.5). ",
    "id": 96
},
{
    "data": "  np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  [DATA]:  species = (     'Adelie\\n $\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), } width = 0.5  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adelie\\n $\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\mu=5076.02g$\"), weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.  [DATA]:  import matplotlib.pyplot as plt import numpy as np  from matplotlib.patches import FancyArrowPatch   def get_point_of_rotated_vertical(origin, line_length, degrees):     '''Return xy coordinates of the vertical line end rotated by degrees.'''     rad = np.deg2rad(-degrees)     return [origin[0] + line_length * np.sin(rad),             origin[1] + line_length * np.cos(rad)]   fig, ax = plt.subplots() ax.set(xlim=(0, 6), ylim=(-1, 5)) ax.set_title('Orientation of the bracket arrows relative to angleA and angleB')  style = ']-[' for i, angle in enumerate([-40, 0, 60]):     y = 2*i     arrow_centers = ((1, y), (5, y))     vlines = ((1, y + 0.5), (5, y + 0.5))     anglesAB = (angle, -angle)     bracketstyle = f'{style}, angleA={anglesAB[0]}, angleB={anglesAB[1]}'     bracket = FancyArrowPatch(*arrow_centers, arrowstyle=bracketstyle,                               mutation_scale=42)     ax.add_patch(bracket)     ax.text(3, y + 0.05, bracketstyle, ha='center', va='bottom', fontsize=14)     ax.vlines([line[0] for line in vlines], [y, y], [line[1] for line in vlines],               linestyles='--', color='C0')     patch_tops = [get_point_of_rotated_vertical(center, 0.5, angle)                   for center, angle in zip(arrow_centers, anglesAB)]     connection_dirs = (1, -1) if angle > 0 else (-1, 1)     arrowstyle = 'Simple, tail_width=0.5, head_width=4, head_length=8'     for vline, dir, patch_top, angle in zip(vlines, connection_dirs,                                             patch_tops, anglesAB):         kw = dict(connectionstyle=f'arc3,rad={dir * 0.5}',                   arrowstyle=arrowstyle, color='C0')         ax.add_patch(FancyArrowPatch(vline, patch_top, **kw))         ax.text(vline[0] - dir * 0.15, y + 0.7, f'{angle}°', ha='center',                 va='center')  [INSTRUCTION]:  Create a plot showing the orientation of the bracket arrows relative to angleA and angleB. Use the following functions and modules from matplotlib: subplots, set, set_title, add_patch, text, vlines, and FancyArrowPatch. Use the following data in the code: style = ']-[', arrow_centers = ((1, y), (5, y)), vlines = ((1, y + 0.5), (5, y + 0.5)) , anglesAB = (angle, -angle), bracketstyle = f'{style}, angleA={anglesAB[0]}, angleB={anglesAB[1]}', and connection_dirs = (1, -1) if angle > 0 else (-1, 1). ",
    "id": 97
},
{
    "data": "  x = np.arange(0, 10, 0.005) y = np.exp(-x/2.) * np.sin(2*np.pi*x)  ",
    "instruction": "  Create a line plot using matplotlib. Use the following data to plot it:  x = np.arange(0, 10, 0.005),  y = np.exp(-x/2.) * np.sin(2*np.pi*x). ",
    "id": 98
},
{
    "data": " t = np.arange(0.0, 5.0, 0.01), s = np.cos(2*np.pi*t) ",
    "instruction": " Create a plot using matplotlib. Use the following data to plot it: t = np.arange(0.0, 5.0, 0.01), s = np.cos(2*np.pi*t). Annotate the plot with an arrow pointing to the coordinates (2, 1) and the text 'local max'. Set the y-axis limits to (-2, 2). ",
    "id": 99
},
{
    "data": " r = np.arange(0, 1, 0.001), theta = 2 * 2*np.pi * r  ",
    "instruction": " Create a polar graph using matplotlib. Use the following data to plot it: r = np.arange(0, 1, 0.001), theta = 2 * 2*np.pi * r. Add an annotation to the graph with the text \"a polar annotation\" at the point (thistheta, thisr). The point (thistheta, thisr) is obtained from the data at index 800. Use an arrow to point to the annotation, with the arrow face color set to black and shrink set to 0.05. ",
    "id": 100
},
{
    "data": "  np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s.  [DATA]:  species = (     'Adelie\\n $\\\\\\\\\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it:  species = ( \"Adelie\\n $\\\\\\\\\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\\\\\\\\\mu=5076.02g$\"), weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }.  [DATA]:  No data preparation blocks were found in the provided code. ",
    "id": 101
},
{
    "data": "  import matplotlib.pyplot as plt  fig = plt.figure() plt.axis((0, 10, 0, 10)) t = ('This is a really long string that I\\'d rather have wrapped so that it '      'doesn\\'t go outside of the figure, but if it\\'s long enough it will go '      'off the top or bottom!')       ",
    "instruction": "  To create a figure with wrapped text in Matplotlib, use the following code: import matplotlib.pyplot as plt  fig = plt.figure() plt.axis((0, 10, 0, 10)) t = ('This is a really long string that I\\'d rather have wrapped so that it '      'doesn\\'t go outside of the figure, but if it\\'s long enough it will go '      'off the top or bottom!') ",
    "id": 102
},
{
    "data": " import matplotlib.pyplot as plt  import matplotlib.cbook as cbook import matplotlib.dates as mdates  # Load a numpy record array from yahoo csv data with fields date, open, high, # low, close, volume, adj_close from the mpl-data/sample_data directory. The # record array stores the date as an np.datetime64 with a day unit ('D') in # the date column. data = cbook.get_sample_data('goog.npz')['price_data']  fig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained') # common to all three: for ax in axs:     ax.plot('date adj_close', data=data)     # Major ticks every half year, minor ticks every month,     ax.xaxis.set_major_locator(mdates.MonthLocator(bymonth=(1, 7)))     ax.xaxis.set_minor_locator(mdates.MonthLocator())     ax.grid(True)     ax.set_ylabel(r'Price [\\\\$]')  # different formats: ax = axs[0] ax.set_title('DefaultFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')  ax = axs[1] ax.set_title('ConciseFormatter', loc='left', y=0.85, x=0.02, fontsize='medium') ax.xaxis.set_major_formatter(     mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))  ax = axs[2] ax.set_title('Manual DateFormatter', loc='left', y=0.85, x=0.02,              fontsize='medium') # Text in the x-axis will be displayed in 'YYYY-mm' format. ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%b')) # Rotates and right-aligns the x labels so they don't crowd each other. for label in ax.get_xticklabels(which='major'):     label.set(rotation=30, horizontalalignment='right')  plt.show()  ",
    "instruction": " Use the following functions from matplotlib: plot, set_title, set_xlabel, set_ylabel, set_ylabel, grid, set_major_locator, set_minor_locator, set_major_formatter, set_xticklabels, and show, to create a matplotlib figure with 3 subplots. In each subplot, plot the 'date adj_close' data from 'data' using the plot function. Set the title of the first subplot to 'DefaultFormatter', the title of the second subplot to 'ConciseFormatter', and the title of the third subplot to 'Manual DateFormatter'. Use the following formatters for the x-axis: DefaultFormatter for the first subplot, ConciseDateFormatter for the second subplot, and DateFormatter with the format string '%Y-%b' for the third subplot. Set the major locator of the x-axis in each subplot to MonthLocator with arguments bymonth=(1, 7), and set the minor locator of the x-axis in each subplot to MonthLocator. Enable gridlines for each subplot using the grid function. Set the y-axis label of each subplot to 'Price [\\\\$]' using the set_ylabel function. Rotate and right-align the x-axis labels of the third subplot by setting the rotation to 30 and the horizontalalignment to 'right' for each major tick label. Finally, display the plot using the show function. ",
    "id": 103
},
{
    "data": " The data used in the code snippet are as follows: - xy: (0.5, 0.7) - offsetbox: 'Test 1' - xybox: (-20, 40) - xycoords: 'data' - boxcoords: 'offset points' - arrowprops: {'arrowstyle': '->'} - bboxprops: {'boxstyle': 'sawtooth'} - offsetbox: 'Test' - xybox: (1.02, xy[1]) - boxcoords: ('axes fraction', 'data') - box_alignment: (0., 0.5) - offsetbox: DrawingArea(20, 20, 0, 0) - p: Circle((10, 10), 10) - xy: [0.3, 0.55] - da: DrawingArea(20, 20, 0, 0) - xybox: (1., xy[1]) - boxcoords: ('axes fraction', 'data') - box_alignment: (0.2, 0.5) - arrowprops: {'arrowstyle': '->'} - bboxprops: {'alpha': 0.5} - arr: np.arange(100).reshape((10, 10)) - im: OffsetImage(arr, zoom=2) - xybox: (-50., 50.) - boxcoords: 'offset points' - pad: 0.3 - arr_img: plt.imread(file) - imagebox: OffsetImage(arr_img, zoom=0.2) - xybox: (120., -80.) - boxcoords: 'offset points' - pad: 0.5 - arrowprops: {'arrowstyle': '->', 'connectionstyle': 'angle,angleA=0,angleB=90,rad=3'} - ax.set_xlim(0, 1) - ax.set_ylim(0, 1)  ",
    "instruction": " To generate the code snippet, use the following steps:  1. Import the necessary modules:    ```    import matplotlib.pyplot as plt    import numpy as np    from matplotlib.cbook import get_sample_data    from matplotlib.offsetbox import (        AnnotationBbox, DrawingArea, OffsetImage, TextArea    )    from matplotlib.patches import Circle    ```  2. Create a figure and axes:    ```    fig, ax = plt.subplots()    ```  3. Define the first position to annotate and add a marker:    ```    xy = (0.5, 0.7)    ax.plot(xy[0], xy[1], '.r')    ```  4. Create an annotation box with the text \"Test 1\" and annotate the first position:    ```    offsetbox = TextArea('Test 1')    ab = AnnotationBbox(offsetbox, xy, xybox=(-20, 40), xycoords='data', boxcoords='offset points', arrowprops=dict(arrowstyle='->'), bboxprops=dict(boxstyle='sawtooth'))    ax.add_artist(ab)    ```  5. Create another annotation box with the text \"Test\" and annotate the first position:    ```    offsetbox = TextArea('Test')    ab = AnnotationBbox(offsetbox, xy, xybox=(1.02, xy[1]), xycoords='data', boxcoords=('axes fraction', 'data'), box_alignment=(0., 0.5), arrowprops=dict(arrowstyle='->'))    ax.add_artist(ab)    ```  6. Define the second position to annotate without displaying a marker:    ```    xy = [0.3, 0.55]    ```  7. Annotate the second position with a circle patch:    ```    da = DrawingArea(20, 20, 0, 0)    p = Circle((10, 10), 10)    da.add_artist(p)    ab = AnnotationBbox(da, xy, xybox=(1., xy[1]), xycoords='data', boxcoords=('axes fraction', 'data'), box_alignment=(0.2, 0.5), arrowprops=dict(arrowstyle='->'), bboxprops=dict(alpha=0.5))    ax.add_artist(ab)    ```  8. Annotate the second position with an image using a generated array of pixels:    ```    arr = np.arange(100).reshape((10, 10))    im = OffsetImage(arr, zoom=2)    ab = AnnotationBbox(im, xy, xybox=(-50., 50.), xycoords='data', boxcoords='offset points', pad=0.3, arrowprops=dict(arrowstyle='->'))    ax.add_artist(ab)    ```  9. Annotate the second position with another image (a Grace Hopper portrait):    ```    with get_sample_data('grace_hopper.jpg') as file:        arr_img = plt.imread(file)    imagebox = OffsetImage(arr_img, zoom=0.2)    ab = AnnotationBbox(imagebox, xy, xybox=(120., -80.), xycoords='data', boxcoords='offset points', pad=0.5, arrowprops=dict(arrowstyle='->', connectionstyle='angle,angleA=0,angleB=90,rad=3'))    ax.add_artist(ab)    ```  10. Set the display limits to see everything:     ```     ax.set_xlim(0, 1)     ax.set_ylim(0, 1)     ```  11. Show the plot:     ```     plt.show()     ``` ",
    "id": 104
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from matplotlib.cbook import get_sample_data from matplotlib.image import BboxImage from matplotlib.offsetbox import (AnchoredOffsetbox, AnnotationBbox,                                   AuxTransformBox) from matplotlib.patches import PathPatch, Shadow from matplotlib.text import TextPath from matplotlib.transforms import IdentityTransform   class PathClippedImagePatch(PathPatch):     '''     The given image is used to draw the face of the patch. Internally,     it uses BboxImage whose clippath set to the path of the patch.      FIXME : The result is currently dpi dependent.     '''      def __init__(self, path, bbox_image, **kwargs):         super().__init__(path, **kwargs)         self.bbox_image = BboxImage(             self.get_window_extent, norm=None, origin=None)         self.bbox_image.set_data(bbox_image)      def set_facecolor(self, color):         '''Simply ignore facecolor.'''         super().set_facecolor('none')      def draw(self, renderer=None):         # the clip path must be updated every draw. any solution? -JJ         self.bbox_image.set_clip_path(self._path, self.get_transform())         self.bbox_image.draw(renderer)         super().draw(renderer)   if __name__ == '__main__':      fig, (ax1, ax2) = plt.subplots(2)      # EXAMPLE 1      arr = plt.imread(get_sample_data('grace_hopper.jpg'))      text_path = TextPath((0, 0), '!?', size=150)     p = PathClippedImagePatch(text_path, arr, ec='k')      # make offset box     offsetbox = AuxTransformBox(IdentityTransform())     offsetbox.add_artist(p)      # make anchored offset box     ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,                            borderpad=0.2)     ax1.add_artist(ao)      # another text     for usetex, ypos, string in [             (False, 0.25, r'textpath supports mathtext'),             (True, 0.05, r'textpath supports \\\\\\\\TeX'),     ]:         text_path = TextPath((0, 0), string, size=20, usetex=usetex)          p1 = PathPatch(text_path, ec='w', lw=3, fc='w', alpha=0.9)         p2 = PathPatch(text_path, ec='none', fc='k')          offsetbox2 = AuxTransformBox(IdentityTransform())         offsetbox2.add_artist(p1)         offsetbox2.add_artist(p2)          ab = AnnotationBbox(offsetbox2, (0.95, ypos),                             xycoords='axes fraction',                             boxcoords='offset points',                             box_alignment=(1., 0.),                             frameon=False,                             )         ax1.add_artist(ab)      ax1.imshow([[0, 1, 2], [1, 2, 3]], cmap=plt.cm.gist_gray_r,                interpolation='bilinear', aspect='auto')      # EXAMPLE 2      arr = np.arange(256).reshape(1, 256)      for usetex, xpos, string in [             (False, 0.25,              r'$\\\\\\\\left[\\\\\\\\sum_{n=1}^\\\\\\\\infty\\\\\\\\frac{-e^{i\\\\\\\\pi}}{2^n}\\\\\\\\right]$!'),             (True, 0.75,              r'$\\\\\\\\displaystyle\\\\\\\\left[\\\\\\\\sum_{n=1}^\\\\\\\\infty'              r'\\\\\\\\frac{-e^{i\\\\\\\\pi}}{2^n}\\\\\\\\right]$!'),     ]:         text_path = TextPath((0, 0), string, size=40, usetex=usetex)         text_patch = PathClippedImagePatch(text_path, arr, ec='none')         shadow1 = Shadow(text_patch, 1, -1, fc='none', ec='0.6', lw=3)         shadow2 = Shadow(text_patch, 1, -1, fc='0.3', ec='none')          # make offset box         offsetbox = AuxTransformBox(IdentityTransform())         offsetbox.add_artist(shadow1)         offsetbox.add_artist(shadow2)         offsetbox.add_artist(text_patch)          # place the anchored offset box using AnnotationBbox         ab = AnnotationBbox(offsetbox, (xpos, 0.5), box_alignment=(0.5, 0.5))          ax2.add_artist(ab)      ax2.set_xlim(0, 1)     ax2.set_ylim(0, 1)      plt.show()  ",
    "instruction": "  Create a stacked bar chart using the matplotlib library. Use the following code snippet to generate the chart:  import matplotlib.pyplot as plt import numpy as np  from matplotlib.cbook import get_sample_data from matplotlib.image import BboxImage from matplotlib.offsetbox import (AnchoredOffsetbox, AnnotationBbox,                                   AuxTransformBox) from matplotlib.patches import PathPatch, Shadow from matplotlib.text import TextPath from matplotlib.transforms import IdentityTransform   class PathClippedImagePatch(PathPatch):     '''     The given image is used to draw the face of the patch. Internally,     it uses BboxImage whose clippath set to the path of the patch.      FIXME : The result is currently dpi dependent.     '''      def __init__(self, path, bbox_image, **kwargs):         super().__init__(path, **kwargs)         self.bbox_image = BboxImage(             self.get_window_extent, norm=None, origin=None)         self.bbox_image.set_data(bbox_image)      def set_facecolor(self, color):         '''Simply ignore facecolor.'''         super().set_facecolor('none')      def draw(self, renderer=None):         # the clip path must be updated every draw. any solution? -JJ         self.bbox_image.set_clip_path(self._path, self.get_transform())         self.bbox_image.draw(renderer)         super().draw(renderer)   if __name__ == '__main__':      fig, (ax1, ax2) = plt.subplots(2)      # EXAMPLE 1      arr = plt.imread(get_sample_data('grace_hopper.jpg'))      text_path = TextPath((0, 0), '!?', size=150)     p = PathClippedImagePatch(text_path, arr, ec='k')      # make offset box     offsetbox = AuxTransformBox(IdentityTransform())     offsetbox.add_artist(p)      # make anchored offset box     ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,                            borderpad=0.2)     ax1.add_artist(ao)      # another text     for usetex, ypos, string in [             (False, 0.25, r'textpath supports mathtext'),             (True, 0.05, r'textpath supports \\\\\\\\TeX'),     ]:         text_path = TextPath((0, 0), string, size=20, usetex=usetex)          p1 = PathPatch(text_path, ec='w', lw=3, fc='w', alpha=0.9)         p2 = PathPatch(text_path, ec='none', fc='k')          offsetbox2 = AuxTransformBox(IdentityTransform())         offsetbox2.add_artist(p1)         offsetbox2.add_artist(p2)          ab = AnnotationBbox(offsetbox2, (0.95, ypos),                             xycoords='axes fraction',                             boxcoords='offset points',                             box_alignment=(1., 0.),                             frameon=False,                             )         ax1.add_artist(ab)      ax1.imshow([[0, 1, 2], [1, 2, 3]], cmap=plt.cm.gist_gray_r,                interpolation='bilinear', aspect='auto')      # EXAMPLE 2      arr = np.arange(256).reshape(1, 256)      for usetex, xpos ",
    "id": 105
},
{
    "data": " import matplotlib.pyplot as plt   def test_rotation_mode(fig, mode):     ha_list = ['left', 'center', 'right']     va_list = ['top', 'center', 'baseline', 'bottom']     axs = fig.subplots(len(va_list), len(ha_list), sharex=True, sharey=True,                        subplot_kw=dict(aspect=1),                        gridspec_kw=dict(hspace=0, wspace=0))      # labels and title     for ha, ax in zip(ha_list, axs[-1, :]):         ax.set_xlabel(ha)     for va, ax in zip(va_list, axs[:, 0]):         ax.set_ylabel(va)     axs[0, 1].set_title(f'rotation_mode='{mode}'', size='large')      kw = (         {} if mode == 'default' else         {'bbox': dict(boxstyle='square,pad=0.', ec='none', fc='C1', alpha=0.3)}     )      texts = {}      # use a different text alignment in each axes     for i, va in enumerate(va_list):         for j, ha in enumerate(ha_list):             ax = axs[i, j]             # prepare axes layout             ax.set(xticks=[], yticks=[])             ax.axvline(0.5, color='skyblue', zorder=0)             ax.axhline(0.5, color='skyblue', zorder=0)             ax.plot(0.5, 0.5, color='C0', marker='o', zorder=1)             # add text with rotation and alignment settings             tx = ax.text(0.5, 0.5, 'Tpg',                          size='x-large', rotation=40,                          horizontalalignment=ha, verticalalignment=va,                          rotation_mode=mode, **kw)             texts[ax] = tx      if mode == 'default':         # highlight bbox         fig.canvas.draw()         for ax, text in texts.items():             bb = text.get_window_extent().transformed(ax.transData.inverted())             rect = plt.Rectangle((bb.x0, bb.y0), bb.width, bb.height,                                  facecolor='C1', alpha=0.3, zorder=2)             ax.add_patch(rect)   fig = plt.figure(figsize=(8, 5)) subfigs = fig.subfigures(1, 2) test_rotation_mode(subfigs[0], 'default') test_rotation_mode(subfigs[1], 'anchor') plt.show()  ",
    "instruction": " Create two subfigures with a shared x-axis and a shared y-axis. Use the function `test_rotation_mode()` to create two plots: one with `rotation_mode='default'` and the other with `rotation_mode='anchor'`. ",
    "id": 106
},
{
    "data": " fig = plt.figure(figsize=(5.25, 0.75)) fig.text(0.5, 0.3, r'\\dfrac: $\\dfrac{a}{b}$',          horizontalalignment='center', verticalalignment='center') fig.text(0.5, 0.7, r'\\frac: $\\frac{a}{b}$',          horizontalalignment='center', verticalalignment='center')  ",
    "instruction": " Create a figure with the size of 5.25 x 0.75. Add two text annotations using the TeX macros \\dfrac and \\frac. Use the following data to create the annotations:  fig.text(0.5, 0.3, r'\\dfrac: $\\dfrac{a}{b}$',          horizontalalignment='center', verticalalignment='center')  fig.text(0.5, 0.7, r'\\frac: $\\frac{a}{b}$',          horizontalalignment='center', verticalalignment='center'). ",
    "id": 107
},
{
    "data": "   np.random.seed(19680801)  xs = np.logspace(1, 9, 100) ys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2  ",
    "instruction": "   To label ticks using engineering notation, you can use the engineering Formatter from matplotlib.ticker module. Here is an example code snippet that demonstrates the usage of the formatter:  ```python import matplotlib.pyplot as plt import numpy as np from matplotlib.ticker import EngFormatter  # Fixing random state for reproducibility np.random.seed(19680801)  # Create artificial data to plot. # The x data span over several decades to demonstrate several SI prefixes. xs = np.logspace(1, 9, 100) ys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2  # Figure width is doubled (2*6.4) to display nicely 2 subplots side by side. fig, (ax0, ax1) = plt.subplots(nrows=2, figsize=(7, 9.6)) for ax in (ax0, ax1):     ax.set_xscale('log')  # Demo of the default settings, with a user-defined unit label. ax0.set_title('Full unit ticklabels, w/ default precision & space separator') formatter0 = EngFormatter(unit='Hz') ax0.xaxis.set_major_formatter(formatter0) ax0.plot(xs, ys) ax0.set_xlabel('Frequency')  # Demo of the options `places` (number of digit after decimal point) and # `sep` (separator between the number and the prefix/unit). ax1.set_title('SI-prefix only ticklabels, 1-digit precision & thin space separator') formatter1 = EngFormatter(places=1, sep='\\N{THIN SPACE}')  # U+2009 ax1.xaxis.set_major_formatter(formatter1) ax1.plot(xs, ys) ax1.set_xlabel('Frequency [Hz]')  plt.tight_layout() plt.show() ```  This code demonstrates how to label ticks on the x-axis using engineering notation. The `EngFormatter` class from the `matplotlib.ticker` module is used to format the tick labels. The first subplot shows the tick labels with full unit names, default precision, and space separator. The second subplot shows the tick labels with SI-prefixes only, 1-digit precision, and thin space separator. The data used in this example is `xs = np.logspace(1, 9, 100)` and `ys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2`. ",
    "id": 108
},
{
    "data": " Code block 1: styles = mpatches.ArrowStyle.get_styles() ncol = 2 nrow = (len(styles) + 1) // ncol axs = (plt.figure(figsize=(4 * ncol, 1 + nrow))        .add_gridspec(1 + nrow, ncol,                      wspace=.7, left=.1, right=.9, bottom=0, top=1).subplots()) for ax in axs.flat:     ax.set_axis_off() for ax in axs[0, :]:     ax.text(0, .5, 'arrowstyle',             transform=ax.transAxes, size='large', color='tab:blue',             horizontalalignment='center', verticalalignment='center')     ax.text(.35, .5, 'default parameters',             transform=ax.transAxes,             horizontalalignment='left', verticalalignment='center') for ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):     l, = ax.plot(.25, .5, 'ok', transform=ax.transAxes)     ax.annotate(stylename, (.25, .5), (-0.1, .5),                 xycoords='axes fraction', textcoords='axes fraction',                 size='large', color='tab:blue',                 horizontalalignment='center', verticalalignment='center',                 arrowprops=dict(                     arrowstyle=stylename, connectionstyle='arc3,rad=-0.05',                     color='k', shrinkA=5, shrinkB=5, patchB=l,                 ),                 bbox=dict(boxstyle='square', fc='w'))     # wrap at every nth comma (n = 1 or 2, depending on text length)     s = str(inspect.signature(stylecls))[1:-1]     n = 2 if s.count(',') > 3 else 1     ax.text(.35, .5,             re.sub(', ', lambda m, c=itertools.count(1): m.group()                    if next(c) % n else '\\\\\\n', s),             transform=ax.transAxes,             horizontalalignment='left', verticalalignment='center')  ",
    "instruction": " Create multiple subplots using matplotlib. Use the `mpatches.ArrowStyle.get_styles()` function to get the available arrow styles. Set the number of columns `ncol` to 2 and calculate the number of rows `nrow` using the length of styles. Create a figure using `plt.figure(figsize=(4 * ncol, 1 + nrow))` and add a grid of subplots using `add_gridspec(1 + nrow, ncol, wspace=.7, left=.1, right=.9, bottom=0, top=1)`. Iterate over each subplot and set their axis off using `ax.set_axis_off()`. For the first row of subplots, add text annotations for 'arrowstyle' and 'default parameters'. For the remaining subplots, plot a point at (0.25, 0.5) and annotate with the stylename, arrowstyle, and other parameters. Wrap the annotation string at every nth comma, where n is determined based on the text length. Finally, show the plot using `plt.show()`. ",
    "id": 109
},
{
    "data": " No data preparation blocks found in the provided code.  ",
    "instruction": " Create a matplotlib plot that shows styled text boxes. Use the following code snippet and relevant context to generate the plot:  import matplotlib.pyplot as plt  plt.text(0.6, 0.7, 'eggs', size=50, rotation=30.,          ha='center', va='center',          bbox=dict(boxstyle='round',                    ec=(1., 0.5, 0.5),                    fc=(1., 0.8, 0.8),                    )          )  plt.text(0.55, 0.6, 'spam', size=50, rotation=-25.,          ha='right', va='top',          bbox=dict(boxstyle='square',                    ec=(1., 0.5, 0.5),                    fc=(1., 0.8, 0.8),                    )          )  plt.show()  This code snippet demonstrates how to style text boxes using the bbox parameters. ",
    "id": 110
},
{
    "data": "  fpath = Path(mpl.get_data_path(), 'fonts/ttf/cmr10.ttf')  ",
    "instruction": "  To use a ttf font file in Matplotlib, follow these steps: 1. Import the required libraries:    from pathlib import Path    import matplotlib.pyplot as plt    import matplotlib as mpl     2. Create a figure and an axis object:    fig, ax = plt.subplots()     3. Specify the path to the ttf font file:    fpath = Path(mpl.get_data_path(), 'fonts/ttf/cmr10.ttf')     4. Set the title of the plot using the special font:    ax.set_title(f'This is a special font: {fpath.name}', font=fpath)     5. Set the xlabel using the default font:    ax.set_xlabel('This is the default font')     6. Display the plot:    plt.show() ",
    "id": 111
},
{
    "data": "  import matplotlib.pyplot as plt  from matplotlib.font_manager import FontProperties  fig = plt.figure() alignment = {'horizontalalignment': 'center verticalalignment': 'baseline'} yp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2] heading_font = FontProperties(size='large')  # Show family options fig.text(0.1, 0.9, 'family', fontproperties=heading_font, **alignment) families = ['serif sans-serif cursive fantasy monospace'] for k, family in enumerate(families):     font = FontProperties()     font.set_family(family)     fig.text(0.1, yp[k], family, fontproperties=font, **alignment)  # Show style options styles = ['normal italic oblique'] fig.text(0.3, 0.9, 'style', fontproperties=heading_font, **alignment) for k, style in enumerate(styles):     font = FontProperties()     font.set_family('sans-serif')     font.set_style(style)     fig.text(0.3, yp[k], style, fontproperties=font, **alignment)  # Show variant options variants = ['normal small-caps'] fig.text(0.5, 0.9, 'variant', fontproperties=heading_font, **alignment) for k, variant in enumerate(variants):     font = FontProperties()     font.set_family('serif')     font.set_variant(variant)     fig.text(0.5, yp[k], variant, fontproperties=font, **alignment)  # Show weight options weights = ['light normal medium semibold bold heavy black'] fig.text(0.7, 0.9, 'weight', fontproperties=heading_font, **alignment) for k, weight in enumerate(weights):     font = FontProperties()     font.set_weight(weight)     fig.text(0.7, yp[k], weight, fontproperties=font, **alignment)  # Show size options sizes = [     'xx-small x-small small medium large x-large xx-large'] fig.text(0.9, 0.9, 'size', fontproperties=heading_font, **alignment) for k, size in enumerate(sizes):     font = FontProperties()     font.set_size(size)     fig.text(0.9, yp[k], size, fontproperties=font, **alignment)  # Show bold italic font = FontProperties(style='italic', weight='bold', size='x-small') fig.text(0.3, 0.1, 'bold italic', fontproperties=font, **alignment) font = FontProperties(style='italic', weight='bold', size='medium') fig.text(0.3, 0.2, 'bold italic', fontproperties=font, **alignment) font = FontProperties(style='italic', weight='bold', size='x-large') fig.text(0.3, 0.3, 'bold italic', fontproperties=font, **alignment)  plt.show()  ",
    "instruction": "  Create a fonts demo in matplotlib using the object-oriented style. Set font properties using setters. Use the following data to create the demo: - alignment = {'horizontalalignment': 'center', 'verticalalignment': 'baseline'} - yp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2] - heading_font = FontProperties(size='large') - families = ['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'] - styles = ['normal', 'italic', 'oblique'] - variants = ['normal', 'small-caps'] - weights = ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black'] - sizes = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] ",
    "id": 112
},
{
    "data": " yp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2] \\nfamilies = ['serif sans-serif cursive fantasy monospace'] \\nstyles = ['normal italic oblique'] \\nvariants = ['normal small-caps'] \\nweights = ['light normal medium semibold bold heavy black'] \\nsizes = ['xx-small x-small small medium large x-large xx-large']  ",
    "instruction": " Create a fonts demo using keyword arguments in matplotlib. Use the following data to customize the fonts: \\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2] \\nfamilies = ['serif sans-serif cursive fantasy monospace'] \\nstyles = ['normal italic oblique'] \\nvariants = ['normal small-caps'] \\nweights = ['light normal medium semibold bold heavy black'] \\nsizes = ['xx-small x-small small medium large x-large xx-large'] ",
    "id": 113
},
{
    "data": " a = b = np.arange(0, 3, .02) c = np.exp(a) d = c[::-1] ",
    "instruction": " Use the following functions from matplotlib: plot and legend, to create a plot with pre-defined labels. Plot three lines using the arrays a, c, and d. Use the labels 'Model length', 'Data length', and 'Total message length' for the lines. Display a legend at the upper center of the plot with a shadow and large font size. ",
    "id": 114
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.lines as lines import matplotlib.text as mtext import matplotlib.transforms as mtransforms   class MyLine(lines.Line2D):     def __init__(self, *args, **kwargs):         self.text = mtext.Text(0, 0, '')         super().__init__(*args, **kwargs)         self.text.set_text(self.get_label())      def set_figure(self, figure):         self.text.set_figure(figure)         super().set_figure(figure)      @lines.Line2D.axes.setter     def axes(self, new_axes):         self.text.axes = new_axes         lines.Line2D.axes.fset(self, new_axes)      def set_transform(self, transform):         texttrans = transform + mtransforms.Affine2D().translate(2, 2)         self.text.set_transform(texttrans)         super().set_transform(transform)      def set_data(self, x, y):         if len(x):             self.text.set_position((x[-1], y[-1]))          super().set_data(x, y)      def draw(self, renderer):         super().draw(renderer)         self.text.draw(renderer)  # Fixing random state for reproducibility np.random.seed(19680801)   fig, ax = plt.subplots() x, y = np.random.rand(2, 20) line = MyLine(x, y, mfc='red', ms=12, label='line label') line.text.set_color('red') line.text.set_fontsize(16)  ax.add_line(line)  plt.show()  ",
    "instruction": " Use the following functions from matplotlib: lines, text, transforms, and pyplot, to create a plot with a line and a text label. Inside the plot, override the basic methods of the line artist to contain a text artist within it. Use the provided data to generate the plot. ",
    "id": 115
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  [DATA]:  species = (\"Adelie\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\mu=5076.02g$\") weight_counts = {     \"Below\": np.array([70, 31, 58]),     \"Above\": np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = (\"Adelie\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\mu=5076.02g$\"), weight_counts = {\"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.  [DATA]:  from io import BytesIO  import matplotlib.pyplot as plt  from matplotlib.figure import Figure from matplotlib.transforms import IdentityTransform   def text_to_rgba(s, *, dpi, **kwargs):     fig = Figure(facecolor='none')     fig.text(0, 0, s, **kwargs)     with BytesIO() as buf:         fig.savefig(buf, dpi=dpi, format='png', bbox_inches='tight',                     pad_inches=0)         buf.seek(0)         rgba = plt.imread(buf)     return rgba   fig = plt.figure() rgba1 = text_to_rgba(r'IQ: $\\\\\\\\sigma_i=15$', color='blue', fontsize=20, dpi=200) rgba2 = text_to_rgba(r'some other string', color='red', fontsize=20, dpi=200) fig.figimage(rgba1, 100, 50) fig.figimage(rgba2, 100, 150) fig.text(100, 250, r'IQ: $\\\\\\\\sigma_i=15$', color='blue', fontsize=20,          transform=IdentityTransform()) fig.text(100, 350, r'some other string', color='red', fontsize=20,          transform=IdentityTransform())  [INSTRUCTION]:  Create a matplotlib figure and draw two text images to it. Use the function `text_to_rgba` to convert the text strings to images. Then, use the `fig.figimage` method to draw the text images to the figure. Finally, use the `fig.text` method to directly draw texts to the figure with positioning in pixel coordinates using the `IdentityTransform`. ",
    "id": 116
},
{
    "data": "  tex = r'$\\mathcal{R}\\prod_{i=\\alpha_{i+1}}^\\infty a_i\\sin(2 \\pi f x_i)$',  ",
    "instruction": "  Create a plot with a line graph using matplotlib. Use the following data to create the plot: tex = r'$\\mathcal{R}\\prod_{i=\\alpha_{i+1}}^\\infty a_i\\sin(2 \\pi f x_i)$'. ",
    "id": 117
},
{
    "data": " None ",
    "instruction": "  Create a plot with a simple background using matplotlib. Include two texts in the plot, one with normal text and math text, and another with normal text and math text using a different font. Set the title of the plot using math mode text. Use the following data to create the plot:  msg = (r'Normal Text. $Text\\\\\\\\ in\\\\\\\\ math\\\\\\\\ mode:\\\\\\\\ '\\n       r'\\\\\\\\int_{0}^{\\\\\\\\infty } x^2 dx$')  ",
    "id": 118
},
{
    "data": "  np.arange(10) np.array([0.2, 0.4, 0.6, 0.8, 1.]) labels=['Jan\\n2009', 'Feb\\n2009', 'Mar\\n2009', 'Apr\\n2009', 'May\\n2009']  ",
    "instruction": "  To generate a plot with two subplots, use the following code snippet: ``` import matplotlib.pyplot as plt import numpy as np  fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(7, 4))  ax0.set_aspect(1) ax0.plot(np.arange(10)) ax0.set_xlabel('this is a xlabel\\n(with newlines!)') ax0.set_ylabel('this is vertical\\ntest', multialignment='center') ax0.text(2, 7, 'this is\\nyet another test',          rotation=45,          horizontalalignment='center',          verticalalignment='top',          multialignment='center')  ax0.grid()   ax1.text(0.29, 0.4, 'Mat\\nTTp\\n123', size=18,          va='baseline', ha='right', multialignment='left',          bbox=dict(fc='none'))  ax1.text(0.34, 0.4, 'Mag\\nTTT\\n123', size=18,          va='baseline', ha='left', multialignment='left',          bbox=dict(fc='none'))  ax1.text(0.95, 0.4, 'Mag\\nTTT$^{A^A}$\\n123', size=18,          va='baseline', ha='right', multialignment='left',          bbox=dict(fc='none'))  ax1.set_xticks([0.2, 0.4, 0.6, 0.8, 1.],                labels=['Jan\\n2009', 'Feb\\n2009', 'Mar\\n2009', 'Apr\\n2009',                        'May\\n2009'])  ax1.axhline(0.4) ax1.set_title('test line spacing for multiline text')  fig.subplots_adjust(bottom=0.25, top=0.75) plt.show() ```  ",
    "id": 119
},
{
    "data": " np.random.seed(19680801)  x = 30*np.random.randn(10000) mu = x.mean() median = np.median(x) sigma = x.std() textstr = '\\n'.join((     r'$\\mu=%.2f$' % (mu, ),     r'$\\mathrm{median}=%.2f$' % (median, ),     r'$\\sigma=%.2f$' % (sigma, )))  ",
    "instruction": " Use the following data to create a histogram with text boxes using Matplotlib: np.random.seed(19680801), x = 30*np.random.randn(10000), mu = x.mean(), median = np.median(x), sigma = x.std(), textstr = '\\n'.join((r'$\\mu=%.2f$' % (mu, ), r'$\\mathrm{median}=%.2f$' % (median, ), r'$\\sigma=%.2f$' % (sigma, ))). Place the text box in the upper left corner of the plot using axes coordinates and use the bbox property to surround the text with a Patch instance. ",
    "id": 120
},
{
    "data": " plt.rcParams['font.size'] = 20 ax = plt.figure().add_subplot(xticks=[], yticks=[])  # The first word, created with text(). text = ax.text(.1, .5, 'Matplotlib', color='red') # Subsequent words, positioned with annotate(), relative to the preceding one. text = ax.annotate(     ' says,', xycoords=text, xy=(1, 0), verticalalignment='bottom',     color='gold', weight='bold')  # custom properties text = ax.annotate(     ' hello', xycoords=text, xy=(1, 0), verticalalignment='bottom',     color='green', style='italic')  # custom properties text = ax.annotate(     ' world!', xycoords=text, xy=(1, 0), verticalalignment='bottom',     color='blue', family='serif')  # custom properties  ",
    "instruction": " Create a plot using matplotlib that concatenates text objects with different properties. The example strings together several text objects with different properties (color or font), positioning each one after the other. The first text is created using the text() function, and all subsequent ones are created with the annotate() function, allowing positioning the text's lower left corner at the lower right corner (xy=(1, 0)) of the previous one (xycoords=text). Use the following data to create the plot: plt.rcParams['font.size'] = 20, ax = plt.figure().add_subplot(xticks=[], yticks=[]). ",
    "id": 121
},
{
    "data": " circle123 = '\\N{CIRCLED DIGIT ONE}\\N{CIRCLED DIGIT TWO}\\N{CIRCLED DIGIT THREE}' tests = [     r'$%s\\;\\mathrm{%s}\\;\\mathbf{%s}$' % ((circle123,) * 3),     r'$\\mathsf{Sans \\Omega}\\;\\mathrm{\\mathsf{Sans \\Omega}};'     r'\\mathbf{\\mathsf{Sans \\Omega}}$',     r'$\\mathtt{Monospace}$',     r'$\\mathcal{CALLIGRAPHIC}$',     r'$\\mathbb{Blackboard\\pi}$',     r'$\\mathrm{\\mathbb{Blackboard\\pi}}$',     r'$\\mathbf{\\mathbb{Blackboard\\pi}}$',     r'$\\mathfrak{Fraktur}\\;\\mathbf{\\mathfrak{Fraktur}}$',     r'$\\mathscr{Script}$', ]  ",
    "instruction": " Create a figure to demonstrate STIX Fonts used in LaTeX rendering. Use the following data to plot the figure:  circle123 = '\\N{CIRCLED DIGIT ONE}\\N{CIRCLED DIGIT TWO}\\N{CIRCLED DIGIT THREE}' tests = [     r'$%s\\;\\mathrm{%s}\\;\\mathbf{%s}$' % ((circle123,) * 3),     r'$\\mathsf{Sans \\Omega}\\;\\mathrm{\\mathsf{Sans \\Omega}};'     r'\\mathbf{\\mathsf{Sans \\Omega}}$',     r'$\\mathtt{Monospace}$',     r'$\\mathcal{CALLIGRAPHIC}$',     r'$\\mathbb{Blackboard\\pi}$',     r'$\\mathrm{\\mathbb{Blackboard\\pi}}$',     r'$\\mathbf{\\mathbb{Blackboard\\pi}}$',     r'$\\mathfrak{Fraktur}\\;\\mathbf{\\mathfrak{Fraktur}}$',     r'$\\mathscr{Script}$', ] ",
    "id": 122
},
{
    "data": " np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  [DATA]: species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\") weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\"), weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}.  [DATA]: No data preparation blocks found.  [INSTRUCTION]: No specific instruction found. ",
    "id": 123
},
{
    "data": " There is no data preparation block in the provided code.  ",
    "instruction": " Create a figure object using the `matplotlib.pyplot.figure()` function. Set the figure supertitle to \"bold figure suptitle\" with a font size of 14 and font weight of \"bold\". Add an axes to the figure using the `figure.add_subplot()` function. Adjust the top spacing of the subplots using `figure.subplots_adjust()` function, with the value `top=0.85`. Set the title of the axes to \"axes title\" using the `axes.set_title()` function. Set the x-label of the axes to \"xlabel\" and the y-label to \"ylabel\" using the `axes.set_xlabel()` and `axes.set_ylabel()` functions, respectively. Add text to the axes at the coordinates (3, 8) with the content \"boxed italics text in data coords\" and with the style set to \"italic\" using the `axes.text()` function. Additionally, add a box around the text with a face color of \"red\" and an alpha value of 0.5, with a padding of 10. Add another text at the coordinates (2, 6) with the content \"an equation: E=mc^2\" and a font size of 15. Add another text at the coordinates (3, 2) with the content \"Unicode: Institut für Festkörperphysik\". Add another text at axes coordinates (0.95, 0.01) with the content \"colored text in axes coords\", vertical alignment set to \"bottom\", and horizontal alignment set to \"right\" using the `axes.text()` function. Set the text color to \"green\" and font size to 15. Add a point marker to the axes at the coordinates (2, 1) using the `axes.plot()` function with the marker style 'o'. Annotate the point with the text \"annotate\" using the `axes.annotate()` function, with an arrow pointing from the coordinates (2, 1) to (3, 4) and with a black arrow color and shrinkage factor of 0.05. Set the x-limits of the axes to (0, 10) and the y-limits to (0, 10) using the `axes.set()` function. Finally, display the figure using `matplotlib.pyplot.show()`. ",
    "id": 124
},
{
    "data": "  font = {'family': 'serif',         'color':  'darkred',         'weight': 'normal',         'size': 16,         }  x = np.linspace(0.0, 5.0, 100) y = np.cos(2*np.pi*x) * np.exp(-x)  ",
    "instruction": " Create a plot of the damped exponential decay using matplotlib. Use the following data to plot it:  font = {'family': 'serif',         'color':  'darkred',         'weight': 'normal',         'size': 16,         }, x = np.linspace(0.0, 5.0, 100), and y = np.cos(2*np.pi*x) * np.exp(-x). ",
    "id": 125
},
{
    "data": "  fig, ax = plt.subplots()  # Plot diagonal line (45 degrees) h = ax.plot(range(0, 10), range(0, 10))  # set limits so that it no longer looks on screen to be 45 degrees ax.set_xlim([-10, 20])  # Locations to plot text l1 = np.array((1, 1)) l2 = np.array((5, 5))  # Rotate angle angle = 45  # Plot text th1 = ax.text(*l1, 'text not rotated correctly', fontsize=16,               rotation=angle, rotation_mode='anchor') th2 = ax.text(*l2, 'text rotated correctly', fontsize=16,               rotation=angle, rotation_mode='anchor',               transform_rotates_text=True)   ",
    "instruction": "  To generate the plot, use the following code and settings:  import matplotlib.pyplot as plt import numpy as np  fig, ax = plt.subplots()  # Plot a diagonal line h = ax.plot(range(0, 10), range(0, 10))  # Set the x-axis limits to make the line appear differently ax.set_xlim([-10, 20])  # Define the locations for text plotting l1 = np.array((1, 1)) l2 = np.array((5, 5))  # Specify the rotation angle angle = 45  # Plot the text with rotation th1 = ax.text(*l1, 'text not rotated correctly', fontsize=16,               rotation=angle, rotation_mode='anchor') th2 = ax.text(*l2, 'text rotated correctly', fontsize=16,               rotation=angle, rotation_mode='anchor',               transform_rotates_text=True)  This code snippet demonstrates text rotation relative to a line in a plot. The axis limits are set to change the appearance of the line, and two text objects are plotted with different rotation behaviors. ",
    "id": 126
},
{
    "data": "  fig = plt.figure(figsize=(4, 2)) fig.text(.15, .6, 'Unicode minus:', fontsize=20) fig.text(.85, .6, '\\\\N{MINUS SIGN}1', ha='right', fontsize=20) fig.text(.15, .3, 'ASCII hyphen:', fontsize=20) fig.text(.85, .3, '-1', ha='right', fontsize=20)  ",
    "instruction": "  To create a figure with text annotations, use the following code:   fig = plt.figure(figsize=(4, 2)) fig.text(.15, .6, 'Unicode minus:', fontsize=20) fig.text(.85, .6, '\\\\N{MINUS SIGN}1', ha='right', fontsize=20) fig.text(.15, .3, 'ASCII hyphen:', fontsize=20) fig.text(.85, .3, '-1', ha='right', fontsize=20)  This code will create a figure with text annotations. The annotations will display \"Unicode minus:\" and \"\\\\N{MINUS SIGN}1\" on the left side of the figure, and \"ASCII hyphen:\" and \"-1\" on the right side of the figure. The font size of the annotations is set to 20. ",
    "id": 127
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  ---  [DATA]: species = (     'Adelie\\n $\\\\mu=3700.66g$',     'Chinstrap\\n $\\\\mu=3733.09g$',     'Gentoo\\n $\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it:  species = (     'Adelie\\n $\\\\mu=3700.66g$',     'Chinstrap\\n $\\\\mu=3733.09g$',     'Gentoo\\n $\\\\mu=5076.02g$', ),  weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  ---  [DATA]: plt.rcParams.update({'mathtext.fontset': 'cm', 'mathtext.rm': 'serif'}) axs = plt.figure(figsize=(2 * 3, 6.5)).subplots(1, 2) for ax, usetex in zip(axs, [False, True]):     ax.axvline(0, color='r')     test_strings = ['lg', r'$\\\\frac{1}{2}\\\\pi$', r'$p^{3^A}$', r'$p_{3_2}$']     for i, s in enumerate(test_strings):         ax.axhline(i, color='r')         ax.text(0., 3 - i, s,                 usetex=usetex,                 verticalalignment='baseline',                 size=50,                 bbox=dict(pad=0, ec='k', fc='none'))     ax.set(xlim=(-0.1, 1.1), ylim=(-.8, 3.9), xticks=[], yticks=[],            title=f'usetex={usetex}\\n')  [INSTRUCTION]: Create a figure with two subplots and set the Baseline Test Comparison of text baselines computed for mathtext and usetex as the relevant context. Use the following data to generate the plot: plt.rcParams.update({'mathtext.fontset': 'cm', 'mathtext.rm': 'serif'}) axs = plt.figure(figsize=(2 * 3, 6.5)).subplots(1, 2) for ax, usetex in zip(axs, [False, True]):     ax.axvline(0, color='r')     test_strings = ['lg', r'$\\\\frac{1}{2}\\\\pi$', r'$p^{3^A}$', r'$p_{3_2}$']     for i, s in enumerate(test_strings):         ax.axhline(i, color='r')         ax.text(0., 3 - i, s,                 usetex=usetex,                 verticalalignment='baseline',                 size=50,                 bbox=dict(pad=0, ec='k', fc='none'))     ax.set(xlim=(-0.1, 1.1), ylim=(-.8, 3.9), xticks=[], yticks=[],            title=f'usetex={usetex}\\n')   ",
    "id": 128
},
{
    "data": "  setFont(font):     return rf'\\\\font\\\\a {font} at 14pt\\\\a '  ",
    "instruction": "  Create a figure with multiple text elements using different fonts and text effects. The fonts and text effects to be used are as follows: - Font: ['ptmr8r ptmri8r ptmro8r ptmr8rn ptmrr8re'] - Text: [f'Nimbus Roman No9 L {x}' for x in [' Italics (real italics for comparison)', '(slanted) (condensed) (extended)']]  Each text element should be positioned vertically on the figure based on its index in the list. Set the suptitle of the figure to 'Usetex font effects'. Display the figure using plt.show(). ",
    "id": 129
},
{
    "data": " np.random.seed(19680801)  ",
    "instruction": " Use the following data to create a plot with a text watermark effect. Set the random seed as np.random.seed(19680801). Use the following code to generate the plot:  ```python import matplotlib.pyplot as plt import numpy as np  fig, ax = plt.subplots() ax.plot(np.random.rand(20), '-o', ms=20, lw=2, alpha=0.7, mfc='orange') ax.grid()  ax.text(0.5, 0.5, 'created with matplotlib', transform=ax.transAxes,         fontsize=40, color='gray', alpha=0.5,         ha='center', va='center', rotation=30)  plt.show() ```  This plot demonstrates the use of the `text()` function to create a watermark effect. The watermark text says 'created with matplotlib' and is semi-transparent. ",
    "id": 130
},
{
    "data": " t = np.linspace(0.0, 2.0, 201) s = np.sin(2 * np.pi * t)  ",
    "instruction": " Use the following data to create a plot titled \"Voltage vs. time chart\". Set the facecolor of the plot to an RGB tuple of float values (0.18, 0.31, 0.31). Set the background color to a hex string '#eafff5'. Set the color of the title to a gray level string '0.7'. Set the color of the x-axis label to a single letter color string 'c'. Set the color of the y-axis label to a named color 'peachpuff'. Plot the data using a line plot with the x-axis data as t, and the y-axis data as s. Set the color of the line to a named xkcd color 'crimson'. Plot another line using the x-axis data as t and the y-axis data as 0.7*s. Set the color of this line using a 'C4' notation. Set the color of the tick labels to 'tab:orange'. ",
    "id": 131
},
{
    "data": "  t = np.arange(0.0, 2.0, 0.01) s = np.sin(2 * np.pi * t) upper = 0.77 lower = -0.77 supper = np.ma.masked_where(s < upper, s) slower = np.ma.masked_where(s > lower, s) smiddle = np.ma.masked_where((s < lower) | (s > upper), s)  ",
    "instruction": "  To create a line plot with different colors based on the y-values, you can use masked arrays in matplotlib. Use the following data to plot it:  t = np.arange(0.0, 2.0, 0.01) s = np.sin(2 * np.pi * t) upper = 0.77 lower = -0.77 supper = np.ma.masked_where(s < upper, s) slower = np.ma.masked_where(s > lower, s) smiddle = np.ma.masked_where((s < lower) | (s > upper), s). ",
    "id": 132
},
{
    "data": " prop_cycle = plt.rcParams['axes.prop_cycle'] colors = prop_cycle.by_key()['color'] lwbase = plt.rcParams['lines.linewidth'] thin = lwbase / 2 thick = lwbase * 3  ",
    "instruction": " Create a 2x2 grid of subplots with shared x and y axes. For each subplot, use the colors from the default prop_cycle to plot horizontal and vertical lines. The line widths should vary based on the column index of the subplot. In the first column, use a thin line for horizontal lines and the default line width for vertical lines. In the second column, use the default line width for both horizontal and vertical lines. Set the face color of the bottom-right subplot to black. Set the x-ticks for the bottom-right subplot to range from 0 to 10 with a step of 2. Set the y-ticks for both subplots in the first row to range from 0 to 10 with a step of 2. Add a suptitle to the figure with the text \"Colors in the default prop_cycle\". ",
    "id": 133
},
{
    "data": " N = 37 x, y = np.mgrid[:N, :N] Z = (np.cos(x*0.2) + np.sin(y*0.3)) Zpos = np.ma.masked_less(Z, 0) Zneg = np.ma.masked_greater(Z, 0)  ",
    "instruction": " Create a figure with three subplots using matplotlib. Use the following data to generate the plots: N = 37, x, y = np.mgrid[:N, :N], Z = (np.cos(x*0.2) + np.sin(y*0.3)), Zpos = np.ma.masked_less(Z, 0), Zneg = np.ma.masked_greater(Z, 0). Plot the positive data in the first subplot using ax1.imshow, colormap 'Blues', and interpolation 'none'. Add a colorbar to the first subplot using fig.colorbar. Plot the negative data in the second subplot using ax2.imshow, colormap 'Reds_r', and interpolation 'none'. Add a colorbar to the second subplot using fig.colorbar, location 'right', anchor (0, 0.3), and shrink 0.7. Plot both positive and negative data in the third subplot using ax3.imshow, colormap 'RdBu', vmin -1.2, vmax 1.2, and interpolation 'none'. Add a colorbar to the third subplot using fig.colorbar, with extend 'both' and minor ticks turned on. ",
    "id": 134
},
{
    "data": " np.random.seed(19680801)  x_values = [n for n in range(20)] y_values = np.random.randn(20)  facecolors = ['green' if y > 0 else 'red' for y in y_values] edgecolors = facecolors  abs_y = [abs(y) for y in y_values] face_alphas = [n / max(abs_y) for n in abs_y] edge_alphas = [1 - alpha for alpha in face_alphas]  colors_with_alphas = list(zip(facecolors, face_alphas)) edgecolors_with_alphas = list(zip(edgecolors, edge_alphas))  ",
    "instruction": " Use the following data to create two bar plots with different transparency settings.   For the first plot, use the values of x_values as the x-axis and y_values as the y-axis. Set the color of each bar to green if the corresponding y-value is positive, and red if it is negative. Set the alpha value for both bars and edges to 0.5.  For the second plot, use the same x_values and y_values. Set the color of each bar and edge using the colors_with_alphas and edgecolors_with_alphas respectively. The alpha values for the bars should be normalized based on the absolute values of y_values, and the alpha values for the edges should be the complement of the bar alpha values. ",
    "id": 135
},
{
    "data": "  codes, verts = zip(*[     (Path.MOVETO, [0.018, -0.11]),     (Path.CURVE4, [-0.031, -0.051]),     (Path.CURVE4, [-0.115, 0.073]),     (Path.CURVE4, [-0.03, 0.073]),     (Path.LINETO, [-0.011, 0.039]),     (Path.CURVE4, [0.043, 0.121]),     (Path.CURVE4, [0.075, -0.005]),     (Path.CURVE4, [0.035, -0.027]),     (Path.CLOSEPOLY, [0.018, -0.11]) ])  artists = [     mpatches.Circle((0, 0), 0.1, ec='none'),     mpatches.Rectangle((-0.025, -0.05), 0.05, 0.1, ec='none'),     mpatches.Wedge((0, 0), 0.1, 30, 270, ec='none'),     mpatches.RegularPolygon((0, 0), 5, radius=0.1),     mpatches.Ellipse((0, 0), 0.2, 0.1),     mpatches.Arrow(-0.05, -0.05, 0.1, 0.1, width=0.1),     mpatches.PathPatch(mpath.Path(verts, codes), ec='none'),     mpatches.FancyBboxPatch((-0.025, -0.05), 0.05, 0.1, ec='none',                             boxstyle=mpatches.BoxStyle('Round', pad=0.02)),     mlines.Line2D([-0.06, 0.0, 0.1], [0.05, -0.05, 0.05], lw=5), ]  ",
    "instruction": " Use the following functions from matplotlib: Circle, Rectangle, Wedge, RegularPolygon, Ellipse, Arrow, PathPatch, FancyBboxPatch, and Line2D, to create a figure with multiple artist objects. Set the colors of the artists using the hsv colormap. Each artist should have a different color. Set the title, aspect ratio, xlim, and ylim for each subplot. Use the data provided to create the artists: codes, verts, artists. ",
    "id": 136
},
{
    "data": "  nverts = 50 npts = 100  # Make some spirals r = np.arange(nverts) theta = np.linspace(0, 2*np.pi, nverts) xx = r * np.sin(theta) yy = r * np.cos(theta) spiral = np.column_stack([xx, yy])  # Fixing random state for reproducibility rs = np.random.RandomState(19680801)  # Make some offsets xyo = rs.randn(npts, 2)  # Make a list of colors cycling through the default series. colors = plt.rcParams['axes.prop_cycle'].by_key()['color']  ",
    "instruction": "  Create a 2x2 grid of subplots using matplotlib. In the first subplot, plot a LineCollection using the offsets of the spirals (spiral) and the offsets (xyo). Set the color of the LineCollection to the colors defined above. Set the title of this subplot to 'LineCollection using offsets'. In the second subplot, plot a PolyCollection using the offsets of the spirals (spiral) and the offsets (xyo). Set the color of the PolyCollection to the colors defined above. Set the title of this subplot to 'PolyCollection using offsets'. In the third subplot, create a RegularPolyCollection with 7 sides and sizes determined by the absolute values of xx multiplied by 10.0. Use the offsets of the spirals (spiral) and the offsets (xyo) for positioning. Set the color of the RegularPolyCollection to the colors defined above. Set the title of this subplot to 'RegularPolyCollection using offsets'. In the fourth subplot, create LineCollections to simulate ocean current profiles. The curves should be successively offset by 0.1 m/s and the offsets should be given in data units. The offsets should be set to (0.1, 0.0). Set the color of the LineCollections to the colors defined above. Set the title of this subplot to 'Successive data offsets'. Set the x-axis label to 'Zonal velocity component (m/s)' and the y-axis label to 'Depth (m)'. ",
    "id": 137
},
{
    "data": "  codes = [Path.MOVETO] + [Path.LINETO]*3 + [Path.CLOSEPOLY] vertices = [(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)] codes += [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY] vertices += [(4, 4), (5, 5), (5, 4), (0, 0)]  ",
    "instruction": "  To create a compound path using matplotlib, follow these steps: 1. Create two lists, `codes` and `vertices`. 2. Define the initial code as `[Path.MOVETO]` and add three `[Path.LINETO]` codes using the multiplication operator `*`. 3. Append the `Path.CLOSEPOLY` code to the `codes` list. 4. Define the initial vertices as `[(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)]`. 5. Append `(4, 4)` and `(5, 5)` vertices to the `vertices` list. 6. Add two `[Path.LINETO]` codes to the `codes` list using the multiplication operator `*`. 7. Append `(5, 4)` and `(0, 0)` vertices to the `vertices` list. 8. Create a `Path` object by passing `vertices` and `codes` to `Path` class. 9. Create a `PathPatch` object with the `Path`, setting `facecolor='none'` and `edgecolor='green'`. 10. Create a figure and axis using `plt.subplots()`. 11. Add the `PathPatch` object to the axis using `ax.add_patch()`. 12. Set the title of the plot to 'A compound path' using `ax.set_title()`. 13. Automatically scale the view using `ax.autoscale_view()`. 14. Display the plot using `plt.show()`. ",
    "id": 138
},
{
    "data": "  np.random.seed(19680801) r = np.random.rand(50) t = np.random.rand(50) * np.pi * 2.0 x = r * np.cos(t) y = r * np.sin(t)  ",
    "instruction": "  Use the matplotlib functions, methods, classes, and modules shown below to create a plot:  - Functions:   - plt.subplots(figsize=(6, 6))   - plt.imshow(np.random.random((100, 100)), origin='lower', cmap=cm.winter, interpolation='spline36', extent=(-1, 1, -1, 1))   - plt.plot(x, y, 'o', color=(0.9, 0.9, 1.0), alpha=0.8)  - Classes:   - Circle((0, 0), 1, facecolor='none', edgecolor=(0, 0.8, 0.8), linewidth=3, alpha=0.5)   - PathPatch(dolphin_path, facecolor=(0.6, 0.6, 0.6), edgecolor=(0.0, 0.0, 0.0))   - PathPatch(dolphin_path2, facecolor=(0.5, 0.5, 0.5), edgecolor=(0.0, 0.0, 0.0))  - Methods:   - add_patch(circle)   - add_patch(dolphin_patch)   - add_patch(dolphin_patch2)  - Modules:   - import matplotlib.cm as cm   - import matplotlib.patches as patches   - import matplotlib.transforms as transforms  Use the provided data to generate the plot: np.random.seed(19680801) r = np.random.rand(50) t = np.random.rand(50) * np.pi * 2.0 x = r * np.cos(t) y = r * np.sin(t)  This example demonstrates how to draw and manipulate shapes using Path, PathPatch, and transforms classes. It includes a circle, an image, and a scatter plot. ",
    "id": 139
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.patches as mpatches import matplotlib.path as mpath   def wise(v):     if v == 1:         return 'CCW'     else:         return 'CW'   def make_circle(r):     t = np.arange(0, np.pi * 2.0, 0.01)     t = t.reshape((len(t), 1))     x = r * np.cos(t)     y = r * np.sin(t)     return np.hstack((x, y))  Path = mpath.Path  fig, ax = plt.subplots()  inside_vertices = make_circle(0.5) outside_vertices = make_circle(1.0) codes = np.ones(     len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO codes[0] = mpath.Path.MOVETO  for i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):     vertices = np.concatenate((outside_vertices[::outside],                                inside_vertices[::inside]))     vertices[:, 0] += i * 2.5     all_codes = np.concatenate((codes, codes))     path = mpath.Path(vertices, all_codes)     patch = mpatches.PathPatch(path, facecolor='#885500', edgecolor='black')     ax.add_patch(patch)      ax.annotate(f'Outside {wise(outside)},\\nInside {wise(inside)}',                 (i * 2.5, -1.5), va='top', ha='center')  ax.set_xlim(-2, 10) ax.set_ylim(-3, 2) ax.set_title('Mmm, donuts!') ax.set_aspect(1.0) plt.show()  ",
    "instruction": "  Create a donut-shaped plot using matplotlib. Use the following data to plot it:   import matplotlib.patches as mpatches import matplotlib.path as mpath  def wise(v):     if v == 1:         return 'CCW'     else:         return 'CW'  def make_circle(r):     t = np.arange(0, np.pi * 2.0, 0.01)     t = t.reshape((len(t), 1))     x = r * np.cos(t)     y = r * np.sin(t)     return np.hstack((x, y))  Path = mpath.Path  inside_vertices = make_circle(0.5) outside_vertices = make_circle(1.0) codes = np.ones(     len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO codes[0] = mpath.Path.MOVETO  for i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):     vertices = np.concatenate((outside_vertices[::outside],                                inside_vertices[::inside]))     vertices[:, 0] += i * 2.5     all_codes = np.concatenate((codes, codes))     path = mpath.Path(vertices, all_codes)     patch = mpatches.PathPatch(path, facecolor='#885500', edgecolor='black')     ax.add_patch(patch)      ax.annotate(f'Outside {wise(outside)},\\nInside {wise(inside)}',                 (i * 2.5, -1.5), va='top', ha='center')  ax.set_xlim(-2, 10) ax.set_ylim(-3, 2) ax.set_title('Mmm, donuts!') ax.set_aspect(1.0) plt.show() ",
    "id": 140
},
{
    "data": " ```python import matplotlib.pyplot as plt  from matplotlib.markers import MarkerStyle from matplotlib.patches import Ellipse from matplotlib.transforms import Affine2D  # Create a figure and axis fig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})  ellipse = Ellipse(     xy=(2, 4),     width=30,     height=20,     angle=35,     facecolor='none',     edgecolor='b' ) ax.add_patch(ellipse)  # Plot an arrow marker at the end point of minor axis vertices = ellipse.get_co_vertices() t = Affine2D().rotate_deg(ellipse.angle) ax.plot(     vertices[0][0],     vertices[0][1],     color='b',     marker=MarkerStyle('>', 'full', t),     markersize=10 ) # Note: To reverse the orientation arrow, switch the marker type from > to <.  plt.show() ```  ",
    "instruction": " To generate a plot of an ellipse with an orientation arrow, use the following steps: 1. Import the necessary modules: `matplotlib.pyplot`, `matplotlib.markers.MarkerStyle`, `matplotlib.patches.Ellipse`, and `matplotlib.transforms.Affine2D`.  2. Create a figure and an axis using the `subplots` function: `fig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})`.  3. Define the properties of the ellipse using the `Ellipse` class, such as the center coordinates (`xy`), width and height (`width` and `height`), angle of rotation (`angle`), face and edge colors (`facecolor` and `edgecolor`).  4. Add the ellipse to the plot using the `add_patch` method of the axis object: `ax.add_patch(ellipse)`.  5. Get the coordinates of the vertices of the ellipse using the `get_co_vertices` method: `vertices = ellipse.get_co_vertices()`.  6. Create a transformation object `t` to rotate the arrow marker based on the ellipse's angle: `t = Affine2D().rotate_deg(ellipse.angle)`.  7. Plot an arrow marker at the end point of the minor axis using the `plot` method of the axis object:     ```python    ax.plot(        vertices[0][0],        vertices[0][1],        color='b',        marker=MarkerStyle('>', 'full', t),        markersize=10    )    ```     Note: To reverse the orientation arrow, switch the marker type from `>` to `<`.  8. Finally, use `plt.show()` to display the plot. ",
    "id": 141
},
{
    "data": "  ```python x = np.arange(10) y = np.arange(15) X, Y = np.meshgrid(x, y)  XY = np.column_stack((X.ravel(), Y.ravel()))  ww = X / 10.0 hh = Y / 15.0 aa = X * 9 ```  ",
    "instruction": "  To create a collection of ellipses using matplotlib, you can use the EllipseCollection function. Use the following data to generate the plot:  ```python x = np.arange(10) y = np.arange(15) X, Y = np.meshgrid(x, y)  XY = np.column_stack((X.ravel(), Y.ravel()))  ww = X / 10.0 hh = Y / 15.0 aa = X * 9 ``` This plot represents a collection of ellipses where the size and orientation of each ellipse is defined by the arrays `ww`, `hh`, and `aa`, respectively. The position of each ellipse is determined by the arrays `X` and `Y` after flattening and stacking them into `XY`. The color of each ellipse is determined by the sum of `X` and `Y`. The x-axis is labeled as 'X', the y-axis is labeled as 'y', and there is a colorbar that represents the sum of `X` and `Y`. ",
    "id": 142
},
{
    "data": " np.random.seed(19680801)  NUM = 250  ells = [Ellipse(xy=np.random.rand(2) * 10,                 width=np.random.rand(), height=np.random.rand(),                 angle=np.random.rand() * 360)         for i in range(NUM)]  ",
    "instruction": " Create a plot using matplotlib to showcase the Ellipse Demo. Draw many individual ellipses. Start by setting the random seed as np.random.seed(19680801). Then, create a list of ellipses called 'ells' with the following parameters: xy=np.random.rand(2) * 10, width=np.random.rand(), height=np.random.rand(), angle=np.random.rand() * 360. Use a for loop to iterate through the range of NUM (250) and add each ellipse to the plot using ax.add_artist(e). Set the clip box for each ellipse to ax.bbox, their alpha (transparency) to np.random.rand(), and their face color to np.random.rand(3). Finally, display the plot using plt.show(). ",
    "id": 143
},
{
    "data": "  x = np.arange(1, 5) y1 = np.arange(1, 5) y2 = np.ones(y1.shape) * 4 x = np.arange(0, 40, 0.2)  ",
    "instruction": "  Use the following code snippet to create a hatch demo in matplotlib. The code includes the usage of hatches in various plot types such as bar, fill_between, and polygons.  import matplotlib.pyplot as plt import numpy as np from matplotlib.patches import Ellipse, Polygon  fig = plt.figure() axs = fig.subplot_mosaic([['bar1', 'patches'], ['bar2', 'patches']])  axs['bar1'].bar(x, y1, edgecolor='black', hatch='/') axs['bar1'].bar(x, y2, bottom=y1, edgecolor='black', hatch='//')  axs['bar2'].bar(x, y1, edgecolor='black', hatch=['--', '+', 'x', '\\\\']) axs['bar2'].bar(x, y2, bottom=y1, edgecolor='black',                 hatch=['*', 'o', 'O', '.'])  axs['patches'].fill_between(x, np.sin(x) * 4 + 30, y2=0,                             hatch='///', zorder=2, fc='c') axs['patches'].add_patch(Ellipse((4, 50), 10, 10, fill=True,                                  hatch='*', facecolor='y')) axs['patches'].add_patch(Polygon([(10, 20), (30, 50), (50, 10)],                                  hatch='\\\\/...', facecolor='g')) axs['patches'].set_xlim([0, 40]) axs['patches'].set_ylim([10, 60]) axs['patches'].set_aspect(1)  plt.show()  This code demonstrates the usage of hatches in different plot types, such as bar charts and patches. The hatches can be added to most polygons in Matplotlib, including bar, fill_between, contourf, and children of Polygon. You can refer to the Hatch style reference for swatches of the existing hatches. Please note that hatches are supported in certain backends such as PS, PDF, SVG, OSX, and Agg, but not in WX and Cairo backends. ",
    "id": 144
},
{
    "data": "   import matplotlib.pyplot as plt import numpy as np  from matplotlib.collections import PatchCollection from matplotlib.patches import Circle, Polygon, Wedge  # Fixing random state for reproducibility np.random.seed(19680801)   fig, ax = plt.subplots()  resolution = 50  # the number of vertices N = 3 x = np.random.rand(N) y = np.random.rand(N) radii = 0.1*np.random.rand(N) patches = [] for x1, y1, r in zip(x, y, radii):     circle = Circle((x1, y1), r)     patches.append(circle)  x = np.random.rand(N) y = np.random.rand(N) radii = 0.1*np.random.rand(N) theta1 = 360.0*np.random.rand(N) theta2 = 360.0*np.random.rand(N) for x1, y1, r, t1, t2 in zip(x, y, radii, theta1, theta2):     wedge = Wedge((x1, y1), r, t1, t2)     patches.append(wedge)  # Some limiting conditions on Wedge patches += [     Wedge((.3, .7), .1, 0, 360),             # Full circle     Wedge((.7, .8), .2, 0, 360, width=0.05),  # Full ring     Wedge((.8, .3), .2, 0, 45),              # Full sector     Wedge((.8, .3), .2, 45, 90, width=0.10),  # Ring sector ]  for i in range(N):     polygon = Polygon(np.random.rand(N, 2), closed=True)     patches.append(polygon)  colors = 100 * np.random.rand(len(patches)) p = PatchCollection(patches, alpha=0.4) p.set_array(colors) ax.add_collection(p) fig.colorbar(p, ax=ax)   ",
    "instruction": "   Create a plot showcasing circles, wedges, and polygons using Matplotlib's PatchCollection. Use the following data to create the plot:  resolution = 50 N = 3 x = np.random.rand(N) y = np.random.rand(N) radii = 0.1 * np.random.rand(N)  For circles: - Create a Circle object using the coordinates (x[i], y[i]) and radius radii[i]. - Append the Circle object to the patches list.  For wedges: - Generate new random values for x, y, radii, theta1, and theta2. - Create a Wedge object using the coordinates (x[i], y[i]), radius radii[i], angle t1=theta1[i], and t2=theta2[i]. - Append the Wedge object to the patches list.  For some limiting conditions on Wedge: - Append the following Wedge objects to the patches list:    - Full circle: Center=(0.3, 0.7), Radius=0.1, Angle start=0, Angle end=360.    - Full ring: Center=(0.7, 0.8), Radius=0.2, Angle start=0, Angle end=360, Width=0.05.    - Full sector: Center=(0.8, 0.3), Radius=0.2, Angle start=0, Angle end=45.    - Ring sector: Center=(0.8, 0.3), Radius=0.2, Angle start=45, Angle end=90, Width=0.10.  For polygons: - Generate random coordinates for N points and create a closed Polygon object using the coordinates. - Append the Polygon object to the patches list.  Set the colors for the patches based on the array of random colors: - Multiply each element of the colors array by 100. - Create a PatchCollection using the patches list and set the alpha value to 0.4. - Set the array of colors for the PatchCollection using p.set_array(colors). - Add the PatchCollection to the axes object ax. - Add a colorbar to the figure using fig.colorbar(p, ax=ax).  ",
    "id": 145
},
{
    "data": "   Path = mpath.Path path_data = [     (Path.MOVETO, (1.58, -2.57)),     (Path.CURVE4, (0.35, -1.1)),     (Path.CURVE4, (-1.75, 2.0)),     (Path.CURVE4, (0.375, 2.0)),     (Path.LINETO, (0.85, 1.15)),     (Path.CURVE4, (2.2, 3.2)),     (Path.CURVE4, (3, 0.05)),     (Path.CURVE4, (2.0, -0.5)),     (Path.CLOSEPOLY, (1.58, -2.57)), ] codes, verts = zip(*path_data) path = mpath.Path(verts, codes) patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5) ax.add_patch(patch) x, y = zip(*path.vertices) line, = ax.plot(x, y, 'go-')  ",
    "instruction": "   Use the following functions from matplotlib: Path, PathPatch, and add_patch to create a graphical representation of a Path object.   Use the following data to create the Path object and add it to the plot: path_data = [     (Path.MOVETO, (1.58, -2.57)),     (Path.CURVE4, (0.35, -1.1)),     (Path.CURVE4, (-1.75, 2.0)),     (Path.CURVE4, (0.375, 2.0)),     (Path.LINETO, (0.85, 1.15)),     (Path.CURVE4, (2.2, 3.2)),     (Path.CURVE4, (3, 0.05)),     (Path.CURVE4, (2.0, -0.5)),     (Path.CLOSEPOLY, (1.58, -2.57)), ]  Create a Path object using the vertices and codes extracted from path_data. Set the facecolor of the PathPatch object to 'r' and the alpha to 0.5. Add the PathPatch object to the plot using the add_patch function. Finally, plot the control points and the connecting lines using the x and y coordinates extracted from the path vertices. ",
    "id": 146
},
{
    "data": "  Path = mpath.Path  ",
    "instruction": "  Create a Bezier curve plot using matplotlib. Use the following data to plot it:  Path = mpath.Path. ",
    "id": 147
},
{
    "data": " np.random.seed(19680801)  N = 50 x = np.random.rand(N) y = np.random.rand(N) colors = np.random.rand(N) area = (30 * np.random.rand(N))**2  # 0 to 15 point radii  ",
    "instruction": " Use the function scatter from matplotlib to create a scatter plot. Use the following data to create the plot: np.random.seed(19680801), N = 50, x = np.random.rand(N), y = np.random.rand(N), colors = np.random.rand(N), area = (30 * np.random.rand(N))**2. ",
    "id": 148
},
{
    "data": " np.random.seed(19680801)  Defining a function called `plot_beta_hist` that takes in `ax, a, b` as arguments. Inside the function, it plots a histogram using the `hist` function from `ax` with the following parameters: `np.random.beta(a, b, size=10000)`, `histtype='stepfilled'`, `bins=25`, `alpha=0.8`, and `density=True`.  Calling `plt.subplots()` to create a figure and axis object, assigning them to the variables `fig` and `ax`.  Calling the `plot_beta_hist` function with `ax` as the first argument and the values `10, 10`, `4, 12`, `50, 12`, `6, 55` as subsequent arguments.  Setting the title of the plot to `'bmh' style sheet`.  Displaying the plot using `plt.show()`.  ",
    "instruction": " Use the given code to create a histogram plot with four histograms using the 'bmh' style sheet. The first histogram should use the `np.random.beta(a=10, b=10, size=10000)` data, the second histogram should use `np.random.beta(a=4, b=12, size=10000)`, the third histogram should use `np.random.beta(a=50, b=12, size=10000)`, and the fourth histogram should use `np.random.beta(a=6, b=55, size=10000)`. Set the title of the plot to 'bmh' style sheet. ",
    "id": 149
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  plt.style.use('dark_background')  fig, ax = plt.subplots()  L = 6 x = np.linspace(0, L) ncolors = len(plt.rcParams['axes.prop_cycle']) shift = np.linspace(0, L, ncolors, endpoint=False) for s in shift:     ax.plot(x, np.sin(x + s), 'o-') ax.set_xlabel('x-axis') ax.set_ylabel('y-axis') ax.set_title('dark_background' style sheet')  ",
    "instruction": "  Create a line plot using the \"dark_background\" style sheet from matplotlib. Use the following data to plot it: L = 6, x = np.linspace(0, L), ncolors = len(plt.rcParams['axes.prop_cycle']), shift = np.linspace(0, L, ncolors, endpoint=False). ",
    "id": 150
},
{
    "data": " x = np.linspace(0, 10) np.random.seed(19680801)  ",
    "instruction": " Use the \"fivethirtyeight\" style sheet from Matplotlib to create a plot. Plot the following lines on the same graph:  1. x vs (np.sin(x) + x + np.random.randn(50)) 2. x vs (np.sin(x) + 0.5 * x + np.random.randn(50)) 3. x vs (np.sin(x) + 2 * x + np.random.randn(50)) 4. x vs (np.sin(x) - 0.5 * x + np.random.randn(50)) 5. x vs (np.sin(x) - 2 * x + np.random.randn(50)) 6. x vs (np.sin(x) + np.random.randn(50)). Set the title of the plot to \"fivethirtyeight style sheet\". ",
    "id": 151
},
{
    "data": " np.random.seed(19680801)  fig, axs = plt.subplots(ncols=2, nrows=2) ax1, ax2, ax3, ax4 = axs.flat  # scatter plot (Note: `plt.scatter` doesn't use default colors) x, y = np.random.normal(size=(2, 200)) ax1.plot(x, y, 'o')  # sinusoidal lines with colors from default color cycle L = 2*np.pi x = np.linspace(0, L) ncolors = len(plt.rcParams['axes.prop_cycle']) shift = np.linspace(0, L, ncolors, endpoint=False) for s in shift:     ax2.plot(x, np.sin(x + s), '-') ax2.margins(0)  # bar graphs x = np.arange(5) y1, y2 = np.random.randint(1, 25, size=(2, 5)) width = 0.25 ax3.bar(x, y1, width) ax3.bar(x + width, y2, width,         color=list(plt.rcParams['axes.prop_cycle'])[2]['color']) ax3.set_xticks(x + width, labels=['a b c d e'])  # circles with colors from default color cycle for i, color in enumerate(plt.rcParams['axes.prop_cycle']):     xy = np.random.normal(size=2)     ax4.add_patch(plt.Circle(xy, radius=0.3, color=color['color'])) ax4.axis('equal') ax4.margins(0)  ",
    "instruction": " Create a plot with four subplots using matplotlib. Use the ggplot style sheet. The first subplot should be a scatter plot of 200 points. The second subplot should contain sinusoidal lines with colors from the default color cycle. The third subplot should display two bar graphs. The fourth subplot should contain circles with colors from the default color cycle. ",
    "id": 152
},
{
    "data": " np.random.seed(19680801)  def color_cycle_example(ax):     L = 6     x = np.linspace(0, L)     ncolors = len(plt.rcParams['axes.prop_cycle'])     shift = np.linspace(0, L, ncolors, endpoint=False)     for s in shift:         ax.plot(x, np.sin(x + s), 'o-')   def image_and_patch_example(ax):     ax.imshow(np.random.random(size=(20, 20)), interpolation='none')     c = plt.Circle((5, 5), radius=5, label='patch')     ax.add_patch(c)   plt.style.use('grayscale')  fig, (ax1, ax2) = plt.subplots(ncols=2) fig.suptitle(''grayscale' style sheet')  color_cycle_example(ax1) image_and_patch_example(ax2)  plt.show()  ",
    "instruction": " Create a grayscale style sheet for your matplotlib plots. Use the provided code and relevant context ",
    "id": 153
},
{
    "data": " np.random.seed(19680801)  x = np.linspace(0, 10)  ",
    "instruction": " Create a line plot using matplotlib. Use the following data to plot it: np.random.seed(19680801), x = np.linspace(0, 10). Apply the \"Solarized_Light\" style to the plot. Set the title of the plot to \"8 Random Lines - Line\". Set the x-axis label to \"x label\" with a font size of 14. Set the y-axis label to \"y label\" with a font size of 14. ",
    "id": 154
},
{
    "data": " None ",
    "instruction": " Create a simple plot using matplotlib. Use the following data to plot it: [1, 2, 3, 4]. Label the y-axis as 'some numbers'. Use the format string 'o-r' to set the markers as circles, linestyle as a solid line, and color as red. ",
    "id": 155
},
{
    "data": "  t = np.arange(0.0, 2.0, 0.01) s = np.sin(2*np.pi*t)  ",
    "instruction": "  Use the following data to create a plot: t = np.arange(0.0, 2.0, 0.01) s = np.sin(2*np.pi*t)  Create a plot using matplotlib, with the following specifications: - Plot the data using the plot() function: plt.plot(t, s) - Add the text \"Hello, world!\" at coordinates (0, -1) using the text() function: plt.text(0, -1, r'Hello, world!', fontsize=15) - Set the title of the plot to \"$\\mathcal{A}\\sin(\\omega t)$\" with a fontsize of 20 using the title() function: plt.title(r'$\\mathcal{A}\\sin(\\omega t)$', fontsize=20) - Set the x-axis label to \"Time [s]\" and the y-axis label to \"Voltage [mV]\" using the xlabel() and ylabel() functions: plt.xlabel('Time [s]'), plt.ylabel('Voltage [mV]') - Show the plot using the show() function: plt.show() ",
    "id": 156
},
{
    "data": " t = np.arange(0., 5., 0.2) ",
    "instruction": " Use the function plot from matplotlib.pyplot to create a plot with three datasets. Plot the first dataset as a red dashed line, the second dataset as blue squares, and the third dataset as green triangles. Use the following data to create the plot: t = np.arange(0., 5., 0.2). ",
    "id": 157
},
{
    "data": " f(t):\\n    return np.exp(-t) * np.cos(2*np.pi*t)\\n\\nt1 = np.arange(0.0, 5.0, 0.1)\\nt2 = np.arange(0.0, 5.0, 0.02), ",
    "instruction": " Create a figure with two subplots using matplotlib.pyplot.subplot. Use the following data to plot the subplots: f(t), t1 = np.arange(0.0, 5.0, 0.1), t2 = np.arange(0.0, 5.0, 0.02). ",
    "id": 158
},
{
    "data": " np.random.seed(19680801)  # Simple example simple_arrow = AnchoredDirectionArrows(ax.transAxes, 'X Y')  # High contrast arrow high_contrast_part_1 = AnchoredDirectionArrows(                             ax.transAxes,                             '111', r'11$\\\\overline{2}$',                             loc='upper right',                             arrow_props={'ec': 'w', 'fc': 'none', 'alpha': 1,                                          'lw': 2}                             )  high_contrast_part_2 = AnchoredDirectionArrows(                             ax.transAxes,                             '111', r'11$\\\\overline{2}$',                             loc='upper right',                             arrow_props={'ec': 'none', 'fc': 'k'},                             text_props={'ec': 'w', 'fc': 'k', 'lw': 0.4}                             )  # Rotated arrow fontprops = fm.FontProperties(family='serif')  rotated_arrow = AnchoredDirectionArrows(                     ax.transAxes,                     '30 120',                     loc='center',                     color='w',                     angle=30,                     fontproperties=fontprops                     )  # Altering arrow directions a1 = AnchoredDirectionArrows(         ax.transAxes, 'A B', loc='lower center',         length=-0.15,         sep_x=0.03, sep_y=0.03,         color='r'     )  a2 = AnchoredDirectionArrows(         ax.transAxes, 'A  B', loc='lower left',         aspect_ratio=-1,         sep_x=0.01, sep_y=-0.02,         color='orange'         )  a3 = AnchoredDirectionArrows(         ax.transAxes, ' A B', loc='lower right',         length=-0.15,         aspect_ratio=-1,         sep_y=-0.1, sep_x=0.04,         color='cyan'         )  ",
    "instruction": " Use the AnchoredDirectionArrows function from Matplotlib to create multiple anchored direction arrows on a plot. Use the following settings and data:  1. Simple example:     - Pass ax.transAxes as the transformation for the arrows.     - Set the text for the arrow to be 'X Y'.      2. High contrast arrow:     - Pass ax.transAxes as the transformation for the arrows.     - Set the text for the arrow to be '111' and '11$\\\\overline{2}$'.     - Set the location to 'upper right'.     - Set the arrow properties to have an edge color of 'w', no face color, full alpha, and line width of 2.      3. Rotated arrow:     - Pass ax.transAxes as the transformation for the arrows.     - Set the text for the arrow to be '30 120'.     - Set the location to 'center'.     - Set the color to 'w'.     - Set the rotation angle to 30 degrees.     - Set the font family to 'serif'.      4. Altering arrow directions:     - Pass ax.transAxes as the transformation for the arrows.     - Set the text for the arrows to be 'A B', 'A  B', and ' A B' respectively.     - Set the locations to 'lower center', 'lower left', and 'lower right' respectively.     - Set the length of the arrows to -0.15.     - Set the separations in x and y axes to 0.03 and 0.03 for the first arrow, 0.01 and -0.02 for the second arrow, and -0.1 and 0.04 for the third arrow.     - Set the colors of the arrows to 'r', 'orange', and 'cyan' respectively. ",
    "id": 159
},
{
    "data": "  import matplotlib.pyplot as plt  from matplotlib import cbook   def get_demo_image():     z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array     return z, (-3, 4, -4, 3)   def demo_simple_image(ax):     Z, extent = get_demo_image()      im = ax.imshow(Z, extent=extent)     cb = plt.colorbar(im)     cb.ax.yaxis.set_tick_params(labelright=False)   def demo_locatable_axes_hard(fig):     from mpl_toolkits.axes_grid1 import Size, SubplotDivider      divider = SubplotDivider(fig, 2, 2, 2, aspect=True)      # axes for image     ax = fig.add_subplot(axes_locator=divider.new_locator(nx=0, ny=0))     # axes for colorbar     ax_cb = fig.add_subplot(axes_locator=divider.new_locator(nx=2, ny=0))      divider.set_horizontal([         Size.AxesX(ax),  # main axes         Size.Fixed(0.05),  # padding, 0.1 inch         Size.Fixed(0.2),  # colorbar, 0.3 inch     ])     divider.set_vertical([Size.AxesY(ax)])      Z, extent = get_demo_image()      im = ax.imshow(Z, extent=extent)     plt.colorbar(im, cax=ax_cb)     ax_cb.yaxis.set_tick_params(labelright=False)   def demo_locatable_axes_easy(ax):     from mpl_toolkits.axes_grid1 import make_axes_locatable      divider = make_axes_locatable(ax)      ax_cb = divider.append_axes('right', size='5%', pad=0.05)     fig = ax.get_figure()     fig.add_axes(ax_cb)      Z, extent = get_demo_image()     im = ax.imshow(Z, extent=extent)      plt.colorbar(im, cax=ax_cb)     ax_cb.yaxis.tick_right()     ax_cb.yaxis.set_tick_params(labelright=False)   def demo_images_side_by_side(ax):     from mpl_toolkits.axes_grid1 import make_axes_locatable      divider = make_axes_locatable(ax)      Z, extent = get_demo_image()     ax2 = divider.append_axes('right', size='100%', pad=0.05)     fig1 = ax.get_figure()     fig1.add_axes(ax2)      ax.imshow(Z, extent=extent)     ax2.imshow(Z, extent=extent)     ax2.yaxis.set_tick_params(labelleft=False)   def demo():     fig = plt.figure(figsize=(6, 6))      # PLOT 1     # simple image & colorbar     ax = fig.add_subplot(2, 2, 1)     demo_simple_image(ax)      # PLOT 2     # image and colorbar with draw-time positioning -- a hard way     demo_locatable_axes_hard(fig)      # PLOT 3     # image and colorbar with draw-time positioning -- an easy way     ax = fig.add_subplot(2, 2, 3)     demo_locatable_axes_easy(ax)      # PLOT 4     # two images side by side with fixed padding.     ax = fig.add_subplot(2, 2, 4)     demo_images_side_by_side(ax)      plt.show()   demo()   ",
    "instruction": " Use the following functions from matplotlib: imshow, colorbar, subplots, add_subplot, append_axes, set_tick_params, get_sample_data, figure, add_axes, and imshow, to create four plots with different images and colorbars. The plots have the following characteristics:  Plot 1: - A simple image and colorbar.  Plot 2: - An image and colorbar with draw-time positioning. - Uses the SubplotDivider class to divide the figure into multiple axes.  Plot 3: - An image and colorbar with draw-time positioning. - Uses the make_axes_locatable function to append a colorbar axes.  Plot 4: - Two images side by side with fixed padding.  The data required for these plots can be obtained from the following functions:  - get_demo_image: Returns an image array and extent. - demo_simple_image: Uses the get_demo_image function to create a simple image plot with a colorbar. - demo_locatable_axes_hard: Uses the SubplotDivider class to create an image plot with a colorbar. - demo_locatable_axes_easy: Uses the make_axes_locatable function to create an image plot with a colorbar. - demo_images_side_by_side: Uses the make_axes_locatable function to create two image plots side by side with fixed padding. ",
    "id": 160
},
{
    "data": " Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array extent = (-3, 4, -4, 3)  grid = ImageGrid(     fig, 141,  # similar to fig.add_subplot(141).      nrows_ncols=(2, 2), axes_pad=0.05, label_mode='1') for ax in grid:     ax.imshow(Z, extent=extent) grid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])  grid = ImageGrid(     fig, 142,  # similar to fig.add_subplot(142).     nrows_ncols=(2, 2), axes_pad=0.0, label_mode='L', share_all=True,     cbar_location='top', cbar_mode='single') for ax in grid:     im = ax.imshow(Z, extent=extent) grid.cbar_axes[0].colorbar(im) for cax in grid.cbar_axes:     cax.tick_params(labeltop=False) grid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])  grid = ImageGrid(     fig, 143,  # similar to fig.add_subplot(143).     nrows_ncols=(2, 2), axes_pad=0.1, label_mode='1', share_all=True,     cbar_location='top', cbar_mode='each', cbar_size='7%', cbar_pad='2%') for ax, cax in zip(grid, grid.cbar_axes):     im = ax.imshow(Z, extent=extent)     cax.colorbar(im)     cax.tick_params(labeltop=False) grid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])  grid = ImageGrid(     fig, 144,  # similar to fig.add_subplot(144).     nrows_ncols=(2, 2), axes_pad=(0.45, 0.15), label_mode='1', share_all=True,     cbar_location='right', cbar_mode='each', cbar_size='7%', cbar_pad='2%') limits = ((0, 1), (-2, 2), (-1.7, 1.4), (-1.5, 1)) for ax, cax, vlim in zip(grid, grid.cbar_axes, limits):     im = ax.imshow(Z, extent=extent, vmin=vlim[0], vmax=vlim[1])     cb = cax.colorbar(im)     cb.set_ticks((vlim[0], vlim[1])) grid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])  ",
    "instruction": " Use the ImageGrid from mpl_toolkits.axes_grid1 package to create a grid of 2x2 images. The images should be generated using the data Z, which is obtained from the 'axes_grid/bivariate_normal.npy' file. Set the extent of the images to (-3, 4, -4, 3). For the first grid, set the axes_pad to 0.05 and label_mode to '1'. Use the imshow function to display the images on each axis. Set the xticks and yticks of the axes_llc to [-2, 0, 2]. For the second grid, set the axes_pad to 0.0, label_mode to 'L', share_all to True, cbar_location to 'top', and cbar_mode to 'single'. Use the imshow function to display the images on each axis. Add a colorbar to the grid and set the tick_params of the cbar_axes to labeltop=False. Set the xticks and yticks of the axes_llc to [-2, 0, 2]. For the third grid, set the axes_pad to 0.1, label_mode to '1', share_all to True, cbar_location to 'top', cbar_mode to 'each', cbar_size to '7%', and cbar_pad to '2%'. Use the imshow function to display the images on each axis. Add a colorbar to each axis and set the tick_params of the cbar_axes to labeltop=False. Set the xticks and yticks of the axes_llc to [-2, 0, 2]. For the fourth grid, set the axes_pad to (0.45, 0.15), label_mode to '1', share_all to True, cbar_location to 'right', cbar_mode to 'each', cbar_size to '7%', and cbar_pad to '2%'. Use the imshow function to display the images on each axis. Add a colorbar to each axis with different colorbar ranges specified by the limits variable. Set the ticks of each colorbar to the corresponding range limits. Set the xticks and yticks of the axes_llc to [-2, 0, 2]. ",
    "id": 161
},
{
    "data": " np.min(ZS), np.max(ZS), extent, grid, grid2, Z, ZS, add_inner_title, cax, cb, clim, i, im, im_title, loc, share_all, share_all, xticks, yticks ",
    "instruction": " Use the following functions from matplotlib: ImageGrid, imshow, colorbar, set, add_inner_title, xlabel, ylabel to create two separate plots: Demo 1 with colorbar at each axes and Demo 2 with a shared colorbar. Use the following data to create the plots: np.min(ZS), np.max(ZS), extent, grid, grid2, Z, ZS, add_inner_title, cax, cb, clim, i, im, im_title, loc, share_all, share_all, xticks, yticks. ",
    "id": 162
},
{
    "data": "  from matplotlib import cbook from mpl_toolkits.axes_grid1.axes_rgb import RGBAxes, make_rgb_axes  def get_rgb():     Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')     Z[Z < 0] = 0.     Z = Z / Z.max()      R = Z[:13, :13]     G = Z[2:, 2:]     B = Z[:13, 2:]      return R, G, B  def make_cube(r, g, b):     ny, nx = r.shape     R = np.zeros((ny, nx, 3))     R[:, :, 0] = r     G = np.zeros_like(R)     G[:, :, 1] = g     B = np.zeros_like(R)     B[:, :, 2] = b      RGB = R + G + B      return R, G, B, RGB  def demo_rgb1():     fig = plt.figure()     ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8], pad=0.0)     r, g, b = get_rgb()     ax.imshow_rgb(r, g, b)  def demo_rgb2():     fig, ax = plt.subplots()     ax_r, ax_g, ax_b = make_rgb_axes(ax, pad=0.02)      r, g, b = get_rgb()     im_r, im_g, im_b, im_rgb = make_cube(r, g, b)     ax.imshow(im_rgb)     ax_r.imshow(im_r)     ax_g.imshow(im_g)     ax_b.imshow(im_b)      for ax in fig.axes:         ax.tick_params(direction='in', color='w')         ax.spines[:].set_color('w')  demo_rgb1() demo_rgb2() ",
    "instruction": "  Use the following functions from matplotlib: RGBAxes, make_rgb_axes, imshow_rgb, and imshow to create two plots: demo_rgb1 and demo_rgb2. Use the following data to create the plots: get_rgb() (which returns R, G, and B arrays) and make_cube(r, g, b) (which returns R, G, B, and RGB arrays). ",
    "id": 163
},
{
    "data": "  Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy') extent = (-3, 4, -4, 3)  ",
    "instruction": "  To create a plot with a colorbar, use the following data: Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy') extent = (-3, 4, -4, 3). ",
    "id": 164
},
{
    "data": "  import matplotlib.pyplot as plt from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable  fig, (ax1, ax2) = plt.subplots(1, 2) fig.subplots_adjust(wspace=0.5)  im1 = ax1.imshow([[1, 2], [3, 4]]) ax1_divider = make_axes_locatable(ax1) cax1 = ax1_divider.append_axes('right', size='7%', pad='2%') cb1 = fig.colorbar(im1, cax=cax1)  im2 = ax2.imshow([[1, 2], [3, 4]]) ax2_divider = make_axes_locatable(ax2) cax2 = ax2_divider.append_axes('top', size='7%', pad='2%') cb2 = fig.colorbar(im2, cax=cax2, orientation='horizontal') cax2.xaxis.set_ticks_position('top')  plt.show()  ",
    "instruction": "  Use the following functions from matplotlib: imshow, make_axes_locatable, append_axes, and colorbar, to create a figure with two subplots. Add colorbars next to the subplots using the following settings: in the first subplot, use the 'right' side with size='7%' and pad='2%', and in the second subplot, use the 'top' side with size='7%' and pad='2%'. Configure the colorbar in the second subplot to have a horizontal orientation and set the x-axis tick position to 'top'. ",
    "id": 165
},
{
    "data": "  import matplotlib.pyplot as plt  from mpl_toolkits.axes_grid1.inset_locator import inset_axes  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=[6, 3])  im1 = ax1.imshow([[1, 2], [2, 3]]) axins1 = inset_axes(     ax1,     width='50%',  # width: 50% of parent_bbox width     height='5%',  # height: 5%     loc='upper right', ) axins1.xaxis.set_ticks_position('bottom') fig.colorbar(im1, cax=axins1, orientation='horizontal', ticks=[1, 2, 3])  im = ax2.imshow([[1, 2], [2, 3]]) axins = inset_axes(     ax2,     width='5%',  # width: 5% of parent_bbox width     height='50%',  # height: 50%     loc='lower left',     bbox_to_anchor=(1.05, 0., 1, 1),     bbox_transform=ax2.transAxes,     borderpad=0, )  fig.colorbar(im, cax=axins, ticks=[1, 2, 3])   ",
    "instruction": " Use the function `inset_axes` from `mpl_toolkits.axes_grid1` to create two subplots. In the first subplot, use the function `imshow` to plot the data [[1, 2], [2, 3]]. Create an inset axes (`axins1`) on the upper right corner of the first subplot with a width of 50% and height of 5%. Set the x-axis ticks position to 'bottom'. Add a horizontal colorbar to the inset axes (`axins1`) using the `colorbar` function and set the ticks to [1, 2, 3].   In the second subplot, use the function `imshow` to plot the data [[1, 2], [2, 3]]. Create an inset axes (`axins`) on the lower left corner of the second subplot with a width of 5% and height of 50%. Set the bbox_to_anchor to (1.05, 0., 1, 1) and use `bbox_transform` as `ax2.transAxes`. Set the borderpad to 0. Add a colorbar to the inset axes (`axins`) using the `colorbar` function and set the ticks to [1, 2, 3]. ",
    "id": 166
},
{
    "data": "  The data used in the provided code is as follows: - Function get_demo_image() is defined and returns a tuple containing a 15x15 array named Z and a tuple of four numbers named extent. - Two functions, demo_bottom_cbar() and demo_right_cbar(), are defined and use the get_demo_image() function to obtain the Z and extent values. - Two lists, cmaps and cbar_pads, are defined and assigned with color map names and padding values, respectively.  ",
    "instruction": "  To generate the provided code, follow these steps: 1. Define the function get_demo_image(), which returns a tuple called Z and extent. 2. Define the function demo_bottom_cbar(fig), which creates a grid of 2x2 images with colorbars at the bottom. Inside the function, do the following:     a. Use the AxesGrid() function to create the grid with the specified parameters.     b. Call the get_demo_image() function to obtain the Z and extent values.     c. Create a list called cmaps and assign it with the color map names.     d. Iterate over a range of 4 and do the following:         - Use the grid[i] notation to access each grid cell.         - Use the imshow() function to plot the image using Z and extent, and assign it to a variable called im.         - Use the if condition (i % 2) to determine if the current iteration is odd.         - If the condition is True, use grid.cbar_axes[i//2].colorbar(im) to add a colorbar to the corresponding cell.     e. Iterate over grid.cbar_axes and do the following:         - Access the cax.orientation attribute and use it to access the corresponding axis.         - Set the label of the axis to \"Bar\" using the set_label() function.     f. Use the grid.axes_llc.set_xticks() and grid.axes_llc.set_yticks() functions to set the x and y ticks for the lower-left axes. 3. Define the function demo_right_cbar(fig), which creates a grid of 2x2 images with colorbars on the right side. Inside the function, follow similar steps as in demo_bottom_cbar() but with the following changes:     - Set the cbar_location parameter of AxesGrid() to 'right'.     - Create a list called cmaps and assign it with different color map names.     - Use the grid[i] notation to access each grid cell and assign the plotted image to the variable im.     - Set the label of the axis to \"Foo\" for each cbar_axes.     - Use the grid.axes_llc.set_xticks() and grid.axes_llc.set_yticks() functions to set the x and y ticks for the lower-left axes. 4. Create a figure using plt.figure(). 5. Call both demo_bottom_cbar(fig) and demo_right_cbar(fig) functions. 6. Use plt.show() to display the generated plot. ",
    "id": 167
},
{
    "data": " No relevant data found.  ",
    "instruction": " Use the following functions from matplotlib: ImageGrid, set_aspect, and plt.show, to create a figure with two ImageGrids. Set a fixed aspect on the cells of the ImageGrids. ",
    "id": 168
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from matplotlib import cbook from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar from mpl_toolkits.axes_grid1.inset_locator import mark_inset, zoomed_inset_axes  fig, (ax, ax2) = plt.subplots(ncols=2, figsize=[6, 3])   # First subplot, showing an inset with a size bar. ax.set_aspect(1)  axins = zoomed_inset_axes(ax, zoom=0.5, loc='upper right') # fix the number of ticks on the inset axes axins.yaxis.get_major_locator().set_params(nbins=7) axins.xaxis.get_major_locator().set_params(nbins=7) axins.tick_params(labelleft=False, labelbottom=False)   def add_sizebar(ax, size):     asb = AnchoredSizeBar(ax.transData,                           size,                           str(size),                           loc=8,                           pad=0.1, borderpad=0.5, sep=5,                           frameon=False)     ax.add_artist(asb)  add_sizebar(ax, 0.5) add_sizebar(axins, 0.5)   # Second subplot, showing an image with an inset zoom and a marked inset Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array extent = (-3, 4, -4, 3) Z2 = np.zeros((150, 150)) ny, nx = Z.shape Z2[30:30+ny, 30:30+nx] = Z  ax2.imshow(Z2, extent=extent, origin='lower')  axins2 = zoomed_inset_axes(ax2, zoom=6, loc=1) axins2.imshow(Z2, extent=extent, origin='lower')  # subregion of the original image x1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9 axins2.set_xlim(x1, x2) axins2.set_ylim(y1, y2) # fix the number of ticks on the inset axes axins2.yaxis.get_major_locator().set_params(nbins=7) axins2.xaxis.get_major_locator().set_params(nbins=7) axins2.tick_params(labelleft=False, labelbottom=False)  # draw a bbox of the region of the inset axes in the parent axes and # connecting lines between the bbox and the inset axes area mark_inset(ax2, axins2, loc1=2, loc2=4, fc='none', ec='0.5')  plt.show()  ",
    "instruction": " Use the following functions from matplotlib: zoomed_inset_axes, zoomed_inset_axes, AnchoredSizeBar, mark_inset, imshow, to create a figure with two subplots. The first subplot should contain an inset with a size bar. The second subplot should contain an image with a zoomed inset and a marked inset. ",
    "id": 169
},
{
    "data": "  import matplotlib.pyplot as plt  from mpl_toolkits.axes_grid1 import host_subplot  host = host_subplot(111) par = host.twinx()  host.set_xlabel('Distance') host.set_ylabel('Density') par.set_ylabel('Temperature')  p1, = host.plot([0, 1, 2], [0, 1, 2], label='Density') p2, = par.plot([0, 1, 2], [0, 3, 2], label='Temperature')  host.legend(labelcolor='linecolor')  host.yaxis.get_label().set_color(p1.get_color()) par.yaxis.get_label().set_color(p2.get_color())  plt.show()  ",
    "instruction": "  Create a plot with two y-axes using the matplotlib library. The plot should have the following properties: - The x-axis represents \"Distance\". - The left y-axis represents \"Density\". - The right y-axis represents \"Temperature\". - The plot should have two lines: one for \"Density\" and one for \"Temperature\". ",
    "id": 170
},
{
    "data": "   obs = [['01_S1', 3.88, 0.14, 1970, 63],        ['01_S4', 5.6, 0.82, 1622, 150],        ['02_S1', 2.4, 0.54, 1570, 40],        ['03_S1', 4.1, 0.62, 2380, 170]]  pm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5  ",
    "instruction": "   Use the following functions and data from matplotlib to create a plot:  1. Use the function `add_subplot()` to create a plot with the specified axes class and aspect ratio. 2. Use the function `twin()` to create a twin Axes sharing the x-axis, with the specified transformation. 3. Use the function `errorbar()` to plot the data points with errorbars. 4. Set the labels for the x-axis and y-axis of the lower x-axis using the `set_label()` method of `axis['bottom']`. 5. Set the labels for the y-axis and x-axis of the upper x-axis using the `set_label()` method of `axis['left']`. 6. Set the label for the upper y-axis using the `set_label()` method of `axis['top']`. 7. Adjust the limits of the x-axis and y-axis using the `set_xlim()` and `set_ylim()` methods of the Axes object.  Use the following data for plotting:  obs = [['01_S1', 3.88, 0.14, 1970, 63],        ['01_S4', 5.6, 0.82, 1622, 150],        ['02_S1', 2.4, 0.54, 1570, 40],        ['03_S1', 4.1, 0.62, 2380, 170]]  pm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5 ",
    "id": 171
},
{
    "data": " np.random.seed(19680801)  x = np.random.randn(1000) y = np.random.randn(1000)  ",
    "instruction": " Use matplotlib's scatter plot function `scatter` to create a scatter plot with the random data `x` and `y`. Set the aspect ratio of the plot to 1.0. Create new axes on the top and right of the scatter plot using make_axes_locatable. Make the x-axis ticks of the top axes invisible and the y-axis ticks of the right axes invisible. Set the binwidth to 0.25 and determine the limits for the x and y axes. Create histograms on the top and right axes using `hist` with the respective bins. Set the y-axis ticks of the top axes to [0, 50, 100] and the x-axis ticks of the right axes to [0, 50, 100]. Finally, show the plot. ",
    "id": 172
},
{
    "data": "  1. np.random.seed(20230930) 2. t = np.arange(0.0, 10.0, 0.2) 3. s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 4. nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:  1. np.random.seed(20230930) 2. t = np.arange(0.0, 10.0, 0.2) 3. s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 4. nse = np.random.normal(0.0, 0.5, t.shape) * s  ---  [DATA]:  1. species = (\"Adelie\\n $\\mu=$3700.66g\", \"Chinstrap\\n $\\mu=$3733.09g\", \"Gentoo\\n $\\mu=5076.02g$\") 2. weight_counts = {\"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it:  1. species = (\"Adelie\\n $\\mu=$3700.66g\", \"Chinstrap\\n $\\mu=$3733.09g\", \"Gentoo\\n $\\mu=5076.02g$\") 2. weight_counts = {\"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}  ---  [DATA]:  1. draw_text(ax) function 2. draw_circle(ax) function 3. draw_sizebar(ax) function  [INSTRUCTION]: Use the provided functions to draw text, circle, and sizebar in a plot. The functions are: draw_text(ax), draw_circle(ax), and draw_sizebar(ax). ",
    "id": 173
},
{
    "data": "  import matplotlib.pyplot as plt  from mpl_toolkits.axes_grid1 import Divider import mpl_toolkits.axes_grid1.axes_size as Size  fig = plt.figure(figsize=(5.5, 4))  # the rect parameter will be ignored as we will set axes_locator rect = (0.1, 0.1, 0.8, 0.8) ax = [fig.add_axes(rect, label='%d' % i) for i in range(4)]   horiz = [Size.AxesX(ax[0]), Size.Fixed(.5), Size.AxesX(ax[1])] vert = [Size.AxesY(ax[0]), Size.Fixed(.5), Size.AxesY(ax[2])]  # divide the axes rectangle into grid whose size is specified by horiz * vert divider = Divider(fig, rect, horiz, vert, aspect=False)   ax[0].set_axes_locator(divider.new_locator(nx=0, ny=0)) ax[1].set_axes_locator(divider.new_locator(nx=2, ny=0)) ax[2].set_axes_locator(divider.new_locator(nx=0, ny=2)) ax[3].set_axes_locator(divider.new_locator(nx=2, ny=2))  ax[0].set_xlim(0, 2) ax[1].set_xlim(0, 1)  ax[0].set_ylim(0, 1) ax[2].set_ylim(0, 2)  divider.set_aspect(1.)  for ax1 in ax:     ax1.tick_params(labelbottom=False, labelleft=False)  plt.show()  ",
    "instruction": "  Create a 4-panel subplot arrangement using matplotlib. Use the mpl_toolkits.axes_grid1 import Divider and mpl_toolkits.axes_grid1.axes_size as Size. Set the figure size to (5.5, 4). Add four axes objects with labels from 0 to 3. Use the specified division parameters to set the layout of the axes. Set the x-axis limits for ax[0] to (0, 2) and ax[1] to (0, 1). Set the y-axis limits for ax[0] to (0, 1) and ax[2] to (0, 2). Set the aspect ratio of the divider to be False. Finally, hide the tick labels for all axes objects and display the plot. ",
    "id": 174
},
{
    "data": " im1 = np.arange(100).reshape((10, 10)) im2 = im1.T im3 = np.flipud(im1) im4 = np.fliplr(im2)  ",
    "instruction": " To create a 2x2 grid of axes with aligned multiple images, you can use the `ImageGrid` class from the `mpl_toolkits.axes_grid1` module. Use the following data to plot the images: im1 = np.arange(100).reshape((10, 10)) im2 = im1.T im3 = np.flipud(im1) im4 = np.fliplr(im2).  ",
    "id": 175
},
{
    "data": "  Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy') im1 = Z im2 = Z[:, :10] im3 = Z[:, 10:] vmin, vmax = Z.min(), Z.max()  ",
    "instruction": "  To align multiple images of different sizes using ImageGrid, import the following modules: matplotlib.pyplot as plt, matplotlib.cbook, and mpl_toolkits.axes_grid1.ImageGrid. Create a figure with a size of 5.5 x 3.5. Use the ImageGrid function to create a grid of 1 row and 3 columns, with an axes pad of 0.1 and a label mode of 'L'.   Load a demo image using cbook.get_sample_data('axes_grid/bivariate_normal.npy') and assign it to the variable Z. Create three subplots within the grid, each displaying a different image: im1, im2, and im3. Use ax.imshow() to show each image, with the 'lower' origin and vmin/vmax set to the minimum and maximum values of Z.  Finally, display the plot using plt.show(). ",
    "id": 176
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from mpl_toolkits.axes_grid1 import host_subplot  ax = host_subplot(111) xx = np.arange(0, 2*np.pi, 0.01) ax.plot(xx, np.sin(xx))  ax2 = ax.twin()  # ax2 is responsible for 'top' axis and 'right' axis ax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi],                labels=['$0$', r'$\\\\frac{1}{2}\\\\pi$',                        r'$\\\\pi$', r'$\\\\frac{3}{2}\\\\pi$', r'$2\\\\pi$'])  ax2.axis['right'].major_ticklabels.set_visible(False) ax2.axis['top'].major_ticklabels.set_visible(True)  plt.show()  ",
    "instruction": "  Use the following functions from matplotlib: host_subplot, np.arange, np.pi, np.sin, plt.plot, plt.twin, ax.set_xticks, ax.plot, ax.twin.set_xticks, ax2.axis, and plt.show, to create a plot showing the sine function on the x-axis and the tick labels showing the values 0, 0.5π, π, 1.5π, and 2π. ",
    "id": 177
},
{
    "data": " import matplotlib.pyplot as plt import numpy as np  from mpl_toolkits.axes_grid1 import make_axes_locatable  ax = plt.subplot() im = ax.imshow(np.arange(100).reshape((10, 10)))  # create an Axes on the right side of ax. The width of cax will be 5% # of ax and the padding between cax and ax will be fixed at 0.05 inch. divider = make_axes_locatable(ax) cax = divider.append_axes('right', size='5%', pad=0.05)  ",
    "instruction": " Create a simple colorbar using matplotlib. Use the following data to plot it: np.arange(100).reshape((10, 10)). ",
    "id": 178
},
{
    "data": "  plt.rcParams.update({     'axes.titlesize': 'medium',     'axes.titley': 1.1, })  fig = plt.figure(figsize=(10, 4)) fig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)  ax1 = setup_axes(fig, 251) ax1.axis['x'].set_axis_direction('left')  ax2 = setup_axes(fig, 252) ax2.axis['x'].label.set_text('Label') ax2.axis['x'].toggle(ticklabels=False) ax2.axis['x'].set_axislabel_direction('+') ax2.set_title('label direction=$+$')  ax3 = setup_axes(fig, 253) ax3.axis['x'].label.set_text('Label') ax3.axis['x'].toggle(ticklabels=False) ax3.axis['x'].set_axislabel_direction('-') ax3.set_title('label direction=$-$')  ax4 = setup_axes(fig, 254) ax4.axis['x'].set_ticklabel_direction('+') ax4.set_title('ticklabel direction=$+$')  ax5 = setup_axes(fig, 255) ax5.axis['x'].set_ticklabel_direction('-') ax5.set_title('ticklabel direction=$-$')  ax7 = setup_axes(fig, 257) ax7.axis['x'].label.set_text('rotation=10') ax7.axis['x'].label.set_rotation(10) ax7.axis['x'].toggle(ticklabels=False)  ax8 = setup_axes(fig, 258) ax8.axis['x'].set_axislabel_direction('-') ax8.axis['x'].label.set_text('rotation=10') ax8.axis['x'].label.set_rotation(10) ax8.axis['x'].toggle(ticklabels=False)   ",
    "instruction": "  To create a figure with different axis directions, follow these steps: 1. Set the following parameters for matplotlib:    plt.rcParams.update({'axes.titlesize': 'medium', 'axes.titley': 1.1}) 2. Create a figure with a size of 10x4 using `fig = plt.figure(figsize=(10, 4))`. 3. Adjust the subplots using `fig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)`. 4. Create the first set of axes with axis direction set to 'left' using `ax1 = setup_axes(fig, 251)`. 5. Create the second set of axes with a label and axis label direction set to '+' using `ax2 = setup_axes(fig, 252)`. Disable tick labels using `ax2.axis['x'].toggle(ticklabels=False)`. Set the title to 'label direction=$+$'. 6. Create the third set of axes with a label and axis label direction set to '-' using `ax3 = setup_axes(fig, 253)`. Disable tick labels using `ax3.axis['x'].toggle(ticklabels=False)`. Set the title to 'label direction=$-$'. 7. Create the fourth set of axes with tick label direction set to '+' using `ax4 = setup_axes(fig, 254)`. Set the title to 'ticklabel direction=$+$'. 8. Create the fifth set of axes with tick label direction set to '-' using `ax5 = setup_axes(fig, 255)`. Set the title to 'ticklabel direction=$-$'. 9. Create the sixth set of axes with a label, a label rotation of 10 degrees, and disabled tick labels using `ax7 = setup_axes(fig, 257)`. Set the title to 'rotation=10'. 10. Create the seventh set of axes with axis label direction set to '-' and a label rotation of 10 degrees using `ax8 = setup_axes(fig, 258)`. Disable tick labels using `ax8.axis['x'].toggle(ticklabels=False)`. 11. Show the figure using `plt.show()`. ",
    "id": 179
},
{
    "data": "  ```python import matplotlib.pyplot as plt import numpy as np  from matplotlib.projections import PolarAxes from matplotlib.transforms import Affine2D import mpl_toolkits.axisartist as axisartist import mpl_toolkits.axisartist.angle_helper as angle_helper import mpl_toolkits.axisartist.grid_finder as grid_finder from mpl_toolkits.axisartist.grid_helper_curvelinear import \\     GridHelperCurveLinear   def setup_axes(fig, rect):     '''Polar projection, but in a rectangular box.'''     # see demo_curvelinear_grid.py for details     grid_helper = GridHelperCurveLinear(         Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform(),         extreme_finder=angle_helper.ExtremeFinderCycle(             20, 20,             lon_cycle=360, lat_cycle=None,             lon_minmax=None, lat_minmax=(0, np.inf),         ),         grid_locator1=angle_helper.LocatorDMS(12),         grid_locator2=grid_finder.MaxNLocator(5),         tick_formatter1=angle_helper.FormatterDMS(),     )     ax = fig.add_subplot(         rect, axes_class=axisartist.Axes, grid_helper=grid_helper,         aspect=1, xlim=(-5, 12), ylim=(-5, 10))     ax.axis[:].toggle(ticklabels=False)     ax.grid(color='.9')     return ax   def add_floating_axis1(ax):     ax.axis['lat'] = axis = ax.new_floating_axis(0, 30)     axis.label.set_text(r'$\\theta = 30^{\\circ}$')     axis.label.set_visible(True)     return axis   def add_floating_axis2(ax):     ax.axis['lon'] = axis = ax.new_floating_axis(1, 6)     axis.label.set_text(r'$r = 6$')     axis.label.set_visible(True)     return axis   fig = plt.figure(figsize=(8, 4), layout='constrained')  for i, d in enumerate(['bottom', 'left', 'top', 'right']):     ax = setup_axes(fig, rect=241+i)     axis = add_floating_axis1(ax)     axis.set_axis_direction(d)     ax.set(title=d)  for i, d in enumerate(['bottom', 'left', 'top', 'right']):     ax = setup_axes(fig, rect=245+i)     axis = add_floating_axis2(ax)     axis.set_axis_direction(d)     ax.set(title=d)  plt.show() ```  ",
    "instruction": " Use the provided code to create four subplots with polar projection, but in a rectangular box. Each subplot should have a floating axis, one representing a latitude value of 30 degrees and the other representing a radius value of 6. Set the titles of the subplots as \"bottom\", \"left\", \"top\", and \"right\", respectively. ",
    "id": 180
},
{
    "data": "  x = np.linspace(-0.5, 1., 100)  ",
    "instruction": "  Create a plot with axis line styles using matplotlib. Use the following data to plot it: x = np.linspace(-0.5, 1., 100). Set the axes to have arrows at the ends and visible X and Y-axes from the origin. Hide the borders. Plot the function np.sin(x*np.pi). ",
    "id": 181
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]:  species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adelie\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\mu=5076.02g$\"), weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.   [DATA]:  No data preparation block found in the code.  [INSTRUCTION]:  No data preparation is required for this code. It demonstrates how to use GridHelperCurveLinear to define custom grids and ticklines by applying a transformation on the grid. This can be used to create polar projections in a rectangular box. ",
    "id": 182
},
{
    "data": " np.sign(x)*abs(x)**.5, y  def curvelinear_test1(fig):     '''Grid for custom transform.'''      def tr(x, y):         return np.sign(x)*abs(x)**.5, y      def inv_tr(x, y):         return np.sign(x)*x**2, y      grid_helper = GridHelperCurveLinear(         (tr, inv_tr),         extreme_finder=ExtremeFinderSimple(20, 20),         # better tick density         grid_locator1=MaxNLocator(nbins=6), grid_locator2=MaxNLocator(nbins=6))      ax1 = fig.add_subplot(axes_class=Axes, grid_helper=grid_helper)     # ax1 will have a ticks and gridlines defined by the given     # transform (+ transData of the Axes). Note that the transform of the Axes     # itself (i.e., transData) is not affected by the given transform.      ax1.imshow(np.arange(25).reshape(5, 5),                vmax=50, cmap=plt.cm.gray_r, origin='lower')   if __name__ == '__main__':     fig = plt.figure(figsize=(7, 4))     curvelinear_test1(fig)     plt.show()  ",
    "instruction": " Create a custom grid and ticklines using the GridHelperCurveLinear function in matplotlib. Use the provided data and code snippet to generate a plot with a 5x5 matrix displayed on the axes. ",
    "id": 183
},
{
    "data": " import matplotlib.pyplot as plt import numpy as np from matplotlib.projections import PolarAxes from matplotlib.transforms import Affine2D from mpl_toolkits.axisartist import GridHelperCurveLinear, HostAxes import mpl_toolkits.axisartist.angle_helper as angle_helper  def curvelinear_test2(fig):     '''Polar projection, but in a rectangular box.'''     # see demo_curvelinear_grid.py for details     tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform()      extreme_finder = angle_helper.ExtremeFinderCycle(20,                                                      20,                                                      lon_cycle=360,                                                      lat_cycle=None,                                                      lon_minmax=None,                                                      lat_minmax=(0, np.inf),                                                      )      grid_locator1 = angle_helper.LocatorDMS(12)      tick_formatter1 = angle_helper.FormatterDMS()      grid_helper = GridHelperCurveLinear(tr,                                         extreme_finder=extreme_finder,                                         grid_locator1=grid_locator1,                                         tick_formatter1=tick_formatter1                                         )      ax1 = fig.add_subplot(axes_class=HostAxes, grid_helper=grid_helper)      # Now creates floating axis      # floating axis whose first coordinate (theta) is fixed at 60     ax1.axis['lat'] = axis = ax1.new_floating_axis(0, 60)     axis.label.set_text(r'$\\\\\\\\theta = 60^{\\\\\\\\circ}$')     axis.label.set_visible(True)      # floating axis whose second coordinate (r) is fixed at 6     ax1.axis['lon'] = axis = ax1.new_floating_axis(1, 6)     axis.label.set_text(r'$r = 6$')      ax1.set_aspect(1.)     ax1.set_xlim(-5, 12)     ax1.set_ylim(-5, 10)      ax1.grid(True)   fig = plt.figure(figsize=(5, 5)) curvelinear_test2(fig) plt.show()  ",
    "instruction": " Create a floating polar curve within a rectangular box using matplotlib. Use the following code to generate the plot: import matplotlib.pyplot as plt import numpy as np from matplotlib.projections import PolarAxes from matplotlib.transforms import Affine2D from mpl_toolkits.axisartist import GridHelperCurveLinear, HostAxes import mpl_toolkits.axisartist.angle_helper as angle_helper  def curvelinear_test2(fig):     '''Polar projection, but in a rectangular box.'''     # see demo_curvelinear_grid.py for details     tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform()      extreme_finder = angle_helper.ExtremeFinderCycle(20,                                                      20,                                                      lon_cycle=360,                                                      lat_cycle=None,                                                      lon_minmax=None,                                                      lat_minmax=(0, np.inf),                                                      )      grid_locator1 = angle_helper.LocatorDMS(12)      tick_formatter1 = angle_helper.FormatterDMS()      grid_helper = GridHelperCurveLinear(tr,                                         extreme_finder=extreme_finder,                                         grid_locator1=grid_locator1,                                         tick_formatter1=tick_formatter1                                         )      ax1 = fig.add_subplot(axes_class=HostAxes, grid_helper=grid_helper)      # Now creates floating axis      # floating axis whose first coordinate (theta) is fixed at 60     ax1.axis['lat'] = axis = ax1.new_floating_axis(0, 60)     axis.label.set_text(r'$\\\\\\\\theta = 60^{\\\\\\\\circ}$')     axis.label.set_visible(True)      # floating axis whose second coordinate (r) is fixed at 6     ax1.axis['lon'] = axis = ax1.new_floating_axis(1, 6)     axis.label.set_text(r'$r = 6$')      ax1.set_aspect(1.)     ax1.set_xlim(-5, 12)     ax1.set_ylim(-5, 10)      ax1.grid(True)   fig = plt.figure(figsize=(5, 5)) curvelinear_test2(fig) plt.show() ",
    "id": 184
},
{
    "data": "   no data extraction is needed for this code snippet.  ",
    "instruction": "   Create a parasite axes using matplotlib. The parasite axes should share the x scale with a host axes, but show a different scale in the y direction. Use the following data to plot it: no data extraction is needed for this code snippet. ",
    "id": 185
},
{
    "data": "  import matplotlib.pyplot as plt  from mpl_toolkits import axisartist from mpl_toolkits.axes_grid1 import host_subplot  host = host_subplot(111, axes_class=axisartist.Axes) plt.subplots_adjust(right=0.75)  par1 = host.twinx() par2 = host.twinx()  par2.axis['right'] = par2.new_fixed_axis(loc='right', offset=(60, 0))  par1.axis['right'].toggle(all=True) par2.axis['right'].toggle(all=True)  p1, = host.plot([0, 1, 2], [0, 1, 2], label='Density') p2, = par1.plot([0, 1, 2], [0, 3, 2], label='Temperature') p3, = par2.plot([0, 1, 2], [50, 30, 15], label='Velocity')  host.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density') par1.set(ylim=(0, 4), ylabel='Temperature') par2.set(ylim=(1, 65), ylabel='Velocity')  host.legend()  host.axis['left'].label.set_color(p1.get_color()) par1.axis['right'].label.set_color(p2.get_color()) par2.axis['right'].label.set_color(p3.get_color())  plt.show()  ",
    "instruction": "  Create a plot with multiple y-axes using the parasite axis technique in matplotlib. Use the following functions and settings: - mpl_toolkits.axisartist.Axes - mpl_toolkits.axes_grid1.host_subplot - host_subplot(111, axes_class=axisartist.Axes) - plt.subplots_adjust(right=0.75) - par1 = host.twinx() - par2 = host.twinx() - par2.axis['right'] = par2.new_fixed_axis(loc='right', offset=(60, 0)) - par1.axis['right'].toggle(all=True) - par2.axis['right'].toggle(all=True) - p1, = host.plot([0, 1, 2], [0, 1, 2], label='Density') - p2, = par1.plot([0, 1, 2], [0, 3, 2], label='Temperature') - p3, = par2.plot([0, 1, 2], [50, 30, 15], label='Velocity') - host.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density') - par1.set(ylim=(0, 4), ylabel='Temperature') - par2.set(ylim=(1, 65), ylabel='Velocity') - host.legend() - host.axis['left'].label.set_color(p1.get_color()) - par1.axis['right'].label.set_color(p2.get_color()) - par2.axis['right'].label.set_color(p3.get_color())   ",
    "id": 186
},
{
    "data": "  import mpl_toolkits.axisartist as axisartist   def setup_axes(fig, pos):     ax = fig.add_subplot(pos, axes_class=axisartist.Axes)     ax.set_yticks([0.2, 0.8], labels=['short', 'loooong'])     ax.set_xticks([0.2, 0.8], labels=[r'$\\frac{1}{2}\\pi$', r'$\\pi$'])     return ax   fig = plt.figure(figsize=(3, 5)) fig.subplots_adjust(left=0.5, hspace=0.7)  ax = setup_axes(fig, 311) ax.set_ylabel('ha=right') ax.set_xlabel('va=baseline')  ax = setup_axes(fig, 312) ax.axis['left'].major_ticklabels.set_ha('center') ax.axis['bottom'].major_ticklabels.set_va('top') ax.set_ylabel('ha=center') ax.set_xlabel('va=top')  ax = setup_axes(fig, 313) ax.axis['left'].major_ticklabels.set_ha('left') ax.axis['bottom'].major_ticklabels.set_va('bottom') ax.set_ylabel('ha=left') ax.set_xlabel('va=bottom')  plt.show()  ",
    "instruction": " Use the mpl_toolkits.axisartist module to create three subplots with different ticklabel alignments. Each subplot should have a different combination of ha (horizontal alignment) and va (vertical alignment) settings for the ticklabels. Set the ticklabel text and positions using the provided data. ",
    "id": 187
},
{
    "data": "  1. No data preparation block is found in the provided code. 2. No data preparation block is found in the provided code.  ",
    "instruction": "  1. No data preparation block is found in the provided code, but you can use the following functions from matplotlib: setup_axes and plt.subplots_adjust to create a figure with three subplots. Use the following context to configure the tick label directions:     - ax.axis['left'].major_ticks.set_tick_out(True)    - ax.axis['bottom'].major_ticks.set_tick_out(True)    - ax.axis['right'].major_ticks.set_tick_out(True)    - ax.axis['top'].major_ticks.set_tick_out(True)    - ax.axis['left'].set_axis_direction('right')    - ax.axis['bottom'].set_axis_direction('top')    - ax.axis['right'].set_axis_direction('left')    - ax.axis['top'].set_axis_direction('bottom')    - ax.axis['left'].set_axis_direction('right')    - ax.axis['bottom'].set_axis_direction('top')    - ax.axis['right'].set_axis_direction('left')    - ax.axis['top'].set_axis_direction('bottom')    - ax.axis['left'].label.set_text('Long Label Left')    - ax.axis['bottom'].label.set_text('Label Bottom')    - ax.axis['right'].label.set_text('Long Label Right')    - ax.axis['right'].label.set_visible(True)    - ax.axis['left'].label.set_pad(0)    - ax.axis['bottom'].label.set_pad(10)  2. No data preparation block is found in the provided code, but you can use the following functions from matplotlib: setup_axes and plt.subplots_adjust to create a figure with three subplots. Use the context provided to configure the tick label directions and labels for each axis, as mentioned above. ",
    "id": 188
},
{
    "data": " No data preparation blocks found in the code. ",
    "instruction": " Use the following imports to create a plot with a left and right axis label:  import matplotlib.pyplot as plt import mpl_toolkits.axisartist as axisartist  Create a figure with the desired size:  fig = plt.figure(figsize=(4, 2.5))  Add an axis with the specified axis class:  ax1 = fig.add_subplot(axes_class=axisartist.Axes)  Adjust the spacing of the subplots to make room for the labels:  fig.subplots_adjust(right=0.8)  Set the axis direction and label for the left axis:  ax1.axis['left'].major_ticklabels.set_axis_direction('top') ax1.axis['left'].label.set_text('Left label')  Make the label for the right axis visible and set its text and direction:  ax1.axis['right'].label.set_visible(True) ax1.axis['right'].label.set_text('Right label') ax1.axis['right'].label.set_axis_direction('left')  Display the plot:  plt.show() ",
    "id": 189
},
{
    "data": "  import mpl_toolkits.axisartist as axisartist   def setup_axes(fig, pos):     ax = fig.add_subplot(pos, axes_class=axisartist.Axes)     ax.set_yticks([0.2, 0.8])     ax.set_xticks([0.2, 0.8])     return ax   fig = plt.figure(figsize=(5, 2)) fig.subplots_adjust(wspace=0.4, bottom=0.3)  ax1 = setup_axes(fig, 121) ax1.set_xlabel('ax1 X-label') ax1.set_ylabel('ax1 Y-label')  ax1.axis[:].invert_ticklabel_direction()  ax2 = setup_axes(fig, 122) ax2.set_xlabel('ax2 X-label') ax2.set_ylabel('ax2 Y-label')  ax2.axis[:].major_ticks.set_tick_out(False)  plt.show()  ",
    "instruction": "  To create a figure with two subplots, with different axis tick label and tick directions, use the function setup_axes to define the axis properties of each subplot. The setup_axes function takes the figure object and the position of the subplot as inputs and returns an axis object. The tick labels and tick directions can be set using the set_xlabel, set_ylabel, invert_ticklabel_direction, and major_ticks.set_tick_out functions. Adjust the figure spacing using the fig.subplots_adjust function, passing the desired spacing values as arguments. Finally, use plt.show to display the figure. ",
    "id": 190
},
{
    "data": "  ```python import matplotlib.pyplot as plt import numpy as np  from matplotlib.projections import PolarAxes from matplotlib.transforms import Affine2D import mpl_toolkits.axisartist as axisartist import mpl_toolkits.axisartist.angle_helper as angle_helper import mpl_toolkits.axisartist.grid_finder as grid_finder from mpl_toolkits.axisartist.grid_helper_curvelinear import \\     GridHelperCurveLinear   def setup_axes(fig, rect):     '''Polar projection, but in a rectangular box.'''      # see demo_curvelinear_grid.py for details     tr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform()      extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,                                                      lon_cycle=360,                                                      lat_cycle=None,                                                      lon_minmax=None,                                                      lat_minmax=(0, np.inf),                                                      )      grid_locator1 = angle_helper.LocatorDMS(12)     grid_locator2 = grid_finder.MaxNLocator(5)      tick_formatter1 = angle_helper.FormatterDMS()      grid_helper = GridHelperCurveLinear(tr,                                         extreme_finder=extreme_finder,                                         grid_locator1=grid_locator1,                                         grid_locator2=grid_locator2,                                         tick_formatter1=tick_formatter1                                         )      ax1 = fig.add_subplot(         rect, axes_class=axisartist.Axes, grid_helper=grid_helper)     ax1.axis[:].set_visible(False)     ax1.set_aspect(1.)     ax1.set_xlim(-5, 12)     ax1.set_ylim(-5, 10)      return ax1   def add_floating_axis1(ax1):     ax1.axis['lat'] = axis = ax1.new_floating_axis(0, 30)     axis.label.set_text(r'$\\\\theta = 30^{\\\\circ}$')     axis.label.set_visible(True)      return axis   def add_floating_axis2(ax1):     ax1.axis['lon'] = axis = ax1.new_floating_axis(1, 6)     axis.label.set_text(r'$r = 6$')     axis.label.set_visible(True)   fig = plt.figure(figsize=(9, 3.)) fig.subplots_adjust(left=0.01, right=0.99, bottom=0.01, top=0.99,                     wspace=0.01, hspace=0.01)   def ann(ax1, d):     if plt.rcParams['text.usetex']:         d = d.replace('_', r'\\\\_')      ax1.annotate(d, (0.5, 1), (5, -5),                  xycoords='axes fraction', textcoords='offset points',                  va='top', ha='center')   ax1 = setup_axes(fig, rect=141) axis = add_floating_axis1(ax1) ann(ax1, r'default')  ax1 = setup_axes(fig, rect=142) axis = add_floating_axis1(ax1) axis.major_ticklabels.set_pad(10) ann(ax1, r'ticklabels.set_pad(10)')  ax1 = setup_axes(fig, rect=143) axis = add_floating_axis1(ax1) axis.label.set_pad(20) ann(ax1, r'label.set_pad(20)')  ax1 = setup_axes(fig, rect=144) axis = add_floating_axis1(ax1) axis.major_ticks.set_tick_out(True) ann(ax1, 'ticks.set_tick_out(True)')  plt.show() ```  ",
    "instruction": "  Use the following functions from matplotlib: setup_axes, add_floating_axis1, add_floating_axis2, and ann, to create a figure with four subplots. Each subplot should have a different demonstration of axis settings. Use the provided setup_axes function to set up a polar projection in a rectangular box. Use the following data to create the plots: None.  ",
    "id": 191
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from mpl_toolkits import axisartist  fig = plt.figure(figsize=(6, 3), layout='constrained') # To construct axes of two different classes, we need to use gridspec (or # MATLAB-style add_subplot calls). gs = fig.add_gridspec(1, 2)   ax0 = fig.add_subplot(gs[0, 0], axes_class=axisartist.Axes) # Make a new axis along the first (x) axis which passes through y=0. ax0.axis['y=0'] = ax0.new_floating_axis(nth_coord=0, value=0,                                         axis_direction='bottom') ax0.axis['y=0'].toggle(all=True) ax0.axis['y=0'].label.set_text('y = 0') # Make other axis invisible. ax0.axis['bottom', 'top', 'right'].set_visible(False)   # Alternatively, one can use AxesZero, which automatically sets up two # additional axis, named 'xzero' (the y=0 axis) and 'yzero' (the x=0 axis). ax1 = fig.add_subplot(gs[0, 1], axes_class=axisartist.axislines.AxesZero) # 'xzero' and 'yzero' default to invisible; make xzero axis visible. ax1.axis['xzero'].set_visible(True) ax1.axis['xzero'].label.set_text('Axis Zero') # Make other axis invisible. ax1.axis['bottom', 'top', 'right'].set_visible(False)   # Draw some sample data. x = np.arange(0, 2*np.pi, 0.01) ax0.plot(x, np.sin(x)) ax1.plot(x, np.sin(x))  plt.show()  ",
    "instruction": "  To create custom spines at custom positions (y = 0), you can use axisartist in matplotlib. Here is the code to generate the plot:  import matplotlib.pyplot as plt import numpy as np from mpl_toolkits import axisartist  fig = plt.figure(figsize=(6, 3), layout='constrained') gs = fig.add_gridspec(1, 2)  ax0 = fig.add_subplot(gs[0, 0], axes_class=axisartist.Axes) ax0.axis['y=0'] = ax0.new_floating_axis(nth_coord=0, value=0, axis_direction='bottom') ax0.axis['y=0'].toggle(all=True) ax0.axis['y=0'].label.set_text('y = 0') ax0.axis['bottom', 'top', 'right'].set_visible(False)  ax1 = fig.add_subplot(gs[0, 1], axes_class=axisartist.axislines.AxesZero) ax1.axis['xzero'].set_visible(True) ax1.axis['xzero'].label.set_text('Axis Zero') ax1.axis['bottom', 'top', 'right'].set_visible(False)  x = np.arange(0, 2*np.pi, 0.01) ax0.plot(x, np.sin(x)) ax1.plot(x, np.sin(x))  plt.show() ",
    "id": 192
},
{
    "data": "  import matplotlib.pyplot as plt from mpl_toolkits.axisartist.axislines import AxesZero  fig = plt.figure() fig.subplots_adjust(right=0.85) ax = fig.add_subplot(axes_class=AxesZero)  ax.axis['right'].set_visible(False) ax.axis['top'].set_visible(False)  ax.axis['xzero'].set_visible(True) ax.axis['xzero'].label.set_text('Axis Zero')  ax.set_ylim(-2, 4) ax.set_xlabel('Label X') ax.set_ylabel('Label Y')  ax.axis['right2'] = ax.new_fixed_axis(loc='right', offset=(20, 0)) ax.axis['right2'].label.set_text('Label Y2')  ax.plot([-2, 3, 2])  plt.show()  ",
    "instruction": " Use the following data to create a plot with a horizontal axis line through y=0, and two y-axes (one on the left and one on the right) with different labels. Set the y-axis limits to -2 and 4. Use the following labels for the x and y axes: Label X and Label Y, respectively. Create a new y-axis on the right side with the label Label Y2 and an offset of 20. Plot the line [-2, 3, 2]. ",
    "id": 193
},
{
    "data": " No data preparation blocks found in the provided code.  ",
    "instruction": " Create a simple plot using matplotlib. Use the following code to generate it:  ``` import matplotlib.pyplot as plt from mpl_toolkits.axisartist.axislines import Axes  fig = plt.figure(figsize=(3, 3))  ax = fig.add_subplot(axes_class=Axes)  ax.axis['right'].set_visible(False) ax.axis['top'].set_visible(False)  plt.show() ```  The code will create a figure with a single plot. The plot will have the right and top axes hidden. ",
    "id": 194
},
{
    "data": "  np.random.seed(19680801)  X = np.linspace(0.5, 3.5, 100) Y1 = 3+np.cos(X) Y2 = 1+np.cos(1+X/0.75)/2 Y3 = np.random.uniform(Y1, Y2, len(X))  ",
    "instruction": "  Create a figure with the following dimensions: width=7.5, height=7.5. Add an axes to the figure with the following position: left=0.2, bottom=0.17, width=0.68, height=0.7. Set the aspect ratio of the axes to 1. Set the major tick locators for both x-axis and y-axis to MultipleLocator with base=1.0. Set the minor tick locators for both x-axis and y-axis to AutoMinorLocator with n=4. Format the minor tick labels on the x-axis to have 2 decimal places. Set the x-axis limits to (0, 4) and the y-axis limits to (0, 4). Set the major tick parameters to have width=1.0, length=10, and label size=14. Set the minor tick parameters to have width=1.0, length=5, label size=10, and label color='0.25'. Add gridlines to the axes with linestyle='--', linewidth=0.5, and color='.25'. Plot Y1 versus X using color='C0', line width=2.5, and label='Blue signal'. Plot Y2 versus X using color='C1' and line width=2.5, without specifying a label. Plot every 3rd element of Y3 versus corresponding elements of X as markers using marker='s', marker size=9, marker face color='none', marker edge color='C4', and marker edge width=2.5. Set the title of the figure to 'Anatomy of a figure' with font size=20 and vertical alignment='bottom'. Set the x-axis label to 'x Axis label' with font size=14. Set the y-axis label to 'y Axis label' with font size=14. Add a legend to the axes located at the upper right corner with font size=14. ",
    "id": 195
},
{
    "data": " np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:  np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape).  ---  [DATA]: species = (\"Adelie\\n $\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\mu=5076.02g$\") weight_counts = {   \"Below\": np.array([70, 31, 58]),   \"Above\": np.array([82, 37, 66]), }  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it:  species = (\"Adelie\\n $\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\mu=5076.02g$\"), weight_counts = {   \"Below\": np.array([70, 31, 58]),   \"Above\": np.array([82, 37, 66]), }.  ---  [DATA]: firefox = 'M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68, ",
    "id": 196
},
{
    "data": "   a, b = 2, 9   x = np.linspace(0, 10) y = func(x) ix = np.linspace(a, b) iy = func(ix) verts = [(a, 0), *zip(ix, iy), (b, 0)] poly = Polygon(verts, facecolor='0.9', edgecolor='0.5')  ",
    "instruction": "   To create a plot of the integral as the area under a curve, follow these steps using matplotlib:  1. Define the function `func(x)`.  2. Specify the integral limits `a` and `b`.  3. Generate an array `x` using `np.linspace(0, 10)`.  4. Calculate the corresponding values of `y = func(x)`.  5. Create a new figure and axis using `fig, ax = plt.subplots()`.  6. Plot the line graph of `y` using `ax.plot(x, y, 'r', linewidth=2)`.  7. Set the y-axis limit to start from 0 using `ax.set_ylim(bottom=0)`.  8. Generate an array `ix` using `np.linspace(a, b)`.  9. Calculate the corresponding values of `iy = func(ix)`.  10. Create the vertices for the shaded region using `verts = [(a, 0), *zip(ix, iy), (b, 0)]`.  11. Create a Polygon patch `poly` with a face color of '0.9' and an edge color of '0.5' using `poly = Polygon(verts, facecolor='0.9', edgecolor='0.5')`.  12. Add the polygon patch to the plot using `ax.add_patch(poly)`.  13. Add a text label to represent the integral using `ax.text(0.5 * (a + b), 30, r'\\int_a^b f(x)\\mathrm{d}x', horizontalalignment='center', fontsize=20)`.  14. Add labels to the x- and y-axes using `fig.text(0.9, 0.05, 'x')` and `fig.text(0.1, 0.9, 'y')`.  15. Hide the top and right spines using `ax.spines[['top', 'right']].set_visible(False)`.  16. Set custom tick placements and labels for the x-axis using `ax.set_xticks([a, b], labels=['$a$', '$b$'])`.  17. Remove ticks from the y-axis using `ax.set_yticks([])`.  18. Display the plot using `plt.show()`. ",
    "id": 197
},
{
    "data": " np.linspace(xmin, xmax, xn).astype(np.float32) Y = np.linspace(ymin, ymax, yn).astype(np.float32) C = X + Y[:, None] * 1j N = np.zeros_like(C, dtype=int) Z = np.zeros_like(C) maxiter = 200 horizon = 2.0 ** 40 log_horizon = np.log2(np.log(horizon)) Z, N = mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon) M = np.nan_to_num(N + 1 - np.log2(np.log(abs(Z))) + log_horizon) dpi = 72 width = 10 height = 10*yn/xn fig = plt.figure(figsize=(width, height), dpi=dpi) ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1) light = colors.LightSource(azdeg=315, altdeg=10) M = light.shade(M, cmap=plt.cm.hot, vert_exag=1.5, norm=colors.PowerNorm(0.3), blend_mode='hsv') ax.imshow(M, extent=[xmin, xmax, ymin, ymax], interpolation='bicubic') ax.set_xticks([]) ax.set_yticks([]) year = time.strftime('%Y') text = ('The Mandelbrot fractal set\\\\\\n' 'Rendered with matplotlib %s, %s - https://matplotlib.org' % (matplotlib.__version__, year)) ax.text(xmin+.025, ymin+.025, text, color='white', fontsize=12, alpha=0.5)  ",
    "instruction": " Use the following data to generate the Mandelbrot set rendering with shaded and power normalized rendering technique: - xmin = -2.25 - xmax = 0.75 - xn = 3000 // 2 - ymin = -1.25 - ymax = 1.25 - yn = 2500 // 2 - maxiter = 200 - horizon = 2.0 ** 40 - log_horizon = np.log2(np.log(horizon))  First, create the Mandelbrot set using the function mandelbrot_set() with the given parameters.  Then, normalize the Mandelbrot set using the formula M = N + 1 - np.log2(np.log(abs(Z))) + log_horizon.  Set the figure size to width = 10 and height = 10*yn/xn with dpi = 72.  Add an axes to the figure with ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1).  Apply shading to the normalized Mandelbrot set using the colors.LightSource() function with azdeg=315 and altdeg=10.  Display the shaded Mandelbrot set on the axes using ax.imshow() with the extent=[xmin, xmax, ymin, ymax] and interpolation='bicubic'.  Remove the x and y ticks using ax.set_xticks([]) and ax.set_yticks([]).  Finally, add text to the axes indicating the version of matplotlib used and the year, using ax.text(). ",
    "id": 198
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]:  species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adelie\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\mu=5076.02g$\"), weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.   [DATA]:  with get_sample_data('Stocks.csv') as file:     stock_data = np.genfromtxt(         file, delimiter=',', names=True, dtype=None,         converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)  [INSTRUCTION]:  Use the following code to load stock data from a CSV file and store it in the 'stock_data' variable:  with get_sample_data('Stocks.csv') as file:     stock_data = np.genfromtxt(         file, delimiter=',', names=True, dtype=None,         converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1).  ",
    "id": 199
},
{
    "data": "  import itertools  import matplotlib.pyplot as plt import numpy as np  import matplotlib.animation as animation   def data_gen():     for cnt in itertools.count():         t = cnt / 10         yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)   def init():     ax.set_ylim(-1.1, 1.1)     ax.set_xlim(0, 1)     del xdata[:]     del ydata[:]     line.set_data(xdata, ydata)     return line,  fig, ax = plt.subplots() line, = ax.plot([], [], lw=2) ax.grid() xdata, ydata = [], []   def run(data):     # update the data     t, y = data     xdata.append(t)     ydata.append(y)     xmin, xmax = ax.get_xlim()      if t >= xmax:         ax.set_xlim(xmin, 2*xmax)         ax.figure.canvas.draw()     line.set_data(xdata, ydata)      return line,  # Only save last 100 frames, but run forever ani = animation.FuncAnimation(fig, run, data_gen, interval=100, init_func=init,                               save_count=100) plt.show()   ",
    "instruction": " To generate an animation with changing axes limits, use the following data:  import itertools  import matplotlib.pyplot as plt import numpy as np  import matplotlib.animation as animation   def data_gen():     for cnt in itertools.count():         t = cnt / 10         yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)           def init():     ax.set_ylim(-1.1, 1.1)     ax.set_xlim(0, 1)     del xdata[:]     del ydata[:]     line.set_data(xdata, ydata)     return line,           fig, ax = plt.subplots() line, = ax.plot([], [], lw=2) ax.grid() xdata, ydata = [], []           def run(data):     # update the data     t, y = data     xdata.append(t)     ydata.append(y)     xmin, xmax = ax.get_xlim()               if t >= xmax:         ax.set_xlim(xmin, 2*xmax)         ax.figure.canvas.draw()     line.set_data(xdata, ydata)               return line,           # Only save last 100 frames, but run forever ani = animation.FuncAnimation(fig, run, data_gen, interval=100, init_func=init,                               save_count=100) plt.show() ",
    "id": 200
},
{
    "data": " np.random.seed(19680801) data = np.random.random((50, 50, 50)), ",
    "instruction": " Use the following data to generate an animation using matplotlib. Create a subplot and iterate through each frame of the data. Clear the axis, show the image of the current frame, and set the title as \"frame {i}\". Pause for 0.1 seconds between each frame to create the animation. ",
    "id": 201
},
{
    "data": "  beta_pdf(x, a, b):     return (x**(a-1) * (1-x)**(b-1) * math.gamma(a + b)              / (math.gamma(a) * math.gamma(b)))  class UpdateDist:     def __init__(self, ax, prob=0.5):         self.success = 0         self.prob = prob         self.line, = ax.plot([], [], 'k-')         self.x = np.linspace(0, 1, 200)         self.ax = ax          # Set up plot parameters         self.ax.set_xlim(0, 1)         self.ax.set_ylim(0, 10)         self.ax.grid(True)          # This vertical line represents the theoretical value, to         # which the plotted distribution should converge.         self.ax.axvline(prob, linestyle='--', color='black')      def __call__(self, i):         # This way the plot can continuously run and we just keep         # watching new realizations of the process         if i == 0:             self.success = 0             self.line.set_data([], [])             return self.line,          # Choose success based on exceed a threshold with a uniform pick         if np.random.rand() < self.prob:             self.success += 1         y = beta_pdf(self.x, self.success + 1, (i - self.success) + 1)         self.line.set_data(self.x, y)         return self.line,  ",
    "instruction": "  Create an animation that displays the posterior estimate updates as it is refitted when new data arrives. The animation should show the convergence of the plotted distribution to a theoretical value. Use the following data and context to create the animation: Data: beta_pdf(x, a, b):     return (x**(a-1) * (1-x)**(b-1) * math.gamma(a + b)              / (math.gamma(a) * math.gamma(b)))  class UpdateDist:     def __init__(self, ax, prob=0.5):         self.success = 0         self.prob = prob         self.line, = ax.plot([], [], 'k-')         self.x = np.linspace(0, 1, 200)         self.ax = ax          # Set up plot parameters         self.ax.set_xlim(0, 1)         self.ax.set_ylim(0, 10)         self.ax.grid(True)          # This vertical line represents the theoretical value, to         # which the plotted distribution should converge.         self.ax.axvline(prob, linestyle='--', color='black')      def __call__(self, i):         # This way the plot can continuously run and we just keep         # watching new realizations of the process         if i == 0:             self.success = 0             self.line.set_data([], [])             return self.line,          # Choose success based on exceed a threshold with a uniform pick         if np.random.rand() < self.prob:             self.success += 1         y = beta_pdf(self.x, self.success + 1, (i - self.success) + 1)         self.line.set_data(self.x, y)         return self.line,  Context: The Bayes update This animation displays the posterior estimate updates as it is refitted when new data arrives. The vertical line represents the theoretical value to which the plotted distribution should converge. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.905 seconds) ",
    "id": 202
},
{
    "data": "  ``` import matplotlib.pyplot as plt import numpy as np from numpy import cos, sin  import matplotlib.animation as animation  G = 9.8  # acceleration due to gravity, in m/s^2 L1 = 1.0  # length of pendulum 1 in m L2 = 1.0  # length of pendulum 2 in m L = L1 + L2  # maximal length of the combined pendulum M1 = 1.0  # mass of pendulum 1 in kg M2 = 1.0  # mass of pendulum 2 in kg t_stop = 2.5  # how many seconds to simulate history_len = 500  # how many trajectory points to display  def derivs(t, state):     dydx = np.zeros_like(state)      dydx[0] = state[1]      delta = state[2] - state[0]     den1 = (M1+M2) * L1 - M2 * L1 * cos(delta) * cos(delta)     dydx[1] = ((M2 * L1 * state[1] * state[1] * sin(delta) * cos(delta)                 + M2 * G * sin(state[2]) * cos(delta)                 + M2 * L2 * state[3] * state[3] * sin(delta)                 - (M1+M2) * G * sin(state[0]))                / den1)      dydx[2] = state[3]      den2 = (L2/L1) * den1     dydx[3] = ((- M2 * L2 * state[3] * state[3] * sin(delta) * cos(delta)                 + (M1+M2) * G * sin(state[0]) * cos(delta)                 - (M1+M2) * L1 * state[1] * state[1] * sin(delta)                 - (M1+M2) * G * sin(state[2]))                / den2)      return dydx  # create a time array from 0..t_stop sampled at 0.02 second steps dt = 0.01 t = np.arange(0, t_stop, dt)  # th1 and th2 are the initial angles (degrees) # w10 and w20 are the initial angular velocities (degrees per second) th1 = 120.0 w1 = 0.0 th2 = -10.0 w2 = 0.0  # initial state state = np.radians([th1, w1, th2, w2])  # integrate the ODE using Euler's method y = np.empty((len(t), 4)) y[0] = state for i in range(1, len(t)):     y[i] = y[i - 1] + derivs(t[i - 1], y[i - 1]) * dt  # A more accurate estimate could be obtained e.g. using scipy: # #   y = scipy.integrate.solve_ivp(derivs, t[[0, -1]], state, t_eval=t).y.T  x1 = L1*sin(y[:, 0]) y1 = -L1*cos(y[:, 0])  x2 = L2*sin(y[:, 2]) + x1 y2 = -L2*cos(y[:, 2]) + y1  fig = plt.figure(figsize=(5, 4)) ax = fig.add_subplot(autoscale_on=False, xlim=(-L, L), ylim=(-L, 1.)) ax.set_aspect('equal') ax.grid()  line, = ax.plot([], [], 'o-', lw=2) trace, = ax.plot([], [], '.-', lw=1, ms=2) time_template = 'time = %.1fs' time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes) history_x, history_y = deque(maxlen=history_len), deque(maxlen=history_len)  def animate(i):     thisx = [0, x1[i], x2[i]]     thisy = [0, y1[i], y2[i]]      if i == 0:         history_x.clear()         history_y.clear()      history_x.appendleft(thisx[2])     history_y.appendleft(thisy[2])      line.set_data(thisx, thisy)     trace.set_data(history_x, history_y)     time_text.set_text(time_template % (i*dt))     return line, trace, time_text  ani = animation.FuncAnimation(     fig, animate, len(y), interval=dt*1000, blit=True) plt.show() ```  ",
    "instruction": " Create an animation of a double pendulum using the provided data. Use the following formulas and parameters to calculate the pendulum motion:  ``` G = 9.8  # acceleration due to gravity, in m/s^2 L1 = 1.0  # length of pendulum 1 in m L2 = 1.0  # length of pendulum 2 in m L = L1 + L2  # maximal length of the combined pendulum M1 = 1.0  # mass of pendulum 1 in kg M2 = 1.0  # mass of pendulum 2 in kg t_stop = 2.5  # how many seconds to simulate history_len = 500  # how many trajectory points to display  def derivs(t, state):     dydx = np.zeros_like(state)      dydx[0] = state[1]      delta = state[2] - state[0]     den1 = (M1+M2) * L1 - M2 * L1 * cos(delta) * cos(delta)     dydx[1] = ((M2 * L1 * state[1] * state[1] * sin(delta) * cos(delta)                 + M2 * G * sin(state[2]) * cos(delta)                 + M2 * L2 * state[3] * state[3] * sin(delta)                 - (M1+M2) * G * sin(state[0]))                / den1)      dydx[2] = state[3]      den2 = (L2/L1) * den1     dydx[3] = ((- M2 * L2 * state[3] * state[3] * sin(delta) * cos(delta)                 + (M1+M2) * G * sin(state[0]) * cos(delta)                 - (M1+M2) * L1 * state[1] * state[1] * sin(delta)                 - (M1+M2) * G * sin(state[2]))                / den2)      return dydx  # create a time array from 0..t_stop sampled at 0.01 second steps dt = 0.01 t = np.arange(0, t_stop, dt)  # th1 and th2 are the initial angles (degrees) # w10 and w20 are the initial angular velocities (degrees per second) th1 = 120.0 w1 = 0.0 th2 = -10.0 w2 = 0.0  # initial state state = np.radians([th1, w1, th2, w2])  # integrate the ODE using Euler's method y = np.empty((len(t), 4)) y[0] = state for i in range(1, len(t)):     y[i] = y[i - 1] + derivs(t[i - 1], y[i - 1]) * dt  x1 = L1*sin(y[:, 0]) y1 = -L1*cos(y[:, 0])  x2 = L2*sin(y[:, 2]) + x1 y2 = -L2*cos(y[:, 2]) + y1  fig = plt.figure(figsize=(5, 4)) ax = fig.add_subplot(autoscale_on=False, xlim=(-L, L), ylim=(-L, 1.)) ax.set_aspect('equal')  ",
    "id": 203
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.animation as animation  fig, ax = plt.subplots()   def f(x, y):     return np.sin(x) + np.cos(y)  x = np.linspace(0, 2 * np.pi, 120) y = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)  # ims is a list of lists, each row is a list of artists to draw in the # current frame; here we are just animating one artist, the image, in # each frame ims = [] for i in range(60):     x += np.pi / 15     y += np.pi / 30     im = ax.imshow(f(x, y), animated=True)     if i == 0:         ax.imshow(f(x, y))  # show an initial one first     ims.append([im])  ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,                                 repeat_delay=1000)  # To save the animation, use e.g. # # ani.save('movie.mp4') # # or # # writer = animation.FFMpegWriter( #     fps=15, metadata=dict(artist='Me'), bitrate=1800) # ani.save('movie.mp4', writer=writer)  plt.show()  ",
    "instruction": " Create an animated image using a precomputed list of images. Use matplotlib.animation.Animation.to_jshtml to generate the output. ",
    "id": 204
},
{
    "data": " np.random.seed(19680801)  metadata = dict(title='Movie Test', artist='Matplotlib',                 comment='Movie support!') writer = FFMpegWriter(fps=15, metadata=metadata)  fig = plt.figure() l, = plt.plot([], [], 'k-o')  plt.xlim(-5, 5) plt.ylim(-5, 5)  x0, y0 = 0, 0  ",
    "instruction": " Create an animation with frame grabbing using matplotlib. Use the following data and settings to generate the animation: np.random.seed(19680801), metadata = dict(title='Movie Test', artist='Matplotlib', comment='Movie support!'), writer = FFMpegWriter(fps=15, metadata=metadata), fig = plt.figure(), l, = plt.plot([], [], 'k-o'), plt.xlim(-5, 5), plt.ylim(-5, 5), x0, y0 = 0, 0. ",
    "id": 205
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.animation as animation from matplotlib.patches import ConnectionPatch  fig, (axl, axr) = plt.subplots(     ncols=2,     sharey=True,     figsize=(6, 2),     gridspec_kw=dict(width_ratios=[1, 3], wspace=0), ) axl.set_aspect(1) axr.set_box_aspect(1 / 3) axr.yaxis.set_visible(False) axr.xaxis.set_ticks([0, np.pi, 2 * np.pi], ['0', r'$\\\\pi$', r'$2\\\\pi$'])  # draw circle with initial point in left Axes x = np.linspace(0, 2 * np.pi, 50) axl.plot(np.cos(x), np.sin(x), 'k', lw=0.3) point, = axl.plot(0, 0, 'o')  # draw full curve to set view limits in right Axes sine, = axr.plot(x, np.sin(x))  # draw connecting line between both graphs con = ConnectionPatch(     (1, 0),     (0, 0),     'data',     'data',     axesA=axl,     axesB=axr,     color='C0',     ls='dotted', ) fig.add_artist(con)   def animate(i):     x = np.linspace(0, i, int(i * 25 / np.pi))     sine.set_data(x, np.sin(x))     x, y = np.cos(i), np.sin(i)     point.set_data([x], [y])     con.xy1 = x, y     con.xy2 = i, y     return point, sine, con   ani = animation.FuncAnimation(     fig,     animate,     interval=50,     blit=False,  # blitting can't be used with Figure artists     frames=x,     repeat_delay=100, )  plt.show()  ",
    "instruction": "  Create a multi-axis animation using matplotlib. Use the following functions, methods, classes, and modules: mpl.animation.FuncAnimation, mpl.patches.ConnectionPatch. The data used in this animation is as follows:  - fig, (axl, axr) = plt.subplots(ncols=2, sharey=True, figsize=(6, 2), gridspec_kw=dict(width_ratios=[1, 3], wspace=0)) - axl.set_aspect(1) - axr.set_box_aspect(1/3) - axr.yaxis.set_visible(False) - axr.xaxis.set_ticks([0, np.pi, 2*np.pi], ['0', r'$\\pi$', r'$2\\pi$']) - x = np.linspace(0, 2*np.pi, 50) - axl.plot(np.cos(x), np.sin(x), 'k', lw=0.3) - point, = axl.plot(0, 0, 'o') - sine, = axr.plot(x, np.sin(x)) - con = ConnectionPatch((1, 0), (0, 0), 'data', 'data', axesA=axl, axesB=axr, color='C0', ls='dotted') - fig.add_artist(con) - def animate(i):         x = np.linspace(0, i, int(i*25/np.pi))         sine.set_data(x, np.sin(x))         x, y = np.cos(i), np.sin(i)         point.set_data([x], [y])         con.xy1 = x, y         con.xy2 = i, y         return point, sine, con - ani = animation.FuncAnimation(fig, animate, interval=50, blit=False, frames=x, repeat_delay=100). ",
    "id": 206
},
{
    "data": "  np.linspace(-0.1, 0.1, 1000) self.n0 = (1.0 / ((4 * np.pi * 2e-4 * 0.1) ** 0.5)                * np.exp(-x ** 2 / (4 * 2e-4 * 0.1))) x = np.linspace(-0.1, 0.1, 1000)  ",
    "instruction": "  To create an animation with a pause/resume functionality, use the following code: import matplotlib.pyplot as plt import numpy as np import matplotlib.animation as animation  class PauseAnimation:     def __init__(self):         fig, ax = plt.subplots()         ax.set_title('Click to pause/resume the animation')         x = np.linspace(-0.1, 0.1, 1000)          # Start with a normal distribution         self.n0 = (1.0 / ((4 * np.pi * 2e-4 * 0.1) ** 0.5)                    * np.exp(-x ** 2 / (4 * 2e-4 * 0.1)))         self.p, = ax.plot(x, self.n0)          self.animation = animation.FuncAnimation(             fig, self.update, frames=200, interval=50, blit=True)         self.paused = False          fig.canvas.mpl_connect('button_press_event', self.toggle_pause)      def toggle_pause(self, *args, **kwargs):         if self.paused:             self.animation.resume()         else:             self.animation.pause()         self.paused = not self.paused      def update(self, i):         self.n0 += i / 100 % 5         self.p.set_ydata(self.n0 % 20)         return (self.p,)   pa = PauseAnimation() plt.show()  Please run this code on your machine to see the interactivity. ",
    "id": 207
},
{
    "data": "  np.random.seed(19680801)  n_drops = 50  rain_drops = np.zeros(n_drops, dtype=[('position', float, (2,)),                                       ('size',     float),                                       ('growth',   float),                                       ('color',    float, (4,))])  rain_drops['position'] = np.random.uniform(0, 1, (n_drops, 2)) rain_drops['growth'] = np.random.uniform(50, 200, n_drops)  fig = plt.figure(figsize=(7, 7)) ax = fig.add_axes([0, 0, 1, 1], frameon=False) ax.set_xlim(0, 1) ax.set_xticks([]) ax.set_ylim(0, 1) ax.set_yticks([])  scat = ax.scatter(rain_drops['position'][:, 0], rain_drops['position'][:, 1],                   s=rain_drops['size'], lw=0.5, edgecolors=rain_drops['color'],                   facecolors='none')  def update(frame_number):     current_index = frame_number % n_drops      rain_drops['color'][:, 3] -= 1.0/len(rain_drops)     rain_drops['color'][:, 3] = np.clip(rain_drops['color'][:, 3], 0, 1)      rain_drops['size'] += rain_drops['growth']      rain_drops['position'][current_index] = np.random.uniform(0, 1, 2)     rain_drops['size'][current_index] = 5     rain_drops['color'][current_index] = (0, 0, 0, 1)     rain_drops['growth'][current_index] = np.random.uniform(50, 200)      scat.set_edgecolors(rain_drops['color'])     scat.set_sizes(rain_drops['size'])     scat.set_offsets(rain_drops['position'])  animation = FuncAnimation(fig, update, interval=10, save_count=100)  ",
    "instruction": " Create a rain simulation using matplotlib.animation.FuncAnimation. Use the provided data to initialize the rain drops, scatter plot, and animation. ",
    "id": 208
},
{
    "data": "  np.random.seed(19680801)  def random_walk(num_steps, max_step=0.05):     '''Return a 3D random walk as (num_steps, 3) array.'''     start_pos = np.random.random(3)     steps = np.random.uniform(-max_step, max_step, size=(num_steps, 3))     walk = start_pos + np.cumsum(steps, axis=0)     return walk   # Data: 40 random walks as (num_steps, 3) arrays num_steps = 30 walks = [random_walk(num_steps) for index in range(40)]  # Attaching 3D axis to the figure fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Create lines initially without data lines = [ax.plot([], [], [])[0] for _ in walks]  # Setting the axes properties ax.set(xlim3d=(0, 1), xlabel='X') ax.set(ylim3d=(0, 1), ylabel='Y') ax.set(zlim3d=(0, 1), zlabel='Z')  # Creating the Animation object ani = animation.FuncAnimation(     fig, update_lines, num_steps, fargs=(walks, lines), interval=100)  plt.show()  ",
    "instruction": " Create an animated 3D random walk using matplotlib. Use the following data to generate the animation:  np.random.seed(19680801)  def random_walk(num_steps, max_step=0.05):     '''Return a 3D random walk as (num_steps, 3) array.'''     start_pos = np.random.random(3)     steps = np.random.uniform(-max_step, max_step, size=(num_steps, 3))     walk = start_pos + np.cumsum(steps, axis=0)     return walk  # Data: 40 random walks as (num_steps, 3) arrays num_steps = 30 walks = [random_walk(num_steps) for index in range(40)]  Attach a 3D axis to the figure and set the axes properties as follows:  ax.set(xlim3d=(0, 1), xlabel='X') ax.set(ylim3d=(0, 1), ylabel='Y') ax.set(zlim3d=(0, 1), zlabel='Z')  Finally, create an animation object using the above-defined function and display the animation using plt.show(). ",
    "id": 209
},
{
    "data": "  x = np.arange(0, 2*np.pi, 0.01)  ",
    "instruction": "  To create an animated line plot using matplotlib, follow these steps: 1. Import the necessary libraries:     import matplotlib.pyplot as plt    import numpy as np    import matplotlib.animation as animation  2. Create a figure and an axis object:    fig, ax = plt.subplots()  3. Define the initial line plot:    line, = ax.plot(x, np.sin(x))  4. Define the animation function:    def animate(i):        line.set_ydata(np.sin(x + i / 50))  # update the data.        return line,  5. Create the animation object:    ani = animation.FuncAnimation(fig, animate, interval=20, blit=True, save_count=50)  6. Show the animation:    plt.show()  Note: You can save the animation as a video by using the `ani.save()` method. ",
    "id": 210
},
{
    "data": "  x = np.linspace(0, 10)  ",
    "instruction": "  To generate an animated scatter plot, use the following code snippet:  ```python import matplotlib.pyplot as plt import numpy as np  import matplotlib.animation as animation  fig, ax = plt.subplots() ax.set_xlim([0, 10])  scat = ax.scatter(1, 0) x = np.linspace(0, 10)   def animate(i):     scat.set_offsets((x[i], 0))     return scat,  ani = animation.FuncAnimation(fig, animate, repeat=True,                                 frames=len(x) - 1, interval=50)  plt.show() ```  The plot will be an animated scatter plot where the scatter point moves horizontally along the x-axis. ",
    "id": 211
},
{
    "data": "  np.random.seed(19680801 // 10)  class Scope:     def __init__(self, ax, maxt=2, dt=0.02):         self.ax = ax         self.dt = dt         self.maxt = maxt         self.tdata = [0]         self.ydata = [0]         self.line = Line2D(self.tdata, self.ydata)         self.ax.add_line(self.line)         self.ax.set_ylim(-.1, 1.1)         self.ax.set_xlim(0, self.maxt)      def update(self, y):         lastt = self.tdata[-1]         if lastt >= self.tdata[0] + self.maxt:  # reset the arrays             self.tdata = [self.tdata[-1]]             self.ydata = [self.ydata[-1]]             self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)             self.ax.figure.canvas.draw()          t = self.tdata[0] + len(self.tdata) * self.dt          self.tdata.append(t)         self.ydata.append(y)         self.line.set_data(self.tdata, self.ydata)         return self.line,   def emitter(p=0.1):     '''Return a random value in [0, 1) with probability p, else 0.'''     while True:         v = np.random.rand()         if v > p:             yield 0.         else:             yield np.random.rand()   fig, ax = plt.subplots() scope = Scope(ax) ani = animation.FuncAnimation(fig, scope.update, emitter, interval=50,                               blit=True, save_count=100)  ",
    "instruction": "  To emulate an oscilloscope, use the given code snippet. Use the following data:  ``` np.random.seed(19680801 // 10)  class Scope:     def __init__(self, ax, maxt=2, dt=0.02):         self.ax = ax         self.dt = dt         self.maxt = maxt         self.tdata = [0]         self.ydata = [0]         self.line = Line2D(self.tdata, self.ydata)         self.ax.add_line(self.line)         self.ax.set_ylim(-.1, 1.1)         self.ax.set_xlim(0, self.maxt)      def update(self, y):         lastt = self.tdata[-1]         if lastt >= self.tdata[0] + self.maxt:  # reset the arrays             self.tdata = [self.tdata[-1]]             self.ydata = [self.ydata[-1]]             self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)             self.ax.figure.canvas.draw()          t = self.tdata[0] + len(self.tdata) * self.dt          self.tdata.append(t)         self.ydata.append(y)         self.line.set_data(self.tdata, self.ydata)         return self.line,   def emitter(p=0.1):     '''Return a random value in [0, 1) with probability p, else 0.'''     while True:         v = np.random.rand()         if v > p:             yield 0.         else:             yield np.random.rand()   fig, ax = plt.subplots() scope = Scope(ax) ani = animation.FuncAnimation(fig, scope.update, emitter, interval=50,                               blit=True, save_count=100) ```  This code will create an animation that emulates an oscilloscope. ",
    "id": 212
},
{
    "data": " import matplotlib.pyplot as plt import numpy as np  import matplotlib.animation as animation  # Fixing random state for reproducibility np.random.seed(19680801)   # Create new Figure with black background fig = plt.figure(figsize=(8, 8), facecolor='black')  # Add a subplot with no frame ax = plt.subplot(frameon=False)  # Generate random data data = np.random.uniform(0, 1, (64, 75)) X = np.linspace(-1, 1, data.shape[-1]) G = 1.5 * np.exp(-4 * X ** 2)  # Generate line plots lines = [] for i in range(len(data)):     # Small reduction of the X extents to get a cheap perspective effect     xscale = 1 - i / 200.     # Same for linewidth (thicker strokes on bottom)     lw = 1.5 - i / 100.0     line, = ax.plot(xscale * X, i + G * data[i], color='w', lw=lw)     lines.append(line)  # Set y limit (or first line is cropped because of thickness) ax.set_ylim(-1, 70)  # No ticks ax.set_xticks([]) ax.set_yticks([])  # 2 part titles to get different font weights ax.text(0.5, 1.0, 'MATPLOTLIB ', transform=ax.transAxes,         ha='right', va='bottom', color='w',         family='sans-serif', fontweight='light', fontsize=16) ax.text(0.5, 1.0, 'UNCHAINED', transform=ax.transAxes,         ha='left', va='bottom', color='w',         family='sans-serif', fontweight='bold', fontsize=16)   def update(*args):     # Shift all data to the right     data[:, 1:] = data[:, :-1]      # Fill-in new values     data[:, 0] = np.random.uniform(0, 1, len(data))      # Update data     for i in range(len(data)):         lines[i].set_ydata(i + G * data[i])      # Return modified artists     return lines  # Construct the animation, using the update function as the animation director. anim = animation.FuncAnimation(fig, update, interval=10, save_count=100) plt.show()  ",
    "instruction": " Create an animation plot using the matplotlib library. Use the following data to plot it: np.random.seed(19680801) data = np.random.uniform(0, 1, (64, 75)) X = np.linspace(-1, 1, data.shape[-1]) G = 1.5 * np.exp(-4 * X ** 2) lines = []  Set the y limit to (-1, 70) and remove the ticks. Add two titles with different font weights: 'MATPLOTLIB UNCHAINED'. Use the update function to shift the data to the right, fill in new values, and update the plots with modified artists. The animation should have an interval of 10 and a save count of 100. ",
    "id": 213
},
{
    "data": " No data preparation blocks found in the provided code.  ",
    "instruction": " Create a matplotlib figure and connect a close event to it. When the figure is closed, it should print 'Closed Figure!' to the console. Display the text 'Close Me!' at coordinates (0.35, 0.5) with a text size of 30. ",
    "id": 214
},
{
    "data": " t = np.arange(0.0, 1.0, 0.01) s = np.sin(2 * np.pi * t)  ",
    "instruction": " Create a plot using matplotlib. Use the following data to plot it: t = np.arange(0.0, 1.0, 0.01), s = np.sin(2 * np.pi * t). Bind the 'motion_notify_event' to the function 'on_move' and the 'button_press_event' to the function 'on_click'. ",
    "id": 215
},
{
    "data": " np.random.seed(19680801)  X = np.random.rand(100, 200) xs = np.mean(X, axis=1) ys = np.std(X, axis=1) import matplotlib.pyplot as plt  class PointBrowser:     '''     Click on a point to select and highlight it -- the data that     generated the point will be shown in the lower axes.  Use the 'n'     and 'p' keys to browse through the next and previous points     '''      def __init__(self):         self.lastind = 0          self.text = ax.text(0.05, 0.95, 'selected: none',                             transform=ax.transAxes, va='top')         self.selected, = ax.plot([xs[0]], [ys[0]], 'o', ms=12, alpha=0.4,                                  color='yellow', visible=False)      def on_press(self, event):         if self.lastind is None:             return         if event.key not in ('n', 'p'):             return         if event.key == 'n':             inc = 1         else:             inc = -1          self.lastind += inc         self.lastind = np.clip(self.lastind, 0, len(xs) - 1)         self.update()      def on_pick(self, event):          if event.artist != line:             return True          N = len(event.ind)         if not N:             return True          # the click locations         x = event.mouseevent.xdata         y = event.mouseevent.ydata          distances = np.hypot(x - xs[event.ind], y - ys[event.ind])         indmin = distances.argmin()         dataind = event.ind[indmin]          self.lastind = dataind         self.update()      def update(self):         if self.lastind is None:             return          dataind = self.lastind          ax2.clear()         ax2.plot(X[dataind])          ax2.text(0.05, 0.9, f'mu={xs[dataind]:1.3f}\\nsigma={ys[dataind]:1.3f}',                  transform=ax2.transAxes, va='top')         ax2.set_ylim(-0.5, 1.5)         self.selected.set_visible(True)         self.selected.set_data(xs[dataind], ys[dataind])          self.text.set_text('selected: %d' % dataind)         fig.canvas.draw()   if __name__ == '__main__':     fig, (ax, ax2) = plt.subplots(2, 1)     ax.set_title('click on point to plot time series')     line, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)      browser = PointBrowser()      fig.canvas.mpl_connect('pick_event', browser.on_pick)     fig.canvas.mpl_connect('key_press_event', browser.on_press)      plt.show() ",
    "instruction": " Create a data browser using matplotlib. The browser should have two subplots: one for selecting and highlighting a point, and another for displaying the data of the selected point. The selected point should be highlighted with a yellow circle. Use the following data to create the browser: np.random.seed(19680801), X = np.random.rand(100, 200), xs = np.mean(X, axis=1), ys = np.std(X, axis=1). ",
    "id": 216
},
{
    "data": " import matplotlib.pyplot as plt   def on_enter_axes(event):     print('enter_axes', event.inaxes)     event.inaxes.patch.set_facecolor('yellow')     event.canvas.draw()   def on_leave_axes(event):     print('leave_axes', event.inaxes)     event.inaxes.patch.set_facecolor('white')     event.canvas.draw()   def on_enter_figure(event):     print('enter_figure', event.canvas.figure)     event.canvas.figure.patch.set_facecolor('red')     event.canvas.draw()   def on_leave_figure(event):     print('leave_figure', event.canvas.figure)     event.canvas.figure.patch.set_facecolor('grey')     event.canvas.draw()   fig, axs = plt.subplots(2, 1) fig.suptitle('mouse hover over figure or axes to trigger events')  fig.canvas.mpl_connect('figure_enter_event', on_enter_figure) fig.canvas.mpl_connect('figure_leave_event', on_leave_figure) fig.canvas.mpl_connect('axes_enter_event', on_enter_axes) fig.canvas.mpl_connect('axes_leave_event', on_leave_axes)  plt.show()  ",
    "instruction": " Create a matplotlib plot with 2 subplots. Implement the following events: - When the mouse enters an axes area, print 'enter_axes' and change the facecolor of the axes to yellow. - When the mouse leaves an axes area, print 'leave_axes' and change the facecolor of the axes to white. - When the mouse enters the figure, print 'enter_figure' and change the facecolor of the figure to red. - When the mouse leaves the figure, print 'leave_figure' and change the facecolor of the figure to grey.  Note: This code demonstrates the interactive capabilities of Matplotlib and requires running the code locally to see the interactivity. ",
    "id": 217
},
{
    "data": " x, y, z = np.ogrid[-10:10:100j, -10:10:100j, 1:10:20j] X = np.sin(x * y * z) / (x * y * z)  ",
    "instruction": " Create a 3D plot using matplotlib. Use the following data to plot it: x, y, z = np.ogrid[-10:10:100j, -10:10:100j, 1:10:20j], X = np.sin(x * y * z) / (x * y * z). ",
    "id": 218
},
{
    "data": " np.random.seed(19680801)  ",
    "instruction": " Use the following data to create a plot with keypress event functionality. The plot should display 12 random points plotted as green circles. Add an x-axis label with the text \"easy come, easy go\" and a title with the text \"Press a key\". When a key is pressed, the x-axis label should toggle its visibility. ",
    "id": 219
},
{
    "data": " np.random.seed(19680801) ax = plt.figure().add_subplot(     xlim=(0, 1), ylim=(0, 1), title='Lasso points using left mouse button') manager = LassoManager(ax, np.random.rand(100, 2))  ",
    "instruction": " To create a Lasso Demo plot, use the following code snippet:  import matplotlib.pyplot as plt import numpy as np from matplotlib import colors as mcolors from matplotlib import path from matplotlib.collections import RegularPolyCollection from matplotlib.widgets import Lasso  class LassoManager:     def __init__(self, ax, data):         self.collection = RegularPolyCollection(             6, sizes=(100,), offset_transform=ax.transData,             offsets=data, array=np.zeros(len(data)),             clim=(0, 1), cmap=mcolors.ListedColormap(['tab:blue', 'tab:red']))         ax.add_collection(self.collection)         canvas = ax.figure.canvas         canvas.mpl_connect('button_press_event', self.on_press)         canvas.mpl_connect('button_release_event', self.on_release)      def callback(self, verts):         data = self.collection.get_offsets()         self.collection.set_array(path.Path(verts).contains_points(data))         canvas = self.collection.figure.canvas         canvas.draw_idle()         del self.lasso      def on_press(self, event):         canvas = self.collection.figure.canvas         if event.inaxes is not self.collection.axes or canvas.widgetlock.locked():             return         self.lasso = Lasso(event.inaxes, (event.xdata, event.ydata), self.callback)         canvas.widgetlock(self.lasso)      def on_release(self, event):         canvas = self.collection.figure.canvas         if hasattr(self, 'lasso') and canvas.widgetlock.isowner(self.lasso):             canvas.widgetlock.release(self.lasso)   if __name__ == '__main__':     np.random.seed(19680801)     ax = plt.figure().add_subplot(         xlim=(0, 1), ylim=(0, 1), title='Lasso points using left mouse button')     manager = LassoManager(ax, np.random.rand(100, 2))     plt.show()  This code snippet demonstrates how to use a lasso to select a set of points and get the indices of the selected points in a plot titled \"Lasso points using left mouse button\". The code uses the Lasso class from matplotlib.widgets to enable interactive selection of points. The selected points are indicated by changing their color to red. Please ensure that you run the code on your machine to see the interactive functionality. ",
    "id": 220
},
{
    "data": " t = np.linspace(0, 1) y1 = 2 * np.sin(2*np.pi*t) y2 = 4 * np.sin(2*np.pi*2*t)  ",
    "instruction": " Create a plot with two lines, one with a frequency of 1 Hz and the other with a frequency of 2 Hz. Add a legend to the plot that allows the user to toggle the visibility of each line by clicking on it. ",
    "id": 221
},
{
    "data": "  np.random.seed(19680801)  x, y = np.random.rand(2, 200)  fig, ax = plt.subplots() circ = patches.Circle((0.5, 0.5), 0.25, alpha=0.8, fc='yellow') ax.add_patch(circ)  ax.plot(x, y, alpha=0.2) line, = ax.plot(x, y, alpha=1.0, clip_path=circ) ax.set_title('Left click and drag to move looking glass')   class EventHandler:     def __init__(self):         fig.canvas.mpl_connect('button_press_event', self.on_press)         fig.canvas.mpl_connect('button_release_event', self.on_release)         fig.canvas.mpl_connect('motion_notify_event', self.on_move)         self.x0, self.y0 = circ.center         self.pressevent = None      def on_press(self, event):         if event.inaxes != ax:             return          if not circ.contains(event)[0]:             return          self.pressevent = event      def on_release(self, event):         self.pressevent = None         self.x0, self.y0 = circ.center      def on_move(self, event):         if self.pressevent is None or event.inaxes != self.pressevent.inaxes:             return          dx = event.xdata - self.pressevent.xdata         dy = event.ydata - self.pressevent.ydata         circ.center = self.x0 + dx, self.y0 + dy         line.set_clip_path(circ)         fig.canvas.draw()  handler = EventHandler() plt.show()  ",
    "instruction": " Use the following data to create an interactive plot of a looking glass example. This example simulates a looking glass for inspecting data. Run the code on your machine to see the interactivity. ",
    "id": 222
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  from matplotlib.backend_bases import MouseButton from matplotlib.patches import PathPatch from matplotlib.path import Path  fig, ax = plt.subplots()  pathdata = [     (Path.MOVETO, (1.58, -2.57)),     (Path.CURVE4, (0.35, -1.1)),     (Path.CURVE4, (-1.75, 2.0)),     (Path.CURVE4, (0.375, 2.0)),     (Path.LINETO, (0.85, 1.15)),     (Path.CURVE4, (2.2, 3.2)),     (Path.CURVE4, (3, 0.05)),     (Path.CURVE4, (2.0, -0.5)),     (Path.CLOSEPOLY, (1.58, -2.57)), ]  codes, verts = zip(*pathdata) path = Path(verts, codes) patch = PathPatch(     path, facecolor='green', edgecolor='yellow', alpha=0.5) ax.add_patch(patch)   class PathInteractor:     '''     A path editor.      Press 't' to toggle vertex markers on and off.  When vertex markers are on,     they can be dragged with the mouse.     '''      showverts = True     epsilon = 5  # max pixel distance to count as a vertex hit      def __init__(self, pathpatch):          self.ax = pathpatch.axes         canvas = self.ax.figure.canvas         self.pathpatch = pathpatch         self.pathpatch.set_animated(True)          x, y = zip(*self.pathpatch.get_path().vertices)          self.line, = ax.plot(             x, y, marker='o', markerfacecolor='r', animated=True)          self._ind = None  # the active vertex          canvas.mpl_connect('draw_event', self.on_draw)         canvas.mpl_connect('button_press_event', self.on_button_press)         canvas.mpl_connect('key_press_event', self.on_key_press)         canvas.mpl_connect('button_release_event', self.on_button_release)         canvas.mpl_connect('motion_notify_event', self.on_mouse_move)         self.canvas = canvas      def get_ind_under_point(self, event):         '''         Return the index of the point closest to the event position or *None*         if no point is within ``self.epsilon`` to the event position.         '''         xy = self.pathpatch.get_path().vertices         xyt = self.pathpatch.get_transform().transform(xy)  # to display coords         xt, yt = xyt[:, 0], xyt[:, 1]         d = np.sqrt((xt - event.x)**2 + (yt - event.y)**2)         ind = d.argmin()         return ind if d[ind] < self.epsilon else None      def on_draw(self, event):         '''Callback for draws.'''         self.background = self.canvas.copy_from_bbox(self.ax.bbox)         self.ax.draw_artist(self.pathpatch)         self.ax.draw_artist(self.line)         self.canvas.blit(self.ax.bbox)      def on_button_press(self, event):         '''Callback for mouse button presses.'''         if (event.inaxes is None                 or event.button != MouseButton.LEFT                 or not self.showverts):             return         self._ind = self.get_ind_under_point(event)      def on_button_release(self, event):         '''Callback for mouse button releases.'''         if (event.button != MouseButton.LEFT                 or not self.showverts):             return         self._ind = None      def on_key_press(self, event):         '''Callback for key presses.'''         if not event.inaxes:             return         if event.key == 't':             self.showverts = not self.showverts             self.line.set_visible(self.showverts)             if not self.showverts:                 self._ind = None         self.canvas.draw()      def on_mouse_move(self, event):         '''Callback for mouse movements.'''         if (self._ind is None                 or event.inaxes is None                 or event.button != MouseButton.LEFT                 or not self.showverts):             return          vertices = self.pathpatch.get_path().vertices          vertices[self._ind] = event.xdata, event.ydata         self.line.set_data(zip(*vertices))          self.canvas.restore_region(self.background)         self.ax.draw_artist(self.pathpatch)         self.ax.draw_artist(self.line)         self.canvas.blit(self.ax.bbox)   interactor = PathInteractor(patch) ax.set_title('drag vertices to update path') ax.set_xlim(-3, 4) ax.set_ylim(-3, 4)  plt.show()  ",
    "instruction": "  Create a path editor using matplotlib. Use the provided pathdata to define the path and patch. Add the patch to the plot. Create a class called PathInteractor with the following functionalities: dragging vertex markers, pressing 't' to toggle vertex markers on and off, and updating the path when vertices are moved. Connect the appropriate event handlers to enable the interactivity. Set the title of the plot to 'drag vertices to update path' and set the x and y limits of the plot to (-3, 4). ",
    "id": 223
},
{
    "data": " np.random.seed(19680801)  X = np.random.rand(100, 1000) xs = np.mean(X, axis=1) ys = np.std(X, axis=1)  ",
    "instruction": " Create a scatter plot with the title \"click on point to plot time series\". Use the following data to plot the scatter plot: X, xs, ys. Implement interactivity such that when you click on one of the points, raw data from the corresponding dataset is plotted. ",
    "id": 224
},

{
    "data": "[DATA]:  np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  [INSTRUCTION]:  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  ---  [DATA]:  species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), } width = 0.5  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adelie\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\mu=5076.02g$\"), weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.  ---  [DATA]:  No data preparation blocks found in the provided code. ",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 225
},
{
    "data": "[DATA]: import time  import matplotlib.pyplot as plt import numpy as np from numpy.random import randint, randn  from matplotlib.font_manager import FontProperties  instructions = ''' Player A:       Player B:   'e'      up     'i'   'd'     down    ' ",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 226
},
{
    "data": "  xdata = np.linspace(16, 365, (365-16)*4) ydata = np.sin(2*np.pi*xdata/153) + np.cos(2*np.pi*xdata/127)  ",
    "instruction": "  Create a plot using matplotlib to display the signal data. Use the following data to plot the signal: xdata = np.linspace(16, 365, (365-16)*4), ydata = np.sin(2*np.pi*xdata/153) + np.cos(2*np.pi*xdata/127). Implement the class `DataDisplayDownsampler` to downsample the data and recompute when zoomed. Use the method `downsample` to downsample the data within the view range. Finally, use the method `update` to update the plot when the view limits are changed by connecting it to the `xlim_changed` event. ",
    "id": 227
},
{
    "data": "  from datetime import datetime  import matplotlib.pyplot as plt import numpy as np   def update_title(axes):     axes.set_title(datetime.now())     axes.figure.canvas.draw()  fig, ax = plt.subplots()  x = np.linspace(-3, 3) ax.plot(x, x ** 2)  # Create a new timer object. Set the interval to 100 milliseconds # (1000 is default) and tell the timer what function should be called. timer = fig.canvas.new_timer(interval=100) timer.add_callback(update_title, ax) timer.start()  # Or could start the timer on first figure draw: # def start_timer(event): #     timer.start() #     fig.canvas.mpl_disconnect(drawid) # drawid = fig.canvas.mpl_connect('draw_event', start_timer)  ",
    "instruction": "  Create a plot using matplotlib with the following instructions: - Plot the function x squared. - Use the current time as the title of the plot. - Set a timer to update the title of the plot every 100 milliseconds.  Please run this code on your machine to see the interactivity. ",
    "id": 228
},
{
    "data": "",
    "instruction": " Create a plot with a triangulation and highlight the triangle under the cursor with a yellow polygon. Set up callbacks to update the highlighted triangle and display its index in the plot title when the mouse is moved over the triangulation.**  The relevant data for generating the code is:  **[DATA]:** ``` n_angles = 16 n_radii = 5 min_radius = 0.25 radii = np.linspace(min_radius, 0.95, n_radii) angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() triang = Triangulation(x, y) triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),                          y[triang.triangles].mean(axis=1))                 < min_radius)  polygon = Polygon([[0, 0], [0, 0]], facecolor='y') ```   ",
    "id": 229
},
{
    "data": "  np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:  np.random.seed(20230930),  t = np.arange(0.0, 10.0, 0.2),  s = np.exp(-t) + np.sin(2 * np.pi * t) + 1,  nse = np.random.normal(0.0, 0.5, t.shape) * s.  ---  [DATA]:  species = ( \"Adelie\\n $\\\\\\\\\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\\\\\\\\\mu=5076.02g$\")  weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it:  species = ( \"Adelie\\n $\\\\\\\\\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\\\\\\\\\mu=5076.02g$\"),  weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.  ---  [DATA]: No data preparation block found.  [INSTRUCTION]:  Please run the provided code to see the interactive capabilities of Matplotlib in action. ",
    "id": 230
},
{
    "data": " np.random.seed(19680801)  x, y, s, c = np.random.rand(4, 200) s *= 200  ",
    "instruction": " Create two subplots with a scatter plot in each. Set the limits of the first subplot to (0, 1) on both x and y axes, and set the limits of the second subplot to (0.45, 0.55) on the x axis and (0.4, 0.6) on the y axis. Use the following data to create the scatter plots: np.random.seed(19680801), x, y, s, c = np.random.rand(4, 200), s *= 200. Connect a mouse press event in the first subplot to adjust the limits of the second subplot based on the clicked point. ",
    "id": 231
},
{
    "data": "  from matplotlib import pyplot as plt from matplotlib.lines import Line2D from matplotlib.offsetbox import (AnchoredOffsetbox, AuxTransformBox,                                   DrawingArea, TextArea, VPacker) from matplotlib.patches import Circle, Ellipse   def draw_text(ax):     '''Draw a text-box anchored to the upper-left corner of the figure.'''     box = AnchoredOffsetbox(child=TextArea('Figure 1a'),                             loc='upper left', frameon=True)     box.patch.set_boxstyle('round,pad=0.,rounding_size=0.2')     ax.add_artist(box)   def draw_circles(ax):     '''Draw circles in axes coordinates.'''     area = DrawingArea(width=40, height=20)     area.add_artist(Circle((10, 10), 10, fc='tab:blue'))     area.add_artist(Circle((30, 10), 5, fc='tab:red'))     box = AnchoredOffsetbox(         child=area, loc='upper right', pad=0, frameon=False)     ax.add_artist(box)   def draw_ellipse(ax):     '''Draw an ellipse of width=0.1, height=0.15 in data coordinates.'''     aux_tr_box = AuxTransformBox(ax.transData)     aux_tr_box.add_artist(Ellipse((0, 0), width=0.1, height=0.15))     box = AnchoredOffsetbox(child=aux_tr_box, loc='lower left', frameon=True)     ax.add_artist(box)   def draw_sizebar(ax):     '''     Draw a horizontal bar with length of 0.1 in data coordinates,     with a fixed label center-aligned underneath.     '''     size = 0.1     text = r'1$^{\\prime}$'     sizebar = AuxTransformBox(ax.transData)     sizebar.add_artist(Line2D([0, size], [0, 0], color='black'))     text = TextArea(text)     packer = VPacker(         children=[sizebar, text], align='center', sep=5)  # separation in points.     ax.add_artist(AnchoredOffsetbox(         child=packer, loc='lower center', frameon=False,         pad=0.1, borderpad=0.5))  # paddings relative to the legend fontsize.   fig, ax = plt.subplots() ax.set_aspect(1)  draw_text(ax) draw_circles(ax) draw_ellipse(ax) draw_sizebar(ax)  plt.show()  ",
    "instruction": "  Create a figure with matplotlib. Use the following functions to add anchored artists to the figure: draw_text(), draw_circles(), draw_ellipse(), draw_sizebar(). The example demonstrates the use of anchored objects without the mpl_toolkits.axes_grid1 toolkit. ",
    "id": 232
},
{
    "data": " np.random.seed(19680801)  left, bottom, width, height = (-1, -1, 2, 2) rect = plt.Rectangle((left, bottom), width, height,                      facecolor='black', alpha=0.1)  bbox = Bbox.from_bounds(left, bottom, width, height)  for i in range(12):     vertices = (np.random.random((2, 2)) - 0.5) * 6.0     path = Path(vertices)     if path.intersects_bbox(bbox):         color = 'r'     else:         color = 'b'     ax.plot(vertices[:, 0], vertices[:, 1], color=color)       ",
    "instruction": " Create a plot where the lines intersecting a rectangle are colored in red, while the others are left as blue lines. Use the matplotlib functions `Rectangle`, `Bbox`, `Path`, and `intersects_bbox` to generate the plot. The data required for the plot is as follows: `np.random.seed(19680801)`, `left, bottom, width, height = (-1, -1, 2, 2)`, and `vertices = (np.random.random((2, 2)) - 0.5) * 6.0` within a loop that iterates 12 times. ",
    "id": 233
},
{
    "data": " np.random.seed(19680801)  x = np.random.rand(20) y = 1e7 * np.random.rand(20)  ",
    "instruction": " Use the following data to create a scatter plot using matplotlib:  np.random.seed(19680801) x = np.random.rand(20) y = 1e7 * np.random.rand(20). ",
    "id": 234
},
{
    "data": "THIS DATA IS TOO LONG FOR GPT-3.5's CONTEXT WINDOW",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 235
},
{
    "data": "  - np.random.seed(20230930) - t = np.arange(0.0, 10.0, 0.2) - s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 - nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  To create two plots, a vertical lines demo plot, and a horizontal lines demo plot, use the following functions from matplotlib: hlines and vlines. Use the following data to create the plots: - np.random.seed(20230930) - t = np.arange(0.0, 10.0, 0.2) - s = np.exp(-t ",
    "id": 236
},
{
    "data": "  np.random, plt, np, t, s, np.exp, np.pi, nse, fig, vax, hax  ",
    "instruction": "  To create a figure with two subplots, you can use the `subplots` function from matplotlib. Set the `figsize` parameter to (12, 6) to adjust the size of the figure. Then, you can plot the vertical lines using the `plot` function on the `vax` subplot and the horizontal lines using the `plot` function on the `hax` subplot. To add the vertical lines, use the `vlines` function on the `vax` subplot. Set the x-coordinates to `t`, the y-coordinates to `[0]`, and the line colors to `'r'`. To add the horizontal lines, use the `hlines` function on the `hax` subplot. Set the y-coordinates to `t`, the x-coordinates to `[0]`, and the line widths to `2`. Finally, set the x-label and title for both subplots using the `set_xlabel` and `set_title` functions. To display the figure, use the `show` function. ",
    "id": 237
},
{
    "data": "  import matplotlib.pyplot as plt  import matplotlib.lines as lines  ",
    "instruction": "  To create a figure in matplotlib, use the `plt.figure()` function. Then, use the `fig.add_artist()` function to add lines to the figure. For example, to add a line from coordinates (0,0) to (1,1), use `fig.add_artist(lines.Line2D([0, 1], [0, 1]))`. Similarly, to add a line from coordinates (0,1) to (1,0), use `fig.add_artist(lines.Line2D([0, 1], [1, 0]))`. Finally, use `plt.show()` to display the figure. ",
    "id": 238
},
{
    "data": " theta = np.arange(0, 8*np.pi, 0.1) a = 1 b = .2  for dt in np.arange(0, 2*np.pi, np.pi/2.0):      x = a*np.cos(theta + dt)*np.exp(b*theta)     y = a*np.sin(theta + dt)*np.exp(b*theta)      dt = dt + np.pi/4.0      x2 = a*np.cos(theta + dt)*np.exp(b*theta)     y2 = a*np.sin(theta + dt)*np.exp(b*theta)      xf = np.concatenate((x, x2[::-1]))     yf = np.concatenate((y, y2[::-1]))      p1 = plt.fill(xf, yf) ",
    "instruction": " Use matplotlib to create a fill spiral plot. Use the following data to generate the plot: theta = np.arange(0, 8*np.pi, 0.1), a = 1, b = .2. ",
    "id": 239
},
{
    "data": " a = np.arange(0, 3, .02) b = np.arange(0, 3, .02) c = np.exp(a) d = c[::-1] ",
    "instruction": " Generate a plot showing the minimum message length. Use the following data: a = np.arange(0, 3, .02), b = np.arange(0, 3, .02), c = np.exp(a), d = c[::-1]. ",
    "id": 240
},
{
    "data": "  parser = ArgumentParser(description='Build thumbnails of all images in a directory.') parser.add_argument('imagedir', type=Path) args = parser.parse_args() if not args.imagedir.is_dir():     sys.exit(f'Could not find input directory {args.imagedir}')  outdir = Path('thumbs') outdir.mkdir(parents=True, exist_ok=True)  for path in args.imagedir.glob('*.png'):     outpath = outdir / path.name     fig = image.thumbnail(path, outpath, scale=0.15)     print(f'saved thumbnail of {path} to {outpath}')  ",
    "instruction": "  Use the following data to generate thumbnails for all images in a directory using Matplotlib: parser = ArgumentParser(description='Build thumbnails of all images in a directory.') parser.add_argument('imagedir', type=Path) args = parser.parse_args() if not args.imagedir.is_dir():     sys.exit(f'Could not find input directory {args.imagedir}')  outdir = Path('thumbs') outdir.mkdir(parents=True, exist_ok=True)  for path in args.imagedir.glob('*.png'):     outpath = outdir / path.name     fig = image.thumbnail(path, outpath, scale=0.15)     print(f'saved thumbnail of {path} to {outpath}') ",
    "id": 241
},
{
    "data": "  np.random.seed(19680801)  data = {'a': np.arange(50),         'c': np.random.randint(0, 50, 50),         'd': np.random.randn(50)} data['b'] = data['a'] + 10 * np.random.randn(50) data['d'] = np.abs(data['d']) * 100  ",
    "instruction": "  To generate a scatter plot using matplotlib, use the following data:  np.random.seed(19680801),  data = {'a': np.arange(50),         'c': np.random.randint(0, 50, 50),         'd': np.random.randn(50)} data['b'] = data['a'] + 10 * np.random.randn(50) data['d'] = np.abs(data['d']) * 100. The scatter plot should have 'a' on the x-axis, 'b' on the y-axis, and 'c' as the color. The size of the markers should be determined by 'd'. ",
    "id": 242
},
{
    "data": "  Imported libraries: import matplotlib.pyplot as plt import numpy as np from matplotlib.backends.backend_pdf import PdfPages  Data variables: x = np.arange(0, 5, 0.1)  ",
    "instruction": "  Create a multipage PDF file with three pages.  On the first page, plot the points (range(7), [3, 1, 4, 1, 5, 9, 2]) and title it \"Page One\".  On the second page, plot the function sin(x) and title it \"Page Two\". Attach the metadata \"plot of sin(x)\" to the page. Render the text using LaTeX.  On the third page, plot the points (x, x^2) and title it \"Page Three\".  Set the metadata of the PDF file as follows: - Title: \"Multipage PDF Example\" - Author: \"Jouni K. Seppänen\" - Subject: \"How to create a multipage pdf file and set its metadata\" - Keywords: \"PdfPages multipage keywords author title subject\" - CreationDate: November 13, 2009 - ModDate: [current date] ",
    "id": 243
},
{
    "data": "  browser_market_share = {     'browsers': ['firefox', 'chrome', 'safari', 'edge', 'ie', 'opera'],     'market_share': [8.61, 69.55, 8.36, 4.12, 2.76, 2.43],     'color': ['#5A69AF', '#579E65', '#F9C784', '#FC944A', '#F24C00', '#00B825'] }   ",
    "instruction": "  Create a packed-bubble chart using matplotlib. Use the following data to plot it:   browser_market_share = {     'browsers': ['firefox', 'chrome', 'safari', 'edge', 'ie', 'opera'],     'market_share': [8.61, 69.55, 8.36, 4.12, 2.76, 2.43],     'color': ['#5A69AF', '#579E65', '#F9C784', '#FC944A', '#F24C00', '#00B825'] }  The presented algorithm tries to move all bubbles as close to the center of mass as possible while avoiding some collisions by moving around colliding objects. In this example we plot the market share of different desktop browsers. ",
    "id": 244
},
{
    "data": "  ```python import matplotlib.pyplot as plt import numpy as np from matplotlib import patheffects  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3)) ax1.imshow([[1, 2], [2, 3]]) txt = ax1.annotate(     'test',      (1., 1.),      (0., 0),     arrowprops=dict(         arrowstyle='->',         connectionstyle='angle3',          lw=2     ),     size=20,     ha='center',     path_effects=[patheffects.withStroke(linewidth=3, foreground='w')] ) txt.arrow_patch.set_path_effects([     patheffects.Stroke(linewidth=5, foreground='w'),     patheffects.Normal() ])  pe = [patheffects.withStroke(linewidth=3, foreground='w')] ax1.grid(True, linestyle='-', path_effects=pe)  arr = np.arange(25).reshape((5, 5)) ax2.imshow(arr) cntr = ax2.contour(arr, colors='k') cntr.set(path_effects=[patheffects.withStroke(linewidth=3, foreground='w')])  clbls = ax2.clabel(cntr, fmt='%2.0f', use_clabeltext=True) plt.setp(clbls, path_effects=[     patheffects.withStroke(linewidth=3, foreground='w') ])  p1, = ax3.plot([0, 1], [0, 1]) leg = ax3.legend([p1], ['Line 1'], fancybox=True, loc='upper left') leg.legendPatch.set_path_effects([patheffects.withSimplePatchShadow()])  plt.show() ```  ",
    "instruction": " Create a figure with three subplots using `plt.subplots()` and pass in the arguments `1`, `3`, and `figsize=(8, 3)`. In the first subplot (`ax1`), use the `imshow()` function to display the array `[[1, 2], [2, 3]]`. Next, annotate the text `'test'` at coordinates `(1., 1.)` with an arrow pointing from `(0., 0)` using the `annotate()` function. Configure the arrow properties by specifying `arrowstyle='->'`, `connectionstyle='angle3'`, and `lw=2`. Set the size of the text to `20`, align it at the center (`ha='center'`), and apply a path effect by setting `path_effects=[patheffects.withStroke(linewidth=3, foreground='w')]`. Apply a path effect to the arrow patch by setting `txt.arrow_patch.set_path_effects([patheffects.Stroke(linewidth=5, foreground='w'), patheffects.Normal()])`. In the second subplot (`ax2`), use the `imshow()` function to display the array `arr`, and create contours lines using `contour()`. Set the line color of the contours to black using `colors='k'` and apply a path effect to the contours using `cntr.set(path_effects=[patheffects.withStroke(linewidth=3, foreground='w')])`. Add labels to the contours using `clbls = ax2.clabel(cntr, fmt='%2.0f', use_clabeltext=True)` and apply a path effect to the labels using `plt.setp(clbls, path_effects=[patheffects.withStroke(linewidth=3, foreground='w')])`. In the third subplot (`ax3`), create a line plot using `plot()` with the coordinates `[0, 1]` and `[0, 1]`. Add a legend to the plot using `ax3.legend([p1], ['Line 1'], fancybox=True, loc='upper left')` and apply a shadow path effect to the legend patch using `leg.legendPatch.set_path_effects([patheffects.withSimplePatchShadow()])`. Finally, display the figure using `plt.show()`. ",
    "id": 245
},
{
    "data": " No data preparation blocks found in the code.  ",
    "instruction": " Generate a line plot using the matplotlib library. Plot the data [1, 2, 3]. Save the plot as a PNG image and print it to the standard output. ",
    "id": 246
},
{
    "data": "  data = [[ 66386, 174296,  75131, 577908,  32015],         [ 58230, 381139,  78045,  99308, 160454],         [ 89135,  80552, 152558, 497981, 603535],         [ 78415,  81858, 150656, 193263,  69638],         [139361, 331509, 343164, 781380,  52269]]          columns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail') rows = ['%d year' % x for x in (100, 50, 20, 10, 5)]  values = np.arange(0, 2500, 500) value_increment = 1000  colors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows))) n_rows = len(data)  index = np.arange(len(columns)) + 0.3 bar_width = 0.4  y_offset = np.zeros(len(columns))  cell_text = [] for row in range(n_rows):     plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row])     y_offset = y_offset + data[row]     cell_text.append(['%1.1f' % (x / 1000.0) for x in y_offset])  colors = colors[::-1] cell_text.reverse()  ",
    "instruction": "  Use the following data to create a table within a plot: data = [[ 66386, 174296,  75131, 577908,  32015],         [ 58230, 381139,  78045,  99308, 160454],         [ 89135,  80552, 152558, 497981, 603535],         [ 78415,  81858, 150656, 193263,  69638],         [139361, 331509, 343164, 781380,  52269]]          columns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail')  Create a bar chart with stacked bars. Each row of data represents a different color for the bars. The bar chart should have the following specifications: - The x-axis should show the different columns: 'Freeze', 'Wind', 'Flood', 'Quake', 'Hail' - The y-axis should show the loss in increments of 1000: 0, 1000, 2000, 3000, 4000 - The chart should have a table at the bottom, displaying the values of each bar in the chart - The colors of the bars should be in the range of blue to purple - The chart should have a title: 'Loss by Disaster' - The y-axis label should be: 'Loss in $1000's' - The table should have row labels: '100 year', '50 year', '20 year', '10 year', '5 year'  Note: Make sure to adjust the layout to make room for the table. ",
    "id": 247
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.transforms as mtransforms  xs = np.arange(7) ys = xs**2  fig = plt.figure(figsize=(5, 10)) ax = plt.subplot(2, 1, 1)  # If we want the same offset for each text instance, # we only need to make one transform.  To get the # transform argument to offset_copy, we need to make the axes # first; the subplot function above is one way to do this. trans_offset = mtransforms.offset_copy(ax.transData, fig=fig,                                        x=0.05, y=0.10, units='inches')  for x, y in zip(xs, ys):     plt.plot(x, y, 'ro')     plt.text(x, y, '%d, %d' % (int(x), int(y)), transform=trans_offset)   # offset_copy works for polar plots also. ax = plt.subplot(2, 1, 2, projection='polar')  trans_offset = mtransforms.offset_copy(ax.transData, fig=fig,                                        y=6, units='dots')  for x, y in zip(xs, ys):     plt.polar(x, y, 'ro')     plt.text(x, y, '%d, %d' % (int(x), int(y)),              transform=trans_offset,              horizontalalignment='center',              verticalalignment='bottom')  plt.show()  ",
    "instruction": "  Use the following functions from matplotlib: plot, text, subplot, and polar, to create a figure with two subplots. In the first subplot, plot the points given by the arrays xs and ys as red circles. Add labels to each point using the corresponding values in xs and ys. Use the offset_copy function to position the labels at an offset of x=0.05 inches and y=0.10 inches from the data points. In the second subplot, create a polar plot with the same data points. Again, plot the points as red circles and add labels using the same offset. Position the labels with horizontalalignment='center' and verticalalignment='bottom'. ",
    "id": 248
},
{
    "data": "  x = np.linspace(0, 1, 100) y = np.sin(x * 2 * np.pi) / 2 + 0.5 colors = ('r g b k') np.random.seed(19680801) x = np.random.sample(20 * len(colors)) y = np.random.sample(20 * len(colors)) c_list = [] for c in colors:     c_list.extend([c] * 20)  ",
    "instruction": "  Create a 3D plot using matplotlib with the following data: x = np.linspace(0, 1, 100) y = np.sin(x * 2 * np.pi) / 2 + 0.5 colors = ('r g b k') np.random.seed(19680801) x = np.random.sample(20 * len(colors)) y = np.random.sample(20 * len(colors)) c_list = [] for c in colors:     c_list.extend([c] * 20)  Use the following functions and settings to customize the plot: - ax = plt.figure().add_subplot(projection='3d') - ax.plot(x, y, zs=0, zdir='z', label='curve in (x, y)') - ax.scatter(x, y, zs=0, zdir='y', c=c_list, label='points in (x, z)') - ax.legend() - ax.set_xlim(0, 1) - ax.set_ylim(0, 1) - ax.set_zlim(0, 1) - ax.set_xlabel('X') - ax.set_ylabel('Y') - ax.set_zlabel('Z') - ax.view_init(elev=20., azim=-35, roll=0)  This code demonstrates how to plot 2D data on selective axes of a 3D plot by using the keyword 'zdir' in the 'ax.plot' and 'ax.scatter' functions. ",
    "id": 249
},
{
    "data": " _x = np.arange(4) _y = np.arange(5) _xx, _yy = np.meshgrid(_x, _y) x, y = _xx.ravel(), _yy.ravel() top = x + y bottom = np.zeros_like(top) width = depth = 1  ",
    "instruction": " Use the following data to create a 3D bar chart with shading and another without shading using matplotlib. The data consists of: _x = np.arange(4) _y = np.arange(5) _xx, _yy = np.meshgrid(_x, _y) x, y = _xx.ravel(), _yy.ravel() top = x + y bottom = np.zeros_like(top) width = depth = 1 ",
    "id": 250
},
{
    "data": " np.random.seed(19680801)  fig = plt.figure() ax = fig.add_subplot(projection='3d')  colors = ['r g b y'] yticks = [3, 2, 1, 0] for c, k in zip(colors, yticks):     # Generate the random data for the y=k 'layer'.     xs = np.arange(20)     ys = np.random.rand(20)      # You can provide either a single color or an array with the same length as     # xs and ys. To demonstrate this, we color the first bar of each set cyan.     cs = [c] * len(xs)     cs[0] = 'c'      # Plot the bar graph given by xs and ys on the plane y=k with 80% opacity.     ax.bar(xs, ys, zs=k, zdir='y', color=cs, alpha=0.8)  ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z')  # On the y-axis let's only label the discrete values that we have data for. ax.set_yticks(yticks)  plt.show()  ",
    "instruction": " Create a 3D plot with 2D bar graphs projected onto different planes. Use the function `ax.bar` from matplotlib to plot the bar graphs on the y-planes with the following data: np.random.seed(19680801), colors = ['r g b y'], yticks = [3, 2, 1, 0]. Label the x-axis as 'X', the y-axis as 'Y', and the z-axis as 'Z'. ",
    "id": 251
},
{
    "data": "  # Define dimensions Nx, Ny, Nz = 100, 300, 500 X, Y, Z = np.meshgrid(np.arange(Nx), np.arange(Ny), -np.arange(Nz))  # Create fake data data = (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1)  kw = {     'vmin': data.min(),     'vmax': data.max(),     'levels': np.linspace(data.min(), data.max(), 10), }  ",
    "instruction": "  To create a 3D box surface plot, use the following data and plot settings:  # Define dimensions Nx, Ny, Nz = 100, 300, 500 X, Y, Z = np.meshgrid(np.arange(Nx), np.arange(Ny), -np.arange(Nz))  # Create fake data data = (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1)  kw = {     'vmin': data.min(),     'vmax': data.max(),     'levels': np.linspace(data.min(), data.max(), 10), }  Create a figure with a 3D ax using `fig = plt.figure(figsize=(5, 4))` and `ax = fig.add_subplot(111, projection='3d')`.  Plot contour surfaces using `ax.contourf()` with the following parameters: - Surface 1:     - X, Y, Z: X[:, :, 0], Y[:, :, 0], data[:, :, 0]     - zdir: 'z'     - offset: 0     - vmin: data.min()     - vmax: data.max()     - levels: np.linspace(data.min(), data.max(), 10) - Surface 2:     - X, Y, Z: X[0, :, :], data[0, :, :], Z[0, :, :]     - zdir: 'y'     - offset: 0     - vmin: data.min()     - vmax: data.max()     - levels: np.linspace(data.min(), data.max(), 10) - Surface 3:     - X, Y, Z: data[:, -1, :], Y[:, -1, :], Z[:, -1, :]     - zdir: 'x'     - offset: X.max()     - vmin: data.min()     - vmax: data.max()     - levels: np.linspace(data.min(), data.max(), 10)  Set the limits of the plot using `ax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax])`, where: - xmin, xmax = X.min(), X.max() - ymin, ymax = Y.min(), Y.max() - zmin, zmax = Z.min(), Z.max()  Plot edges using `ax.plot()` with the following parameters: - Edge 1: [xmax, xmax], [ymin, ymax], 0 - Edge 2: [xmin, xmax], [ymin, ymin], 0 - Edge 3: [xmax, xmax], [ymin, ymin], [zmin, zmax] - Color: '0.4' - Linewidth: 1 - Zorder: 1e3  Set labels and zticks using `ax.set()` with the following parameters: - xlabel: 'X [km]' - ylabel: 'Y [km]' - zlabel: 'Z [m]' - zticks: [0, -150, -300, -450]  Set the view angle using `ax.view_init()` with the following parameters: - elevation: 40 - azimuth: -30 - distance: 0  Set the aspect ratio and zoom using `ax.set_box_aspect()` with the following parameters: - aspect: None - zoom: 0.9  Add a colorbar using `fig.colorbar()` with the following parameters: - C: The contour surface created earlier - ax: ax - fraction: 0.02 - pad: 0.1 - label: 'Name [units]'  Finally, show the figure by using `plt.show()`. ",
    "id": 252
},
{
    "data": "  X, Y, Z = axes3d.get_test_data(0.05)  ",
    "instruction": "  To generate a 3D plot with contour curves, use the following code snippet:  import matplotlib.pyplot as plt from matplotlib import cm from mpl_toolkits.mplot3d import axes3d  ax = plt.figure().add_subplot(projection='3d') ax.contour(X, Y, Z, cmap=cm.coolwarm)  Make sure to plot the contour (level) curves in 3D. This is similar to a contour plot in 2D, but the f(x, y)=c curve is plotted on the plane z=c. ",
    "id": 253
},
{
    "data": "  X, Y, Z = axes3d.get_test_data(0.05)  ",
    "instruction": "  Use the following data to create a 3D plot with contour curves:  X, Y, Z = axes3d.get_test_data(0.05).  Specify the extend3d=True option to extend the curves vertically into 'ribbons'. ",
    "id": 254
},
{
    "data": "  X, Y, Z = axes3d.get_test_data(0.05)  ",
    "instruction": "  To generate a 3D surface plot with contour projections, use the following code: ```python import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import axes3d  ax = plt.figure().add_subplot(projection='3d')  # Plot the 3D surface ax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,                 alpha=0.3)  # Plot projections of the contours for each dimension. By choosing offsets # that match the appropriate axes limits, the projected contours will sit on # the 'walls' of the graph. ax.contour(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm') ax.contour(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm') ax.contour(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')  ax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),        xlabel='X', ylabel='Y', zlabel='Z')  plt.show() ```  This code will generate a 3D surface plot with the contour projections onto the walls of the graph. The data used in this plot is obtained from `X, Y, Z = axes3d.get_test_data(0.05)`. ",
    "id": 255
},
{
    "data": " X, Y, Z = axes3d.get_test_data(0.05) ",
    "instruction": " Use the following data to create a filled contours plot in 3D using matplotlib: X, Y, Z = axes3d.get_test_data(0.05). ",
    "id": 256
},
{
    "data": " X, Y, Z = axes3d.get_test_data(0.05) ",
    "instruction": " Use the following data to create a 3D surface plot with projected filled contour profiles onto the walls of the graph: X, Y, Z = axes3d.get_test_data(0.05) Plot the 3D surface using ax.plot_surface() function with the following parameters: edgecolor='royalblue', lw=0.5, rstride=8, cstride=8, alpha=0.3. Plot the projections of the contours for each dimension using ax.contourf() function with the following parameters: zdir='z', offset=-100, cmap='coolwarm', to project onto the z-axis; zdir='x', offset=-40, cmap='coolwarm', to project onto the x-axis; zdir='y', offset=40, cmap='coolwarm', to project onto the y-axis. Set the x-axis limits to (-40, 40), y-axis limits to (-40, 40), and z-axis limits to (-100, 100) using ax.set() function. Set the x-axis label to 'X', y-axis label to 'Y', and z-axis label to 'Z'. Finally, display the plot using plt.show(). ",
    "id": 257
},
{
    "data": "   import matplotlib.pyplot as plt import numpy as np  from matplotlib import cbook, cm from matplotlib.colors import LightSource  # Load and format data dem = cbook.get_sample_data('jacksboro_fault_dem.npz') z = dem['elevation'] nrows, ncols = z.shape x = np.linspace(dem['xmin'], dem['xmax'], ncols) y = np.linspace(dem['ymin'], dem['ymax'], nrows) x, y = np.meshgrid(x, y)  region = np.s_[5:50, 5:50] x, y, z = x[region], y[region], z[region]  # Set up plot fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))  ls = LightSource(270, 45) # To use a custom hillshading mode, override the built-in shading and pass # in the rgb colors of the shaded surface calculated from 'shade'. rgb = ls.shade(z, cmap=cm.gist_earth, vert_exag=0.1, blend_mode='soft') surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,                        linewidth=0, antialiased=False, shade=False)  plt.show()  ",
    "instruction": "   Create a 3D surface plot with custom hillshading using matplotlib. Use the following data to plot it:   - dem = cbook.get_sample_data('jacksboro_fault_dem.npz') - z = dem['elevation'] - ncols, nrows = z.shape - x = np.linspace(dem['xmin'], dem['xmax'], ncols) - y = np.linspace(dem['ymin'], dem['ymax'], nrows) - region = np.s_[5:50, 5:50] - x, y, z = x[region], y[region], z[region]  Set up the plot with the following settings:  - subplot_kw=dict(projection='3d') - LightSource(azdeg, altdeg) - cmap=cm.gist_earth - vert_exag=0.1 - blend_mode='soft'  Plot the surface using the following settings:  - rstride=1 - cstride=1 - facecolors=rgb - linewidth=0 - antialiased=False - shade=False  Finally, display the plot. ",
    "id": 258
},
{
    "data": "  t = np.arange(0, 2*np.pi+.1, 0.01) x, y, z = np.sin(t), np.cos(3*t), np.sin(5*t) estep = 15 i = np.arange(t.size) zuplims = (i % estep == 0) & (i // estep % 3 == 0) zlolims = (i % estep == 0) & (i // estep % 3 == 2)  ",
    "instruction": "  Create a 3D plot with error bars using matplotlib. Use the following data to plot it:  t = np.arange(0, 2*np.pi+.1, 0.01) x, y, z = np.sin(t), np.cos(3*t), np.sin(5*t) estep = 15 i = np.arange(t.size) zuplims = (i % estep == 0) & (i // estep % 3 == 0) zlolims = (i % estep == 0) & (i // estep % 3 == 2) ",
    "id": 259
},
{
    "data": " np.random.seed(19680801)  fig = plt.figure() ax = fig.add_subplot(projection='3d') x, y = np.random.rand(2, 100) * 4 hist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]])  xpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25, indexing='ij') xpos = xpos.ravel() ypos = ypos.ravel() zpos = 0  dx = dy = 0.5 * np.ones_like(zpos) dz = hist.ravel()  ax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')  plt.show()  ",
    "instruction": " Create a 3D histogram of 2D data using matplotlib. Use the following data to plot it: np.random.seed(19680801), x, y = np.random.rand(2, 100) * 4, hist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]]). ",
    "id": 260
},
{
    "data": "  theta = np.linspace(-4 * np.pi, 4 * np.pi, 100) z = np.linspace(-2, 2, 100) r = z**2 + 1 x = r * np.sin(theta) y = r * np.cos(theta)  ",
    "instruction": "  To create a plot of a parametric curve in 3D using matplotlib, use the following data: theta = np.linspace(-4 * np.pi, 4 * np.pi, 100) z = np.linspace(-2, 2, 100) r = z**2 + 1 x = r * np.sin(theta) y = r * np.cos(theta).   ",
    "id": 261
},
{
    "data": " np.empty((num_steps + 1, 3)), xyzs[0] = (0., 1., 1.05), for i in range(num_steps):, xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt ",
    "instruction": " Generate a 3-dimensional plot of Edward Lorenz's 1963 \"Deterministic Nonperiodic Flow\" using matplotlib. Use the following data to plot it: np.empty((num_steps + 1, 3)), xyzs[0] = (0., 1., 1.05), for i in range(num_steps):, xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt. ",
    "id": 262
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np   def f(t):     return np.cos(2 * np.pi * t) * np.exp(-t)   # Set up a figure twice as tall as it is wide fig = plt.figure(figsize=plt.figaspect(2.)) fig.suptitle('A tale of 2 subplots')  # First subplot ax = fig.add_subplot(2, 1, 1)  t1 = np.arange(0.0, 5.0, 0.1) t2 = np.arange(0.0, 5.0, 0.02) t3 = np.arange(0.0, 2.0, 0.01)  ax.plot(t1, f(t1), 'bo',         t2, f(t2), 'k--', markerfacecolor='green') ax.grid(True) ax.set_ylabel('Damped oscillation')  # Second subplot ax = fig.add_subplot(2, 1, 2, projection='3d')  X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R)  surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1,                        linewidth=0, antialiased=False) ax.set_zlim(-1, 1)  plt.show()  ",
    "instruction": "  Use the following data to plot the figure: t1 = np.arange(0.0, 5.0, 0.1) t2 = np.arange(0.0, 5.0, 0.02) t3 = np.arange(0.0, 2.0, 0.01)  Create a figure with two subplots. In the first subplot, plot the points (t1, f(t1)) as blue circles and the points (t2, f(t2)) as a black dashed line with green marker faces. Add gridlines to the plot and set the y-axis label to \"Damped oscillation\".   In the second subplot, create a 3D plot of the surface defined by X, Y, and Z. X and Y should range from -5 to 5 with a step size of 0.25. Calculate R as the square root of the sum of the squares of X and Y. Define Z as the sine of R. Plot the surface using the plot_surface function and set the z-axis limits to -1 to 1. ",
    "id": 263
},
{
    "data": " X, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25] Z = np.sqrt(np.abs(np.cos(X) + np.cos(Y)))  ",
    "instruction": " Create a 3D plot using matplotlib's mplot3d module. Use the following data to plot the surface: X, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25], Z = np.sqrt(np.abs(np.cos(X) + np.cos(Y))). Set the x-axis label to 'X label', the y-axis label to 'Y label', and the z-axis label to 'Z label'. Set the z-axis limits to be between 0 and 2. Finally, use the cmap='autumn', cstride=2, and rstride=2 parameters to style the surface plot. ",
    "id": 264
},
{
    "data": "   import matplotlib.pyplot as plt import numpy as np  from matplotlib.patches import Circle, PathPatch from matplotlib.text import TextPath from matplotlib.transforms import Affine2D import mpl_toolkits.mplot3d.art3d as art3d   def text3d(ax, xyz, s, zdir='z', size=None, angle=0, usetex=False, **kwargs):     '''     Plots the string *s* on the axes *ax*, with position *xyz*, size *size*,     and rotation angle *angle*. *zdir* gives the axis which is to be treated as     the third dimension. *usetex* is a boolean indicating whether the string     should be run through a LaTeX subprocess or not.  Any additional keyword     arguments are forwarded to `.transform_path`.      Note: zdir affects the interpretation of xyz.     '''      x, y, z = xyz     if zdir == 'y':         xy1, z1 = (x, z), y     elif zdir == 'x':         xy1, z1 = (y, z), x     else:         xy1, z1 = (x, y), z      text_path = TextPath((0, 0), s, size=size, usetex=usetex)     trans = Affine2D().rotate(angle).translate(xy1[0], xy1[1])      p1 = PathPatch(trans.transform_path(text_path), **kwargs)     ax.add_patch(p1)     art3d.pathpatch_2d_to_3d(p1, z=z1, zdir=zdir)   fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Draw a circle on the x=0 'wall' p = Circle((5, 5), 3) ax.add_patch(p) art3d.pathpatch_2d_to_3d(p, z=0, zdir='x')  # Manually label the axes text3d(ax, (4, -2, 0), 'X-axis', zdir='z', size=.5, usetex=False,        ec='none', fc='k') text3d(ax, (12, 4, 0), 'Y-axis', zdir='z', size=.5, usetex=False,        angle=np.pi / 2, ec='none', fc='k') text3d(ax, (12, 10, 4), 'Z-axis', zdir='y', size=.5, usetex=False,        angle=np.pi / 2, ec='none', fc='k')  # Write a Latex formula on the z=0 'floor' text3d(ax, (1, 5, 0),        r'$\\\\\\\\displaystyle G_{\\\\\\\\mu\\\\\\nu} + \\\\\\\\Lambda g_{\\\\\\\\mu\\\\\\nu} = '        r'\\\\\\\\frac{8\\\\\\\\pi G}{c^4} T_{\\\\\\\\mu\\\\\\nu}  $',        zdir='z', size=1, usetex=True,        ec='none', fc='k')  ax.set_xlim(0, 10) ax.set_ylim(0, 10) ax.set_zlim(0, 10)  plt.show()   ",
    "instruction": "   Create a 3D plot using matplotlib. Use the following functions and classes: Circle, PathPatch, TextPath, Affine2D, and art3d.   Use the provided code to plot a circle on the 'x=0' wall and label the axes: X-axis, Y-axis, and Z-axis. Additionally, write a LaTeX formula on the 'z=0' floor.  Adjust the limits of the x-axis, y-axis, and z-axis to be between 0 and 10.  Display the plot. ",
    "id": 265
},
{
    "data": "  np.random.seed(19680801)  def polygon_under_graph(x, y):     '''     Construct the vertex list which defines the polygon filling the space under     the (x, y) line graph. This assumes x is in ascending order.     '''     return [(x[0], 0.), *zip(x, y), (x[-1], 0.)]  ax = plt.figure().add_subplot(projection='3d')  x = np.linspace(0., 10., 31) lambdas = range(1, 9)  gamma = np.vectorize(math.gamma) verts = [polygon_under_graph(x, l**x * np.exp(-l) / gamma(x + 1))          for l in lambdas] facecolors = plt.colormaps['viridis_r'](np.linspace(0, 1, len(verts)))  ",
    "instruction": "  Use the function `polygon_under_graph` to construct vertex lists for polygons that will fill the space under a 3D line graph. Plot these polygons using the given axes `ax` and the given x-axis values `x` and lambdas as the y-axis values. Use the function `plt.colormaps` to assign face colors to the polygons and set their transparency to 0.7. Set the limits of the x-axis to (0, 10), the y-axis to (1, 9), and the z-axis to (0, 0.35). Label the x-axis as 'x', the y-axis as lambda (λ), and the z-axis as 'probability'. ",
    "id": 266
},
{
    "data": "  X, Y, Z = axes3d.get_test_data(0.05)  ",
    "instruction": "  Create a 3D plot with different camera projections using matplotlib. Use the following data to plot it: X, Y, Z = axes3d.get_test_data(0.05). Plot three wireframe plots, one for each projection type: ortho, persp with default focal length, and persp with a focal length of 0.2. Add titles to each plot to indicate the projection type and focal length. ",
    "id": 267
},
{
    "data": "  x, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2), np.arange(-0.8, 1, 0.2), np.arange(-0.8, 1, 0.8)) u = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z) v = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z) w = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) * np.sin(np.pi * z))  ",
    "instruction": "  To create a 3D quiver plot demonstrating directional arrows on a meshgrid, use the following code:  import matplotlib.pyplot as plt import numpy as np  ax = plt.figure().add_subplot(projection='3d')  # Make the grid x, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2), np.arange(-0.8, 1, 0.2), np.arange(-0.8, 1, 0.8))  # Make the direction data for the arrows u = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z) v = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z) w = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) * np.sin(np.pi * z))  ax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)  plt.show() ",
    "id": 268
},
{
    "data": " X, Y, Z = axes3d.get_test_data(0.05) ",
    "instruction": " Use the function `axes3d.get_test_data()` to generate example data for the wireframe plot. Then use the `plot_wireframe()` function from matplotlib to create a basic wireframe plot. Set the x-axis label to 'x', the y-axis label to 'y', and the z-axis label to 'z'. Lastly, animate the plot by rotating it about all three axes using the `ax.view_init()` function, and update the title of the plot to display the current elevation, azimuth, and roll angles. ",
    "id": 269
},
{
    "data": " np.random.seed(19680801)   def randrange(n, vmin, vmax):     '''     Helper function to make an array of random numbers having shape (n, )     with each number distributed Uniform(vmin, vmax).     '''     return (vmax - vmin)*np.random.rand(n) + vmin  fig = plt.figure() ax = fig.add_subplot(projection='3d')  n = 100  # For each set of style and range settings, plot n random points in the box # defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh]. for m, zlow, zhigh in [('o', -50, -25), ('^', -30, -5)]:     xs = randrange(n, 23, 32)     ys = randrange(n, 0, 100)     zs = randrange(n, zlow, zhigh)     ax.scatter(xs, ys, zs, marker=m)  ax.set_xlabel('X Label') ax.set_ylabel('Y Label') ax.set_zlabel('Z Label')  ",
    "instruction": " Create a 3D scatterplot using matplotlib. Use the following data to plot it: np.random.seed(19680801), `def randrange(n, vmin, vmax)` as a helper function, n = 100, for each set of style and range settings: ('o', -50, -25) and ('^', -30, -5), xs = randrange(n, 23, 32), ys = randrange(n, 0, 100), zs = randrange(n, zlow, zhigh). Set the x-axis label to 'X Label', the y-axis label to 'Y Label', and the z-axis label to 'Z Label'. Please note that this code demonstrates a basic scatterplot in 3D. ",
    "id": 270
},
{
    "data": "  X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R)  ",
    "instruction": "  To create a figure with two subplots, where each subplot contains a 3D plot, use the following code snippet:  import matplotlib.pyplot as plt import numpy as np from matplotlib import cm from mpl_toolkits.mplot3d.axes3d import get_test_data  # Set up a figure twice as wide as it is tall fig = plt.figure(figsize=plt.figaspect(0.5))  # First subplot ax = fig.add_subplot(1, 2, 1, projection='3d') surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm, linewidth=0, antialiased=False) ax.set_zlim(-1.01, 1.01) fig.colorbar(surf, shrink=0.5, aspect=10)  # Second subplot ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)  plt.show()  This code will generate two subplots, each containing a 3D plot. The first subplot will display a 3D surface plot based on the data provided, and the second subplot will display a wireframe plot based on the data provided. ",
    "id": 271
},
{
    "data": " X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R)  ",
    "instruction": " Create a 3D surface plot colored with the coolwarm colormap. Use the following data to plot it: X = np.arange(-5, 5, 0.25), Y = np.arange(-5, 5, 0.25), X, Y = np.meshgrid(X, Y), R = np.sqrt(X**2 + Y**2), Z = np.sin(R). ",
    "id": 272
},
{
    "data": " u = np.linspace(0, 2 * np.pi, 100) v = np.linspace(0, np.pi, 100) x = 10 * np.outer(np.cos(u), np.sin(v)) y = 10 * np.outer(np.sin(u), np.sin(v)) z = 10 * np.outer(np.ones(np.size(u)), np.cos(v))  ",
    "instruction": " Create a 3D surface plot using matplotlib. Use the following data to plot it: u = np.linspace(0, 2 * np.pi, 100) v = np.linspace(0, np.pi, 100) x = 10 * np.outer(np.cos(u), np.sin(v)) y = 10 * np.outer(np.sin(u), np.sin(v)) z = 10 * np.outer(np.ones(np.size(u)), np.cos(v)). ",
    "id": 273
},
{
    "data": " X = np.arange(-5, 5, 0.25) xlen = len(X) Y = np.arange(-5, 5, 0.25) ylen = len(Y) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) colortuple = ('y b') colors = np.empty(X.shape, dtype=str) for y in range(ylen):     for x in range(xlen):         colors[y, x] = colortuple[(x + y) % len(colortuple)]  ",
    "instruction": " Use the following data to generate a 3D surface plot with a checkerboard pattern.  X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) colortuple = ('y b') ",
    "id": 274
},
{
    "data": "  r = np.linspace(0, 1.25, 50) p = np.linspace(0, 2*np.pi, 50) R, P = np.meshgrid(r, p) Z = ((R**2 - 1)**2) X, Y = R*np.cos(P), R*np.sin(P)  ",
    "instruction": " Create a 3D surface plot with polar coordinates using matplotlib. Use the following data to plot it: r = np.linspace(0, 1.25, 50) p = np.linspace(0, 2*np.pi, 50) R, P = np.meshgrid(r, p) Z = ((R**2 - 1)**2) X, Y = R*np.cos(P), R*np.sin(P). ",
    "id": 275
},
{
    "data": "  zdirs = (None, 'x', 'y', 'z', (1, 1, 0), (1, 1, 1)) xs = (1, 4, 4, 9, 4, 1) ys = (2, 5, 8, 10, 1, 2) zs = (10, 3, 8, 9, 1, 8)  ",
    "instruction": "  To create a 3D plot with text annotations, use the following instructions: 1. Use the `text` function to annotate points in 3D space. Pass the following parameters for each annotation:    - `(x, y, z)`: The coordinates of the point.    - `label`: The text for the annotation.    - `zdir`: The direction of the annotation. It can be `None`, `'x'`, `'y'`, `'z'`, or a direction tuple. 2, Use the `text` function with the `color` parameter to change the color of a specific annotation. 3. Use the `text2D` function to place text on a fixed position on the plot. 4. Set the limits of the x, y, and z axes using `set_xlim`, `set_ylim`, and `set_zlim` functions respectively. 5. Set labels for the x, y, and z axes using `set_xlabel`, `set_ylabel`, and `set_zlabel` functions respectively.  Use the specified data to create the plot: zdirs = (None, 'x', 'y', 'z', (1, 1, 0), (1, 1, 1)) xs = (1, 4, 4, 9, 4, 1) ys = (2, 5, 8, 10, 1, 2) zs = (10, 3, 8, 9, 1, 8) ",
    "id": 276
},
{
    "data": "   n_angles = 48 n_radii = 8 min_radius = 0.25  radii = np.linspace(min_radius, 0.95, n_radii) angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += np.pi/n_angles  x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() z = (np.cos(radii)*np.cos(3*angles)).flatten()  triang = tri.Triangulation(x, y) triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1), y[triang.triangles].mean(axis=1)) < min_radius)  ",
    "instruction": "   Create a triangular 3D contour plot using matplotlib. Use the following data to plot it:  n_angles = 48,  n_radii = 8,  min_radius = 0.25,  radii = np.linspace(min_radius, 0.95, n_radii),  angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False),  angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1),  angles[:, 1::2] += np.pi/n_angles,  x = (radii*np.cos(angles)).flatten(),  y = (radii*np.sin(angles)).flatten(),  z = (np.cos(radii)*np.cos(3*angles)).flatten().   Display the plot using ax.tricontour() function, and customize the view angle to make it easier to understand using ax.view_init(elev=45.). ",
    "id": 277
},
{
    "data": "  n_angles = 48 n_radii = 8 min_radius = 0.25  # Create the mesh in polar coordinates and compute x, y, z. radii = np.linspace(min_radius, 0.95, n_radii) angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += np.pi/n_angles  x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() z = (np.cos(radii)*np.cos(3*angles)).flatten()  # Create a custom triangulation. triang = tri.Triangulation(x, y)  # Mask off unwanted triangles. triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),                          y[triang.triangles].mean(axis=1))                 < min_radius)  ",
    "instruction": "  Create a triangular 3D filled contour plot using matplotlib. Use the following steps and data: 1. Set the variables n_angles, n_radii, and min_radius. 2. Create the mesh in polar coordinates using the variables radii and angles. 3. Compute the x, y, and z coordinates using the formulas provided. 4. Create a custom triangulation using the Triangulation function from matplotlib.tri. 5. Mask off unwanted triangles using the set_mask function. 6. Use the tricontourf function from matplotlib to create the contour plot. 7. Customize the view angle of the plot using ax.view_init. 8. Display the plot using plt.show(). ",
    "id": 278
},
{
    "data": "  n_radii = 8 n_angles = 36  # Make radii and angles spaces (radius r=0 omitted to eliminate duplication). radii = np.linspace(0.125, 1.0, n_radii) angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]  # Convert polar (radii, angles) coords to cartesian (x, y) coords. # (0, 0) is manually added at this stage,  so there will be no duplicate # points in the (x, y) plane. x = np.append(0, (radii*np.cos(angles)).flatten()) y = np.append(0, (radii*np.sin(angles)).flatten())  # Compute z to make the pringle surface. z = np.sin(-x*y)  ",
    "instruction": "   To create a triangular 3D surface plot with a pringle surface, use the provided data and the following functions from matplotlib: plot_trisurf, np.linspace, and np.sin. Generate the plot using the cartesian coordinates x, y, and the calculated z. ",
    "id": 279
},
{
    "data": "   # ========== # First plot # ==========  # Make a mesh in the space of parameterisation variables u and v u = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50) v = np.linspace(-0.5, 0.5, endpoint=True, num=10) u, v = np.meshgrid(u, v) u, v = u.flatten(), v.flatten()  # This is the Mobius mapping, taking a u, v pair and returning an x, y, z triple x = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u) y = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u) z = 0.5 * v * np.sin(u / 2.0)  # Triangulate parameter space to determine the triangles tri = mtri.Triangulation(u, v)  # =========== # Second plot # ===========  # Make parameter spaces radii and angles. n_angles = 36 n_radii = 8 min_radius = 0.25 radii = np.linspace(min_radius, 0.95, n_radii)  angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += np.pi/n_angles  # Map radius, angle pairs to x, y, z points. x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() z = (np.cos(radii)*np.cos(3*angles)).flatten()  # Create the Triangulation; no triangles so Delaunay triangulation created. triang = mtri.Triangulation(x, y)  # Mask off unwanted triangles. xmid = x[triang.triangles].mean(axis=1) ymid = y[triang.triangles].mean(axis=1) mask = xmid**2 + ymid**2 < min_radius**2 triang.set_mask(mask)  ",
    "instruction": "   Create two 3D surface plots using matplotlib.   For the first plot, use the parameterization variables u and v to create a mesh. Apply the Mobius mapping to the u and v pairs to obtain x, y, z values. Use the triangulation of the parameter space to determine the triangles. Plot the surface using the plot_trisurf function.  For the second plot, create parameter spaces for radii and angles. Map the radius and angle pairs to x, y, z points. Create a triangulation using the x and y values. Mask off unwanted triangles based on a condition. Plot the surface using the plot_trisurf function. ",
    "id": 280
},
{
    "data": "  import matplotlib.pyplot as plt   def annotate_axes(ax, text, fontsize=18):     ax.text(x=0.5, y=0.5, z=0.5, s=text,             va='center', ha='center', fontsize=fontsize, color='black')  # (plane, (elev, azim, roll)) views = [('XY',   (90, -90, 0)),          ('XZ',    (0, -90, 0)),          ('YZ',    (0,   0, 0)),          ('-XY', (-90,  90, 0)),          ('-XZ',   (0,  90, 0)),          ('-YZ',   (0, 180, 0))]  layout = [['XY',  '.',   'L',   '.'],           ['XZ', 'YZ', '-XZ', '-YZ'],           ['.',   '.', '-XY',   '.']] fig, axd = plt.subplot_mosaic(layout, subplot_kw={'projection': '3d'},                               figsize=(12, 8.5)) for plane, angles in views:     axd[plane].set_xlabel('x')     axd[plane].set_ylabel('y')     axd[plane].set_zlabel('z')     axd[plane].set_proj_type('ortho')     axd[plane].view_init(elev=angles[0], azim=angles[1], roll=angles[2])     axd[plane].set_box_aspect(None, zoom=1.25)      label = f'{plane}\\\\\\n{angles}'     annotate_axes(axd[plane], label, fontsize=14)  for plane in ('XY', '-XY'):     axd[plane].set_zticklabels([])     axd[plane].set_zlabel('') for plane in ('XZ', '-XZ'):     axd[plane].set_yticklabels([])     axd[plane].set_ylabel('') for plane in ('YZ', '-YZ'):     axd[plane].set_xticklabels([])     axd[plane].set_xlabel('')  label = 'mplot3d primary view planes\\\\\\n' + 'ax.view_init(elev, azim, roll)' annotate_axes(axd['L'], label, fontsize=18) axd['L'].set_axis_off()  plt.show()   ",
    "instruction": "  Create a 3D plot using matplotlib with unfolded primary view planes. Each plane should be labeled with its corresponding elevation, azimuth, and roll angles. Use the following code to generate the plot:  ```python import matplotlib.pyplot as plt   def annotate_axes(ax, text, fontsize=18):     ax.text(x=0.5, y=0.5, z=0.5, s=text,             va='center', ha='center', fontsize=fontsize, color='black')  # (plane, (elev, azim, roll)) views = [('XY',   (90, -90, 0)),          ('XZ',    (0, -90, 0)),          ('YZ',    (0,   0, 0)),          ('-XY', (-90,  90, 0)),          ('-XZ',   (0,  90, 0)),          ('-YZ',   (0, 180, 0))]  layout = [['XY',  '.',   'L',   '.'],           ['XZ', 'YZ', '-XZ', '-YZ'],           ['.',   '.', '-XY',   '.']] fig, axd = plt.subplot_mosaic(layout, subplot_kw={'projection': '3d'},                               figsize=(12, 8.5)) for plane, angles in views:     axd[plane].set_xlabel('x')     axd[plane].set_ylabel('y')     axd[plane].set_zlabel('z')     axd[plane].set_proj_type('ortho')     axd[plane].view_init(elev=angles[0], azim=angles[1], roll=angles[2])     axd[plane].set_box_aspect(None, zoom=1.25)      label = f'{plane}\\\\\\n{angles}'     annotate_axes(axd[plane], label, fontsize=14)  for plane in ('XY', '-XY'):     axd[plane].set_zticklabels([])     axd[plane].set_zlabel('') for plane in ('XZ', '-XZ'):     axd[plane].set_yticklabels([])     axd[plane].set_ylabel('') for plane in ('YZ', '-YZ'):     axd[plane].set_xticklabels([])     axd[plane].set_xlabel('')  label = 'mplot3d primary view planes\\\\\\n' + 'ax.view_init(elev, azim, roll)' annotate_axes(axd['L'], label, fontsize=18) axd['L'].set_axis_off()  plt.show() ``` ",
    "id": 281
},
{
    "data": "  x, y, z = np.indices((8, 8, 8)) cube1 = (x < 3) & (y < 3) & (z < 3) cube2 = (x >= 5) & (y >= 5) & (z >= 5) link = abs(x - y) + abs(y - z) + abs(z - x) <= 2 voxelarray = cube1 | cube2 | link colors = np.empty(voxelarray.shape, dtype=object) colors[link] = 'red' colors[cube1] = 'blue' colors[cube2] = 'green'  ",
    "instruction": " To create a 3D voxel plot, use the `voxels` function from matplotlib's Axes3D module. Use the following data to plot it: x, y, z = np.indices((8, 8, 8)) cube1 = (x < 3) & (y < 3) & (z < 3) cube2 = (x >= 5) & (y >= 5) & (z >= 5) link = abs(x - y) + abs(y - z) + abs(z - x) <= 2 voxelarray = cube1 | cube2 | link colors = np.empty(voxelarray.shape, dtype=object) colors[link] = 'red' colors[cube1] = 'blue' colors[cube2] = 'green'. ",
    "id": 282
},
{
    "data": " np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]: species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ), weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }.  [DATA]: No data preparation blocks found in the code.  [INSTRUCTION]: Create a 3D voxel plot of the NumPy logo using matplotlib. Use the provided code to generate the plot. ",
    "id": 283
},
{
    "data": "  midpoints(x):  r, g, b = np.indices((17, 17, 17)) / 16.0 rc = midpoints(r) gc = midpoints(g) bc = midpoints(b)  sphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2  colors = np.zeros(sphere.shape + (3,)) colors[..., 0] = rc colors[..., 1] = gc colors[..., 2] = bc  ",
    "instruction": "  Create a 3D voxel plot with RGB colors using the matplotlib function `voxels`. Use `rc`, `gc`, `bc`, `sphere`, and `colors` as the data to plot. ",
    "id": 284
},
{
    "data": "  r, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j] x = r*np.cos(theta) y = r*np.sin(theta) rc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z) sphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 < 0.2**2 hsv = np.zeros(sphere.shape + (3,)) hsv[..., 0] = thetac / (np.pi*2) hsv[..., 1] = rc hsv[..., 2] = zc + 0.5 colors = matplotlib.colors.hsv_to_rgb(hsv)  ",
    "instruction": " Create a 3D voxel plot with cylindrical coordinates using matplotlib. Use the following data to plot it:  r = np.mgrid[0:1:11j],  theta = np.mgrid[0:np.pi*2:25j],  z = np.mgrid[-0.5:0.5:11j],  x = r*np.cos(theta),  y = r*np.sin(theta),  rc = midpoints(r),  thetac = midpoints(theta),  zc = midpoints(z),  sphere = (rc - 0.7)^2 + (zc + 0.2*np.cos(thetac*2))^2 < 0.2^2,  hsv = np.zeros(sphere.shape + (3,)),  hsv[..., 0] = thetac / (np.pi*2),  hsv[..., 1] = rc,  hsv[..., 2] = zc + 0.5,  colors = matplotlib.colors.hsv_to_rgb(hsv). ",
    "id": 285
},
{
    "data": " X, Y, Z = axes3d.get_test_data(0.05) ",
    "instruction": " Use the following data to create a 3D wireframe plot: X, Y, Z = axes3d.get_test_data(0.05). ",
    "id": 286
},
{
    "data": "  import time  import matplotlib.pyplot as plt import numpy as np  fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Make the X, Y meshgrid. xs = np.linspace(-1, 1, 50) ys = np.linspace(-1, 1, 50) X, Y = np.meshgrid(xs, ys)  # Set the z axis limits, so they aren't recalculated each frame. ax.set_zlim(-1, 1)  # Begin plotting. wframe = None tstart = time.time() for phi in np.linspace(0, 180. / np.pi, 100):     # If a line collection is already remove it before drawing.     if wframe:         wframe.remove()     # Generate data.     Z = np.cos(2 * np.pi * X + phi) * (1 - np.hypot(X, Y))     # Plot the new wireframe and pause briefly before continuing.     wframe = ax.plot_wireframe(X, Y, Z, rstride=2, cstride=2)     plt.pause(.001)  print('Average FPS: %f' % (100 / (time.time() - tstart)))  ",
    "instruction": "  Animate a 3D wireframe plot. Create a figure with a 3D axis. Generate a meshgrid with X and Y coordinates. Set the z-axis limits to -1 and 1. Iterate through a range of values for phi and for each value, remove the existing wireframe if it exists and generate a new wireframe using the formula np.cos(2 * np.pi * X + phi) * (1 - np.hypot(X, Y)). Plot the new wireframe and pause briefly between frames. Print the average frames per second at the end. ",
    "id": 287
},
{
    "data": "  X, Y, Z = axes3d.get_test_data(0.05)  ",
    "instruction": "  To generate a 3D wireframe plot, use the function plot_wireframe from mpl_toolkits.mplot3d. Create two subplots, ax1 and ax2, with a figsize of (8, 12) and set the subplot projection to '3d'. Use the following data to plot the wireframes: X, Y, Z = axes3d.get_test_data(0.05). Set the rstride to 10 and cstride to 0 in the first plot to only generate wireframes in the y = c direction and set the title as 'Column (x) stride set to 0'. Set the rstride to 0 and cstride to 10 in the second plot to only generate wireframes in the x = c direction and set the title as 'Row (y) stride set to 0'. ",
    "id": 288
},
{
    "data": "  - Line 2: fig, (ax1, ax2) = plt.subplots(1, 2) - Line 3: ax1.set_xscale('log') - Line 4: ax1.set_yscale('log') - Line 5: ax1.set_xlim(1e1, 1e3) - Line 6: ax1.set_ylim(1e2, 1e3) - Line 7: ax1.set_aspect(1) - Line 8: ax1.set_title('adjustable = box') - Line 10: ax2.set_xscale('log') - Line 11: ax2.set_yscale('log') - Line 12: ax2.set_adjustable('datalim') - Line 13: ax2.plot([1, 3, 10], [1, 9, 100], 'o-') - Line 14: ax2.set_xlim(1e-1, 1e2) - Line 15: ax2.set_ylim(1e-1, 1e3) - Line 16: ax2.set_aspect(1) - Line 17: ax2.set_title('adjustable = datalim')  ",
    "instruction": "  Create two subplots using matplotlib, with one subplot having an x-axis and y-axis on a logarithmic scale. Set the x-axis limits to 1e1 and 1e3, and the y-axis limits to 1e2 and 1e3. Set the aspect ratio to 1 and title to 'adjustable = box'. The second subplot should also have the x-axis and y-axis on a logarithmic scale, but with an adjustable value of 'datalim'. Plot the points [1, 3, 10] and [1, 9, 100] using a line with markers. Set the x-axis limits to 1e-1 and 1e2, and the y-axis limits to 1e-1 and 1e3. Set the aspect ratio to 1 and title to 'adjustable = datalim'. Finally, show the plot. ",
    "id": 289
},
{
    "data": " np.deg2rad(85) **Code Block 1**: ```python class MercatorLatitudeScale(mscale.ScaleBase):      name = 'mercator'      def __init__(self, axis, *, thresh=np.deg2rad(85), **kwargs):         super().__init__(axis)         if thresh >= np.pi / 2:             raise ValueError('thresh must be less than pi/2')         self.thresh = thresh      def get_transform(self):         return self.MercatorLatitudeTransform(self.thresh)      def set_default_locators_and_formatters(self, axis):         fmt = FuncFormatter(lambda x, pos=None: f'{np.degrees(x):.0f}°')         axis.set(major_locator=FixedLocator(np.radians(range(-90, 90, 10))),                  major_formatter=fmt, minor_formatter=fmt)      def limit_range_for_scale(self, vmin, vmax, minpos):         return max(vmin, -self.thresh), min(vmax, self.thresh)      class MercatorLatitudeTransform(mtransforms.Transform):         input_dims = output_dims = 1          def __init__(self, thresh):             mtransforms.Transform.__init__(self)             self.thresh = thresh          def transform_non_affine(self, a):             masked = ma.masked_where((a < -self.thresh) | (a > self.thresh), a)             if masked.mask.any():                 return ma.log(np.abs(ma.tan(masked) + 1 / ma.cos(masked)))             else:                 return np.log(np.abs(np.tan(a) + 1 / np.cos(a)))          def inverted(self):             return MercatorLatitudeScale.InvertedMercatorLatitudeTransform(                 self.thresh)      class InvertedMercatorLatitudeTransform(mtransforms.Transform):         input_dims = output_dims = 1          def __init__(self, thresh):             mtransforms.Transform.__init__(self)             self.thresh = thresh          def transform_non_affine(self, a):             return np.arctan(np.sinh(a))          def inverted(self):             return MercatorLatitudeScale.MercatorLatitudeTransform(self.thresh)   mscale.register_scale(MercatorLatitudeScale)   if __name__ == '__main__':     import matplotlib.pyplot as plt      t = np.arange(-180.0, 180.0, 0.1)     s = np.radians(t) / 2.      plt.plot(t, s, '-', lw=2)     plt.yscale('mercator')      plt.xlabel('Longitude')     plt.ylabel('Latitude')     plt.title('Mercator projection')     plt.grid(True)      plt.show() ``` ",
    "instruction": " Create a custom scale called `MercatorLatitudeScale` to implement the scaling used for latitude data in a Mercator Projection. Register the custom scale using `mscale.register_scale()`. Use the following data to plot a graph using the custom scale: `t = np.arange(-180.0, 180.0, 0.1)` and `s = np.radians(t)/2.`. Plot the graph using `plt.plot(t, s, '-', lw=2)` and set the y-axis scale to `'mercator'` using `plt.yscale('mercator')`. Set the x-axis label to `'Longitude'`, y-axis label to `'Latitude'`, and title to `'Mercator projection'`. Display the grid on the plot using `plt.grid(True)` and show the plot using `plt.show()`. ",
    "id": 290
},
{
    "data": " data = ((3, 1000), (10, 3), (100, 30), (500, 800), (50, 1)), dim = len(data[0]), w = 0.75, dimw = w / dim  ",
    "instruction": " Create a bar plot with a logarithmic y-axis using matplotlib. Use the following data to plot it: data = ((3, 1000), (10, 3), (100, 30), (500, 800), (50, 1)), dim = len(data[0]), w = 0.75, dimw = w / dim. ",
    "id": 291
},
{
    "data": "  t = np.arange(0.01, 20.0, 0.01) x = 10.0**np.linspace(0.0, 2.0, 20) y = x**2.0  ",
    "instruction": "  To create four plots with logarithmic axes, use the following functions from matplotlib: semilogy, semilogx, loglog, and errorbar.  For the first plot, use the data t and np.exp(-t / 5.0) to create a semilogy plot. Set the title of the plot to \"semilogy\" and add a grid.  For the second plot, use the data t and np.sin(2 * np.pi * t) to create a semilogx plot. Set the title of the plot to \"semilogx\" and add a grid. For the third plot, use the data t and 20 * np.exp(-t / 10.0) to create a loglog plot. Set the title of the plot to \"loglog base 2 on x\" and add a grid. Set the x-axis scale to logarithmic with a base of 2. For the fourth plot, use the data x, y, and errorbars to create a plot with errorbars. Set the title of the plot to \"Errorbars go negative\". Set the x and y axis scales to logarithmic with non-positive values clipped. Set the x-axis error to 0.1 * x and the y-axis error to 5.0 + 0.75 * y. Set the y-axis limit to a minimum value of 0.1. ",
    "id": 292
},
{
    "data": " xmax = 10  x = np.linspace(-xmax, xmax, 10000) cdf_norm = [math.erf(w / np.sqrt(2)) / 2 + 1 / 2 for w in x] cdf_laplacian = np.where(x < 0, 1 / 2 * np.exp(x), 1 - 1 / 2 * np.exp(-x)) cdf_cauchy = np.arctan(x) / np.pi + 1 / 2  ",
    "instruction": " Create a figure with 3 rows and 2 columns using matplotlib. Plot three lines on each subplot using the given data: cdf_norm, cdf_laplacian, and cdf_cauchy. Use logit scale for the first two plots in the first row, and linear scale for the plots in the second and third rows. Set appropriate axis limits and titles for each subplot. ",
    "id": 293
},
{
    "data": "  np.random.seed(19680801)  data = np.vstack([     multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),     multivariate_normal([30, 20], [[3, 1], [1, 3]], size=1000) ])  gammas = [0.8, 0.5, 0.3]  ",
    "instruction": "  To create a plot exploring normalizations on a multivariate normal distribution, use the following functions and modules from matplotlib: matplotlib.colors, matplotlib.colors.PowerNorm, matplotlib.axes.Axes.hist2d, and matplotlib.pyplot.hist2d. The data used for the plot is as follows:  - np.random.seed(19680801) - data = np.vstack([multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000), multivariate_normal([30, 20], [[3, 1], [1, 3]], size=1000)]) - gammas = [0.8, 0.5, 0.3]. ",
    "id": 294
},
{
    "data": "  np.random.seed(19680801) y = np.random.normal(loc=0.5, scale=0.4, size=1000) y = y[(y > 0) & (y < 1)] y.sort() x = np.arange(len(y))  ",
    "instruction": "  Create a figure with 3 rows and 2 columns, each with a different scale transformation applied to the y-axis. Use the following scales for the subplots: 'linear', 'log', 'symlog', 'logit', and 'function'. Use the data y = np.random.normal(loc=0.5, scale=0.4, size=1000), and x = np.arange(len(y)). Plot y against x for each subplot. ",
    "id": 295
},
{
    "data": "  dt = 0.01 t = np.arange(dt, 20.0, dt)  ",
    "instruction": "  Create a plot with a log-scale x-axis using the semilogx function from matplotlib. Use the following data to create the plot: dt = 0.01, t = np.arange(dt, 20.0, dt). ",
    "id": 296
},
{
    "data": " dt = 0.01 x = np.arange(-50.0, 50.0, dt) y = np.arange(0, 100.0, dt)  ",
    "instruction": " Use the matplotlib function plot to create three subplots with symlog scaling for the x-axis in the first subplot and both the x-axis and y-axis in the third subplot. Set the ylabel of the first subplot to 'symlogx' and the ylabel of the third subplot to 'symlog both'. Additionally, set minor grid lines on the x-axis in the first subplot and enable grid lines in the third subplot. ",
    "id": 297
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]:  species = (\"Adelie\\\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\\\n $\\\\\\\\mu=5076.02g$\") weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = (\"Adelie\\\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\\\n $\\\\\\\\mu=5076.02g$\"), weight_counts = {'Below': np.array([70, 31, 58]), 'Above': np.array([82, 37, 66])}.  [DATA]:  No data preparation blocks found in the provided code. ",
    "id": 298
},
{
    "data": " x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] y2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74] y3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73] x4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8] y4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89]  ",
    "instruction": " Create a 2x2 grid of plots in matplotlib. Share the x-axis and y-axis among the plots. Set the figure size to (6, 6) and the spacing between the plots to 0.08. For each plot, use the corresponding dataset from the following dictionary:   datasets = {     'I': (x, y1),     'II': (x, y2),     'III': (x, y3),     'IV': (x4, y4) }  In each plot, plot the x-values against the y-values using 'o' markers. Perform linear regression for each dataset and plot the regression line using 'r' color. Calculate and display the following statistics on each plot: mean, standard deviation, and correlation coefficient. ",
    "id": 299
},
{
    "data": "  import numpy as np  def hinton(matrix, max_weight=None, ax=None):     '''Draw Hinton diagram for visualizing a weight matrix.'''     ax = ax if ax is not None else plt.gca()      if not max_weight:         max_weight = 2 ** np.ceil(np.log2(np.abs(matrix).max()))      ax.patch.set_facecolor('gray')     ax.set_aspect('equal', 'box')     ax.xaxis.set_major_locator(plt.NullLocator())     ax.yaxis.set_major_locator(plt.NullLocator())      for (x, y), w in np.ndenumerate(matrix):         color = 'white' if w > 0 else 'black'         size = np.sqrt(abs(w) / max_weight)         rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,                              facecolor=color, edgecolor=color)         ax.add_patch(rect)      ax.autoscale_view()     ax.invert_yaxis()   if __name__ == '__main__':     # Fixing random state for reproducibility     np.random.seed(19680801)      hinton(np.random.rand(20, 20) - 0.5)     plt.show()  ",
    "instruction": "  Create a Hinton diagram using the provided function hinton. Follow the relevant context to understand the purpose of the diagram. ",
    "id": 300
},
{
    "data": "  data = {     'Method': ['Time consumption', 'Cost', 'Procedures', 'Inefficient process', 'Sampling'],     'Machine': ['Faulty equipment', 'Compatibility'],     'Material': ['Poor-quality input', 'Raw materials', 'Supplier', 'Shortage'],     'Measurement': ['Calibration', 'Performance', 'Wrong measurements'],     'Environment': ['Bad conditions'],     'People': ['Lack of training', 'Managers', 'Labor shortage', 'Procedures', 'Sales strategy'] }  ",
    "instruction": "  To generate an Ishikawa diagram using matplotlib, use the provided draw_body function. Use the following data to plot the diagram:  data = {     'Method': ['Time consumption', 'Cost', 'Procedures', 'Inefficient process', 'Sampling'],     'Machine': ['Faulty equipment', 'Compatibility'],     'Material': ['Poor-quality input', 'Raw materials', 'Supplier', 'Shortage'],     'Measurement': ['Calibration', 'Performance', 'Wrong measurements'],     'Environment': ['Bad conditions'],     'People': ['Lack of training', 'Managers', 'Labor shortage', 'Procedures', 'Sales strategy'] }  The diagram represents an Ishikawa diagram (also known as a fishbone diagram or cause-and-effect diagram) which is used to identify problems in a system and show how causes and effects are linked. ",
    "id": 301
},
{
    "data": "   np.arange(17) + 1  cmap = mpl.cm.viridis norm = mpl.colors.Normalize(vmin=1, vmax=17)  cmap2 = mpl.cm.cool norm2 = mpl.colors.Normalize(vmin=1, vmax=17)  cmap3 = (mpl.colors.ListedColormap(['r', 'g', 'b', 'c'])          .with_extremes(over='0.35', under='0.75'))          bounds = [2, 3, 7, 9, 15] norm3 = mpl.colors.BoundaryNorm(bounds, cmap3.N)  ",
    "instruction": "   Create a figure with 3 subplots arranged horizontally. Set the layout of the figure to have a size of 10x5. Set the title of the window to 'Left Ventricle Bulls Eyes (AHA)'. Use polar projection for each subplot.   Create a horizontal colorbar in the first subplot using the colormap 'viridis' and the normalization range from 1 to 17. Label the colorbar as 'Some units'.  Create a horizontal colorbar in the second subplot using the colormap 'cool' and the normalization range from 1 to 17. Label the colorbar as 'Some other units'.  Create a horizontal colorbar in the third subplot using the colormap specified by the listed colors ['r', 'g', 'b', 'c']. Set the colorbar boundaries as [2, 3, 7, 9, 15] and use the color extremes '0.35' for over and '0.75' for under. Label the colorbar as 'Discrete intervals, some other units'.  Create a \"Bulls Eye (AHA)\" plot in the first subplot using the function `bullseye_plot()`. Use the provided data `np.arange(17) + 1` as the intensity values for each of the 17 segments. Set the colormap to 'viridis' and the normalization to `norm`.  Set the title of the first subplot to 'Bulls Eye (AHA)'.  Create a \"Bulls Eye (AHA)\" plot in the second subplot using the function `bullseye_plot()`. Use the provided data `np.arange(17) + 1` as the intensity values for each of the 17 segments. Set the colormap to 'cool' and the normalization to `norm2`.  Set the title of the second subplot to 'Bulls Eye (AHA)'.  Create a \"Bulls Eye (AHA)\" plot in the third subplot using the function `bullseye_plot()`. Use the provided data `np.arange(17) + 1` as the intensity values for each of the 17 segments. Set the colormap to the listed colors ['r', 'g', 'b', 'c'] and the normalization to `norm3`. Highlight the segments [3, 5, 6, 11, 12, 16] by setting them as bold.  Set the title of the third subplot to 'Segments [3, 5, 6, 11, 12, 16] in bold'.  Display the plot. ",
    "id": 302
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.cbook as cbook  fig, axd = plt.subplot_mosaic(     [['image', 'density'],      ['EEG', 'EEG']],     layout='constrained',     width_ratios=[1.05, 2], ) with cbook.get_sample_data('s1045.ima.gz') as dfile:     im = np.frombuffer(dfile.read(), np.uint16).reshape((256, 256))  im = im[im.nonzero()] axd['image'].imshow(im, cmap='gray') axd['image'].axis('off')  im = im[im.nonzero()] axd['density'].hist(im, bins=np.arange(0, 2**16+1, 512)) axd['density'].set(xlabel='Intensity (a.u.)', xlim=(0, 2**16),                    ylabel='MRI density', yticks=[]) axd['density'].minorticks_on()  n_samples, n_rows = 800, 4 with cbook.get_sample_data('eeg.dat') as eegfile:     data = np.fromfile(eegfile, dtype=float).reshape((n_samples, n_rows)) t = 10 * np.arange(n_samples) / n_samples  axd['EEG'].set_xlabel('Time (s)') axd['EEG'].set_xlim(0, 10) dy = (data.min() - data.max()) * 0.7 axd['EEG'].set_ylim(-dy, n_rows * dy) axd['EEG'].set_yticks([0, dy, 2*dy, 3*dy], labels=['PG3', 'PG5', 'PG7', 'PG9'])  for i, data_col in enumerate(data.T):     axd['EEG'].plot(t, data_col + i*dy, color='C0')  plt.show()  ",
    "instruction": "  Create a set of subplots using the function `plt.subplot_mosaic`. The layout should be 'constrained' and the width ratios should be [1.05, 2]. Use the following data to generate the plots:   - Load the MRI data from the file 's1045.ima.gz' using `cbook.get_sample_data`. Store it in the variable `im`. - Display the MRI image in the subplot with the key 'image' using `imshow` with colormap 'gray'. - Remove the axis from the 'image' subplot using `axis('off')`. - Compute the histogram of the MRI intensity from the nonzero elements of `im` and store it in the 'density' subplot using `hist`. Use the bins np.arange(0, 2**16+1, 512). - Set the x-label of the 'density' subplot to 'Intensity (a.u.)' and the y-label to 'MRI density'. Set the x-limit to (0, 2**16). - Load the EEG data from the file 'eeg.dat' using `cbook.get_sample_data`. Store it in the variable `data`. Reshape it to have shape (n_samples, n_rows), where n_samples=800 and n_rows=4. - Compute the variable `t` as 10 * np.arange(n_samples) / n_samples. - Set the x-label of the 'EEG' subplot to 'Time (s)' and x-limits to (0, 10). - Set the y-limits of the 'EEG' subplot to -dy and n_rows * dy, where dy is (data.min() - data.max()) * 0.7. - Set the y-ticks of the 'EEG' subplot to [0, dy, 2*dy, 3*dy] with labels ['PG3', 'PG5', 'PG7', 'PG9']. - Plot each column of `data` against `t` in the 'EEG' subplot using `plot`. Set the color to 'C0'. ",
    "id": 303
},
{
    "data": "[DATA]: \r import matplotlib.pyplot as plt\r import numpy as np\r \r from matplotlib.patches import Circle, RegularPolygon\r from matplotlib.path import Path\r from matplotlib.projections import register_projection\r from matplotlib.projections.polar import PolarAxes\r from matplotlib.spines import Spine\r  ",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 304
},
{
    "data": " links_per_side = 6    def side(sankey, n=1):     '''Generate a side chain.'''     prior = len(sankey.diagrams)     for i in range(0, 2*n, 2):         sankey.add(flows=[1, -1], orientations=[-1, -1],                    patchlabel=str(prior + i),                    prior=prior + i - 1, connect=(1, 0), alpha=0.5)         sankey.add(flows=[1, -1], orientations=[1, 1],                    patchlabel=str(prior + i + 1),                    prior=prior + i, connect=(1, 0), alpha=0.5)  def corner(sankey):     '''Generate a corner link.'''     prior = len(sankey.diagrams)     sankey.add(flows=[1, -1], orientations=[0, 1],                patchlabel=str(prior), facecolor='k',                prior=prior - 1, connect=(1, 0), alpha=0.5)   ",
    "instruction": " Use the following functions from matplotlib: Sankey, add, finish, to create a long chain of connections using the Sankey class. Here is the code you can use: ```python import matplotlib.pyplot as plt from matplotlib.sankey import Sankey  links_per_side = 6  def side(sankey, n=1):     '''Generate a side chain.'''     prior = len(sankey.diagrams)     for i in range(0, 2*n, 2):         sankey.add(flows=[1, -1], orientations=[-1, -1],                    patchlabel=str(prior + i),                    prior=prior + i - 1, connect=(1, 0), alpha=0.5)         sankey.add(flows=[1, -1], orientations=[1, 1],                    patchlabel=str(prior + i + 1),                    prior=prior + i, connect=(1, 0), alpha=0.5)  def corner(sankey):     '''Generate a corner link.'''     prior = len(sankey.diagrams)     sankey.add(flows=[1, -1], orientations=[0, 1],                patchlabel=str(prior), facecolor='k',                prior=prior - 1, connect=(1, 0), alpha=0.5)   fig = plt.figure() ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],                      title='Why would you want to do this?\\n(But you could.)') sankey = Sankey(ax=ax, unit=None) sankey.add(flows=[1, -1], orientations=[0, 1],            patchlabel='0', facecolor='k',            rotation=45) side(sankey, n=links_per_side) corner(sankey) side(sankey, n=links_per_side) corner(sankey) side(sankey, n=links_per_side) corner(sankey) side(sankey, n=links_per_side) sankey.finish() plt.show() ```  This code will create a long chain of connections using the Sankey class. You can adjust the number of links per side by changing the value of `links_per_side`. ",
    "id": 305
},
{
    "data": "  Hdot = [260.431, 35.078, 180.794, 221.115, 22.700, 142.361, 10.193, 10.210, 43.670, 44.312, 68.631, 10.758, 10.758, 0.017, 0.642, 232.121, 44.559, 100.613, 132.168]  # MW  ",
    "instruction": "  Use the following functions from matplotlib: Sankey, plt.subplots, plt.figure, plt.show, ax.bar, ax.set_title, ax.legend, Sankey.add, for creating a Sankey diagram for the Rankine Power Cycle example. Use the following data in the Sankey diagram: Hdot = [260.431, 35.078, 180.794, 221.115, 22.700, 142.361, 10.193, 10.210, 43.670, 44.312, 68.631, 10.758, 10.758, 0.017, 0.642, 232.121, 44.559, 100.613, 132.168]. ",
    "id": 306
},
{
    "data": "[DATA]: from contextlib import ExitStack  from matplotlib.axes import Axes import matplotlib.axis as maxis from matplotlib.projections import register_projection import matplotlib.spines as mspines import matplotlib.transforms as transforms   # The sole purpose of this class is to look at the upper, lower, or total # interval as appropriate and see what parts of the tick to draw, if any. class SkewXTick(maxis.XTick):     def draw(self, renderer):         # When adding the callbacks with `stack.callback`, we fetch the current         # visibility state of the artist with `get_visible`; the ExitStack will         # restore these states (`set ",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 307
},
{
    "data": "  d = get_sample_data('jacksboro_fault_dem.npz') z = d['elevation'] dx, dy = d['dx'], d['dy'] dy = 111200 * dy dx = 111200 * dx * np.cos(np.radians(d['ymin'])) ls = LightSource(azdeg=315, altdeg=45) cmap = plt.cm.gist_earth  ",
    "instruction": "  To create a plot demonstrating topographic hillshading, use the following data:  d = get_sample_data('jacksboro_fault_dem.npz') z = d['elevation'] dx, dy = d['dx'], d['dy'] dy = 111200 * dy dx = 111200 * dx * np.cos(np.radians(d['ymin'])) ls = LightSource(azdeg=315, altdeg=45) cmap = plt.cm.gist_earth  Use the following functions from `matplotlib` to create the plot: `imshow` and `shade`. Vary the vertical exaggeration and blend mode for different combinations. ",
    "id": 308
},
{
    "data": " x = np.linspace(0, 2 * np.pi, 100) y = 2 * np.sin(x) ",
    "instruction": " Use the following data to create a plot with three subplots. The first subplot should have normal spines, the second subplot should have only left and bottom spines, and the third subplot should have spines with bounds limited to the data range. ",
    "id": 309
},
{
    "data": "  x = np.linspace(0, 2 * np.pi, 100)  ",
    "instruction": "  Generate a dropped spines demo plot using matplotlib. Use the following data to create the plot: x = np.linspace(0, 2 * np.pi, 100). ",
    "id": 310
},
{
    "data": "  fig, ax = plt.subplots() fig.subplots_adjust(right=0.75) twin1 = ax.twinx() twin2 = ax.twinx() twin2.spines.right.set_position(('axes', 1.2)) p1, = ax.plot([0, 1, 2], [0, 1, 2], 'C0', label='Density') p2, = twin1.plot([0, 1, 2], [0, 3, 2], 'C1', label='Temperature') p3, = twin2.plot([0, 1, 2], [50, 30, 15], 'C2', label='Velocity') ax.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density') twin1.set(ylim=(0, 4), ylabel='Temperature') twin2.set(ylim=(1, 65), ylabel='Velocity') ax.yaxis.label.set_color(p1.get_color()) twin1.yaxis.label.set_color(p2.get_color()) twin2.yaxis.label.set_color(p3.get_color()) ax.tick_params(axis='y', colors=p1.get_color()) twin1.tick_params(axis='y', colors=p2.get_color()) twin2.tick_params(axis='y', colors=p3.get_color()) ax.legend(handles=[p1, p2, p3])  ",
    "instruction": "  To create a plot with multiple y-axes in matplotlib, use the following steps:  1. Import the necessary libraries:     import matplotlib.pyplot as plt  2. Create a figure and axes:     fig, ax = plt.subplots()    fig.subplots_adjust(right=0.75)  3. Create twin axes for the additional y-axes:     twin1 = ax.twinx()    twin2 = ax.twinx()  4. Offset the right spine of twin2:     twin2.spines.right.set_position(('axes', 1.2))  5. Plot the data on each axis:     p1, = ax.plot([0, 1, 2], [0, 1, 2], 'C0', label='Density')    p2, = twin1.plot([0, 1, 2], [0, 3, 2], 'C1', label='Temperature')    p3, = twin2.plot([0, 1, 2], [50, 30, 15], 'C2', label='Velocity')  6. Set the labels and limits for each axis:     ax.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density')    twin1.set(ylim=(0, 4), ylabel='Temperature')    twin2.set(ylim=(1, 65), ylabel='Velocity')  7. Adjust the colors and tick parameters for each axis:     ax.yaxis.label.set_color(p1.get_color())    twin1.yaxis.label.set_color(p2.get_color())    twin2.yaxis.label.set_color(p3.get_color())    ax.tick_params(axis='y', colors=p1.get_color())    twin1.tick_params(axis='y', colors=p2.get_color())    twin2.tick_params(axis='y', colors=p3.get_color())  8. Add a legend to the plot:     ax.legend(handles=[p1, p2, p3])  9. Display the plot:     plt.show() ",
    "id": 311
},
{
    "data": "  x = np.linspace(-0.5, 1., 100)  ",
    "instruction": "  To create a \"math textbook\" style plot with centered spines and arrows at the ends, use the following code snippet:  ```python import matplotlib.pyplot as plt import numpy as np  fig, ax = plt.subplots()  # Move the left and bottom spines to x = 0 and y = 0, respectively. ax.spines[['left', 'bottom']].set_position(('data', 0)) # Hide the top and right spines. ax.spines[['top', 'right']].set_visible(False)  # Draw arrows (as black triangles: '>k'/'^k') at the end of the axes. In each # case, one of the coordinates (0) is a data coordinate (i.e., y = 0 or x = 0, # respectively) and the other one (1) is an axes coordinate (i.e., at the very # right/top of the axes). Also, disable clipping (clip_on=False) as the marker # actually spills out of the axes. ax.plot(1, 0, '>k', transform=ax.get_yaxis_transform(), clip_on=False) ax.plot(0, 1, '^k', transform=ax.get_xaxis_transform(), clip_on=False)  # Some sample data. x = np.linspace(-0.5, 1., 100) ax.plot(x, np.sin(x*np.pi))  plt.show() ```  This code will produce a plot with centered spines and arrows at the ends. The main steps involve moving the left and bottom spines to x = 0 and y = 0 respectively, hiding the top and right spines, and drawing arrows at the ends of the axes using black triangles. Finally, some sample data (x and np.sin(x*np.pi)) is plotted on the axes. ",
    "id": 312
},
{
    "data": " money = [1.5e5, 2.5e6, 5.5e6, 2.0e7], ",
    "instruction": " Use the following data to create a bar chart: money = [1.5e5, 2.5e6, 5.5e6, 2.0e7]. Set the y-axis tick labels format to display values in millions of dollars. ",
    "id": 313
},
{
    "data": " date1 = datetime.datetime(2000, 3, 2) date2 = datetime.datetime(2000, 3, 6) delta = datetime.timedelta(hours=6) dates = drange(date1, date2, delta)  y = np.arange(len(dates))  ",
    "instruction": " Use the following data to create a plot with dates on the x-axis:  date1 = datetime.datetime(2000, 3, 2) date2 = datetime.datetime(2000, 3, 6) delta = datetime.timedelta(hours=6) dates = drange(date1, date2, delta) y = np.arange(len(dates))  Plot the data using ax.plot(dates, y**2, 'o'). Set the x-axis limits using ax.set_xlim(dates[0], dates[-1]). Use DayLocator() as the major locator for the x-axis and HourLocator(range(0, 25, 6)) as the minor locator. Format the major ticks on the x-axis as '%Y-%m-%d' using DateFormatter('%Y-%m-%d'). Finally, display the plot using plt.show(). ",
    "id": 314
},
{
    "data": "  np.random.seed(19680801)  rule = rrulewrapper(YEARLY, byeaster=1, interval=5) loc = RRuleLocator(rule) formatter = DateFormatter('%m/%d/%y') date1 = datetime.date(1952, 1, 1) date2 = datetime.date(2004, 4, 12) delta = datetime.timedelta(days=100)  dates = drange(date1, date2, delta) s = np.random.rand(len(dates))  ",
    "instruction": "  Create a line plot using matplotlib to display data points plotted against dates. Place custom date ticks on the x-axis using recurrence rules. Set the tick interval to every 5th Easter and format the tick labels to show the dates in the format of month/day/year. ",
    "id": 315
},
{
    "data": " np.random.seed(19680801)  ",
    "instruction": " Use the following functions from matplotlib: subplots, plot, yaxis.set_major_formatter, yaxis.set_tick_params, to create a plot with the following data. Set the y-axis ticks to have a dollar sign as a prefix on the labels. Use the following data to create the plot: np.random.seed(19680801).  ",
    "id": 316
},
{
    "data": " x = np.arange(0, 1, .01)  ",
    "instruction": " Create a 3x3 grid of subplots using matplotlib, with a figure size of 9x9. In the first column, plot x * 1e5 + 1e10 vs x * 1e-10 + 1e-5. In the second column, plot x * 1e5 vs x * 1e-4. In the third column, plot -x * 1e5 - 1e10 vs -x * 1e-5 - 1e-10. For the plots in the second column, use math text formatting for the tick labels. For the plots in the third column, do not use offset notation. Set the title weight to bold and position the titles slightly above the default position. The first subplot should have the title \"default settings\", the second subplot should have the title \"useMathText=True\", and the third subplot should have the title \"useOffset=False\". ",
    "id": 317
},
{
    "data": " np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape).  [DATA]: species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\") weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])} [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adeleii $\\\\mu=$2805.45g\", \"Chingstopy $\\\\mu=$2961.34g\", \"RrtooDetoo\\\\n $\\\\mu=4237.51g$\"), weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}.  [DATA]: The data used in the code is not available for processing. ",
    "id": 318
},
{
    "data": " ``` setup(ax, title):     '''Set up common parameters for the Axes in the example.'''     # only show the bottom spine     ax.yaxis.set_major_locator(ticker.NullLocator())     ax.spines[['left', 'right', 'top']].set_visible(False)      ax.xaxis.set_ticks_position('bottom')     ax.tick_params(which='major', width=1.00, length=5)     ax.tick_params(which='minor', width=0.75, length=2.5)     ax.set_xlim(0, 5)     ax.set_ylim(0, 1)     ax.text(0.0, 0.2, title, transform=ax.transAxes,             fontsize=14, fontname='Monospace', color='tab:blue')   fig, axs = plt.subplots(8, 1, figsize=(8, 6))  # Null Locator setup(axs[0], title='NullLocator()') axs[0].xaxis.set_major_locator(ticker.NullLocator()) axs[0].xaxis.set_minor_locator(ticker.NullLocator())  # Multiple Locator setup(axs[1], title='MultipleLocator(0.5, offset=0.2)') axs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5, offset=0.2)) axs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))  # Fixed Locator setup(axs[2], title='FixedLocator([0, 1, 5])') axs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5])) axs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))  # Linear Locator setup(axs[3], title='LinearLocator(numticks=3)') axs[3].xaxis.set_major_locator(ticker.LinearLocator(3)) axs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))  # Index Locator setup(axs[4], title='IndexLocator(base=0.5, offset=0.25)') axs[4].plot([0]*5, color='white') axs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))  # Auto Locator setup(axs[5], title='AutoLocator()') axs[5].xaxis.set_major_locator(ticker.AutoLocator()) axs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())  # MaxN Locator setup(axs[6], title='MaxNLocator(n=4)') axs[6].xaxis.set_major_locator(ticker.MaxNLocator(4)) axs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))  # Log Locator setup(axs[7], title='LogLocator(base=10, numticks=15)') axs[7].set_xlim(10**3, 10**10) axs[7].set_xscale('log') axs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))  plt.tight_layout() plt.show() ```  ",
    "instruction": " Use the following functions from matplotlib: `matplotlib.axis.Axis.set_major_locator`, `matplotlib.axis.Axis.set_minor_locator`, `matplotlib.ticker.NullLocator`, `matplotlib.ticker.MultipleLocator`, `matplotlib.ticker.FixedLocator`, `matplotlib.ticker.LinearLocator`, `matplotlib.ticker.IndexLocator`, `matplotlib.ticker.AutoLocator`, `matplotlib.ticker.MaxNLocator`, and `matplotlib.ticker.LogLocator`, to create a plot with 8 subplots arranged in a column. Each subplot should have a different tick locator. Set up the common parameters for the axes by defining the `setup` function. Use the given data and titles for each subplot in the code:  - Null Locator: `NullLocator()` - Multiple Locator: `MultipleLocator(0.5, offset=0.2)` - Fixed Locator: `FixedLocator([0, 1, 5])` - Linear Locator: `LinearLocator(numticks=3)` - Index Locator: `IndexLocator(base=0.5, offset=0.25)` - Auto Locator: `AutoLocator()` - MaxN Locator: `MaxNLocator(n=4)` - Log Locator: `LogLocator(base=10, numticks=15)`  Ensure that the subplots are properly arranged, the axes are set up with the specified parameters, and the titles are displayed correctly. ",
    "id": 319
},
{
    "data": " x = np.arange(10) ",
    "instruction": " Create a figure with two subplots, each sharing the same x-axis. Plot the data x on both subplots. Set the y-axis tick labels on the left for the first subplot and use the default tick labels for the second subplot. ",
    "id": 320
},
{
    "data": "  xs = range(26) ys = range(26) labels = list('abcdefghijklmnopqrstuvwxyz')  ",
    "instruction": "  To create a plot with custom tick labels, use the following code with matplotlib: import matplotlib.pyplot as plt from matplotlib.ticker import MaxNLocator  fig, ax = plt.subplots()  def format_fn(tick_val, tick_pos):     if int(tick_val) in xs:         return labels[int(tick_val)]     else:         return ''  ax.xaxis.set_major_formatter(format_fn) ax.xaxis.set_major_locator(MaxNLocator(integer=True)) ax.plot(xs, ys)  This code sets the tick labels of the x-axis to custom labels defined in the 'labels' list. The tick values are determined by the 'xs' range. The tick labels are formatted using the 'format_fn' function, which checks if the tick value is in 'xs' and returns the corresponding label from 'labels'. The 'MaxNLocator' is used to ensure that the tick values take integer values. ",
    "id": 321
},
{
    "data": " x = [1, 2, 3, 4] y = [1, 4, 9, 6] labels = ['Frogs Hogs Bogs Slogs'] ",
    "instruction": " Create a line plot using matplotlib. Use the following data to plot it: x = [1, 2, 3, 4], y = [1, 4, 9, 6], labels = ['Frogs Hogs Bogs Slogs']. Rotate the tick labels vertically and adjust the margins and spacing to prevent clipping. ",
    "id": 322
},
{
    "data": "  from basic_units import cm  import matplotlib.pyplot as plt  fig, ax = plt.subplots()  ax.annotate('Note 01', [0.5*cm, 0.5*cm])  # xy and text both unitized ax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',             xytext=(0.8*cm, 0.95*cm), textcoords='data',             arrowprops=dict(facecolor='black', shrink=0.05),             horizontalalignment='right', verticalalignment='top')  # mixing units w/ nonunits ax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',             xytext=(0.8, 0.95), textcoords='axes fraction',             arrowprops=dict(facecolor='black', shrink=0.05),             horizontalalignment='right', verticalalignment='top')   ax.set_xlim(0*cm, 4*cm) ax.set_ylim(0*cm, 4*cm) plt.show()  ",
    "instruction": "  Create a plot using matplotlib with the following features: - Annotate the point (0.5cm, 0.5cm) with the text 'Note 01'. - Annotate the point (3cm, 1cm) with the text 'local max'. Use data coordinates for both the point and the text. Place the text at (0.8cm, 0.95cm) with an arrow pointing to the point. The arrow color should be black and the arrow size should be shrunk by 0.05. The text should be aligned to the right and top. - Annotate the point (3cm, 1cm) with the text 'local max'. Mix units (cm) with non-units (axes fraction) in the point and text coordinates. Place the text at (0.8, 0.95) with an arrow pointing to the point. The arrow color should be black and the arrow size should be shrunk by 0.05. The text should be aligned to the right and top. - Set the x-axis limits to 0cm and 4cm. - Set the y-axis limits to 0cm and 4cm. ",
    "id": 323
},
{
    "data": " import random  from basic_units import cm, inch  import matplotlib.pyplot as plt import numpy as np  import matplotlib.collections as collections import matplotlib.lines as lines import matplotlib.patches as patches import matplotlib.text as text  fig, ax = plt.subplots() ax.xaxis.set_units(cm) ax.yaxis.set_units(cm)  # Fixing random state for reproducibility np.random.seed(19680801)  if 0:     # test a line collection     # Not supported at present.     verts = []     for i in range(10):         # a random line segment in inches         verts.append(zip(*inch*10*np.random.rand(2, random.randint(2, 15))))     lc = collections.LineCollection(verts, axes=ax)     ax.add_collection(lc)  # test a plain-ol-line line = lines.Line2D([0*cm, 1.5*cm], [0*cm, 2.5*cm],                     lw=2, color='black', axes=ax) ax.add_line(line)  if 0:     # test a patch     # Not supported at present.     rect = patches.Rectangle((1*cm, 1*cm), width=5*cm, height=2*cm,                              alpha=0.2, axes=ax)     ax.add_patch(rect)   t = text.Text(3*cm, 2.5*cm, 'text label', ha='left', va='bottom', axes=ax) ax.add_artist(t)  ax.set_xlim(-1*cm, 10*cm) ax.set_ylim(-1*cm, 10*cm) # ax.xaxis.set_units(inch) ax.grid(True) ax.set_title('Artists with units') plt.show()  ",
    "instruction": " Create a plot using matplotlib by utilizing various artists types such as lines, patches, and text. Set the units for the x-axis and y-axis to centimeters. Use the following data to create the plot:  t = text.Text(3*cm, 2.5*cm, 'text label', ha='left', va='bottom', axes=ax)  ax.set_xlim(-1*cm, 10*cm) ax.set_ylim(-1*cm, 10*cm) ax.grid(True) ax.set_title('Artists with units') ",
    "id": 324
},
{
    "data": "  cms = cm * np.arange(0, 10, 2) bottom = 0 * cm width = 0.8 * cm  ",
    "instruction": "  Create a bar plot using matplotlib with units. Use the following data to plot it: cms = cm * np.arange(0, 10, 2), bottom = 0 * cm, width = 0.8 * cm. The plot should consist of 2 rows and 2 columns.  In the first row, first column, create a bar plot with x and y values equal to cms and bottom equal to bottom.  In the first row, second column, create a bar plot with x and y values equal to cms, bottom equal to bottom, width equal to width, x units equal to cm, and y units equal to inch.  In the second row, first column, create a bar plot with x and y values equal to cms, bottom equal to bottom, width equal to width, x units equal to inch, and y units equal to cm. Set the x-axis limits to the range from 2 to 6.  In the second row, second column, create a bar plot with x and y values equal to cms, bottom equal to bottom, width equal to width, x units equal to inch, and y units equal to inch. Set the x-axis limits to the range from 2 cm to 6 cm (converted to inches). ",
    "id": 325
},
{
    "data": "  N = 5 tea_means = [15*cm, 10*cm, 8*cm, 12*cm, 5*cm] tea_std = [2*cm, 1*cm, 1*cm, 4*cm, 2*cm] coffee_means = (14*cm, 19*cm, 7*cm, 5*cm, 10*cm) coffee_std = (3*cm, 5*cm, 2*cm, 1*cm, 2*cm)  ",
    "instruction": "  Create a group bar chart with units using matplotlib. Use the following data to plot it:  N = 5,  tea_means = [15*cm, 10*cm, 8*cm, 12*cm, 5*cm],  tea_std = [2*cm, 1*cm, 1*cm, 4*cm, 2*cm],  coffee_means = (14*cm, 19*cm, 7*cm, 5*cm, 10*cm),  coffee_std = (3*cm, 5*cm, 2*cm, 1*cm, 2*cm). ",
    "id": 326
},
{
    "data": "THIS DATA IS TOO LONG FOR GPT-3.5's CONTEXT WINDOW",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 327
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  import matplotlib.ticker as ticker import matplotlib.units as units   class Foo:     def __init__(self, val, unit=1.0):         self.unit = unit         self._val = val * unit      def value(self, unit):         if unit is None:             unit = self.unit         return self._val / unit   class FooConverter(units.ConversionInterface):     @staticmethod     def axisinfo(unit, axis):         '''Return the Foo AxisInfo.'''         if unit == 1.0 or unit == 2.0:             return units.AxisInfo(                 majloc=ticker.IndexLocator(8, 0),                 majfmt=ticker.FormatStrFormatter('VAL: %s'),                 label='foo',                 )          else:             return None      @staticmethod     def convert(obj, unit, axis):         '''         Convert *obj* using *unit*.          If *obj* is a sequence, return the converted sequence.         '''         if np.iterable(obj):             return [o.value(unit) for o in obj]         else:             return obj.value(unit)      @staticmethod     def default_units(x, axis):         '''Return the default unit for *x* or None.'''         if np.iterable(x):             for thisx in x:                 return thisx.unit         else:             return x.unit   units.registry[Foo] = FooConverter()  # create some Foos x = [Foo(val, 1.0) for val in range(0, 50, 2)] # and some arbitrary y data y = [i for i in range(len(x))]  fig, (ax1, ax2) = plt.subplots(1, 2) fig.suptitle('Custom units') fig.subplots_adjust(bottom=0.2)  # plot specifying units ax2.plot(x, y, 'o', xunits=2.0) ax2.set_title('xunits = 2.0') plt.setp(ax2.get_xticklabels(), rotation=30, ha='right')  # plot without specifying units; will use the None branch for axisinfo ax1.plot(x, y)  # uses default units ax1.set_title('default units') plt.setp(ax1.get_xticklabels(), rotation=30, ha='right')  plt.show()  ",
    "instruction": "  This code snippet creates a custom units plot using matplotlib. It defines a class called Foo, which has a value and a unit. It also defines a converter for Foo units. The code then creates a list of Foo objects, 'x', and an arbitrary list of integers, 'y'.   To create the plot, it creates two subplots using plt.subplots(). The first subplot, ax1, uses the default units for the x-axis and plots 'x' against 'y'. The second subplot, ax2, specifies the x-axis units as 2.0 and plots 'x' against 'y' with markers. The plot's title is set to \"Custom units\".   Finally, the plot is displayed using plt.show(). ",
    "id": 328
},
{
    "data": " x = [val*radians for val in np.arange(0, 15, 0.01)], ",
    "instruction": " Create a plot with two subplots. In the first subplot, plot cos(x) where x ranges from 0 to 15 in increments of 0.01. Specify the x-axis units as radians. In the second subplot, plot cos(x) where x ranges from 0 to 15 in increments of 0.01. Specify the x-axis units as degrees. ",
    "id": 329
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np  cms = cm * np.arange(0, 10, 2)  fig, axs = plt.subplots(2, 2, layout='constrained')  axs[0, 0].plot(cms, cms)  axs[0, 1].plot(cms, cms, xunits=cm, yunits=inch)  axs[1, 0].plot(cms, cms, xunits=inch, yunits=cm) axs[1, 0].set_xlim(-1, 4)  # scalars are interpreted in current units  axs[1, 1].plot(cms, cms, xunits=inch, yunits=inch) axs[1, 1].set_xlim(3*cm, 6*cm)  # cm are converted to inches  plt.show()  ",
    "instruction": "  To create a plot with conversions between inches and centimeters, you can use the following code segment:  import matplotlib.pyplot as plt import numpy as np  cms = cm * np.arange(0, 10, 2)  fig, axs = plt.subplots(2, 2, layout='constrained')  axs[0, 0].plot(cms, cms)  axs[0, 1].plot(cms, cms, xunits=cm, yunits=inch)  axs[1, 0].plot(cms, cms, xunits=inch, yunits=cm) axs[1, 0].set_xlim(-1, 4)  axs[1, 1].plot(cms, cms, xunits=inch, yunits=inch) axs[1, 1].set_xlim(3*cm, 6*cm)  plt.show()  The above code demonstrates how to plot using different units of measurement, specifically centimeters and inches. It creates a 2x2 grid of subplots and shows how to specify the units for each subplot using the xunits and yunits parameters in the plot() function. The resulting plot will have one subplot with a square aspect ratio, one subplot with x-axis in centimeters and y-axis in inches, one subplot with x-axis in inches and y-axis in centimeters (with a specified x-axis limit), and one subplot with both x-axis and y-axis in inches (with a specified x-axis limit). ",
    "id": 330
},
{
    "data": "  data = (1, 2, 3, 4, 5, 6, 7, 8) mask = (1, 0, 1, 0, 0, 0, 1, 0) xsecs = secs * np.ma.MaskedArray(data, mask, float)  ",
    "instruction": "  Create a scatter plot using matplotlib with three subplots. Use the following data to create the plot:  data = (1, 2, 3, 4, 5, 6, 7, 8),  mask = (1, 0, 1, 0, 0, 0, 1, 0), xsecs = secs * np.ma.MaskedArray(data, mask, float). Make sure to set the y-axis units of the first subplot to \"secs\", the second subplot to \"hertz\", and the third subplot to \"minutes\". ",
    "id": 331
},
{
    "data": " np.random.seed(20230930)  t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s   ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   ---  [DATA]: species = ( \"Adeleii $\\mu=$2805.45g\", \"Chingstopy $\\mu=$2961.34g\", \"RrtooDetoo\\n $\\mu=4237.51g$\") weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adeleii $\\mu=$2805.45g\", \"Chingstopy $\\mu=$2961.34g\", \"RrtooDetoo\\n $\\mu=4237.51g$\"), weight_counts = { \"Below\": np.array([60, 41, 78]), \"Above\": np.array([92, 77, 59])}.   ---  [DATA]: No data preparation blocks found in the provided code.  [INSTRUCTION]: Unable to generate the code as there are no data preparation blocks in the provided code. ",
    "id": 332
},
{
    "data": " gi import gi  gi.require_version('Gtk', '3.0') from gi.repository import Gtk  import numpy as np  from matplotlib.backends.backend_gtk3 import \\\\     NavigationToolbar2GTK3 as NavigationToolbar from matplotlib.backends.backend_gtk3agg import \\\\     FigureCanvasGTK3Agg as FigureCanvas from matplotlib.figure import Figure  win = Gtk.Window() win.connect('delete-event', Gtk.main_quit) win.set_default_size(400, 300) win.set_title('Embedding in GTK3')  fig = Figure(figsize=(5, 4), dpi=100) ax = fig.add_subplot(1, 1, 1) t = np.arange(0.0, 3.0, 0.01) s = np.sin(2*np.pi*t) ax.plot(t, s)  vbox = Gtk.VBox() win.add(vbox)  # Add canvas to vbox canvas = FigureCanvas(fig)  # a Gtk.DrawingArea vbox.pack_start(canvas, True, True, 0)  # Create toolbar toolbar = NavigationToolbar(canvas) vbox.pack_start(toolbar, False, False, 0)  win.show_all() Gtk.main()  ",
    "instruction": " Embed a matplotlib plot in a GTK3 window with a navigation toolbar. Create a window with a title \"Embedding in GTK3\" and a default size of 400x300. Add a matplotlib figure, with a single subplot, to the window. Plot the data generated by `t = np.arange(0.0, 3.0, 0.01)` and `s = np.sin(2*np.pi*t)` on the subplot. Add a canvas for the figure to the window, and pack it into a vertical box. Create a navigation toolbar for the canvas and pack it into the vertical box. Finally, show the window and start the GTK3 event loop. ",
    "id": 333
},
{
    "data": "  - 'code':  import gi  gi.require_version('Gtk', '3.0') from gi.repository import Gtk  import numpy as np  from matplotlib.backends.backend_gtk3agg import \\     FigureCanvasGTK3Agg as FigureCanvas from matplotlib.figure import Figure  win = Gtk.Window() win.connect('delete-event', Gtk.main_quit) win.set_default_size(400, 300) win.set_title('Embedding in GTK3')  fig = Figure(figsize=(5, 4), dpi=100) ax = fig.add_subplot() t = np.arange(0.0, 3.0, 0.01) s = np.sin(2*np.pi*t) ax.plot(t, s)  sw = Gtk.ScrolledWindow() win.add(sw) # A scrolled window border goes outside the scrollbars and viewport sw.set_border_width(10)  canvas = FigureCanvas(fig)  # a Gtk.DrawingArea canvas.set_size_request(800, 600) sw.add(canvas)  win.show_all() Gtk.main()  ",
    "instruction": " To create a GTK3 application embedding a FigureCanvas using matplotlib, use the following code:  import gi gi.require_version('Gtk', '3.0') from gi.repository import Gtk import numpy as np from matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas from matplotlib.figure import Figure  win = Gtk.Window() win.connect('delete-event', Gtk.main_quit) win.set_default_size(400, 300) win.set_title('Embedding in GTK3')  fig = Figure(figsize=(5, 4), dpi=100) ax = fig.add_subplot() t = np.arange(0.0, 3.0, 0.01) s = np.sin(2*np.pi*t) ax.plot(t, s)  sw = Gtk.ScrolledWindow() win.add(sw) sw.set_border_width(10)  canvas = FigureCanvas(fig) canvas.set_size_request(800, 600) sw.add(canvas)  win.show_all() Gtk.main() ",
    "id": 334
},
{
    "data": "  import gi  gi.require_version('Gtk', '4.0') from gi.repository import Gtk  import numpy as np  from matplotlib.backends.backend_gtk4 import \\\\     NavigationToolbar2GTK4 as NavigationToolbar from matplotlib.backends.backend_gtk4agg import \\\\     FigureCanvasGTK4Agg as FigureCanvas from matplotlib.figure import Figure   def on_activate(app):     win = Gtk.ApplicationWindow(application=app)     win.set_default_size(400, 300)     win.set_title('Embedding in GTK4')      fig = Figure(figsize=(5, 4), dpi=100)     ax = fig.add_subplot(1, 1, 1)     t = np.arange(0.0, 3.0, 0.01)     s = np.sin(2*np.pi*t)     ax.plot(t, s)      vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)     win.set_child(vbox)      # Add canvas to vbox     canvas = FigureCanvas(fig)  # a Gtk.DrawingArea     canvas.set_hexpand(True)     canvas.set_vexpand(True)     vbox.append(canvas)      # Create toolbar     toolbar = NavigationToolbar(canvas)     vbox.append(toolbar)      win.show()   app = Gtk.Application(     application_id='org.matplotlib.examples.EmbeddingInGTK4PanZoom') app.connect('activate', on_activate) app.run(None)  ",
    "instruction": " Use the following data and instructions to create an embedded GTK4 application with a navigation toolbar using matplotlib.   Data: None.  Instructions: 1. Import the necessary modules:     - gi     - Gtk     - numpy     - NavigationToolbar2GTK4     - FigureCanvasGTK4Agg     - Figure  2. Set up the GTK application:     - Create an application window with a default size of 400x300 and title \"Embedding in GTK4\".     - Create a figure with a size of 5x4 and dpi of 100.     - Add a subplot to the figure.     - Generate data for the plot using numpy.     - Plot the data on the subplot.  3. Create the GTK layout:     - Create a vertical box container.     - Add the figure canvas to the vertical box, setting the canvas to expand both horizontally and vertically.     - Add a navigation toolbar to the vertical box.  4. Show the GTK application.  Note: The provided code demonstrates embedding a matplotlib plot with a navigation toolbar into a GTK4 application. ",
    "id": 335
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": " Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]:  species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), } width = 0.5  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it: species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ), weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }.  [DATA]: None  [INSTRUCTION]: Generate a plot by embedding a FigureCanvasGTK4Agg widget to a Gtk.ScrolledWindow using GTK4 accessed via pygobject. ",
    "id": 336
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  [DATA]:  species = (      'Adelie\\n $\\\\\\\\\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = (      'Adelie\\n $\\\\\\\\\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\\\\\\\\\mu=5076.02g$', ), weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }.  [DATA]:  t = np.linspace(0, 10, 501) line2d_t = np.linspace(0, 10, 101)  [INSTRUCTION]:  Create a Qt application with two Matplotlib canvases. In the first canvas, plot the tangent of t using the plot function. In the second canvas, plot the sine function of (t + time.time()) using the plot function. Periodically update the second canvas with the updated values of t and np.sin(t + time.time()) using a timer. ",
    "id": 337
},
{
    "data": "  t = np.arange(0, 3, .01) ax = fig.add_subplot() line, = ax.plot(t, 2 * np.sin(2 * np.pi * t)) ax.set_xlabel('time [s]') ax.set_ylabel('f(t)')  ",
    "instruction": "  Use the following data to create a plot embedded in a Tkinter window: t = np.arange(0, 3, .01) ax = fig.add_subplot() line, = ax.plot(t, 2 * np.sin(2 * np.pi * t)) ax.set_xlabel('time [s]') ax.set_ylabel('f(t)') ",
    "id": 338
},
{
    "data": " \r import wx\r import wx.lib.mixins.inspection as WIT\r \r import numpy as np\r \r from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\r from matplotlib.backends.backend_wxagg import \\\r     NavigationToolbar2WxAgg as NavigationToolbar\r from matplotlib.figure import Figure\r \r \r class CanvasFrame(wx.Frame):\r     def __init__(self):\r         super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\r \r         self.figure = Figure()\r         self.axes = self.figure.add_subplot()\r         t = np.arange(0.0, 3.0, 0.01)\r         s = np.sin(2 * np.pi * t)\r \r         self.axes.plot(t, s)\r         self.canvas = FigureCanvas(self, -1, self.figure)\r \r         self.sizer = wx.BoxSizer(wx.VERTICAL)\r         self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.EXPAND)\r         self.SetSizer(self.sizer)\r         self.Fit()\r \r         self.add_toolbar()  # comment this out for no toolbar\r \r     def add_toolbar(self):\r         self.toolbar = NavigationToolbar(self.canvas)\r         self.toolbar.Realize()\r         # By adding toolbar in sizer, we are able to put it at the bottom\r         # of the frame - so appearance is closer to GTK version.\r         self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\r         # update the axes menu on the toolbar\r         self.toolbar.update()\r \r \r # Alternatively you could use:\r # class App(wx.App):\r class App(WIT.InspectableApp):\r     def OnInit(self):\r         '''Create the main window and insert the custom frame.'''\r         self.Init()\r         frame = CanvasFrame()\r         frame.Show(True)\r \r         return True\r \r \r if __name__ == '__main__':\r     app = App()\r     app.MainLoop()\r \r \r ",
    "instruction": " To create a matplotlib plot embedded in a wx application, use the following code. Define a CanvasFrame class that inherits from wx.Frame and initializes a Figure, an Axes, and a FigureCanvas. Then, plot data using the plot method of the Axes object. Finally, create an instance of the CanvasFrame class, add it to the wx application, and run the application. ",
    "id": 339
},
{
    "data": "  import wx import wx.xrc as xrc  import numpy as np  from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas from matplotlib.backends.backend_wxagg import \\     NavigationToolbar2WxAgg as NavigationToolbar import matplotlib.cbook as cbook import matplotlib.cm as cm from matplotlib.figure import Figure  ERR_TOL = 1e-5  # floating point slop for peak-detection   class PlotPanel(wx.Panel):     def __init__(self, parent):         super().__init__(parent, -1)          self.fig = Figure((5, 4), 75)         self.canvas = FigureCanvas(self, -1, self.fig)         self.toolbar = NavigationToolbar(self.canvas)  # matplotlib toolbar         self.toolbar.Realize()          # Now put all into a sizer         sizer = wx.BoxSizer(wx.VERTICAL)         # This way of adding to sizer allows resizing         sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)         # Best to allow the toolbar to resize!         sizer.Add(self.toolbar, 0, wx.GROW)         self.SetSizer(sizer)         self.Fit()      def init_plot_data(self):         ax = self.fig.add_subplot()          x = np.arange(120.0) * 2 * np.pi / 60.0         y = np.arange(100.0) * 2 * np.pi / 50.0         self.x, self.y = np.meshgrid(x, y)         z = np.sin(self.x) + np.cos(self.y)         self.im = ax.imshow(z, cmap=cm.RdBu, origin='lower')          zmax = np.max(z) - ERR_TOL         ymax_i, xmax_i = np.nonzero(z >= zmax)         if self.im.origin == 'upper':             ymax_i = z.shape[0] - ymax_i         self.lines = ax.plot(xmax_i, ymax_i, 'ko')          self.toolbar.update()  # Not sure why this is needed - ADS      def GetToolBar(self):         # You will need to override GetToolBar if you are using an         # unmanaged toolbar in your frame         return self.toolbar      def OnWhiz(self, event):         self.x += np.pi / 15         self.y += np.pi / 20         z = np.sin(self.x) + np.cos(self.y)         self.im.set_array(z)          zmax = np.max(z) - ERR_TOL         ymax_i, xmax_i = np.nonzero(z >= zmax)         if self.im.origin == 'upper':             ymax_i = z.shape[0] - ymax_i         self.lines[0].set_data(xmax_i, ymax_i)          self.canvas.draw()   class MyApp(wx.App):     def OnInit(self):         xrcfile = cbook.get_sample_data('embedding_in_wx3.xrc',                                         asfileobj=False)         print('loading', xrcfile)          self.res = xrc.XmlResource(xrcfile)          # main frame and panel ---------          self.frame = self.res.LoadFrame(None, 'MainFrame')         self.panel = xrc.XRCCTRL(self.frame, 'MainPanel')          # matplotlib panel -------------          # container for matplotlib panel (I like to make a container         # panel for our panel so I know where it'll go when in XRCed.)         plot_container = xrc.XRCCTRL(self.frame, 'plot_container_panel')         sizer = wx.BoxSizer(wx.VERTICAL)          # matplotlib panel itself         self.plotpanel = PlotPanel(plot_container)         self.plotpanel.init_plot_data()          # wx boilerplate         sizer.Add(self.plotpanel, 1, wx.EXPAND)         plot_container.SetSizer(sizer)          # whiz button ------------------         whiz_button = xrc.XRCCTRL(self.frame, 'whiz_button')         whiz_button.Bind(wx.EVT_BUTTON, self.plotpanel.OnWhiz)          # bang button ------------------         bang_button = xrc.XRCCTRL(self.frame, 'bang_button')         bang_button.Bind(wx.EVT_BUTTON, self.OnBang)          # final setup ------------------         self.frame.Show()          self.SetTopWindow(self.frame)          return True      def OnBang(self, event):         bang_count = xrc.XRCCTRL(self.frame, 'bang_count')         bangs = bang_count.GetValue()         bangs = int(bangs) + 1         bang_count.SetValue(str(bangs))   if __name__ == '__main__':     app = MyApp()     app.MainLoop()   ",
    "instruction": "  The provided code is an example of how to embed a Matplotlib plot into a wxPython application. To create the plot, follow these steps:  1. Import the required modules:    - wx    - wx.xrc as xrc    - numpy as np    - matplotlib.cbook as cbook    - matplotlib.cm as cm    - from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas    - from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg as NavigationToolbar    - from matplotlib.figure import Figure  2. Set the floating-point tolerance for peak detection to 1e-5 (ERR_TOL).  3. Define a class named PlotPanel that inherits from wx.Panel. This class represents the panel where the plot will be displayed. It contains the following methods:    - __init__(self, parent): Initializes the panel and sets up the Figure, Canvas, and Toolbar.    - init_plot_data(self): Initializes the data for the plot, including generating the x and y coordinates and calculating the z values using sine and cosine functions. It also plots the calculated data and sets up the toolbar.    - GetToolBar(self): Returns the toolbar associated with the plot panel.    - OnWhiz(self, event): Updates the plot data when the \"Whiz\" button is clicked, by modifying the x and y coordinates and recalculating the z values. It then updates the plot accordingly.  4. Define a class named MyApp that inherits from wx.App. This class represents the wxPython application itself. It contains the following methods:    - OnInit(self): Initializes the application and sets up the main frame and panel. It also loads an XRC file to define the GUI layout and creates the plot panel.    - OnBang(self, event): Updates a counter when the \"Bang\" button is clicked.  5. Create an instance of MyApp and start the application by calling MainLoop().  To use this code, make sure you have the required dependencies installed (wxPython, numpy, and matplotlib). Then, create an instance of MyApp and run the application. The GUI will display a plot panel with a \"Whiz\" button and a \"Bang\" button. Clicking the \"Whiz\" button will update the plot data, and clicking the \"Bang\" button will increment a counter. ",
    "id": 340
},
{
    "data": "  import wx import numpy as np from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg as NavigationToolbar from matplotlib.figure import Figure  class MyNavigationToolbar(NavigationToolbar):     def __init__(self, canvas):         super().__init__(canvas)         bmp = wx.ArtProvider.GetBitmap(wx.ART_CROSS_MARK, wx.ART_TOOLBAR)         tool = self.AddTool(wx.ID_ANY, 'Click me', bmp, 'Activate custom control')         self.Bind(wx.EVT_TOOL, self._on_custom, id=tool.GetId())      def _on_custom(self, event):         ax = self.canvas.figure.axes[0]         x, y = np.random.rand(2)         rgb = np.random.rand(3)         ax.text(x, y, 'You clicked me', transform=ax.transAxes, color=rgb)         self.canvas.draw()         event.Skip()  class CanvasFrame(wx.Frame):     def __init__(self):         super().__init__(None, -1, 'CanvasFrame', size=(550, 350))         self.figure = Figure(figsize=(5, 4), dpi=100)         self.axes = self.figure.add_subplot()         t = np.arange(0.0, 3.0, 0.01)         s = np.sin(2 * np.pi * t)         self.axes.plot(t, s)         self.canvas = FigureCanvas(self, -1, self.figure)         self.sizer = wx.BoxSizer(wx.VERTICAL)         self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)         self.toolbar = MyNavigationToolbar(self.canvas)         self.toolbar.Realize()         self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)         self.toolbar.update()         self.SetSizer(self.sizer)         self.Fit()  class App(wx.App):     def OnInit(self):         frame = CanvasFrame()         frame.Show(True)         return True  if __name__ == '__main__':     app = App()     app.MainLoop()  ",
    "instruction": " Use the provided code to embed a matplotlib plot in a wxPython application. The code creates a figure with a custom toolbar that can be activated by clicking a button. The plot displays a sine wave with randomly placed text when the button is clicked. ",
    "id": 341
},
{
    "data": " No data blocks found in the provided code.  ",
    "instruction": " Create a plot in wxPython using the matplotlib library. Use the provided code as a starting point and modify it as necessary. The code sets up a wxFrame and adds a wxNotebook to it. The notebook contains two pages, each with a matplotlib Figure and Subplot. The first subplot plots the points (1, 2), (2, 1), and (3, 4), while the second subplot plots the points (1, 2), (2, 1), (3, 4), (4, 2), and (5, 3). ",
    "id": 342
},

{
    "data": "[DATA]:  - np.random.seed(20230930)  - t = np.arange(0.0, 10.0, 0.2)  - s = np.exp(-t) + np.sin(2*np.pi*t) + 1  - nse = np.random.normal(0.0, 0.5, t.shape) * s  [INSTRUCTION]: Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots:   - np.random.seed(20230930)  - t = np.arange(0.0, 10.0, 0.2)  - s = np.exp(-t) + np.sin(2*np.pi*t) + 1  - nse = np.random.normal(0.0, 0.5, t.shape) * s  [DATA]:  - species = (\"Adelie\\n $\\mu=$3700.66g\", \"Chinstrap\\n $\\mu=$3733.09g\", \"Gentoo\\n $\\mu=5076.02g$\")  - weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]) }  - width = 0.5  [INSTRUCTION]: Create a stacked bar chart using matplotlib. Use the following data to plot it:  - species = (\"Adelie\\n $\\mu=$3700.66g\", \"Chinstrap\\n $\\mu=$3733.09g\", \"Gentoo\\n $\\mu=5076.02g$\")  - weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]) } ",
    "instruction": "THIS DATA SAMPLE IS UNDESIRED!!! MANUALLY ANNOTATE IT FROM SCRATCH",
    "id": 343
},
{
    "data": " No data preparation block found in the provided code.  ",
    "instruction": " There is no data preparation required for generating the provided code. The code is a complete implementation of a GUI application using the wxPython library for creating a Fourier Demo. The code consists of several classes including Knob, Param, SliderGroup, and FourierDemoFrame, which handle the creation of GUI elements, setting and updating parameter values, and creating and updating plots. The code can be run as is to launch the application. ",
    "id": 344
},
{
    "data": "  num_rows, num_cols = 20, 10  data = random((num_rows, num_cols))  ",
    "instruction": "  Create a GTK3 spreadsheet with a treeview to store data. Embed Matplotlib in the application and interact with the treeview to update plot data.   Use the following data to create the application:  num_rows, num_cols = 20, 10 data = random((num_rows, num_cols)) ",
    "id": 345
},
{
    "data": "   import gi  gi.require_version('Gtk 4.0') gi.require_version('Gdk 4.0') from gi.repository import Gtk  from numpy.random import random  from matplotlib.backends.backend_gtk4agg import FigureCanvas  # or gtk4cairo. from matplotlib.figure import Figure   class DataManager(Gtk.ApplicationWindow):     num_rows, num_cols = 20, 10      data = random((num_rows, num_cols))      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.set_default_size(600, 600)          self.set_title('GtkListStore demo')          vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, homogeneous=False,                        spacing=8)         self.set_child(vbox)          label = Gtk.Label(label='Double click a row to plot the data')         vbox.append(label)          sw = Gtk.ScrolledWindow()         sw.set_has_frame(True)         sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)         sw.set_hexpand(True)         sw.set_vexpand(True)         vbox.append(sw)          model = self.create_model()         self.treeview = Gtk.TreeView(model=model)         self.treeview.connect('row-activated', self.plot_row)         sw.set_child(self.treeview)          # Matplotlib stuff         fig = Figure(figsize=(6, 4), layout='constrained')          self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea         self.canvas.set_hexpand(True)         self.canvas.set_vexpand(True)         vbox.append(self.canvas)         ax = fig.add_subplot()         self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row          self.add_columns()      def plot_row(self, treeview, path, view_column):         ind, = path  # get the index into data         points = self.data[ind, :]         self.line.set_ydata(points)         self.canvas.draw()      def add_columns(self):         for i in range(self.num_cols):             column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)             self.treeview.append_column(column)      def create_model(self):         types = [float] * self.num_cols         store = Gtk.ListStore(*types)         for row in self.data:             # Gtk.ListStore.append is broken in PyGObject, so insert manually.             it = store.insert(-1)             store.set(it, {i: val for i, val in enumerate(row)})         return store   def on_activate(app):     manager = DataManager(application=app)     manager.show()   app = Gtk.Application(application_id='org.matplotlib.examples.GTK4Spreadsheet') app.connect('activate', on_activate) app.run()  ",
    "instruction": "   Use the following code to create a GTK4 spreadsheet with embedded Matplotlib and interact with a treeview to store data.   ```python import gi  gi.require_version('Gtk 4.0') gi.require_version('Gdk 4.0') from gi.repository import Gtk  from numpy.random import random  from matplotlib.backends.backend_gtk4agg import FigureCanvas  # or gtk4cairo. from matplotlib.figure import Figure   class DataManager(Gtk.ApplicationWindow):     num_rows, num_cols = 20, 10      data = random((num_rows, num_cols))      def __init__(self, *args, **kwargs):         super().__init__(*args, **kwargs)         self.set_default_size(600, 600)          self.set_title('GtkListStore demo')          vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, homogeneous=False,                        spacing=8)         self.set_child(vbox)          label = Gtk.Label(label='Double click a row to plot the data')         vbox.append(label)          sw = Gtk.ScrolledWindow()         sw.set_has_frame(True)         sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)         sw.set_hexpand(True)         sw.set_vexpand(True)         vbox.append(sw)          model = self.create_model()         self.treeview = Gtk.TreeView(model=model)         self.treeview.connect('row-activated', self.plot_row)         sw.set_child(self.treeview)          # Matplotlib stuff         fig = Figure(figsize=(6, 4), layout='constrained')          self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea         self.canvas.set_hexpand(True)         self.canvas.set_vexpand(True)         vbox.append(self.canvas)         ax = fig.add_subplot()         self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row          self.add_columns()      def plot_row(self, treeview, path, view_column):         ind, = path  # get the index into data         points = self.data[ind, :]         self.line.set_ydata(points)         self.canvas.draw()      def add_columns(self):         for i in range(self.num_cols):             column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)             self.treeview.append_column(column)      def create_model(self):         types = [float] * self.num_cols         store = Gtk.ListStore(*types)         for row in self.data:             # Gtk.ListStore.append is broken in PyGObject, so insert manually.             it = store.insert(-1)             store.set(it, {i: val for i, val in enumerate(row)})         return store   def on_activate(app):     manager = DataManager(application=app)     manager.show()   app = Gtk.Application(application_id='org.matplotlib.examples.GTK4Spreadsheet') app.connect('activate', on_activate) app.run() ```  This code creates a GTK4 spreadsheet with an embedded Matplotlib plot. Double-clicking on a row in the spreadsheet updates the plot with the corresponding data. ",
    "id": 346
},
{
    "data": "  import wx  import numpy as np  from matplotlib.backends.backend_wx import NavigationToolbar2Wx from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas from matplotlib.figure import Figure  IS_WIN = 'wxMSW' in wx.PlatformInfo   def mathtext_to_wxbitmap(s):     fig = Figure(facecolor='none')     text_color = (np.array(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)) / 255)     fig.text(0, 0, s, fontsize=10, color=text_color)     buf = BytesIO()     fig.savefig(buf, format='png', dpi=150, bbox_inches='tight', pad_inches=0)     s = buf.getvalue()     return wx.Bitmap.NewFromPNGData(s, len(s))   functions = [     (r'$\\sin(2 \\pi x)$', lambda x: np.sin(2*np.pi*x)),     (r'$\\frac{4}{3}\\pi x^3$', lambda x: (4/3)*np.pi*x**3),     (r'$\\cos(2 \\pi x)$', lambda x: np.cos(2*np.pi*x)),     (r'$\\log(x)$', lambda x: np.log(x)) ]   class CanvasFrame(wx.Frame):     def __init__(self, parent, title):         super().__init__(parent, -1, title, size=(550, 350))          self.figure = Figure()         self.axes = self.figure.add_subplot()          self.canvas = FigureCanvas(self, -1, self.figure)          self.change_plot(0)          self.sizer = wx.BoxSizer(wx.VERTICAL)         self.add_buttonbar()         self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)         self.add_toolbar()          menuBar = wx.MenuBar()          menu = wx.Menu()         m_exit = menu.Append(wx.ID_EXIT, 'E&xit\\tAlt-X', 'Exit this simple sample')         menuBar.Append(menu, '&File')         self.Bind(wx.EVT_MENU, self.OnClose, m_exit)          if IS_WIN:             menu = wx.Menu()             for i, (mt, func) in enumerate(functions):                 bm = mathtext_to_wxbitmap(mt)                 item = wx.MenuItem(menu, 1000 + i, ' ')                 item.SetBitmap(bm)                 menu.Append(item)                 self.Bind(wx.EVT_MENU, self.OnChangePlot, item)             menuBar.Append(menu, '&Functions')          self.SetMenuBar(menuBar)          self.SetSizer(self.sizer)         self.Fit()      def add_buttonbar(self):         self.button_bar = wx.Panel(self)         self.button_bar_sizer = wx.BoxSizer(wx.HORIZONTAL)         self.sizer.Add(self.button_bar, 0, wx.LEFT | wx.TOP | wx.GROW)          for i, (mt, func) in enumerate(functions):             bm = mathtext_to_wxbitmap(mt)             button = wx.BitmapButton(self.button_bar, 1000 + i, bm)             self.button_bar_sizer.Add(button, 1, wx.GROW)             self.Bind(wx.EVT_BUTTON, self.OnChangePlot, button)          self.button_bar.SetSizer(self.button_bar_sizer)      def add_toolbar(self):         self.toolbar = NavigationToolbar2Wx(self.canvas)         self.toolbar.Realize()         self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)         self.toolbar.update()      def OnChangePlot(self, event):         self.change_plot(event.GetId() - 1000)      def change_plot(self, plot_number):         t = np.arange(1.0, 3.0, 0.01)         s = functions[plot_number][1](t)         self.axes.clear()         self.axes.plot(t, s)         self.canvas.draw()      def OnClose(self, event):         self.Destroy()   class MyApp(wx.App):     def OnInit(self):         frame = CanvasFrame(None, 'wxPython mathtext demo app')         self.SetTopWindow(frame)         frame.Show(True)         return True   if __name__ == '__main__':     app = MyApp()     app.MainLoop()   ",
    "instruction": " Use the matplotlib library with the wxPython backend to create a graphical application that displays math text. The application should provide the following features:  1. Display a set of mathematical functions: $\\sin(2 \\pi x)$, $\\frac{4}{3}\\pi x^3$, $\\cos(2 \\pi x)$, and $\\log(x)$. 2. Allow the user to switch between different functions using buttons. 3. Plot the selected function on a canvas using the matplotlib library.  To achieve this, follow the steps below:  1. Import the necessary libraries:    - import wx    - import numpy as np    - from matplotlib.backends.backend_wx import NavigationToolbar2Wx    - from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas    - from matplotlib.figure import Figure  2. Define the function `mathtext_to_wxbitmap` to convert math text to a wx.Bitmap.  3. Define a list of functions to display: $\\sin(2 \\pi x)$, $\\frac{4}{3}\\pi x^3$, $\\cos(2 \\pi x)$, and $\\log(x)`. Each function should be associated with a lambda function that takes an input variable `x`.  4. Create a class `CanvasFrame` derived from `wx.Frame` to hold the application window.  5. Inside the `CanvasFrame` class, initialize the window with the necessary attributes and components:    - Create a `Figure` object and an `Axes` object.    - Create a `FigureCanvas` object to display the plot.    - Define a method `change_plot` to update the plot based on the selected function.    - Create a button bar with buttons for each function using the `add_buttonbar` method.    - Add the canvas and button bar to the frame using a sizer.    - Add a toolbar to the frame using the `add_toolbar` method.    - Create a menu bar with a \"File\" menu that contains an \"Exit\" item, and a \"Functions\" menu that contains items for each function.    - Bind event handlers to the menu items and buttons.  6. Define a class `MyApp` derived from `wx.App` to initialize the application and show the frame.  7. In the main section of the code, create an instance of `MyApp` and start the event loop.  When the application is run, it should display a window with buttons for each function. Clicking on a button should update the plot with the corresponding function. The toolbar at the top of the window should enable zooming and panning of the plot. ",
    "id": 347
},
{
    "data": "  from pathlib import Path  import gi  gi.require_version('Gtk', '3.0') from gi.repository import Gtk  import numpy as np  from matplotlib.backends.backend_gtk3agg import \\     FigureCanvasGTK3Agg as FigureCanvas from matplotlib.figure import Figure   class Window1Signals:     def on_window1_destroy(self, widget):         Gtk.main_quit()   def main():     builder = Gtk.Builder()     builder.add_objects_from_file(         str(Path(__file__).parent / 'mpl_with_glade3.glade'),         ('window1', ''))     builder.connect_signals(Window1Signals())     window = builder.get_object('window1')     sw = builder.get_object('scrolledwindow1')      # Start of Matplotlib specific code     figure = Figure(figsize=(8, 6), dpi=71)     axis = figure.add_subplot()     t = np.arange(0.0, 3.0, 0.01)     s = np.sin(2*np.pi*t)     axis.plot(t, s)      axis.set_xlabel('time [s]')     axis.set_ylabel('voltage [V]')      canvas = FigureCanvas(figure)  # a Gtk.DrawingArea     canvas.set_size_request(800, 600)     sw.add(canvas)     # End of Matplotlib specific code      window.show_all()     Gtk.main()  if __name__ == '__main__':     main()  ",
    "instruction": " Use the following code to create a Matplotlib plot in a GTK window:  from pathlib import Path  import gi  gi.require_version('Gtk', '3.0') from gi.repository import Gtk  import numpy as np  from matplotlib.backends.backend_gtk3agg import \\     FigureCanvasGTK3Agg as FigureCanvas from matplotlib.figure import Figure  class Window1Signals:     def on_window1_destroy(self, widget):         Gtk.main_quit()   def main():     builder = Gtk.Builder()     builder.add_objects_from_file(         str(Path(__file__).parent / 'mpl_with_glade3.glade'),         ('window1', ''))     builder.connect_signals(Window1Signals())     window = builder.get_object('window1')     sw = builder.get_object('scrolledwindow1')      # Start of Matplotlib specific code     figure = Figure(figsize=(8, 6), dpi=71)     axis = figure.add_subplot()     t = np.arange(0.0, 3.0, 0.01)     s = np.sin(2*np.pi*t)     axis.plot(t, s)      axis.set_xlabel('time [s]')     axis.set_ylabel('voltage [V]')      canvas = FigureCanvas(figure)  # a Gtk.DrawingArea     canvas.set_size_request(800, 600)     sw.add(canvas)     # End of Matplotlib specific code      window.show_all()     Gtk.main()  This code creates a GTK window and adds a Matplotlib plot to it. The plot shows a sine wave over time. The x-axis of the plot represents time in seconds, and the y-axis represents voltage in volts. The plot is displayed in a scrolled window in the GTK window. ",
    "id": 348
},
{
    "data": " functools, pathlib.Path, colorspacious, numpy,             _BUTTON_NAME = 'Filter',             _BUTTON_HELP = 'Simulate color vision deficiencies',             _MENU_ENTRIES = {                 'None': None,                 'Greyscale': 'greyscale',                 'Deuteranopia': 'deuteranomaly',                 'Protanopia': 'protanomaly',                 'Tritanopia': 'tritanomaly',             },             _get_color_filter(name)->callable,             _set_menu_entry(tb, name),             setup(figure),             _setup_gtk(tb),             _setup_qt(tb),             _setup_tk(tb),             _setup_wx(tb)  ",
    "instruction": " Create a figure hook for matplotlib using the `mplcvd:setup` parameter. Use the following dependencies: functools, pathlib.Path, colorspacious, and numpy. Define the following variables: `_BUTTON_NAME = 'Filter'`, `_BUTTON_HELP = 'Simulate color vision deficiencies'`, `_MENU_ENTRIES = {'None': None, 'Greyscale': 'greyscale', 'Deuteranopia': 'deuteranomaly', 'Protanopia': 'protanomaly', 'Tritanopia': 'tritanomaly'}`. Implement the function `_get_color_filter(name)`, which takes a color filter name as input and returns a callable function. Implement the function `_set_menu_entry(tb, name)`, which sets the color filter of a toolbar to a specified name. Implement the function `setup(figure)`, which configures the toolbar of a figure using platform-specific methods (`_setup_gtk(tb)`, `_setup ",
    "id": 349
},
{
    "data": "  import matplotlib matplotlib.use('GTK3Agg') import gi  import matplotlib.pyplot as plt gi.require_version('Gtk', '3.0') from gi.repository import Gtk  fig, ax = plt.subplots() ax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3') ax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared') ax.legend()  manager = fig.canvas.manager toolbar = manager.toolbar vbox = manager.vbox  button = Gtk.Button(label='Click me') button.show() button.connect('clicked', lambda button: print('hi mom'))  toolitem = Gtk.ToolItem() toolitem.show() toolitem.set_tooltip_text('Click me for fun and profit') toolitem.add(button)  pos = 8 toolbar.insert(toolitem, pos)  label = Gtk.Label() label.set_markup('Drag mouse over axes for position') label.show() vbox.pack_start(label, False, False, 0) vbox.reorder_child(toolbar, -1)  def update(event):     if event.xdata is None:         label.set_markup('Drag mouse over axes for position')     else:         label.set_markup(             f'<span color=\\'#ef0000\\'>x,y=({event.xdata}, {event.ydata})</span>')  fig.canvas.mpl_connect('motion_notify_event', update)  ",
    "instruction": " Use the following code to create a pyplot window and modify the GUI using GTK3.  Explanation: 1. Import the necessary libraries and modules. 2. Create a figure object and set the axes. 3. Plot two lines on the axes and add labels. 4. Create a manager object and access the toolbar and vbox. 5. Add a button to the toolbar with a click event. 6. Insert the button into the toolbar at a specific position. 7. Add a label to the vbox. 8. Create a function to update the label based on mouse movement. 9. Connect the update function with the canvas motion event. 10. Show the plot.  Note: This code example demonstrates how to use pyplot to manage figure windows and modify the GUI by accessing the underlying GTK widgets. ",
    "id": 350
},
{
    "data": "  matplotlib.use('GTK4Agg')  # or 'GTK4Cairo' import gi  import matplotlib.pyplot as plt  gi.require_version('Gtk', '4.0') from gi.repository import Gtk  fig, ax = plt.subplots() ax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3') ax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared') ax.legend()  manager = fig.canvas.manager # you can access the window or vbox attributes this way toolbar = manager.toolbar vbox = manager.vbox  # now let's add a button to the toolbar button = Gtk.Button(label='Click me') button.connect('clicked', lambda button: print('hi mom')) button.set_tooltip_text('Click me for fun and profit') toolbar.append(button)  # now let's add a widget to the vbox label = Gtk.Label() label.set_markup('Drag mouse over axes for position') vbox.insert_child_after(label, fig.canvas)   def update(event):     if event.xdata is None:         label.set_markup('Drag mouse over axes for position')     else:         label.set_markup(             f'<span color='#ef0000'>x,y=({event.xdata}, {event.ydata})</span>')   fig.canvas.mpl_connect('motion_notify_event', update)  plt.show()  ",
    "instruction": " Use the pyplot module from matplotlib to manage your figure windows and modify the GUI by accessing the underlying GTK widgets. Create a figure with subplots and plot two lines on the axes: one with red circles and dashes labeled 'easy as 1 2 3', and the other with green squares and dashes labeled 'easy as 1 2 3 squared'. Add a legend to the axes. Access the figure's manager, toolbar, and vbox attributes to customize the GUI. Append a button to the toolbar with the label 'Click me'. When the button is clicked, print 'hi mom' to the console. Set a tooltip text for the button as 'Click me for fun and profit'. Insert a label widget with the text 'Drag mouse over axes for position' after the figure canvas in the vbox. Define an 'update' function that takes an event parameter. If the event's xdata is None, set the label's markup to 'Drag mouse over axes for position'. Otherwise, set the label's markup to '<span color='#ef0000'>x,y=(event.xdata, event.ydata)</span>'. Connect the 'update' function to the 'motion_notify_event' of the figure canvas. Finally, display the plot using plt.show(). ",
    "id": 351
},
{
    "data": "  from io import BytesIO import json import xml.etree.ElementTree as ET  import matplotlib.pyplot as plt import numpy as np  plt.rcParams['svg.fonttype'] = 'none'  # Apparently, this `register_namespace` method is necessary to avoid garbling # the XML namespace with ns0. ET.register_namespace('', 'http://www.w3.org/2000/svg')  # Fixing random state for reproducibility np.random.seed(19680801)  # --- Create histogram, legend and title --- plt.figure() r = np.random.randn(100) r1 = r + 1 labels = ['Rabbits', 'Frogs'] H = plt.hist([r, r1], label=labels) containers = H[-1] leg = plt.legend(frameon=False) plt.title('From a web browser, click on the legend' \\           'marker to toggle the corresponding histogram.')   # --- Add ids to the svg objects we'll modify  hist_patches = {} for ic, c in enumerate(containers):     hist_patches[f'hist_{ic}'] = []     for il, element in enumerate(c):         element.set_gid(f'hist_{ic}_patch_{il}')         hist_patches[f'hist_{ic}'].append(f'hist_{ic}_patch_{il}')  # Set ids for the legend patches for i, t in enumerate(leg.get_patches()):     t.set_gid(f'leg_patch_{i}')  # Set ids for the text patches for i, t in enumerate(leg.get_texts()):     t.set_gid(f'leg_text_{i}')  # Save SVG in a fake file object. f = BytesIO() plt.savefig(f, format='svg')  # Create XML tree from the SVG file. tree, xmlid = ET.XMLID(f.getvalue())   # --- Add interactivity ---  # Add attributes to the patch objects. for i, t in enumerate(leg.get_patches()):     el = xmlid[f'leg_patch_{i}']     el.set('cursor', 'pointer')     el.set('onclick', 'toggle_hist(this)')  # Add attributes to the text objects. for i, t in enumerate(leg.get_texts()):     el = xmlid[f'leg_text_{i}']     el.set('cursor', 'pointer')     el.set('onclick', 'toggle_hist(this)')  # Create script defining the function `toggle_hist`. # We create a global variable `container` that stores the patches id # belonging to each histogram. Then a function 'toggle_element' sets the # visibility attribute of all patches of each histogram and the opacity # of the marker itself.  script = ''' <script type='text/ecmascript'> <![CDATA[ var container = %s  function toggle(oid, attribute, values) {     /* Toggle the style attribute of an object between two values.      Parameters     ----------     oid : str       Object identifier.     attribute : str       Name of style attribute.     values : [on state, off state]       The two values that are switched between.     */     var obj = document.getElementById(oid);     var a = obj.style[attribute];      a = (a == values[0] || a == '') ? values[1] : values[0];     obj.style[attribute] = a;     }  function toggle_hist(obj) {      var num = obj.id.slice(-1);      toggle('leg_patch_' + num, 'opacity', [1, 0.3]);     toggle('leg_text_' + num, 'opacity', [1, 0.5]);      var names = container['hist_'+num]      for (var i=0; i < names.length; i++) {         toggle(names[i], 'opacity', [1, 0])     };     } ]]> </script> ''' % json.dumps(hist_patches)  # Add a transition effect css = tree.find('.//{http://www.w3.org/2000/svg}style') css.text = css.text + 'g {-webkit-transition:opacity 0.4s ease-out;' + \\     '-moz-transition:opacity 0.4s ease-out;}'  # Insert the script and save to file. tree.insert(0, ET.XML(script))  ET.ElementTree(tree).write('svg_histogram.svg')   ",
    "instruction": " Use the following data and code to create an interactive histogram with a legend that toggles the corresponding histogram when clicked:  Data: - r: [numpy array generated with seed 19680801] - r1: r + 1 - labels: ['Rabbits', 'Frogs']  Code: from io import BytesIO import json import xml.etree.ElementTree as ET  import matplotlib.pyplot as plt import numpy as np  plt.rcParams['svg.fonttype'] = 'none'  # Apparently, this `register_namespace` method is necessary to avoid garbling # the XML namespace with ns0. ET.register_namespace('', 'http://www.w3.org/2000/svg')  # Fixing random state for reproducibility np.random.seed(19680801)  # --- Create histogram, legend and title --- plt.figure() r = np.random.randn(100) r1 = r + 1 labels = ['Rabbits', 'Frogs'] H = plt.hist([r, r1], label=labels) containers = H[-1] leg = plt.legend(frameon=False) plt.title('From a web browser, click on the legend' \\           'marker to toggle the corresponding histogram.')  # --- Add ids to the svg objects we'll modify  hist_patches = {} for ic, c in enumerate(containers):     hist_patches[f'hist_{ic}'] = []     for il, element in enumerate(c):         element.set_gid(f'hist_{ic}_patch_{il}')         hist_patches[f'hist_{ic}'].append(f'hist_{ic}_patch_{il}')  # Set ids for the legend patches for i, t in enumerate(leg.get_patches()):     t.set_gid(f'leg_patch_{i}')  # Set ids for the text patches for i, t in enumerate(leg.get_texts()):     t.set_gid(f'leg_text_{i}')  # Save SVG in a fake file object. f = BytesIO() plt.savefig(f, format='svg')  # Create XML tree from the SVG file. tree, xmlid = ET.XMLID(f.getvalue())  # --- Add interactivity ---  # Add attributes to the patch objects. for i, t in enumerate(leg.get_patches()):     el = xmlid[f'leg_patch_{i}']     el.set('cursor', 'pointer')     el.set('onclick', 'toggle_hist(this)')  # Add attributes to the text objects. for i, t in enumerate(leg.get_texts()):     el = xmlid[f'leg_text_{i}']     el.set('cursor', 'pointer')     el.set('onclick', 'toggle_hist(this)')  # Create script defining the function `toggle_hist`. # We create a global variable `container` that stores the patches id # belonging to each histogram. Then a function 'toggle_element' sets the # visibility attribute of all patches of each histogram and the opacity # of the marker itself.  script = ''' <script type='text/ecmascript'> <![CDATA[ var container = %s  function toggle(oid, attribute, values) {     /* Toggle the style attribute of an object between two values.      Parameters     ----------     oid : str       Object identifier.     attribute : str       Name of style attribute.     values : [on state, off state]       The two values that are switched between.     */     var obj = document.getElementById(oid);     var a = obj.style[attribute];      a = (a == values[0] || a == '') ? values[1] : values[0];     obj ",
    "id": 352
},
{
    "data": "   import matplotlib.pyplot as plt import xml.etree.ElementTree as ET  ET.register_namespace('', 'http://www.w3.org/2000/svg')  fig, ax = plt.subplots()  rect1 = plt.Rectangle((10, -20), 10, 5, fc='blue') rect2 = plt.Rectangle((-20, 15), 10, 5, fc='green')  shapes = [rect1, rect2] labels = ['This is a blue rectangle.', 'This is a green rectangle']  for i, (item, label) in enumerate(zip(shapes, labels)):     patch = ax.add_patch(item)     annotate = ax.annotate(labels[i], xy=item.get_xy(), xytext=(0, 0),                            textcoords='offset points', color='w', ha='center',                            fontsize=8, bbox=dict(boxstyle='round, pad=.5',                                                  fc=(.1, .1, .1, .92),                                                  ec=(1., 1., 1.), lw=1,                                                  zorder=1))      ax.add_patch(patch)     patch.set_gid(f'mypatch_{i:03d}')     annotate.set_gid(f'mytooltip_{i:03d}')  ax.set_xlim(-30, 30) ax.set_ylim(-30, 30) ax.set_aspect('equal')  plt.savefig(f, format='svg')  tree, xmlid = ET.XMLID(f.getvalue()) tree.set('onload', 'init(event)')  for i in shapes:     index = shapes.index(i)     tooltip = xmlid[f'mytooltip_{index:03d}']     tooltip.set('visibility', 'hidden')     mypatch = xmlid[f'mypatch_{index:03d}']     mypatch.set('onmouseover', 'ShowTooltip(this)')     mypatch.set('onmouseout', 'HideTooltip(this)')  script = '''     <script type='text/ecmascript'>     <![CDATA[      function init(event) {         if ( window.svgDocument == null ) {             svgDocument = event.target.ownerDocument;             }         }      function ShowTooltip(obj) {         var cur = obj.id.split('_')[1];         var tip = svgDocument.getElementById('mytooltip_' + cur);         tip.setAttribute('visibility', 'visible')         }      function HideTooltip(obj) {         var cur = obj.id.split('_')[1];         var tip = svgDocument.getElementById('mytooltip_' + cur);         tip.setAttribute('visibility', 'hidden')         }      ]]>     </script>     '''  tree.insert(0, ET.XML(script)) ET.ElementTree(tree).write('svg_tooltip.svg')  ",
    "instruction": "   Create an interactive SVG tooltip using matplotlib and xml.etree.ElementTree. The tooltip should be displayed when hovering over a matplotlib patch. Use the following data and code to generate the SVG tooltip:  Code: import matplotlib.pyplot as plt import xml.etree.ElementTree as ET  ET.register_namespace('', 'http://www.w3.org/2000/svg')  fig, ax = plt.subplots()  rect1 = plt.Rectangle((10, -20), 10, 5, fc='blue') rect2 = plt.Rectangle((-20, 15), 10, 5, fc='green')  shapes = [rect1, rect2] labels = ['This is a blue rectangle.', 'This is a green rectangle']  for i, (item, label) in enumerate(zip(shapes, labels)):     patch = ax.add_patch(item)     annotate = ax.annotate(labels[i], xy=item.get_xy(), xytext=(0, 0),                            textcoords='offset points', color='w', ha='center',                            fontsize=8, bbox=dict(boxstyle='round, pad=.5',                                                  fc=(.1, .1, .1, .92),                                                  ec=(1., 1., 1.), lw=1,                                                  zorder=1))      ax.add_patch(patch)     patch.set_gid(f'mypatch_{i:03d}')     annotate.set_gid(f'mytooltip_{i:03d}')  ax.set_xlim(-30, 30) ax.set_ylim(-30, 30) ax.set_aspect('equal')  plt.savefig(f, format='svg')  tree, xmlid = ET.XMLID(f.getvalue()) tree.set('onload', 'init(event)')  for i in shapes:     index = shapes.index(i)     tooltip = xmlid[f'mytooltip_{index:03d}']     tooltip.set('visibility', 'hidden')     mypatch = xmlid[f'mypatch_{index:03d}']     mypatch.set('onmouseover', 'ShowTooltip(this)')     mypatch.set('onmouseout', 'HideTooltip(this)')  script = '''     <script type='text/ecmascript'>     <![CDATA[      function init(event) {         if ( window.svgDocument == null ) {             svgDocument = event.target.ownerDocument;             }         }      function ShowTooltip(obj) {         var cur = obj.id.split('_')[1];         var tip = svgDocument.getElementById('mytooltip_' + cur);         tip.setAttribute('visibility', 'visible')         }      function HideTooltip(obj) {         var cur = obj.id.split('_')[1];         var tip = svgDocument.getElementById('mytooltip_' + cur);         tip.setAttribute('visibility', 'hidden')         }      ]]>     </script>     '''  tree.insert(0, ET.XML(script)) ET.ElementTree(tree).write('svg_tooltip.svg') ",
    "id": 353
},
{
    "data": "  No data preparation blocks found in the provided code.  ",
    "instruction": " This code demonstrates how to modify the Toolbar in matplotlib using the Tool Manager. It creates tools, adds tools, and removes tools from the toolbar. Additionally, it shows how to add a custom tool to a specific location in the navigation group. ",
    "id": 354
},
{
    "data": "  ```python import wx  import numpy as np  from matplotlib.backends.backend_wx import NavigationToolbar2Wx from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas from matplotlib.figure import Figure   class CanvasFrame(wx.Frame):     def __init__(self, ):         super().__init__(None, -1, 'CanvasFrame', size=(550, 350))          self.figure = Figure()         self.axes = self.figure.add_subplot()         t = np.arange(0.0, 3.0, 0.01)         s = np.sin(2*np.pi*t)          self.axes.plot(t, s)         self.axes.set_xlabel('t')         self.axes.set_ylabel('sin(t)')         self.figure_canvas = FigureCanvas(self, -1, self.figure)          # Note that event is a MplEvent         self.figure_canvas.mpl_connect(             'motion_notify_event', self.UpdateStatusBar)         self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)          self.sizer = wx.BoxSizer(wx.VERTICAL)         self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)         self.SetSizer(self.sizer)         self.Fit()          self.statusBar = wx.StatusBar(self, -1)         self.SetStatusBar(self.statusBar)          self.toolbar = NavigationToolbar2Wx(self.figure_canvas)         self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)         self.toolbar.Show()      def ChangeCursor(self, event):         self.figure_canvas.SetCursor(wx.Cursor(wx.CURSOR_BULLSEYE))      def UpdateStatusBar(self, event):         if event.inaxes:             self.statusBar.SetStatusText(f'x={event.xdata}  y={event.ydata}')   class App(wx.App):     def OnInit(self):         '''Create the main window and insert the custom frame.'''         frame = CanvasFrame()         self.SetTopWindow(frame)         frame.Show(True)         return True   if __name__ == '__main__':     app = App()     app.MainLoop() ```  ",
    "instruction": " Use the following code snippet to create a graphical user interface (GUI) application in wxPython with a matplotlib plot. The plot shows the data of the sine function for values of `t` ranging from 0.0 to 3.0. The x-axis represents `t`, and the y-axis represents `sin(t)`. The GUI includes a cursor that reports the coordinates (x, y) of the mouse pointer when it is hovering over the plot. The GUI also includes a navigation toolbar for zooming and panning the plot. ",
    "id": 355
},
{
    "data": " freqs = np.arange(2, 20, 3) t = np.arange(0.0, 1.0, 0.001) s = np.sin(2*np.pi*freqs[0]*t) l, = ax.plot(t, s, lw=2) class Index:     ind = 0      def next(self, event):         self.ind += 1         i = self.ind % len(freqs)         ydata = np.sin(2*np.pi*freqs[i]*t)         l.set_ydata(ydata)         plt.draw()      def prev(self, event):         self.ind -= 1         i = self.ind % len(freqs)         ydata = np.sin(2*np.pi*freqs[i]*t)         l.set_ydata(ydata)         plt.draw()  callback = Index() axprev = fig.add_axes([0.7, 0.05, 0.1, 0.075]) axnext = fig.add_axes([0.81, 0.05, 0.1, 0.075]) bnext = Button(axnext, 'Next') bnext.on_clicked(callback.next) bprev = Button(axprev, 'Previous') bprev.on_clicked(callback.prev)  ",
    "instruction": " Create a button GUI with matplotlib to modify a sine wave. Use the following data: freqs = np.arange(2, 20, 3), t = np.arange(0.0, 1.0, 0.001), s = np.sin(2*np.pi*freqs[0]*t), and plot it using ax.plot(t, s, lw=2). The GUI should have two buttons: \"Next\" and \"Previous\", which should update the wave with new frequencies when clicked. ",
    "id": 356
},
{
    "data": "  t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(6*np.pi*t)  lines_by_label = {l.get_label(): l for l in [l0, l1, l2]} line_colors = [l.get_color() for l in lines_by_label.values()]  ",
    "instruction": "  To create a plot with check buttons in matplotlib, you can use the CheckButtons widget. First, define the data: t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(6*np.pi*t)  Next, create the lines for each frequency: l0, = ax.plot(t, s0, visible=False, lw=2, color='black', label='1 Hz') l1, = ax.plot(t, s1, lw=2, color='red', label='2 Hz') l2, = ax.plot(t, s2, lw=2, color='green', label='3 Hz')  Create a dictionary to store the lines by their labels: lines_by_label = {l.get_label(): l for l in [l0, l1, l2]}  Create a list of line colors: line_colors = [l.get_color() for l in lines_by_label.values()]  Create the CheckButtons widget with the labels, initial visibility, and styling properties: rax = ax.inset_axes([0.0, 0.0, 0.12, 0.2]) check = CheckButtons(     ax=rax,     labels=lines_by_label.keys(),     actives=[l.get_visible() for l in lines_by_label.values()],     label_props={'color': line_colors},     frame_props={'edgecolor': line_colors},     check_props={'facecolor': line_colors}, )  Define a callback function to toggle the visibility of the lines: def callback(label):     ln = lines_by_label[label]     ln.set_visible(not ln.get_visible())     ln.figure.canvas.draw_idle()  Associate the callback function with the CheckButtons widget: check.on_clicked(callback)  Finally, display the plot: plt.show() ",
    "id": 357
},
{
    "data": " np.random.seed(19680801) x, y = 4*(np.random.rand(2, 100) - .5)  ",
    "instruction": " To create a plot with a cursor, use the following data: np.random.seed(19680801) x, y = 4*(np.random.rand(2, 100) - .5). Use the matplotlib.widgets.Cursor function with the specified settings: useblit=True, color='red', linewidth=2. ",
    "id": 358
},
{
    "data": " import numpy as np  from matplotlib.path import Path from matplotlib.widgets import LassoSelector   class SelectFromCollection:     '''     Select indices from a matplotlib collection using `LassoSelector`.      Selected indices are saved in the `ind` attribute. This tool fades out the     points that are not part of the selection (i.e., reduces their alpha     values). If your collection has alpha < 1, this tool will permanently     alter the alpha values.      Note that this tool selects collection objects based on their *origins*     (i.e., `offsets`).      Parameters     ----------     ax : `~matplotlib.axes.Axes`         Axes to interact with.     collection : `matplotlib.collections.Collection` subclass         Collection you want to select from.     alpha_other : 0 <= float <= 1         To highlight a selection, this tool sets all selected points to an         alpha value of 1 and non-selected points to *alpha_other*.     '''      def __init__(self, ax, collection, alpha_other=0.3):         self.canvas = ax.figure.canvas         self.collection = collection         self.alpha_other = alpha_other          self.xys = collection.get_offsets()         self.Npts = len(self.xys)          # Ensure that we have separate colors for each object         self.fc = collection.get_facecolors()         if len(self.fc) == 0:             raise ValueError('Collection must have a facecolor')         elif len(self.fc) == 1:             self.fc = np.tile(self.fc, (self.Npts, 1))          self.lasso = LassoSelector(ax, onselect=self.onselect)         self.ind = []      def onselect(self, verts):         path = Path(verts)         self.ind = np.nonzero(path.contains_points(self.xys))[0]         self.fc[:, -1] = self.alpha_other         self.fc[self.ind, -1] = 1         self.collection.set_facecolors(self.fc)         self.canvas.draw_idle()      def disconnect(self):         self.lasso.disconnect_events()         self.fc[:, -1] = 1         self.collection.set_facecolors(self.fc)         self.canvas.draw_idle()   if __name__ == '__main__':     import matplotlib.pyplot as plt      # Fixing random state for reproducibility     np.random.seed(19680801)      data = np.random.rand(100, 2)      subplot_kw = dict(xlim=(0, 1), ylim=(0, 1), autoscale_on=False)     fig, ax = plt.subplots(subplot_kw=subplot_kw)      pts = ax.scatter(data[:, 0], data[:, 1], s=80)     selector = SelectFromCollection(ax, pts)      def accept(event):         if event.key == 'enter':             print('Selected points:')             print(selector.xys[selector.ind])             selector.disconnect()             ax.set_title('')             fig.canvas.draw()      fig.canvas.mpl_connect('key_press_event', accept)     ax.set_title('Press enter to accept selected points.')      plt.show()  ",
    "instruction": " Use the LassoSelector tool from the matplotlib.widgets module to interactively select data points in a scatter plot. The selected indices are saved in the 'ind' attribute. The selected points will be highlighted by setting their alpha value to 1 and fading out the non-selected points. To use this tool, click and hold on the graph, then drag to draw a lasso loop around the points you want to select. To accept the selected points, press the 'enter' key. The selected points will be printed and the tool will disconnect, allowing normal interaction with the plot. ",
    "id": 359
},
{
    "data": "   np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "   Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.  ---  [DATA]:   species = (     'Adelie\\n $\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\mu=$3733.09g',     'Gentoo\\n $\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), } width = 0.5  [INSTRUCTION]:   Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ('Adelie\\n $\\\\mu=$3700.66g', 'Chinstrap\\n $\\\\mu=$3733.09g', 'Gentoo\\n $\\\\mu=5076.02g$'), weight_counts = {'Below': np.array([70, 31, 58]), 'Above': np.array([82, 37, 66])}. ",
    "id": 360
},
{
    "data": "  from matplotlib.backend_tools import Cursors  fig, axs = plt.subplots(len(Cursors), figsize=(6, len(Cursors) + 0.5),                         gridspec_kw={'hspace': 0}) fig.suptitle('Hover over an Axes to see alternate Cursors')  for cursor, ax in zip(Cursors, axs):     ax.cursor_to_use = cursor     ax.text(0.5, 0.5, cursor.name,             horizontalalignment='center', verticalalignment='center')     ax.set(xticks=[], yticks=[])   def hover(event):     if fig.canvas.widgetlock.locked():         # Don't do anything if the zoom/pan tools have been enabled.         return      fig.canvas.set_cursor(         event.inaxes.cursor_to_use if event.inaxes else Cursors.POINTER)   fig.canvas.mpl_connect('motion_notify_event', hover)  plt.show()  ",
    "instruction": "  Create a plot that displays alternate cursors when hovering over different axes using matplotlib. Use the following data to create the plots:  from matplotlib.backend_tools import Cursors  fig, axs = plt.subplots(len(Cursors), figsize=(6, len(Cursors) + 0.5),                         gridspec_kw={'hspace': 0}) fig.suptitle('Hover over an Axes to see alternate Cursors')  for cursor, ax in zip(Cursors, axs):     ax.cursor_to_use = cursor     ax.text(0.5, 0.5, cursor.name,             horizontalalignment='center', verticalalignment='center')     ax.set(xticks=[], yticks=[])   def hover(event):     if fig.canvas.widgetlock.locked():         # Don't do anything if the zoom/pan tools have been enabled.         return      fig.canvas.set_cursor(         event.inaxes.cursor_to_use if event.inaxes else Cursors.POINTER)   fig.canvas.mpl_connect('motion_notify_event', hover)  plt.show()  This example demonstrates how to set alternative cursors on a figure canvas in matplotlib. The code creates a figure with multiple axes, each representing a different cursor. The `Cursors` module is imported to provide a list of available cursors. A for loop is used to iterate over each cursor and axis, assigning the cursor to the axis and displaying the cursor name. The `hover` function is defined to change the cursor based on the current position of the mouse. The `fig.canvas.mpl_connect` method is used to connect the `motion_notify_event` to the `hover` function. Finally, `plt.show()` is called to display the plot. ",
    "id": 361
},
{
    "data": " t = np.arange(0.0, 2.0, 0.01) s1 = np.sin(2*np.pi*t) s2 = np.sin(3*np.pi*t) s3 = np.sin(4*np.pi*t)  ",
    "instruction": " Use the following functions from matplotlib: plot, subplots, and MultiCursor, to create three subplots with shared x-axis. Plot s1 on the first subplot, s2 on the second subplot, and s3 on the third subplot. Finally, use the MultiCursor to display a cursor on all three subplots simultaneously. ",
    "id": 362
},
{
    "data": " t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(8*np.pi*t)  ",
    "instruction": " Create a plot using matplotlib with Radio Buttons. Use the following data: t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(8*np.pi*t)  Set up the plot layout using subplot_mosaic with the following configuration: - Three subplots with names 'main freq', 'main color', and 'main linestyle' - Width ratio of 5:1 - Constrained layout  Create a line plot in the 'main freq' subplot using the data s0 and line width of 2. Set the color to 'red'.  Set the facecolor of the 'main color' subplot to 'lightgoldenrodyellow' and create radio buttons with label options '1 Hz', '2 Hz', and '4 Hz'. Customize the label properties with 'color': 'cmy' and 'fontsize': [12, 14, 16]. Set the radio options properties with 's': [16, 32, 64].  Create a callback function hzfunc which takes a label as input. Inside the function, create a dictionary hzdict with keys '1 Hz', '2 Hz', and '4 Hz', and values s0, s1, and s2 respectively. Retrieve the corresponding ydata from the dictionary using the input label. Update the ydata of the line plot in the 'main freq' subplot with the new ydata. Redraw the figure canvas.  Associate the hzfunc callback function with the radio buttons in the 'main freq' subplot using the on_clicked method.  Set the facecolor of the 'main color' subplot to 'lightgoldenrodyellow' and create radio buttons with label options 'red', 'blue', and 'green'. Customize the label properties with 'color': ['red', 'blue', 'green']. Set the radio options properties with 'facecolor': ['red', 'blue', 'green'] and 'edgecolor': ['darkred', 'darkblue', 'darkgreen'].  Create a callback function colorfunc which takes a label as input. Inside the function, update the color of the line plot in the 'main freq' subplot with the input label. Redraw the figure canvas.  Associate the colorfunc callback function with the radio buttons in the 'main color' subplot using the on_clicked method.  Set the facecolor of the 'main linestyle' subplot to 'lightgoldenrodyellow' and create radio buttons with label options '-','--','-.', and ':'.   Create a callback function stylefunc which takes a label as input. Inside the function, update the linestyle of the line plot in the 'main freq' subplot with the input label. Redraw the figure canvas.  Associate the stylefunc callback function with the radio buttons in the 'main linestyle' subplot using the on_clicked method.  Finally, display the plot using plt.show(). ",
    "id": 363
},
{
    "data": " np.random.seed(19680801) N = 128 img = np.random.randn(N, N) slider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03]) slider = RangeSlider(slider_ax, 'Threshold', img.min(), img.max())  ",
    "instruction": " To create a thresholding image with a RangeSlider, follow these steps: 1. Set the random seed using the numpy function np.random.seed(19680801). 2. Generate a fake image using np.random.randn(N, N), where N is the size of the image. 3. Create a figure with two subplots using fig, axs = plt.subplots(1, 2, figsize=(10, 5)). 4. Adjust the bottom spacing of the subplots using fig.subplots_adjust(bottom=0.25). 5. Display the image on the first subplot using axs[0].imshow(img). 6. Create a histogram of pixel intensities on the second subplot using axs[1].hist(img.flatten(), bins='auto'). 7. Set the title of the histogram subplot to 'Histogram of pixel intensities' using axs[1].set_title('Histogram of pixel intensities'). 8. Add a RangeSlider widget to control the threshold values. Use the command slider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03]) to create the slider axis. 9. Create the RangeSlider object using slider = RangeSlider(slider_ax, 'Threshold', img.min(), img.max()). 10. Create vertical lines on the histogram to indicate the selected threshold values. Use the commands lower_limit_line = axs[1].axvline(slider.val[0], color='k') and upper_limit_line = axs[1].axvline(slider.val[1], color='k'). 11. Define an update function that will be called when the slider values change. Inside the function, update the colormap of the image using im.norm.vmin = val[0] and im.norm.vmax = val[1]. Update the position of the vertical lines using lower_limit_line.set_xdata([val[0], val[0]]) and upper_limit_line.set_xdata([val[1], val[1]]). Finally, redraw the figure using fig.canvas.draw_idle(). 12. Connect the update function to the RangeSlider using the command slider.on_changed(update). 13. Show the plot using plt.show(). ",
    "id": 364
},
{
    "data": "  import matplotlib.pyplot as plt import numpy as np from matplotlib.widgets import EllipseSelector, RectangleSelector  def select_callback(eclick, erelease):     '''     Callback for line selection.      *eclick* and *erelease* are the press and release events.     '''     x1, y1 = eclick.xdata, eclick.ydata     x2, y2 = erelease.xdata, erelease.ydata     print(f'({x1:3.2f}, {y1:3.2f}) --> ({x2:3.2f}, {y2:3.2f})')     print(f'The buttons you used were: {eclick.button} {erelease.button}')   def toggle_selector(event):     print('Key pressed.')     if event.key == 't':         for selector in selectors:             name = type(selector).__name__             if selector.active:                 print(f'{name} deactivated.')                 selector.set_active(False)             else:                 print(f'{name} activated.')                 selector.set_active(True)   fig = plt.figure(layout='constrained') axs = fig.subplots(2)  N = 100000  # If N is large one can see improvement by using blitting. x = np.linspace(0, 10, N)  selectors = [] for ax, selector_class in zip(axs, [RectangleSelector, EllipseSelector]):     ax.plot(x, np.sin(2*np.pi*x))  # plot something     ax.set_title(f'Click and drag to draw a {selector_class.__name__}.')     selectors.append(selector_class(         ax, select_callback,         useblit=True,         button=[1, 3],  # disable middle button         minspanx=5, minspany=5,         spancoords='pixels',         interactive=True))     fig.canvas.mpl_connect('key_press_event', toggle_selector) axs[0].set_title('Press \\'t\\' to toggle the selectors on and off.\\n'                  + axs[0].get_title())  ",
    "instruction": "  Create two subplots using matplotlib, and assign them to the variables `axs`. Plot a curve using the `plot` function in each subplot. In the first subplot, allow the user to draw a rectangle by clicking and dragging on the plot. In the second subplot, allow the user to draw an ellipse by clicking and dragging on the plot. Print the start and end coordinates of the drawn rectangle/ellipse in the console. When the 't' key is pressed, toggle the active state of the selectors between activated and deactivated. ",
    "id": 365
},
{
    "data": "  from matplotlib.widgets import Button, Slider  # The parametrized function to be plotted def f(t, amplitude, frequency):     return amplitude * np.sin(2 * np.pi * frequency * t)  t = np.linspace(0, 1, 1000)  # Define initial parameters init_amplitude = 5 init_frequency = 3  # Create the figure and the line that we will manipulate fig, ax = plt.subplots() line, = ax.plot(t, f(t, init_amplitude, init_frequency), lw=2) ax.set_xlabel('Time [s]')  # adjust the main plot to make room for the sliders fig.subplots_adjust(left=0.25, bottom=0.25)  # Make a horizontal slider to control the frequency. axfreq = fig.add_axes([0.25, 0.1, 0.65, 0.03]) freq_slider = Slider(     ax=axfreq,     label='Frequency [Hz]',     valmin=0.1,     valmax=30,     valinit=init_frequency, )  # Make a vertically oriented slider to control the amplitude axamp = fig.add_axes([0.1, 0.25, 0.0225, 0.63]) amp_slider = Slider(     ax=axamp,     label='Amplitude',     valmin=0,     valmax=10,     valinit=init_amplitude,     orientation='vertical' )  # The function to be called anytime a slider's value changes def update(val):     line.set_ydata(f(t, amp_slider.val, freq_slider.val))     fig.canvas.draw_idle()   # register the update function with each slider freq_slider.on_changed(update) amp_slider.on_changed(update)  # Create a `matplotlib.widgets.Button` to reset the sliders to initial values. resetax = fig.add_axes([0.8, 0.025, 0.1, 0.04]) button = Button(resetax, 'Reset', hovercolor='0.975')   def reset(event):     freq_slider.reset()     amp_slider.reset() button.on_clicked(reset)   plt.show()  ",
    "instruction": " Create a plot using the parametrized function f(t, amplitude, frequency) from the module matplotlib.widgets. Plot the values of t against the values of f(t, init_amplitude, init_frequency). Set the x-axis label to 'Time [s]'. Adjust the plot size to make room for the sliders. Make a horizontal slider with the label 'Frequency [Hz]', ranging from 0.1 to 30, and with an initial value of init_frequency. Make a vertical slider with the label 'Amplitude', ranging from 0 to 10, and with an initial value of init_amplitude. Whenever the values of the sliders change, update the plot accordingly. Create a button labeled 'Reset' that resets the sliders to their initial values when clicked. ",
    "id": 366
},
{
    "data": "  t = np.arange(0.0, 1.0, 0.001) a0 = 5 f0 = 3 s = a0 * np.sin(2 * np.pi * f0 * t) allowed_amplitudes = np.concatenate([np.linspace(.1, 5, 100), [6, 7, 8, 9]])  ",
    "instruction": "  To create a plot with a sine wave, create two sliders to control the amplitude and frequency of the wave. Use the following data to initialize the plot:  t = np.arange(0.0, 1.0, 0.001) a0 = 5 f0 = 3 s = a0 * np.sin(2 * np.pi * f0 * t) allowed_amplitudes = np.concatenate([np.linspace(.1, 5, 100), [6, 7, 8, 9]]). Use the matplotlib.widgets.Slider class to create the sliders and the matplotlib.widgets.Button class to create a reset button. Implement the update() function to update the plot based on the slider values. When the reset button is clicked, reset the sliders to their initial values. ",
    "id": 367
},
{
    "data": "  np.random.seed(19680801)  fig, (ax1, ax2) = plt.subplots(2, figsize=(8, 6))  x = np.arange(0.0, 5.0, 0.01) y = np.sin(2 * np.pi * x) + 0.5 * np.random.randn(len(x))  ax1.plot(x, y) ax1.set_ylim(-2, 2) ax1.set_title('Press left mouse button and drag to select a region in the top graph')  line2, = ax2.plot([], [])   def onselect(xmin, xmax):     indmin, indmax = np.searchsorted(x, (xmin, xmax))     indmax = min(len(x) - 1, indmax)      region_x = x[indmin:indmax]     region_y = y[indmin:indmax]      if len(region_x) >= 2:         line2.set_data(region_x, region_y)         ax2.set_xlim(region_x[0], region_x[-1])         ax2.set_ylim(region_y.min(), region_y.max())         fig.canvas.draw_idle()   span = SpanSelector(     ax1,     onselect,     'horizontal',     useblit=True,     props=dict(alpha=0.5, facecolor='tab:blue'),     interactive=True,     drag_from_anywhere=True ) # Set useblit=True on most backends for enhanced performance.   ",
    "instruction": "  Create a figure with two subplots, where the first subplot (ax1) shows a plot of x vs y. Set the y-axis limits of ax1 to -2 and 2, and set the title of ax1 to 'Press left mouse button and drag to select a region in the top graph'. Define an empty line2 to be plotted in the second subplot (ax2). Create a function named onselect with parameters xmin and xmax. Inside the function, use np.searchsorted to find the indices indmin and indmax corresponding to the x-values xmin and xmax in the array x. Set indmax to the minimum value between len(x) - 1 and indmax. Slice the arrays x and y from indmin to indmax and assign them to region_x and region_y respectively. If the length of region_x is greater than or equal to 2, set the data of line2 to be the region_x and region_y arrays, and set the x-axis limits of ax2 to region_x[0] and region_x[-1], and set the y-axis limits of ax2 to the minimum and maximum values of region_y. Finally, call fig.canvas.draw_idle() to update the plot. Create a SpanSelector object named span, using ax1 as the target axis, 'horizontal' as the orientation, useblit=True for enhanced performance, set the transparency to 0.5 and facecolor to 'tab:blue', enable interactivity, and allow drag from anywhere on the plot. ",
    "id": 368
},
{
    "data": " t = np.arange(-2.0, 2.0, 0.001), ",
    "instruction": " Create a plot using matplotlib. Add a textbox widget that allows users to enter a mathematical expression using variable 't'. The plot should update dynamically when the user submits a new expression using the textbox. Use the following code to create the plot:  ```python import matplotlib.pyplot as plt import numpy as np  from matplotlib.widgets import TextBox  fig, ax = plt.subplots() fig.subplots_adjust(bottom=0.2)  t = np.arange(-2.0, 2.0, 0.001) l, = ax.plot(t, np.zeros_like(t), lw=2)  def submit(expression):     '''     Update the plotted function to the new math *expression*.      *expression* is a string using 't' as its independent variable, e.g.     't ** 3'.     '''     ydata = eval(expression, {'np': np}, {'t': t})     l.set_ydata(ydata)     ax.relim()     ax.autoscale_view()     plt.draw()  axbox = fig.add_axes([0.1, 0.05, 0.8, 0.075]) text_box = TextBox(axbox, 'Evaluate', textalignment='center') text_box.on_submit(submit) text_box.set_val('t ** 2')  # Trigger `submit` with the initial string.  plt.show() ```  This example demonstrates the use of a textbox widget in matplotlib to allow users to dynamically change the plotted function based on the inputted mathematical expression. The code utilizes the `TextBox` widget from `matplotlib.widgets`, defines a `submit` function to evaluate the expression, and updates the plot accordingly. ",
    "id": 369
},
{
    "data": "  import matplotlib.pyplot as plt  import matplotlib.patches as mpatches  fig, axs = plt.subplots(2, 2) x1, y1 = 0.3, 0.3 x2, y2 = 0.7, 0.7  ax = axs.flat[0] ax.plot([x1, x2], [y1, y2], '.') el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate('',             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle='-',                             color='0.5',                             patchB=None,                             shrinkB=0,                             connectionstyle='arc3,rad=0.3',                             ),             ) ax.text(.05, .95, 'connect', transform=ax.transAxes, ha='left', va='top')  ax = axs.flat[1] ax.plot([x1, x2], [y1, y2], '.') el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate('',             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle='-',                             color='0.5',                             patchB=el,                             shrinkB=0,                             connectionstyle='arc3,rad=0.3',                             ),             ) ax.text(.05, .95, 'clip', transform=ax.transAxes, ha='left', va='top')  ax = axs.flat[2] ax.plot([x1, x2], [y1, y2], '.') el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate('',             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle='-',                             color='0.5',                             patchB=el,                             shrinkB=5,                             connectionstyle='arc3,rad=0.3',                             ),             ) ax.text(.05, .95, 'shrink', transform=ax.transAxes, ha='left', va='top')  ax = axs.flat[3] ax.plot([x1, x2], [y1, y2], '.') el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate('',             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle='fancy',                             color='0.5',                             patchB=el,                             shrinkB=5,                             connectionstyle='arc3,rad=0.3',                             ),             ) ax.text(.05, .95, 'mutate', transform=ax.transAxes, ha='left', va='top')  for ax in axs.flat:     ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[], aspect=1)  plt.show()   ",
    "instruction": "  Create a 2x2 subplot grid using matplotlib. Use the following data to generate the subplots: x1=0.3, y1=0.3, x2=0.7, y2=0.7. In the first subplot, plot a line connecting (x1, y1) to (x2, y2) using the '.' marker. Add an ellipse at position (x1, y1) with a width of 0.3, height of 0.4, angle of 30 degrees, and alpha value of 0.2. Annotate the line with an arrow from (x1, y1) to (x2, y2), with arrowstyle '-', color '0.5', and connection style 'arc3,rad=0.3'. Add the text 'connect' at the position (0.05, 0.95) on the subplot. Repeat the same steps for the other three subplots, but with different annotations: 'clip', 'shrink', and 'mutate'. Set the x-axis limit to (0, 1), y-axis limit to (0, 1), and remove the ticks on both axes. ",
    "id": 370
},
{
    "data": " np.random.seed(19680801)  x1 = -1 + np.random.randn(100) y1 = -1 + np.random.randn(100) x2 = 1. + np.random.randn(100) y2 = 1. + np.random.randn(100)  bbox_props = dict(boxstyle='round', fc='w', ec='0.5', alpha=0.9)  bbox_props = dict(boxstyle='rarrow', fc=(0.8, 0.9, 0.9), ec='b', lw=2)  ",
    "instruction": " Use the following functions from matplotlib: scatter and text, to create a scatter plot with annotations. Use the following data to create the plot: np.random.seed(19680801), x1 = -1 + np.random.randn(100), y1 = -1 + np.random.randn(100), x2 = 1. + np.random.randn(100), y2 = 1. + np.random.randn(100), bbox_props = dict(boxstyle='round', fc='w', ec='0.5', alpha=0.9), bbox_props = dict(boxstyle='rarrow', fc=(0.8, 0.9, 0.9), ec='b', lw=2). ",
    "id": 371
},
{
    "data": "  np.random.seed(20230930) t = np.arange(0.0, 10.0, 0.2) s = np.exp(-t) + np.sin(2 * np.pi * t) + 1 nse = np.random.normal(0.0, 0.5, t.shape) * s  ",
    "instruction": "  Use the following functions from matplotlib: hlines and vlines, to create two plots: a vertical lines demo plot and a horizontal lines demo plot. Use the following data to create the plots: np.random.seed(20230930), t = np.arange(0.0, 10.0, 0.2), s = np.exp(-t) + np.sin(2 * np.pi * t) + 1, nse = np.random.normal(0.0, 0.5, t.shape) * s.   [DATA]:  species = (     'Adelie\\n $\\\\\\\\mu=$3700.66g',     'Chinstrap\\n $\\\\\\\\mu=$3733.09g',     'Gentoo\\n $\\\\\\\\mu=5076.02g$', ) weight_counts = {     'Below': np.array([70, 31, 58]),     'Above': np.array([82, 37, 66]), }  [INSTRUCTION]:  Create a stacked bar chart using matplotlib. Use the following data to plot it: species = ( \"Adelie\\n $\\\\\\\\mu=$3700.66g\", \"Chinstrap\\n $\\\\\\\\mu=$3733.09g\", \"Gentoo\\n $\\\\\\\\mu=5076.02g$\"), weight_counts = { \"Below\": np.array([70, 31, 58]), \"Above\": np.array([82, 37, 66])}.  [DATA]: None  [INSTRUCTION]: The code provided does not contain any data preparation blocks. ",
    "id": 372
},
{
    "data": "  No data preparation blocks found in the provided code.  ",
    "instruction": "  Create a figure with 5 subplots using `subplot2grid` from Matplotlib. The subplots should be arranged as follows: - Subplot 1: Occupying the entire top row - Subplot 2: Occupying the first 2 columns in the second row - Subplot 3: Occupying the last column in the second row and the entire third row - Subplot 4: Located at the bottom-left position - Subplot 5: Located at the bottom-right position  Use the function `annotate_axes` to add centered text with the format 'axN' (where N is the subplot index) to each subplot. Also, hide the tick labels on the x-axis and y-axis for all subplots.  Finally, display the figure. ",
    "id": 373
},
{
    "data": " import matplotlib.pyplot as plt import numpy as np   def squiggle_xy(a, b, c, d):     i = np.arange(0.0, 2*np.pi, 0.05)     return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)   fig = plt.figure(figsize=(8, 8)) outer_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0)  for a in range(4):     for b in range(4):         # gridspec inside gridspec         inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0)         axs = inner_grid.subplots()  # Create all subplots for the inner grid.         for (c, d), ax in np.ndenumerate(axs):             ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1))             ax.set(xticks=[], yticks=[])  # show only the outside spines for ax in fig.get_axes():     ss = ax.get_subplotspec()     ax.spines.top.set_visible(ss.is_first_row())     ax.spines.bottom.set_visible(ss.is_last_row())     ax.spines.left.set_visible(ss.is_first_col())     ax.spines.right.set_visible(ss.is_last_col())  plt.show()  ",
    "instruction": " Create a nested GridSpecs plot using matplotlib. Use the following data to generate the plot: No specific data is required for this example. ",
    "id": 374
},
{
    "data": " plt.rcParams.update({     'font.family': 'serif',       'text.usetex': True,          'pgf.rcfonts': False,         'pgf.preamble': '\\n'.join([          r'\\\\usepackage{url}',                      r'\\\\usepackage{unicode-math}',             r'\\\\setmainfont{DejaVu Serif}',       ]) })  ",
    "instruction": " Use the following data to generate a plot using matplotlib with the PGF preamble settings:  plt.rcParams.update({     'font.family': 'serif',       'text.usetex': True,          'pgf.rcfonts': False,         'pgf.preamble': '\\n'.join([          r'\\\\usepackage{url}',                      r'\\\\usepackage{unicode-math}',             r'\\\\setmainfont{DejaVu Serif}',       ]) })  The code block you provided sets the PGF preamble settings for matplotlib. These settings ensure that the plot uses a serif font for text elements, allows the use of inline math for ticks, and uses additional packages like \"url\" and \"unicode-math\". The code also creates a figure and axes using the `subplots` function, sets the figure size to (4.5, 2.5), plots a line plot with `range(5)`, sets the x-label to include Unicode text characters such as \"я, ψ, €, ü\", sets the y-label to a URL link, and adds a legend with a Unicode math equation.  Please note that when using this code, make sure to have the necessary packages and fonts installed for the PGF preamble to work properly. ",
    "id": 375
},
{
    "data": "  ```python plt.rcParams.update({     'pgf.texsystem': 'pdflatex',     'pgf.preamble': '\\n'.join([          r'\\usepackage[utf8x]{inputenc}',          r'\\usepackage[T1]{fontenc}',          r'\\usepackage{cmbright}',     ]), })  fig, ax = plt.subplots(figsize=(4.5, 2.5))  ax.plot(range(5))  ax.text(0.5, 3., 'serif', family='serif') ax.text(0.5, 2., 'monospace', family='monospace') ax.text(2.5, 2., 'sans-serif', family='sans-serif') ax.set_xlabel(r'µ is not $\\mu$')  fig.tight_layout(pad=.5)  fig.savefig('pgf_texsystem.pdf') fig.savefig('pgf_texsystem.png') ```  ",
    "instruction": "  To create a plot with the following settings: - Set the PGF texsystem to pdflatex and include the following preamble: '\\usepackage[utf8x]{inputenc}', '\\usepackage[T1]{fontenc}', '\\usepackage{cmbright}'. - Create a figure with a size of 4.5 x 2.5 inches. - Plot a line graph with the values from 0 to 4. - Add three text annotations with the labels 'serif', 'monospace', and 'sans-serif' at positions (0.5, 3.0), (0.5, 2.0), and (2.5, 2.0) respectively. Use the corresponding font family for each annotation. - Set the x-axis label as 'µ is not $\\\\mu$'. - Adjust the layout of the figure with a padding of 0.5. - Save the figure as 'pgf_texsystem.pdf' and 'pgf_texsystem.png'. ",
    "id": 376
},
{
    "data": "  x1, y1 = 0.3, 0.3 x2, y2 = 0.7, 0.7  ",
    "instruction": " Use the following functions from matplotlib: plot, annotate, text, add_artist, and set, to create 8 plots with annotations and arrows connecting points. Use the following data to create the plots:  x1, y1 = 0.3, 0.3 x2, y2 = 0.7, 0.7 ",
    "id": 377
},
{
    "data": "  fig = plt.figure()  ax = fig.add_subplot(211) ax.plot([1, 2, 3], label='test1') ax.plot([3, 2, 1], label='test2') # Place a legend above this subplot, expanding itself to # fully use the given bounding box. ax.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc='lower left',            ncols=2, mode='expand', borderaxespad=0.)  ax = fig.add_subplot(223) ax.plot([1, 2, 3], label='test1') ax.plot([3, 2, 1], label='test2') # Place a legend to the right of this smaller subplot. ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)  ",
    "instruction": " Create a figure with two subplots. In the first subplot, plot two lines using the data [1, 2, 3] for 'test1' and [3, 2, 1] for 'test2'. Add a legend above the subplot that expands to fully use the given bounding box. Specify the legend with ncols=2 and set the borderaxespad to 0. In the second subplot, plot two lines using the same data as the first subplot. Add a legend to the right of the subplot. ",
    "id": 378
},
{
    "data": "  line1, = ax.plot([1, 2, 3], label='Line 1', linestyle='--') line2, = ax.plot([3, 2, 1], label='Line 2', linewidth=4) first_legend = ax.legend(handles=[line1], loc='upper right') ax.add_artist(first_legend) ax.legend(handles=[line2], loc='lower right')  ",
    "instruction": "  To generate a plot with two lines and two separate legends, use the following code: 1. Create the first line using the command \"line1, = ax.plot([1, 2, 3], label='Line 1', linestyle='--')\" 2. Create the second line using the command \"line2, = ax.plot([3, 2, 1], label='Line 2', linewidth=4)\" 3. Create the first legend using the command \"first_legend = ax.legend(handles=[line1], loc='upper right')\" 4. Add the first legend to the current Axes using the command \"ax.add_artist(first_legend)\" 5. Create the second legend using the command \"ax.legend(handles=[line2], loc='lower right')\" Finally, use the command \"plt.show()\" to display the plot. ",
    "id": 379
}
]