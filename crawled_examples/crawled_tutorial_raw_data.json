[
{
    "raw_page": "{'h1': 'User guide tutorials'}",
    "id": 0
},
{
    "raw_page": "{'h1': 'Frequently Asked Questions'}, {'h2': 'Why do I have so many ticks, and/or why are they out of order?'}, {'text': 'One common cause for unexpected tick behavior is passing a list of strings\ninstead of numbers or datetime objects. This can easily happen without notice\nwhen reading in a comma-delimited text file. Matplotlib treats lists of strings\nas categorical variables\n(Plotting categorical variables), and by default\nputs one tick per category, and plots them in the order in which they are\nsupplied.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2))\n\nax[0].set_title('Ticks seem out of order / misplaced')\nx = ['5 20 1 9']  # strings\ny = [5, 20, 1, 9]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', labelcolor='red', labelsize=14)\n\nax[1].set_title('Many ticks')\nx = [str(xx) for xx in np.arange(100)]  # strings\ny = np.arange(100)\nax[1].plot(x, y)\nax[1].tick_params(axis='x', labelcolor='red', labelsize=14)\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'The solution is to convert the list of strings to numbers or\ndatetime objects (often np.asarray(numeric_strings, dtype='float') or\nnp.asarray(datetime_strings, dtype='datetime64[s]')).'}, {'text': 'For more information see Fixing too many ticks.'}, {'h2': 'Determine the extent of Artists in the Figure'}, {'text': 'Sometimes we want to know the extent of an Artist. Matplotlib Artist objects\nhave a method Artist.get_window_extent that will usually return the extent of\nthe artist in pixels. However, some artists, in particular text, must be\nrendered at least once before their extent is known. Matplotlib supplies\nFigure.draw_without_rendering, which should be called before calling\nget_window_extent.'}, {'h2': 'Check whether a figure is empty'}, {'text': 'Empty can actually mean different things. Does the figure contain any artists?\nDoes a figure with an empty Axes still count as empty? Is the figure\nempty if it was rendered pure white (there may be artists present, but they\ncould be outside the drawing area or transparent)?'}, {'text': 'For the purpose here, we define empty as: 'The figure does not contain any\nartists except it's background patch.' The exception for the background is\nnecessary, because by default every figure contains a Rectangle as it's\nbackground patch. This definition could be checked via:'}, {'code': 'def is_empty(figure):\n    '''\n    Return whether the figure contains no Artists (other than the default\n    background patch).\n    '''\n    contained_artists = figure.get_children()\n    return len(contained_artists) <= 1\n'}, {'text': 'We've decided not to include this as a figure method because this is only one\nway of defining empty, and checking the above is only rarely necessary.\nUsually the user or program handling the figure know if they have added\nsomething to the figure.'}, {'text': 'The only reliable way to check whether a figure would render empty is to\nactually perform such a rendering and inspect the result.'}, {'h2': 'Find all objects in a figure of a certain type'}, {'text': 'Every Matplotlib artist (see Artist tutorial) has a method\ncalled findobj() that can be used to\nrecursively search the artist for any artists it may contain that meet\nsome criteria (e.g., match all Line2D\ninstances or match some arbitrary filter function). For example, the\nfollowing snippet finds every object in the figure which has a\nset_color property and makes the object blue:'}, {'code': 'def myfunc(x):\n    return hasattr(x, 'set_color')\n\nfor o in fig.findobj(myfunc):\n    o.set_color('blue')\n'}, {'text': 'You can also filter on class instances:'}, {'code': 'import matplotlib.text as text\nfor o in fig.findobj(text.Text):\n    o.set_fontstyle('italic')\n'}, {'h2': 'Prevent ticklabels from having an offset'}, {'text': 'The default formatter will use an offset to reduce\nthe length of the ticklabels. To turn this feature\noff on a per-axis basis:'}, {'code': 'ax.get_xaxis().get_major_formatter().set_useOffset(False)\n'}, {'text': 'set rcParamsaxes.formatter.useoffset (default: True), or use a different\nformatter. See ticker for details.'}, {'h2': 'Save transparent figures'}, {'text': 'The savefig() command has a keyword argument\ntransparent which, if 'True', will make the figure and axes\nbackgrounds transparent when saving, but will not affect the displayed\nimage on the screen.'}, {'text': 'If you need finer grained control, e.g., you do not want full transparency\nor you want to affect the screen displayed version as well, you can set\nthe alpha properties directly. The figure has a\nRectangle instance called patch\nand the axes has a Rectangle instance called patch. You can set\nany property on them directly (facecolor, edgecolor, linewidth,\nlinestyle, alpha). e.g.:'}, {'code': 'fig = plt.figure()\nfig.patch.set_alpha(0.5)\nax = fig.add_subplot(111)\nax.patch.set_alpha(0.5)\n'}, {'text': 'If you need all the figure elements to be transparent, there is\ncurrently no global alpha setting, but you can set the alpha channel\non individual elements, e.g.:'}, {'code': 'ax.plot(x, y, alpha=0.5)\nax.set_xlabel('volts', alpha=0.5)\n'}, {'h2': 'Save multiple plots to one pdf file'}, {'text': 'Many image file formats can only have one image per file, but some formats\nsupport multi-page files. Currently, Matplotlib only provides multi-page\noutput to pdf files, using either the pdf or pgf backends, via the\nbackend_pdf.PdfPages and backend_pgf.PdfPages classes.'}, {'h2': 'Make room for tick labels'}, {'text': 'By default, Matplotlib uses fixed percentage margins around subplots. This can\nlead to labels overlapping or being cut off at the figure boundary. There are\nmultiple ways to fix this:'}, {'text': 'Manually adapt the subplot parameters using Figure.subplots_adjust /\npyplot.subplots_adjust.'}, {'text': 'Use one of the automatic layout mechanisms:'}, {'text': 'constrained layout (Constrained Layout Guide)'}, {'text': 'tight layout (Tight Layout guide)'}, {'text': 'Calculate good values from the size of the plot elements yourself\n(Programmatically controlling subplot adjustment)'}, {'h2': 'Align my ylabels across multiple subplots'}, {'text': 'If you have multiple subplots over one another, and the y data have\ndifferent scales, you can often get ylabels that do not align\nvertically across the multiple subplots, which can be unattractive.\nBy default, Matplotlib positions the x location of the ylabel so that\nit does not overlap any of the y ticks. You can override this default\nbehavior by specifying the coordinates of the label. To learn how, see\nAlign y-labels'}, {'h2': 'Control the draw order of plot elements'}, {'text': 'The draw order of plot elements, and thus which elements will be on top, is\ndetermined by the set_zorder property.\nSee Zorder Demo for a detailed description.'}, {'h2': 'Make the aspect ratio for plots equal'}, {'text': 'The Axes property set_aspect() controls the\naspect ratio of the axes. You can set it to be 'auto equal', or\nsome ratio which controls the ratio:'}, {'code': 'ax = fig.add_subplot(111, aspect='equal')\n'}, {'text': 'See Equal axis aspect ratio for a\ncomplete example.'}, {'h2': 'Draw multiple y-axis scales'}, {'text': 'A frequent request is to have two scales for the left and right\ny-axis, which is possible using twinx() (more\nthan two scales are not currently supported, though it is on the wish\nlist). This works pretty well, though there are some quirks when you\nare trying to interactively pan and zoom, because both scales do not get\nthe signals.'}, {'text': 'The approach uses twinx() (and its sister\ntwiny()) to use 2 different axes,\nturning the axes rectangular frame off on the 2nd axes to keep it from\nobscuring the first, and manually setting the tick locs and labels as\ndesired. You can use separate matplotlib.ticker formatters and\nlocators as desired because the two axes are independent.'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'See Plots with different scales for a\ncomplete example.'}, {'h2': 'Generate images without having a window appear'}, {'text': 'Simply do not call show, and directly save the figure to\nthe desired format:'}, {'code': 'import matplotlib.pyplot as plt\nplt.plot([1, 2, 3])\nplt.savefig('myfig.png')\n'}, {'text': 'See also'}, {'text': 'Embedding in a web application server (Flask) for\ninformation about running matplotlib inside of a web application.'}, {'h2': 'Work with threads'}, {'text': 'Matplotlib is not thread-safe: in fact, there are known race conditions\nthat affect certain artists. Hence, if you work with threads, it is your\nresponsibility to set up the proper locks to serialize access to Matplotlib\nartists.'}, {'text': 'You may be able to work on separate figures from separate threads. However,\nyou must in that case use a non-interactive backend (typically Agg), because\nmost GUI backends require being run from the main thread as well.'}, {'h2': 'Get help'}, {'text': 'There are a number of good resources for getting help with Matplotlib.\nThere is a good chance your question has already been asked:'}, {'text': 'The mailing list archive.'}, {'text': 'GitHub issues.'}, {'text': 'Stackoverflow questions tagged matplotlib.'}, {'text': 'If you are unable to find an answer to your question through search, please\nprovide the following information in your e-mail to the mailing list:'}, {'text': 'Your operating system (Linux/Unix users: post the output of uname -a).'}, {'text': 'Matplotlib version:'}, {'code': 'python -c 'import matplotlib; print(matplotlib.__version__)'\n'}, {'text': 'Where you obtained Matplotlib (e.g., your Linux distribution's packages,\nGitHub, PyPI, or Anaconda).'}, {'text': 'Any customizations to your matplotlibrc file (see\nCustomizing Matplotlib with style sheets and rcParams).'}, {'text': 'If the problem is reproducible, please try to provide a minimal, standalone\nPython script that demonstrates the problem. This is the critical step.\nIf you can't post a piece of code that we can run and reproduce your error,\nthe chances of getting help are significantly diminished. Very often, the\nmere act of trying to minimize your code to the smallest bit that produces\nthe error will help you find a bug in your code that is causing the\nproblem.'}, {'text': 'Matplotlib provides debugging information through the logging library, and\na helper function to set the logging level: one can call'}, {'code': 'plt.set_loglevel('info')  # or 'debug' for more info\n'}, {'text': 'to obtain this debugging information.'}, {'text': 'Standard functions from the logging module are also applicable; e.g. one\ncould call logging.basicConfig(level='DEBUG') even before importing\nMatplotlib (this is in particular necessary to get the logging info emitted\nduring Matplotlib's import), or attach a custom handler to the 'matplotlib'\nlogger. This may be useful if you use a custom logging configuration.'}, {'text': 'If you compiled Matplotlib yourself, please also provide:'}, {'text': 'any changes you have made to setup.py or setupext.py.'}, {'text': 'the output of:'}, {'code': 'rm -rf build\npython setup.py build\n'}, {'text': 'The beginning of the build output contains lots of details about your\nplatform that are useful for the Matplotlib developers to diagnose your\nproblem.'}, {'text': 'your compiler version -- e.g., gcc --version.'}, {'text': 'Including this information in your first e-mail to the mailing list\nwill save a lot of time.'}, {'text': 'You will likely get a faster response writing to the mailing list than\nfiling a bug in the bug tracker. Most developers check the bug\ntracker only periodically. If your problem has been determined to be\na bug and cannot be quickly solved, you may be asked to file a bug in\nthe tracker so the issue doesn't get lost.'}",
    "id": 1
},
{
    "raw_page": "{'h1': 'Figures and backends'}, {'text': 'When looking at Matplotlib visualization, you are almost always looking at\nArtists placed on a Figure. In the example below, the figure is the\nblue region and add_subplot has added an Axes artist to the\nFigure (see Parts of a Figure). A more complicated visualization can add\nmultiple Axes to the Figure, colorbars, legends, annotations, and the Axes\nthemselves can have multiple Artists added to them\n(e.g. ax.plot or ax.imshow).'}, {'code': 'fig = plt.figure(figsize=(4, 2), facecolor='lightskyblue',\n                 layout='constrained')\nfig.suptitle('A nice Matplotlib Figure')\nax = fig.add_subplot()\nax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n'}, {'text': '(Source code, 2x.png, png)'}",
    "id": 2
},
{
    "raw_page": "{'h1': 'Introduction to Figures'}, {'code': 'fig = plt.figure(figsize=(2, 2), facecolor='lightskyblue',\n                 layout='constrained')\nfig.suptitle('Figure')\nax = fig.add_subplot()\nax.set_title('Axes', loc='left', fontstyle='oblique', fontsize='medium')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'When looking at Matplotlib visualization, you are almost always looking at\nArtists placed on a Figure. In the example above, the figure is the\nblue region and add_subplot has added an Axes artist to the\nFigure (see Parts of a Figure). A more complicated visualization can add\nmultiple Axes to the Figure, colorbars, legends, annotations, and the Axes\nthemselves can have multiple Artists added to them\n(e.g. ax.plot or ax.imshow).'}, {'text': 'Viewing Figures'}, {'text': 'Notebooks and IDEs'}, {'text': 'Standalone scripts and interactive use'}, {'text': 'Creating Figures'}, {'text': 'Figure options'}, {'text': 'Adding Artists'}, {'text': 'Saving Figures'}, {'h2': 'Viewing Figures'}, {'text': 'We will discuss how to create Figures in more detail below, but first it is\nhelpful to understand how to view a Figure. This varies based on how you are\nusing Matplotlib, and what Backend you are using.'}, {'h3': 'Notebooks and IDEs'}, {'text': 'Screenshot of a Jupyter Notebook, with a figure\ngenerated via the default inline backend.#'}, {'text': 'If you are using a Notebook (e.g. Jupyter) or an IDE\nthat renders Notebooks (PyCharm, VSCode, etc), then they have a backend that\nwill render the Matplotlib Figure when a code cell is executed. One thing to\nbe aware of is that the default Jupyter backend (%matplotlib inline) will\nby default trim or expand the figure size to have a tight box around Artists\nadded to the Figure (see Saving Figures, below). If you use a backend\nother than the default 'inline' backend, you will likely need to use an ipython\n'magic' like %matplotlib notebook for the Matplotlib notebook or %matplotlib widget for the ipympl backend.'}, {'text': 'Screenshot of a Jupyter Notebook with an interactive figure generated via\nthe %matplotlib notebook magic. Users should also try the similar\nwidget backend if using JupyterLab.#'}, {'text': 'See also'}, {'text': 'Interactive figures.'}, {'h3': 'Standalone scripts and interactive use'}, {'text': 'If the user is on a client with a windowing system, there are a number of\nBackends that can be used to render the Figure to\nthe screen, usually using a Python Qt, Tk, or Wx toolkit, or the native MacOS\nbackend. These are typically chosen either in the user's matplotlibrc, or by calling, for example,\nmatplotlib.use('QtAgg') at the beginning of a session or script.'}, {'text': 'Screenshot of a Figure generated via a python script and shown using the\nQtAgg backend.#'}, {'text': 'When run from a script, or interactively (e.g. from an\niPython shell) the Figure\nwill not be shown until we call plt.show(). The Figure will appear in\na new GUI window, and usually will have a toolbar with Zoom, Pan, and other tools\nfor interacting with the Figure. By default, plt.show() blocks\nfurther interaction from the script or shell until the Figure window is closed,\nthough that can be toggled off for some purposes. For more details, please see\nInteractive mode.'}, {'text': 'Note that if you are on a client that does not have access to a windowing\nsystem, the Figure will fallback to being drawn using the 'Agg' backend, and\ncannot be viewed, though it can be saved.'}, {'text': 'See also'}, {'text': 'Interactive figures.'}, {'h2': 'Creating Figures'}, {'text': 'By far the most common way to create a figure is using the\npyplot interface. As noted in\nMatplotlib Application Interfaces (APIs), the pyplot interface serves two purposes. One is to spin\nup the Backend and keep track of GUI windows. The other is a global state for\nAxes and Artists that allow a short-form API to plotting methods. In the\nexample above, we use pyplot for the first purpose, and create the Figure object,\nfig. As a side effect fig is also added to pyplot's global state, and\ncan be accessed via gcf.'}, {'text': 'Users typically want an Axes or a grid of Axes when they create a Figure, so in\naddition to figure, there are convenience methods that return both\na Figure and some Axes. A simple grid of Axes can be achieved with\npyplot.subplots (which\nsimply wraps Figure.subplots):'}, {'code': 'fig, axs = plt.subplots(2, 2, figsize=(4, 3), layout='constrained')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'More complex grids can be achieved with pyplot.subplot_mosaic (which wraps\nFigure.subplot_mosaic):'}, {'code': 'fig, axs = plt.subplot_mosaic([['A right'], ['B right']],\n                              figsize=(4, 3), layout='constrained')\nfor ax_name, ax in axs.items():\n    ax.text(0.5, 0.5, ax_name, ha='center', va='center')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'Sometimes we want to have a nested layout in a Figure, with two or more sets of\nAxes that do not share the same subplot grid.\nWe can use add_subfigure or subfigures to create virtual\nfigures inside a parent Figure; see\nFigure subfigures for more details.'}, {'code': 'fig = plt.figure(layout='constrained', facecolor='lightskyblue')\nfig.suptitle('Figure')\nfigL, figR = fig.subfigures(1, 2)\nfigL.set_facecolor('thistle')\naxL = figL.subplots(2, 1, sharex=True)\naxL[1].set_xlabel('x [m]')\nfigL.suptitle('Left subfigure')\nfigR.set_facecolor('paleturquoise')\naxR = figR.subplots(1, 2, sharey=True)\naxR[0].set_title('Axes 1')\nfigR.suptitle('Right subfigure')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'It is possible to directly instantiate a Figure instance without using the\npyplot interface. This is usually only necessary if you want to create your\nown GUI application or service that you do not want carrying the pyplot global\nstate. See the embedding examples in Embedding Matplotlib in graphical user interfaces for examples of\nhow to do this.'}, {'h3': 'Figure options'}, {'text': 'There are a few options available when creating figures. The Figure size on\nthe screen is set by figsize and dpi. figsize is the (width, height)\nof the Figure in inches (or, if preferred, units of 72 typographic points). dpi\nare how many pixels per inch the figure will be rendered at. To make your Figures\nappear on the screen at the physical size you requested, you should set dpi\nto the same dpi as your graphics system. Note that many graphics systems now use\na 'dpi ratio' to specify how many screen pixels are used to represent a graphics\npixel. Matplotlib applies the dpi ratio to the dpi passed to the figure to make\nit have higher resolution, so you should pass the lower number to the figure.'}, {'text': 'The facecolor, edgecolor, linewidth, and frameon options all change the appearance of the\nfigure in expected ways, with frameon making the figure transparent if set to False.'}, {'text': 'Finally, the user can specify a layout engine for the figure with the layout\nparameter. Currently Matplotlib supplies\n'constrained',\n'compressed' and\n'tight' layout engines. These\nrescale axes inside the Figure to prevent overlap of ticklabels, and try and align\naxes, and can save significant manual adjustment of artists on a Figure for many\ncommon cases.'}, {'h3': 'Adding Artists'}, {'text': 'The FigureBase class has a number of methods to add artists to a Figure or\na SubFigure. By far the most common are to add Axes of various configurations\n(add_axes, add_subplot, subplots,\nsubplot_mosaic) and subfigures (subfigures). Colorbars\nare added to Axes or group of Axes at the Figure level (colorbar).\nIt is also possible to have a Figure-level legend (legend).\nOther Artists include figure-wide labels (suptitle,\nsupxlabel, supylabel) and text (text).\nFinally, low-level Artists can be added directly using add_artist\nusually with care being taken to use the appropriate transform. Usually these\ninclude Figure.transFigure which ranges from 0 to 1 in each direction, and\nrepresents the fraction of the current Figure size, or Figure.dpi_scale_trans\nwhich will be in physical units of inches from the bottom left corner of the Figure\n(see Transformations Tutorial for more details).'}, {'h2': 'Saving Figures'}, {'text': 'Finally, Figures can be saved to disk using the savefig method.\nfig.savefig('MyFigure.png', dpi=200) will save a PNG formatted figure to\nthe file MyFigure.png in the current directory on disk with 200 dots-per-inch\nresolution. Note that the filename can include a relative or absolute path to\nany place on the file system.'}, {'text': 'Many types of output are supported, including raster formats like PNG, GIF, JPEG,\nTIFF and vector formats like PDF, EPS, and SVG.'}, {'text': 'By default, the size of the saved Figure is set by the Figure size (in inches) and, for the raster\nformats, the dpi. If dpi is not set, then the dpi of the Figure is used.\nNote that dpi still has meaning for vector formats like PDF if the Figure includes\nArtists that have been rasterized; the\ndpi specified will be the resolution of the rasterized objects.'}, {'text': 'It is possible to change the size of the Figure using the bbox_inches argument\nto savefig. This can be specified manually, again in inches. However, by far\nthe most common use is bbox_inches='tight'. This option 'shrink-wraps', trimming\nor expanding as needed, the size of the figure so that it is tight around all the artists\nin a figure, with a small pad that can be specified by pad_inches, which defaults to\n0.1 inches. The dashed box in the plot below shows the portion of the figure that\nwould be saved if bbox_inches='tight' were used in savefig.'}, {'text': '(Source code, 2x.png, png)'}",
    "id": 3
},
{
    "raw_page": "{'h1': 'Backends'}, {'h2': 'What is a backend?'}, {'text': 'A lot of documentation on the website and in the mailing lists refers\nto the 'backend' and many new users are confused by this term.\nMatplotlib targets many different use cases and output formats. Some\npeople use Matplotlib interactively from the Python shell and have\nplotting windows pop up when they type commands. Some people run\nJupyter notebooks and draw inline plots for\nquick data analysis. Others embed Matplotlib into graphical user\ninterfaces like PyQt or PyGObject to build rich applications. Some\npeople use Matplotlib in batch scripts to generate postscript images\nfrom numerical simulations, and still others run web application\nservers to dynamically serve up graphs.'}, {'text': 'To support all of these use cases, Matplotlib can target different\noutputs, and each of these capabilities is called a backend; the\n'frontend' is the user facing code, i.e., the plotting code, whereas the\n'backend' does all the hard work behind-the-scenes to make the figure.\nThere are two types of backends: user interface backends (for use in\nPyQt/PySide, PyGObject, Tkinter, wxPython, or macOS/Cocoa); also referred to\nas 'interactive backends') and hardcopy backends to make image files\n(PNG, SVG, PDF, PS; also referred to as 'non-interactive backends').'}, {'h2': 'Selecting a backend'}, {'text': 'There are three ways to configure your backend:'}, {'text': 'The rcParamsbackend parameter in your matplotlibrc file'}, {'text': 'The MPLBACKEND environment variable'}, {'text': 'The function matplotlib.use()'}, {'text': 'Below is a more detailed description.'}, {'text': 'If there is more than one configuration present, the last one from the\nlist takes precedence; e.g. calling matplotlib.use() will override\nthe setting in your matplotlibrc.'}, {'text': 'Without a backend explicitly set, Matplotlib automatically detects a usable\nbackend based on what is available on your system and on whether a GUI event\nloop is already running. The first usable backend in the following list is\nselected: MacOSX, QtAgg, GTK4Agg, Gtk3Agg, TkAgg, WxAgg, Agg. The last, Agg,\nis a non-interactive backend that can only write to files. It is used on\nLinux, if Matplotlib cannot connect to either an X display or a Wayland\ndisplay.'}, {'text': 'Here is a detailed description of the configuration methods:'}, {'text': 'Setting rcParamsbackend in your matplotlibrc file:'}, {'code': 'backend : qtagg   # use pyqt with antigrain (agg) rendering\n'}, {'text': 'See also Customizing Matplotlib with style sheets and rcParams.'}, {'text': 'Setting the MPLBACKEND environment variable:'}, {'text': 'You can set the environment variable either for your current shell or for\na single script.'}, {'text': 'On Unix:'}, {'code': '> export MPLBACKEND=qtagg\n> python simple_plot.py\n\n> MPLBACKEND=qtagg python simple_plot.py\n'}, {'text': 'On Windows, only the former is possible:'}, {'code': '> set MPLBACKEND=qtagg\n> python simple_plot.py\n'}, {'text': 'Setting this environment variable will override the backend parameter\nin any matplotlibrc, even if there is a matplotlibrc in\nyour current working directory. Therefore, setting MPLBACKEND\nglobally, e.g. in your .bashrc or .profile, is discouraged\nas it might lead to counter-intuitive behavior.'}, {'text': 'If your script depends on a specific backend you can use the function\nmatplotlib.use():'}, {'code': 'import matplotlib\nmatplotlib.use('qtagg')\n'}, {'text': 'This should be done before any figure is created, otherwise Matplotlib may\nfail to switch the backend and raise an ImportError.'}, {'text': 'Using use will require changes in your code if users want to\nuse a different backend. Therefore, you should avoid explicitly calling\nuse unless absolutely necessary.'}, {'h2': 'The builtin backends'}, {'text': 'By default, Matplotlib should automatically select a default backend which\nallows both interactive work and plotting from scripts, with output to the\nscreen and/or to a file, so at least initially, you will not need to worry\nabout the backend. The most common exception is if your Python distribution\ncomes without tkinter and you have no other GUI toolkit installed.\nThis happens with certain Linux distributions, where you need to install a\nLinux package named python-tk (or similar).'}, {'text': 'If, however, you want to write graphical user interfaces, or a web\napplication server\n(Embedding in a web application server (Flask)), or need a\nbetter understanding of what is going on, read on. To make things easily\nmore customizable for graphical user interfaces, Matplotlib separates\nthe concept of the renderer (the thing that actually does the drawing)\nfrom the canvas (the place where the drawing goes). The canonical\nrenderer for user interfaces is Agg which uses the Anti-Grain\nGeometry C++ library to make a raster (pixel) image of the figure; it\nis used by the QtAgg, GTK4Agg, GTK3Agg, wxAgg, TkAgg, and\nmacosx backends. An alternative renderer is based on the Cairo library,\nused by QtCairo, etc.'}, {'text': 'For the rendering engines, users can also distinguish between vector or raster renderers. Vector\ngraphics languages issue drawing commands like 'draw a line from this\npoint to this point' and hence are scale free. Raster backends\ngenerate a pixel representation of the line whose accuracy depends on a\nDPI setting.'}, {'h3': 'Static backends'}, {'text': 'Here is a summary of the Matplotlib renderers (there is an eponymous\nbackend for each; these are non-interactive backends, capable of\nwriting to a file):'}, {'text': 'Renderer'}, {'text': 'Filetypes'}, {'text': 'Description'}, {'text': 'AGG'}, {'text': 'png'}, {'text': 'raster graphics -- high quality images using the\nAnti-Grain Geometry engine.'}, {'text': 'PDF'}, {'text': 'pdf'}, {'text': 'vector graphics -- Portable Document Format output.'}, {'text': 'PS'}, {'text': 'ps, eps'}, {'text': 'vector graphics -- PostScript output.'}, {'text': 'SVG'}, {'text': 'svg'}, {'text': 'vector graphics -- Scalable Vector Graphics output.'}, {'text': 'PGF'}, {'text': 'pgf, pdf'}, {'text': 'vector graphics -- using the pgf package.'}, {'text': 'Cairo'}, {'text': 'png, ps,\npdf, svg'}, {'text': 'raster or vector graphics -- using the Cairo library\n(requires pycairo or cairocffi).'}, {'text': 'To save plots using the non-interactive backends, use the\nmatplotlib.pyplot.savefig('filename') method.'}, {'h3': 'Interactive backends'}, {'text': 'These are the user interfaces and renderer combinations supported;\nthese are interactive backends, capable of displaying to the screen\nand using appropriate renderers from the table above to write to\na file:'}, {'text': 'Backend'}, {'text': 'Description'}, {'text': 'QtAgg'}, {'text': 'Agg rendering in a Qt canvas (requires PyQt or Qt for Python,\na.k.a. PySide). This backend can be activated in IPython with\n%matplotlib qt. The Qt binding can be selected via the\nQT_API environment variable; see Qt Bindings for\nmore details.'}, {'text': 'ipympl'}, {'text': 'Agg rendering embedded in a Jupyter widget (requires ipympl).\nThis backend can be enabled in a Jupyter notebook with\n%matplotlib ipympl.'}, {'text': 'GTK3Agg'}, {'text': 'Agg rendering to a GTK 3.x canvas (requires PyGObject and\npycairo). This backend can be activated in IPython with\n%matplotlib gtk3.'}, {'text': 'GTK4Agg'}, {'text': 'Agg rendering to a GTK 4.x canvas (requires PyGObject and\npycairo). This backend can be activated in IPython with\n%matplotlib gtk4.'}, {'text': 'macosx'}, {'text': 'Agg rendering into a Cocoa canvas in OSX. This backend can be\nactivated in IPython with %matplotlib osx.'}, {'text': 'TkAgg'}, {'text': 'Agg rendering to a Tk canvas (requires TkInter). This\nbackend can be activated in IPython with %matplotlib tk.'}, {'text': 'nbAgg'}, {'text': 'Embed an interactive figure in a Jupyter classic notebook. This\nbackend can be enabled in Jupyter notebooks via\n%matplotlib notebook.'}, {'text': 'WebAgg'}, {'text': 'On show() will start a tornado server with an interactive\nfigure.'}, {'text': 'GTK3Cairo'}, {'text': 'Cairo rendering to a GTK 3.x canvas (requires PyGObject and\npycairo).'}, {'text': 'GTK4Cairo'}, {'text': 'Cairo rendering to a GTK 4.x canvas (requires PyGObject and\npycairo).'}, {'text': 'wxAgg'}, {'text': 'Agg rendering to a wxWidgets canvas (requires wxPython 4).\nThis backend can be activated in IPython with %matplotlib wx.'}, {'text': 'Note'}, {'text': 'The names of builtin backends case-insensitive; e.g., 'QtAgg' and\n'qtagg' are equivalent.'}, {'h3': 'ipympl'}, {'text': 'The Jupyter widget ecosystem is moving too fast to support directly in\nMatplotlib. To install ipympl:'}, {'code': 'pip install ipympl\n'}, {'text': 'or'}, {'code': 'conda install ipympl -c conda-forge\n'}, {'text': 'See installing ipympl for more details.'}, {'h2': 'Using non-builtin backends'}, {'text': 'More generally, any importable backend can be selected by using any of the\nmethods above. If name.of.the.backend is the module containing the\nbackend, use module://name.of.the.backend as the backend name, e.g.\nmatplotlib.use('module://name.of.the.backend').'}, {'text': 'Information for backend implementers is available at Writing a backend -- the pyplot interface.'}",
    "id": 4
},
{
    "raw_page": "{'h1': 'Matplotlib Application Interfaces (APIs)'}, {'text': 'Matplotlib has two major application interfaces, or styles of using the library:'}, {'text': 'An explicit 'Axes' interface that uses methods on a Figure or Axes object to\ncreate other Artists, and build a visualization step by step. This has also\nbeen called an 'object-oriented' interface.'}, {'text': 'An implicit 'pyplot' interface that keeps track of the last Figure and Axes\ncreated, and adds Artists to the object it thinks the user wants.'}, {'text': 'In addition, a number of downstream libraries (like pandas and xarray) offer\na plot method implemented directly on their data classes so that users can\ncall data.plot().'}, {'text': 'The difference between these interfaces can be a bit confusing, particularly\ngiven snippets on the web that use one or the other, or sometimes multiple\ninterfaces in the same example. Here we attempt to point out how the 'pyplot'\nand downstream interfaces relate to the explicit 'Axes' interface to help users\nbetter navigate the library.'}, {'h2': 'Native Matplotlib interfaces'}, {'h3': 'The explicit 'Axes' interface'}, {'text': 'The 'Axes' interface is how Matplotlib is implemented, and many customizations\nand fine-tuning end up being done at this level.'}, {'text': 'This interface works by instantiating an instance of a\nFigure class (fig below), using a\nsubplots method (or similar) on that object to create one or more\nAxes objects (ax below), and then calling drawing\nmethods on the Axes (plot in this example):'}, {'code': 'import matplotlib.pyplot as plt\n\nfig = plt.figure()\nax = fig.subplots()\nax.plot([1, 2, 3, 4], [0, 0.5, 1, 0.2])\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'We call this an 'explicit' interface because each object is explicitly\nreferenced, and used to make the next object. Keeping references to the objects\nis very flexible, and allows us to customize the objects after they are created,\nbut before they are displayed.'}, {'h3': 'The implicit 'pyplot' interface'}, {'text': 'The pyplot module shadows most of the\nAxes plotting methods to give the equivalent of\nthe above, where the creation of the Figure and Axes is done for the user:'}, {'code': 'import matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4], [0, 0.5, 1, 0.2])\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'This can be convenient, particularly when doing interactive work or simple\nscripts. A reference to the current Figure can be retrieved using\ngcf and to the current Axes by gca. The pyplot module\nretains a list of Figures, and each Figure retains a list of Axes on the figure\nfor the user so that the following:'}, {'code': 'import matplotlib.pyplot as plt\n\nplt.subplot(1, 2, 1)\nplt.plot([1, 2, 3], [0, 0.5, 0.2])\n\nplt.subplot(1, 2, 2)\nplt.plot([3, 2, 1], [0, 0.5, 0.2])\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'is equivalent to:'}, {'code': 'import matplotlib.pyplot as plt\n\nplt.subplot(1, 2, 1)\nax = plt.gca()\nax.plot([1, 2, 3], [0, 0.5, 0.2])\n\nplt.subplot(1, 2, 2)\nax = plt.gca()\nax.plot([3, 2, 1], [0, 0.5, 0.2])\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'In the explicit interface, this would be:'}, {'code': 'import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(1, 2)\naxs[0].plot([1, 2, 3], [0, 0.5, 0.2])\naxs[1].plot([3, 2, 1], [0, 0.5, 0.2])\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'What happens if you have to backtrack, and operate on an old axes that is not\nreferenced by plt.gca()? One simple way is to call subplot again with\nthe same arguments. However, that quickly becomes inelegant. You can also\ninspect the Figure object and get its list of Axes objects, however, that can be\nmisleading (colorbars are Axes too!). The best solution is probably to save a\nhandle to every Axes you create, but if you do that, why not simply create the\nall the Axes objects at the start?'}, {'text': 'The first approach is to call plt.subplot again:'}, {'code': 'import matplotlib.pyplot as plt\n\nplt.subplot(1, 2, 1)\nplt.plot([1, 2, 3], [0, 0.5, 0.2])\n\nplt.subplot(1, 2, 2)\nplt.plot([3, 2, 1], [0, 0.5, 0.2])\n\nplt.suptitle('Implicit Interface: re-call subplot')\n\nfor i in range(1, 3):\n    plt.subplot(1, 2, i)\n    plt.xlabel('Boo')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'The second is to save a handle:'}, {'code': 'import matplotlib.pyplot as plt\n\naxs = []\nax = plt.subplot(1, 2, 1)\naxs += [ax]\nplt.plot([1, 2, 3], [0, 0.5, 0.2])\n\nax = plt.subplot(1, 2, 2)\naxs += [ax]\nplt.plot([3, 2, 1], [0, 0.5, 0.2])\n\nplt.suptitle('Implicit Interface: save handles')\n\nfor i in range(2):\n    plt.sca(axs[i])\n    plt.xlabel('Boo')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'However, the recommended way would be to be explicit from the outset:'}, {'code': 'import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(1, 2)\naxs[0].plot([1, 2, 3], [0, 0.5, 0.2])\naxs[1].plot([3, 2, 1], [0, 0.5, 0.2])\nfig.suptitle('Explicit Interface')\nfor i in range(2):\n    axs[i].set_xlabel('Boo')\n'}, {'text': '(Source code, 2x.png, png)'}, {'h2': 'Third-party library 'Data-object' interfaces'}, {'text': 'Some third party libraries have chosen to implement plotting for their data\nobjects, e.g. data.plot(), is seen in pandas, xarray, and other\nthird-party libraries. For illustrative purposes, a downstream library may\nimplement a simple data container that has x and y data stored together,\nand then implements a plot method:'}, {'code': 'import matplotlib.pyplot as plt\n\n# supplied by downstream library:\nclass DataContainer:\n\n    def __init__(self, x, y):\n        '''\n        Proper docstring here!\n        '''\n        self._x = x\n        self._y = y\n\n    def plot(self, ax=None, **kwargs):\n        if ax is None:\n            ax = plt.gca()\n        ax.plot(self._x, self._y, **kwargs)\n        ax.set_title('Plotted from DataClass!')\n        return ax\n\n\n# what the user usually calls:\ndata = DataContainer([0, 1, 2, 3], [0, 0.2, 0.5, 0.3])\ndata.plot()\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'So the library can hide all the nitty-gritty from the user, and can make a\nvisualization appropriate to the data type, often with good labels, choices of\ncolormaps, and other convenient features.'}, {'text': 'In the above, however, we may not have liked the title the library provided.\nThankfully, they pass us back the Axes from the plot() method, and\nunderstanding the explicit Axes interface, we could call:\nax.set_title('My preferred title') to customize the title.'}, {'text': 'Many libraries also allow their plot methods to accept an optional ax\nargument. This allows us to place the visualization in an Axes that we have\nplaced and perhaps customized.'}, {'h2': 'Summary'}, {'text': 'Overall, it is useful to understand the explicit 'Axes' interface since it is\nthe most flexible and underlies the other interfaces. A user can usually\nfigure out how to drop down to the explicit interface and operate on the\nunderlying objects. While the explicit interface can be a bit more verbose\nto setup, complicated plots will often end up simpler than trying to use\nthe implicit 'pyplot' interface.'}, {'text': 'Note'}, {'text': 'It is sometimes confusing to people that we import pyplot for both\ninterfaces. Currently, the pyplot module implements the 'pyplot'\ninterface, but it also provides top-level Figure and Axes creation\nmethods, and ultimately spins up the graphical user interface, if one\nis being used. So pyplot is still needed regardless of the\ninterface chosen.'}, {'text': 'Similarly, the declarative interfaces provided by partner libraries use the\nobjects accessible by the 'Axes' interface, and often accept these as arguments\nor pass them back from methods. It is usually essential to use the explicit\n'Axes' interface to perform any customization of the default visualization, or\nto unpack the data into NumPy arrays and pass directly to Matplotlib.'}, {'h2': 'Appendix: 'Axes' interface with data structures'}, {'text': 'Most Axes methods allow yet another API addressing by passing a\ndata object to the method and specifying the arguments as strings:'}, {'code': 'import matplotlib.pyplot as plt\n\ndata = {'xdat': [0, 1, 2, 3], 'ydat': [0, 0.2, 0.4, 0.1]}\nfig, ax = plt.subplots(figsize=(2, 2))\nax.plot('xdat ydat', data=data)\n'}, {'text': '(Source code, 2x.png, png)'}, {'h2': 'Appendix: 'pylab' interface'}, {'text': 'There is one further interface that is highly discouraged, and that is to\nbasically do from matplotlib.pyplot import *. This allows users to simply\ncall plot(x, y). While convenient, this can lead to obvious problems if the\nuser unwittingly names a variable the same name as a pyplot method.'}",
    "id": 5
},
{
    "raw_page": "{'h1': 'Interactive figures'}, {'text': 'When working with data, interactivity can be invaluable. The pan/zoom and\nmouse-location tools built into the Matplotlib GUI windows are often sufficient, but\nyou can also use the event system to build customized data exploration tools.'}, {'text': 'See also'}, {'text': 'Introduction to Figures.'}, {'text': 'Matplotlib ships with backends binding to\nseveral GUI toolkits (Qt, Tk, Wx, GTK, macOS, JavaScript) and third party\npackages provide bindings to kivy and Jupyter Lab. For the figures to be responsive to\nmouse, keyboard, and paint events, the GUI event loop needs to be integrated\nwith an interactive prompt. We recommend using IPython (see below).'}, {'text': 'The pyplot module provides functions for explicitly creating figures\nthat include interactive tools, a toolbar, a tool-tip, and\nkey bindings:'}, {'text': 'Creates a new empty Figure or selects an existing figure'}, {'text': 'Creates a new Figure and fills it with a grid of Axes'}, {'text': 'pyplot has a notion of 'The Current Figure' which can be accessed\nthrough pyplot.gcf and a notion of 'The Current Axes' accessed\nthrough pyplot.gca. Almost all of the functions in pyplot pass\nthrough the current Figure / Axes (or create one) as\nappropriate.'}, {'text': 'Matplotlib keeps a reference to all of the open figures\ncreated via pyplot.figure or pyplot.subplots so that the figures will not be garbage\ncollected. Figures can be closed and deregistered from pyplot individually via\npyplot.close; all open Figures can be closed via plt.close('all').'}, {'text': 'See also'}, {'text': 'For more discussion of Matplotlib's event system and integrated event loops:'}, {'text': 'Interactive figures and asynchronous programming'}, {'text': 'Event handling and picking'}, {'h2': 'IPython integration'}, {'text': 'We recommend using IPython for an interactive shell. In addition to\nall of its features (improved tab-completion, magics, multiline editing, etc),\nit also ensures that the GUI toolkit event loop is properly integrated\nwith the command line (see Command prompt integration).'}, {'text': 'In this example, we create and modify a figure via an IPython prompt.\nThe figure displays in a QtAgg GUI window. To configure the integration\nand enable interactive mode use the\n%matplotlib magic:'}, {'code': 'In [1]: %matplotlib\nUsing matplotlib backend: QtAgg\n\nIn [2]: import matplotlib.pyplot as plt\n'}, {'text': 'Create a new figure window:'}, {'code': 'In [3]: fig, ax = plt.subplots()\n'}, {'text': 'Add a line plot of the data to the window:'}, {'code': 'In [4]: ln, = ax.plot(range(5))\n'}, {'text': 'Change the color of the line from blue to orange:'}, {'code': 'In [5]: ln.set_color('orange')\n'}, {'text': 'If you wish to disable automatic redrawing of the plot:'}, {'code': 'In [6]: plt.ioff()\n'}, {'text': 'If you wish to re-enable automatic redrawing of the plot:'}, {'code': 'In [7]: plt.ion()\n'}, {'text': 'In recent versions of Matplotlib and IPython, it is\nsufficient to import matplotlib.pyplot and call pyplot.ion.\nUsing the % magic is guaranteed to work in all versions of Matplotlib and IPython.'}, {'h2': 'Interactive mode'}, {'text': 'pyplot.ion'}, {'text': 'Enable interactive mode.'}, {'text': 'pyplot.ioff'}, {'text': 'Disable interactive mode.'}, {'text': 'pyplot.isinteractive'}, {'text': 'Return whether plots are updated after every plotting command.'}, {'text': 'pyplot.show'}, {'text': 'Display all open figures.'}, {'text': 'pyplot.pause'}, {'text': 'Run the GUI event loop for interval seconds.'}, {'text': 'Interactive mode controls:'}, {'text': 'whether created figures are automatically shown'}, {'text': 'whether changes to artists automatically trigger re-drawing existing figures'}, {'text': 'when pyplot.show() returns if given no arguments: immediately, or after all of the figures have been closed'}, {'text': 'If in interactive mode:'}, {'text': 'newly created figures will be displayed immediately'}, {'text': 'figures will automatically redraw when elements are changed'}, {'text': 'pyplot.show() displays the figures and immediately returns'}, {'text': 'If not in interactive mode:'}, {'text': 'newly created figures and changes to figures are not displayed until'}, {'text': 'pyplot.show() is called'}, {'text': 'pyplot.pause() is called'}, {'text': 'FigureCanvasBase.flush_events() is called'}, {'text': 'pyplot.show() runs the GUI event loop and does not return until all the plot windows are closed'}, {'text': 'If you are in non-interactive mode (or created figures while in\nnon-interactive mode) you may need to explicitly call pyplot.show\nto display the windows on your screen. If you only want to run the\nGUI event loop for a fixed amount of time, you can use pyplot.pause.\nThis will block the progress of your code as if you had called\ntime.sleep, ensure the current window is shown and re-drawn if needed,\nand run the GUI event loop for the specified period of time.'}, {'text': 'The GUI event loop being integrated with your command prompt and\nthe figures being in interactive mode are independent of each other.\nIf you try to use pyplot.ion without arranging for the event-loop integration,\nyour figures will appear but will not be interactive while the prompt is waiting for input.\nYou will not be able to pan/zoom and the figure may not even render\n(the window might appear black, transparent, or as a snapshot of the\ndesktop under it). Conversely, if you configure the event loop\nintegration, displayed figures will be responsive while waiting for input\nat the prompt, regardless of pyplot's 'interactive mode'.'}, {'text': 'No matter what combination of interactive mode setting and event loop integration,\nfigures will be responsive if you use pyplot.show(block=True), pyplot.pause, or run\nthe GUI main loop in some other way.'}, {'text': 'Warning'}, {'text': 'Using Figure.show it is possible to display a figure on\nthe screen without starting the event loop and without being in\ninteractive mode. This may work (depending on the GUI toolkit) but\nwill likely result in a non-responsive figure.'}, {'h2': 'Default UI'}, {'text': 'The windows created by pyplot have an interactive toolbar with navigation\nbuttons and a readout of the data values the cursor is pointing at.'}, {'h2': 'Interactive navigation'}, {'text': 'All figure windows come with a navigation toolbar, which can be used\nto navigate through the data set. Here is a description of each of\nthe buttons at the bottom of the toolbar'}, {'text': 'These are akin to a web browser's home, forward and back controls.\nForward and Back are used to navigate back and forth between\npreviously defined views. They have no meaning unless you have already\nnavigated somewhere else using the pan and zoom buttons. This is analogous\nto trying to click Back on your web browser before visiting a\nnew page or Forward before you have gone back to a page --\nnothing happens. Home always takes you to the\nfirst, default view of your data. Again, all of these buttons should\nfeel very familiar to any user of a web browser.'}, {'text': 'This button has two modes: pan and zoom. Click the toolbar button\nto activate panning and zooming, then put your mouse somewhere\nover an axes. Press the left mouse button and hold it to pan the\nfigure, dragging it to a new position. When you release it, the\ndata under the point where you pressed will be moved to the point\nwhere you released. If you press 'x' or 'y' while panning the\nmotion will be constrained to the x or y axis, respectively. Press\nthe right mouse button to zoom, dragging it to a new position.\nThe x axis will be zoomed in proportionately to the rightward\nmovement and zoomed out proportionately to the leftward movement.\nThe same is true for the y axis and up/down motions. The point under your\nmouse when you begin the zoom remains stationary, allowing you to\nzoom in or out around that point as much as you wish. You can use the\nmodifier keys 'x y' or 'CONTROL' to constrain the zoom to the x\naxis, the y axis, or aspect ratio preserve, respectively.'}, {'text': 'With polar plots, the pan and zoom functionality behaves\ndifferently. The radius axis labels can be dragged using the left\nmouse button. The radius scale can be zoomed in and out using the\nright mouse button.'}, {'text': 'Click this toolbar button to activate this mode. Put your mouse somewhere\nover an axes and press a mouse button. Define a rectangular region by\ndragging the mouse while holding the button to a new location. When using\nthe left mouse button, the axes view limits will be zoomed to the defined\nregion. When using the right mouse button, the axes view limits will be\nzoomed out, placing the original axes in the defined region.'}, {'text': 'Use this tool to configure the appearance of the subplot:\nyou can stretch or compress the left, right, top, or bottom\nside of the subplot, or the space between the rows or\nspace between the columns.'}, {'text': 'Click this button to launch a file save dialog. You can save\nfiles with the following extensions: png, ps, eps,\nsvg and pdf.'}, {'h3': 'Navigation keyboard shortcuts'}, {'text': 'A number of helpful keybindings are registered by default. The following table\nholds all the default keys, which can be overwritten by use of your\nmatplotlibrc.'}, {'text': 'Command'}, {'text': 'Default key binding and rcParam'}, {'text': 'Home/Reset'}, {'text': 'rcParamskeymap.home (default: ['h', 'r', 'home'])'}, {'text': 'Back'}, {'text': 'rcParamskeymap.back (default: ['left', 'c', 'backspace', 'MouseButton.BACK'])'}, {'text': 'Forward'}, {'text': 'rcParamskeymap.forward (default: ['right', 'v', 'MouseButton.FORWARD'])'}, {'text': 'Pan/Zoom'}, {'text': 'rcParamskeymap.pan (default: ['p'])'}, {'text': 'Zoom-to-rect'}, {'text': 'rcParamskeymap.zoom (default: ['o'])'}, {'text': 'Save'}, {'text': 'rcParamskeymap.save (default: ['s', 'ctrl+s'])'}, {'text': 'Toggle fullscreen'}, {'text': 'rcParamskeymap.fullscreen (default: ['f', 'ctrl+f'])'}, {'text': 'Toggle major grids'}, {'text': 'rcParamskeymap.grid (default: ['g'])'}, {'text': 'Toggle minor grids'}, {'text': 'rcParamskeymap.grid_minor (default: ['G'])'}, {'text': 'Toggle x axis scale (log/linear)'}, {'text': 'rcParamskeymap.xscale (default: ['k', 'L'])'}, {'text': 'Toggle y axis scale (log/linear)'}, {'text': 'rcParamskeymap.yscale (default: ['l'])'}, {'text': 'Close Figure'}, {'text': 'rcParamskeymap.quit (default: ['ctrl+w', 'cmd+w', 'q'])'}, {'text': 'Constrain pan/zoom to x axis'}, {'text': 'hold x when panning/zooming with mouse'}, {'text': 'Constrain pan/zoom to y axis'}, {'text': 'hold y when panning/zooming with mouse'}, {'text': 'Preserve aspect ratio'}, {'text': 'hold CONTROL when panning/zooming with mouse'}, {'h2': 'Other Python prompts'}, {'text': 'Interactive mode works in the default Python prompt:'}, {'code': '>>> import matplotlib.pyplot as plt\n>>> plt.ion()\n>>>\n'}, {'text': 'however this does not ensure that the event hook is properly installed\nand your figures may not be responsive. Please consult the\ndocumentation of your GUI toolkit for details.'}, {'h3': 'Jupyter Notebooks / JupyterLab'}, {'text': 'Note'}, {'text': 'To get the interactive functionality described here, you must be\nusing an interactive backend. The default backend in notebooks,\nthe inline backend, is not. backend_inline\nrenders the figure once and inserts a static image into the\nnotebook when the cell is executed. Because the images are static, they\ncannot be panned / zoomed, take user input, or be updated from other\ncells.'}, {'text': 'To get interactive figures in the 'classic' notebook or Jupyter lab,\nuse the ipympl backend\n(must be installed separately) which uses the ipywidget framework.\nIf ipympl is installed use the magic:'}, {'code': '%matplotlib widget\n'}, {'text': 'to select and enable it.'}, {'text': 'If you only need to use the classic notebook, you can use'}, {'code': '%matplotlib notebook\n'}, {'text': 'which uses the backend_nbagg backend provided by Matplotlib;\nhowever, nbagg does not work in Jupyter Lab.'}, {'text': 'You can also use one of the non-ipympl GUI backends in a Jupyter Notebook.\nIf you are running your Jupyter kernel locally, the GUI window will spawn on\nyour desktop adjacent to your web browser. If you run your notebook on a remote server,\nthe kernel will try to open the GUI window on the remote computer. Unless you have\narranged to forward the xserver back to your desktop, you will not be able to\nsee or interact with the window. It may also raise an exception.'}, {'h3': 'PyCharm, Spyder, and VSCode'}, {'text': 'Many IDEs have built-in integration with Matplotlib, please consult their\ndocumentation for configuration details.'}",
    "id": 6
},
{
    "raw_page": "{'h1': 'Interactive figures and asynchronous programming'}, {'text': 'Matplotlib supports rich interactive figures by embedding figures into\na GUI window. The basic interactions of panning and zooming in an\nAxes to inspect your data is 'baked in' to Matplotlib. This is\nsupported by a full mouse and keyboard event handling system that\nyou can use to build sophisticated interactive graphs.'}, {'text': 'This guide is meant to be an introduction to the low-level details of\nhow Matplotlib integration with a GUI event loop works. For a more\npractical introduction to the Matplotlib event API see event\nhandling system, Interactive Tutorial, and\nInteractive Applications using Matplotlib.'}, {'h2': 'Event loops'}, {'text': 'Fundamentally, all user interaction (and networking) is implemented as\nan infinite loop waiting for events from the user (via the OS) and\nthen doing something about it. For example, a minimal Read Evaluate\nPrint Loop (REPL) is'}, {'code': 'exec_count = 0\nwhile True:\n    inp = input(f'[{exec_count}] > ')        # Read\n    ret = eval(inp)                          # Evaluate\n    print(ret)                               # Print\n    exec_count += 1                          # Loop\n'}, {'text': 'This is missing many niceties (for example, it exits on the first\nexception!), but is representative of the event loops that underlie\nall terminals, GUIs, and servers [1]. In general the Read step\nis waiting on some sort of I/O -- be it user input or the network --\nwhile the Evaluate and Print are responsible for interpreting the\ninput and then doing something about it.'}, {'text': 'In practice we interact with a framework that provides a mechanism to\nregister callbacks to be run in response to specific events rather\nthan directly implement the I/O loop [2]. For example 'when the\nuser clicks on this button, please run this function' or 'when the\nuser hits the 'z' key, please run this other function'. This allows\nusers to write reactive, event-driven, programs without having to\ndelve into the nitty-gritty [3] details of I/O. The core event loop\nis sometimes referred to as 'the main loop' and is typically started,\ndepending on the library, by methods with names like _exec,\nrun, or start.'}, {'text': 'All GUI frameworks (Qt, Wx, Gtk, tk, OSX, or web) have some method of\ncapturing user interactions and passing them back to the application\n(for example Signal / Slot framework in Qt) but the exact\ndetails depend on the toolkit. Matplotlib has a backend for each GUI toolkit we support which uses the\ntoolkit API to bridge the toolkit UI events into Matplotlib's event\nhandling system. You can then use\nFigureCanvasBase.mpl_connect to connect your function to\nMatplotlib's event handling system. This allows you to directly\ninteract with your data and write GUI toolkit agnostic user\ninterfaces.'}, {'h2': 'Command prompt integration'}, {'text': 'So far, so good. We have the REPL (like the IPython terminal) that\nlets us interactively send code to the interpreter and get results\nback. We also have the GUI toolkit that runs an event loop waiting\nfor user input and lets us register functions to be run when that\nhappens. However, if we want to do both we have a problem: the prompt\nand the GUI event loop are both infinite loops that each think they\nare in charge! In order for both the prompt and the GUI windows to be\nresponsive we need a method to allow the loops to 'timeshare' :'}, {'text': 'let the GUI main loop block the python process when you want\ninteractive windows'}, {'text': 'let the CLI main loop block the python process and intermittently\nrun the GUI loop'}, {'text': 'fully embed python in the GUI (but this is basically writing a full\napplication)'}, {'h3': 'Blocking the prompt'}, {'text': 'pyplot.show'}, {'text': 'Display all open figures.'}, {'text': 'pyplot.pause'}, {'text': 'Run the GUI event loop for interval seconds.'}, {'text': 'backend_bases.FigureCanvasBase.start_event_loop'}, {'text': 'Start a blocking event loop.'}, {'text': 'backend_bases.FigureCanvasBase.stop_event_loop'}, {'text': 'Stop the current blocking event loop.'}, {'text': 'The simplest 'integration' is to start the GUI event loop in\n'blocking' mode and take over the CLI. While the GUI event loop is\nrunning you cannot enter new commands into the prompt (your terminal\nmay echo the characters typed into the terminal, but they will not be\nsent to the Python interpreter because it is busy running the GUI\nevent loop), but the figure windows will be responsive. Once the\nevent loop is stopped (leaving any still open figure windows\nnon-responsive) you will be able to use the prompt again. Re-starting\nthe event loop will make any open figure responsive again (and will\nprocess any queued up user interaction).'}, {'text': 'To start the event loop until all open figures are closed, use\npyplot.show as'}, {'code': 'pyplot.show(block=True)\n'}, {'text': 'To start the event loop for a fixed amount of time (in seconds) use\npyplot.pause.'}, {'text': 'If you are not using pyplot you can start and stop the event loops\nvia FigureCanvasBase.start_event_loop and\nFigureCanvasBase.stop_event_loop. However, in most contexts where\nyou would not be using pyplot you are embedding Matplotlib in a\nlarge GUI application and the GUI event loop should already be running\nfor the application.'}, {'text': 'Away from the prompt, this technique can be very useful if you want to\nwrite a script that pauses for user interaction, or displays a figure\nbetween polling for additional data. See Scripts and functions\nfor more details.'}, {'h3': 'Input hook integration'}, {'text': 'While running the GUI event loop in a blocking mode or explicitly\nhandling UI events is useful, we can do better! We really want to be\nable to have a usable prompt and interactive figure windows.'}, {'text': 'We can do this using the 'input hook' feature of the interactive\nprompt. This hook is called by the prompt as it waits for the user\nto type (even for a fast typist the prompt is mostly waiting for the\nhuman to think and move their fingers). Although the details vary\nbetween prompts the logic is roughly'}, {'text': 'start to wait for keyboard input'}, {'text': 'start the GUI event loop'}, {'text': 'as soon as the user hits a key, exit the GUI event loop and handle the key'}, {'text': 'repeat'}, {'text': 'This gives us the illusion of simultaneously having interactive GUI\nwindows and an interactive prompt. Most of the time the GUI event\nloop is running, but as soon as the user starts typing the prompt\ntakes over again.'}, {'text': 'This time-share technique only allows the event loop to run while\npython is otherwise idle and waiting for user input. If you want the\nGUI to be responsive during long running code it is necessary to\nperiodically flush the GUI event queue as described in Explicitly spinning the event Loop.\nIn this case it is your code, not the REPL, which\nis blocking the process so you need to handle the 'time-share' manually.\nConversely, a very slow figure draw will block the prompt until it\nfinishes drawing.'}, {'h2': 'Full embedding'}, {'text': 'It is also possible to go the other direction and fully embed figures\n(and a Python interpreter) in a rich\nnative application. Matplotlib provides classes for each toolkit\nwhich can be directly embedded in GUI applications (this is how the\nbuilt-in windows are implemented!). See Embedding Matplotlib in graphical user interfaces for\nmore details.'}, {'h2': 'Scripts and functions'}, {'text': 'backend_bases.FigureCanvasBase.flush_events'}, {'text': 'Flush the GUI events for the figure.'}, {'text': 'backend_bases.FigureCanvasBase.draw_idle'}, {'text': 'Request a widget redraw once control returns to the GUI event loop.'}, {'text': 'figure.Figure.ginput'}, {'text': 'Blocking call to interact with a figure.'}, {'text': 'pyplot.ginput'}, {'text': 'Blocking call to interact with a figure.'}, {'text': 'pyplot.show'}, {'text': 'Display all open figures.'}, {'text': 'pyplot.pause'}, {'text': 'Run the GUI event loop for interval seconds.'}, {'text': 'There are several use-cases for using interactive figures in scripts:'}, {'text': 'capture user input to steer the script'}, {'text': 'progress updates as a long running script progresses'}, {'text': 'streaming updates from a data source'}, {'h3': 'Blocking functions'}, {'text': 'If you only need to collect points in an Axes you can use\nFigure.ginput. However if you have written some custom event\nhandling or are using widgets you will need to manually run the GUI\nevent loop using the methods described above.'}, {'text': 'You can also use the methods described in Blocking the prompt\nto suspend run the GUI event loop. Once the loop exits your code will\nresume. In general, any place you would use time.sleep you can use\npyplot.pause instead with the added benefit of interactive figures.'}, {'text': 'For example, if you want to poll for data you could use something like'}, {'code': 'fig, ax = plt.subplots()\nln, = ax.plot([], [])\n\nwhile True:\n    x, y = get_new_data()\n    ln.set_data(x, y)\n    plt.pause(1)\n'}, {'text': 'which would poll for new data and update the figure at 1Hz.'}, {'h3': 'Explicitly spinning the event Loop'}, {'text': 'backend_bases.FigureCanvasBase.flush_events'}, {'text': 'Flush the GUI events for the figure.'}, {'text': 'backend_bases.FigureCanvasBase.draw_idle'}, {'text': 'Request a widget redraw once control returns to the GUI event loop.'}, {'text': 'If you have open windows that have pending UI\nevents (mouse clicks, button presses, or draws) you can explicitly\nprocess those events by calling FigureCanvasBase.flush_events.\nThis will run the GUI event loop until all UI events currently waiting\nhave been processed. The exact behavior is backend-dependent but\ntypically events on all figure are processed and only events waiting\nto be processed (not those added during processing) will be handled.'}, {'text': 'For example'}, {'code': 'import time\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.ion()\n\nfig, ax = plt.subplots()\nth = np.linspace(0, 2*np.pi, 512)\nax.set_ylim(-1.5, 1.5)\n\nln, = ax.plot(th, np.sin(th))\n\ndef slow_loop(N, ln):\n    for j in range(N):\n        time.sleep(.1)  # to simulate some work\n        ln.figure.canvas.flush_events()\n\nslow_loop(100, ln)\n'}, {'text': 'While this will feel a bit laggy (as we are only processing user input\nevery 100ms whereas 20-30ms is what feels 'responsive') it will\nrespond.'}, {'text': 'If you make changes to the plot and want it re-rendered you will need\nto call draw_idle to request that the canvas be\nre-drawn. This method can be thought of draw_soon in analogy to\nasyncio.loop.call_soon.'}, {'text': 'We can add this to our example above as'}, {'code': 'def slow_loop(N, ln):\n    for j in range(N):\n        time.sleep(.1)  # to simulate some work\n        if j % 10:\n            ln.set_ydata(np.sin(((j // 10) % 5 * th)))\n            ln.figure.canvas.draw_idle()\n\n        ln.figure.canvas.flush_events()\n\nslow_loop(100, ln)\n'}, {'text': 'The more frequently you call FigureCanvasBase.flush_events the more\nresponsive your figure will feel but at the cost of spending more\nresources on the visualization and less on your computation.'}, {'h2': 'Stale artists'}, {'text': 'Artists (as of Matplotlib 1.5) have a stale attribute which is\nTrue if the internal state of the artist has changed since the last\ntime it was rendered. By default the stale state is propagated up to\nthe Artists parents in the draw tree, e.g., if the color of a Line2D\ninstance is changed, the Axes and Figure that\ncontain it will also be marked as 'stale'. Thus, fig.stale will\nreport if any artist in the figure has been modified and is out of sync\nwith what is displayed on the screen. This is intended to be used to\ndetermine if draw_idle should be called to schedule a re-rendering\nof the figure.'}, {'text': 'Each artist has a Artist.stale_callback attribute which holds a callback\nwith the signature'}, {'code': 'def callback(self: Artist, val: bool) -> None:\n   ...\n'}, {'text': 'which by default is set to a function that forwards the stale state to\nthe artist's parent. If you wish to suppress a given artist from propagating\nset this attribute to None.'}, {'text': 'Figure instances do not have a containing artist and their\ndefault callback is None. If you call pyplot.ion and are not in\nIPython we will install a callback to invoke\ndraw_idle whenever the\nFigure becomes stale. In IPython we use the\n'post_execute' hook to invoke\ndraw_idle on any stale figures\nafter having executed the user's input, but before returning the prompt\nto the user. If you are not using pyplot you can use the callback\nFigure.stale_callback attribute to be notified when a figure has\nbecome stale.'}, {'h2': 'Idle draw'}, {'text': 'backend_bases.FigureCanvasBase.draw'}, {'text': 'Render the Figure.'}, {'text': 'backend_bases.FigureCanvasBase.draw_idle'}, {'text': 'Request a widget redraw once control returns to the GUI event loop.'}, {'text': 'backend_bases.FigureCanvasBase.flush_events'}, {'text': 'Flush the GUI events for the figure.'}, {'text': 'In almost all cases, we recommend using\nbackend_bases.FigureCanvasBase.draw_idle over\nbackend_bases.FigureCanvasBase.draw. draw forces a rendering of\nthe figure whereas draw_idle schedules a rendering the next time\nthe GUI window is going to re-paint the screen. This improves\nperformance by only rendering pixels that will be shown on the screen. If\nyou want to be sure that the screen is updated as soon as possible do'}, {'code': 'fig.canvas.draw_idle()\nfig.canvas.flush_events()\n'}, {'h2': 'Threading'}, {'text': 'Most GUI frameworks require that all updates to the screen, and hence\ntheir main event loop, run on the main thread. This makes pushing\nperiodic updates of a plot to a background thread impossible.\nAlthough it seems backwards, it is typically easier to push your\ncomputations to a background thread and periodically update\nthe figure on the main thread.'}, {'text': 'In general Matplotlib is not thread safe. If you are going to update\nArtist objects in one thread and draw from another you should make\nsure that you are locking in the critical sections.'}, {'h2': 'Eventloop integration mechanism'}, {'h3': 'CPython / readline'}, {'text': 'The Python C API provides a hook, PyOS_InputHook, to register a\nfunction to be run ('The function will be called when Python's\ninterpreter prompt is about to become idle and wait for user input\nfrom the terminal.'). This hook can be used to integrate a second\nevent loop (the GUI event loop) with the python input prompt loop.\nThe hook functions typically exhaust all pending events on the GUI\nevent queue, run the main loop for a short fixed amount of time, or\nrun the event loop until a key is pressed on stdin.'}, {'text': 'Matplotlib does not currently do any management of PyOS_InputHook due\nto the wide range of ways that Matplotlib is used. This management is left to\ndownstream libraries -- either user code or the shell. Interactive figures,\neven with Matplotlib in 'interactive mode', may not work in the vanilla python\nrepl if an appropriate PyOS_InputHook is not registered.'}, {'text': 'Input hooks, and helpers to install them, are usually included with\nthe python bindings for GUI toolkits and may be registered on import.\nIPython also ships input hook functions for all of the GUI frameworks\nMatplotlib supports which can be installed via %matplotlib. This\nis the recommended method of integrating Matplotlib and a prompt.'}, {'h3': 'IPython / prompt_toolkit'}, {'text': 'With IPython >= 5.0 IPython has changed from using CPython's readline\nbased prompt to a prompt_toolkit based prompt. prompt_toolkit\nhas the same conceptual input hook, which is fed into prompt_toolkit via the\nIPython.terminal.interactiveshell.TerminalInteractiveShell.inputhook()\nmethod. The source for the prompt_toolkit input hooks lives at\nIPython.terminal.pt_inputhooks.'}, {'text': 'Footnotes'}, {'text': 'A limitation of this design is that you can only wait for one\ninput, if there is a need to multiplex between multiple sources\nthen the loop would look something like'}, {'code': 'fds = [...]\n    while True:                    # Loop\n        inp = select(fds).read()   # Read\n        eval(inp)                  # Evaluate / Print\n'}, {'text': 'Or you can write your own if you must.'}, {'text': 'These examples are aggressively dropping many of the\ncomplexities that must be dealt with in the real world such as\nkeyboard interrupts, timeouts, bad input, resource\nallocation and cleanup, etc.'}",
    "id": 7
},
{
    "raw_page": "{'h1': 'Event handling and picking'}, {'text': 'Matplotlib works with a number of user interface toolkits (wxpython,\ntkinter, qt, gtk, and macosx) and in order to support features like\ninteractive panning and zooming of figures, it is helpful to the\ndevelopers to have an API for interacting with the figure via key\npresses and mouse movements that is 'GUI neutral' so we don't have to\nrepeat a lot of code across the different user interfaces. Although\nthe event handling API is GUI neutral, it is based on the GTK model,\nwhich was the first user interface Matplotlib supported. The events\nthat are triggered are also a bit richer vis-a-vis Matplotlib than\nstandard GUI events, including information like which\nAxes the event occurred in. The events also\nunderstand the Matplotlib coordinate system, and report event\nlocations in both pixel and data coordinates.'}, {'h2': 'Event connections'}, {'text': 'To receive events, you need to write a callback function and then\nconnect your function to the event manager, which is part of the\nFigureCanvasBase. Here is a simple\nexample that prints the location of the mouse click and which button\nwas pressed:'}, {'code': 'fig, ax = plt.subplots()\nax.plot(np.random.rand(10))\n\ndef onclick(event):\n    print('%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %\n          ('double' if event.dblclick else 'single', event.button,\n           event.x, event.y, event.xdata, event.ydata))\n\ncid = fig.canvas.mpl_connect('button_press_event', onclick)\n'}, {'text': 'The FigureCanvasBase.mpl_connect method returns a connection id (an\ninteger), which can be used to disconnect the callback via'}, {'code': 'fig.canvas.mpl_disconnect(cid)\n'}, {'text': 'Note'}, {'text': 'The canvas retains only weak references to instance methods used as\ncallbacks. Therefore, you need to retain a reference to instances owning\nsuch methods. Otherwise the instance will be garbage-collected and the\ncallback will vanish.'}, {'text': 'This does not affect free functions used as callbacks.'}, {'text': 'Here are the events that you can connect to, the class instances that\nare sent back to you when the event occurs, and the event descriptions:'}, {'text': 'Event name'}, {'text': 'Class'}, {'text': 'Description'}, {'text': ''button_press_event''}, {'text': 'MouseEvent'}, {'text': 'mouse button is pressed'}, {'text': ''button_release_event''}, {'text': 'MouseEvent'}, {'text': 'mouse button is released'}, {'text': ''close_event''}, {'text': 'CloseEvent'}, {'text': 'figure is closed'}, {'text': ''draw_event''}, {'text': 'DrawEvent'}, {'text': 'canvas has been drawn (but screen\nwidget not updated yet)'}, {'text': ''key_press_event''}, {'text': 'KeyEvent'}, {'text': 'key is pressed'}, {'text': ''key_release_event''}, {'text': 'KeyEvent'}, {'text': 'key is released'}, {'text': ''motion_notify_event''}, {'text': 'MouseEvent'}, {'text': 'mouse moves'}, {'text': ''pick_event''}, {'text': 'PickEvent'}, {'text': 'artist in the canvas is selected'}, {'text': ''resize_event''}, {'text': 'ResizeEvent'}, {'text': 'figure canvas is resized'}, {'text': ''scroll_event''}, {'text': 'MouseEvent'}, {'text': 'mouse scroll wheel is rolled'}, {'text': ''figure_enter_event''}, {'text': 'LocationEvent'}, {'text': 'mouse enters a new figure'}, {'text': ''figure_leave_event''}, {'text': 'LocationEvent'}, {'text': 'mouse leaves a figure'}, {'text': ''axes_enter_event''}, {'text': 'LocationEvent'}, {'text': 'mouse enters a new axes'}, {'text': ''axes_leave_event''}, {'text': 'LocationEvent'}, {'text': 'mouse leaves an axes'}, {'text': 'Note'}, {'text': 'When connecting to 'key_press_event' and 'key_release_event' events,\nyou may encounter inconsistencies between the different user interface\ntoolkits that Matplotlib works with. This is due to inconsistencies/limitations\nof the user interface toolkit. The following table shows some basic examples of\nwhat you may expect to receive as key(s) (using a QWERTY keyboard layout)\nfrom the different user interface toolkits, where a comma separates different keys:'}, {'text': 'Key(s) Pressed'}, {'text': 'Tkinter'}, {'text': 'Qt'}, {'text': 'macosx'}, {'text': 'WebAgg'}, {'text': 'GTK'}, {'text': 'WxPython'}, {'text': 'Shift+2'}, {'text': 'shift, @'}, {'text': 'shift, @'}, {'text': 'shift, @'}, {'text': 'shift, @'}, {'text': 'shift, @'}, {'text': 'shift, shift+2'}, {'text': 'Shift+F1'}, {'text': 'shift, shift+f1'}, {'text': 'shift, shift+f1'}, {'text': 'shift, shift+f1'}, {'text': 'shift, shift+f1'}, {'text': 'shift, shift+f1'}, {'text': 'shift, shift+f1'}, {'text': 'Shift'}, {'text': 'shift'}, {'text': 'shift'}, {'text': 'shift'}, {'text': 'shift'}, {'text': 'shift'}, {'text': 'shift'}, {'text': 'Control'}, {'text': 'control'}, {'text': 'control'}, {'text': 'control'}, {'text': 'control'}, {'text': 'control'}, {'text': 'control'}, {'text': 'Alt'}, {'text': 'alt'}, {'text': 'alt'}, {'text': 'alt'}, {'text': 'alt'}, {'text': 'alt'}, {'text': 'alt'}, {'text': 'AltGr'}, {'text': 'iso_level3_shift'}, {'text': 'nothing'}, {'text': 'alt'}, {'text': 'iso_level3_shift'}, {'text': 'nothing'}, {'text': 'CapsLock'}, {'text': 'caps_lock'}, {'text': 'caps_lock'}, {'text': 'caps_lock'}, {'text': 'caps_lock'}, {'text': 'caps_lock'}, {'text': 'caps_lock'}, {'text': 'CapsLock+a'}, {'text': 'caps_lock, A'}, {'text': 'caps_lock, a'}, {'text': 'caps_lock, a'}, {'text': 'caps_lock, A'}, {'text': 'caps_lock, A'}, {'text': 'caps_lock, a'}, {'text': 'a'}, {'text': 'a'}, {'text': 'a'}, {'text': 'a'}, {'text': 'a'}, {'text': 'a'}, {'text': 'a'}, {'text': 'Shift+a'}, {'text': 'shift, A'}, {'text': 'shift, A'}, {'text': 'shift, A'}, {'text': 'shift, A'}, {'text': 'shift, A'}, {'text': 'shift, A'}, {'text': 'CapsLock+Shift+a'}, {'text': 'caps_lock, shift, a'}, {'text': 'caps_lock, shift, A'}, {'text': 'caps_lock, shift, A'}, {'text': 'caps_lock, shift, a'}, {'text': 'caps_lock, shift, a'}, {'text': 'caps_lock, shift, A'}, {'text': 'Ctrl+Shift+Alt'}, {'text': 'control, ctrl+shift, ctrl+meta'}, {'text': 'control, ctrl+shift, ctrl+meta'}, {'text': 'control, ctrl+shift, ctrl+alt+shift'}, {'text': 'control, ctrl+shift, ctrl+meta'}, {'text': 'control, ctrl+shift, ctrl+meta'}, {'text': 'control, ctrl+shift, ctrl+alt'}, {'text': 'Ctrl+Shift+a'}, {'text': 'control, ctrl+shift, ctrl+a'}, {'text': 'control, ctrl+shift, ctrl+A'}, {'text': 'control, ctrl+shift, ctrl+A'}, {'text': 'control, ctrl+shift, ctrl+A'}, {'text': 'control, ctrl+shift, ctrl+A'}, {'text': 'control, ctrl+shift, ctrl+A'}, {'text': 'F1'}, {'text': 'f1'}, {'text': 'f1'}, {'text': 'f1'}, {'text': 'f1'}, {'text': 'f1'}, {'text': 'f1'}, {'text': 'Ctrl+F1'}, {'text': 'control, ctrl+f1'}, {'text': 'control, ctrl+f1'}, {'text': 'control, nothing'}, {'text': 'control, ctrl+f1'}, {'text': 'control, ctrl+f1'}, {'text': 'control, ctrl+f1'}, {'text': 'Matplotlib attaches some keypress callbacks by default for interactivity; they\nare documented in the Navigation keyboard shortcuts section.'}, {'h2': 'Event attributes'}, {'text': 'All Matplotlib events inherit from the base class\nmatplotlib.backend_bases.Event, which stores the attributes:'}, {'text': 'the event name'}, {'text': 'the FigureCanvas instance generating the event'}, {'text': 'the GUI event that triggered the Matplotlib event'}, {'text': 'The most common events that are the bread and butter of event handling\nare key press/release events and mouse press/release and movement\nevents. The KeyEvent and MouseEvent classes that handle\nthese events are both derived from the LocationEvent, which has the\nfollowing attributes'}, {'text': 'mouse x and y position in pixels from left and bottom of canvas'}, {'text': 'the Axes instance over which the mouse is, if any; else None'}, {'text': 'mouse x and y position in data coordinates, if the mouse is over an\naxes'}, {'text': 'Let's look a simple example of a canvas, where a simple line segment\nis created every time a mouse is pressed:'}, {'code': 'from matplotlib import pyplot as plt\n\nclass LineBuilder:\n    def __init__(self, line):\n        self.line = line\n        self.xs = list(line.get_xdata())\n        self.ys = list(line.get_ydata())\n        self.cid = line.figure.canvas.mpl_connect('button_press_event', self)\n\n    def __call__(self, event):\n        print('click', event)\n        if event.inaxes!=self.line.axes: return\n        self.xs.append(event.xdata)\n        self.ys.append(event.ydata)\n        self.line.set_data(self.xs, self.ys)\n        self.line.figure.canvas.draw()\n\nfig, ax = plt.subplots()\nax.set_title('click to build line segments')\nline, = ax.plot([0], [0])  # empty line\nlinebuilder = LineBuilder(line)\n\nplt.show()\n'}, {'text': 'The MouseEvent that we just used is a LocationEvent, so we have access to\nthe data and pixel coordinates via (event.x, event.y) and (event.xdata,\nevent.ydata). In addition to the LocationEvent attributes, it also has:'}, {'text': 'the button pressed: None, MouseButton, 'up', or 'down' (up and down are used for scroll events)'}, {'text': 'the key pressed: None, any character, 'shift win', or 'control''}, {'h3': 'Draggable rectangle exercise'}, {'text': 'Write draggable rectangle class that is initialized with a\nRectangle instance but will move its xy\nlocation when dragged. Hint: you will need to store the original\nxy location of the rectangle which is stored as rect.xy and\nconnect to the press, motion and release mouse events. When the mouse\nis pressed, check to see if the click occurs over your rectangle (see\nRectangle.contains) and if it does, store\nthe rectangle xy and the location of the mouse click in data coords.\nIn the motion event callback, compute the deltax and deltay of the\nmouse movement, and add those deltas to the origin of the rectangle\nyou stored. The redraw the figure. On the button release event, just\nreset all the button press data you stored as None.'}, {'text': 'Here is the solution:'}, {'code': 'import numpy as np\nimport matplotlib.pyplot as plt\n\nclass DraggableRectangle:\n    def __init__(self, rect):\n        self.rect = rect\n        self.press = None\n\n    def connect(self):\n        '''Connect to all the events we need.'''\n        self.cidpress = self.rect.figure.canvas.mpl_connect(\n            'button_press_event', self.on_press)\n        self.cidrelease = self.rect.figure.canvas.mpl_connect(\n            'button_release_event', self.on_release)\n        self.cidmotion = self.rect.figure.canvas.mpl_connect(\n            'motion_notify_event', self.on_motion)\n\n    def on_press(self, event):\n        '''Check whether mouse is over us; if so, store some data.'''\n        if event.inaxes != self.rect.axes:\n            return\n        contains, attrd = self.rect.contains(event)\n        if not contains:\n            return\n        print('event contains', self.rect.xy)\n        self.press = self.rect.xy, (event.xdata, event.ydata)\n\n    def on_motion(self, event):\n        '''Move the rectangle if the mouse is over us.'''\n        if self.press is None or event.inaxes != self.rect.axes:\n            return\n        (x0, y0), (xpress, ypress) = self.press\n        dx = event.xdata - xpress\n        dy = event.ydata - ypress\n        # print(f'x0={x0}, xpress={xpress}, event.xdata={event.xdata}, '\n        #       f'dx={dx}, x0+dx={x0+dx}')\n        self.rect.set_x(x0+dx)\n        self.rect.set_y(y0+dy)\n\n        self.rect.figure.canvas.draw()\n\n    def on_release(self, event):\n        '''Clear button press information.'''\n        self.press = None\n        self.rect.figure.canvas.draw()\n\n    def disconnect(self):\n        '''Disconnect all callbacks.'''\n        self.rect.figure.canvas.mpl_disconnect(self.cidpress)\n        self.rect.figure.canvas.mpl_disconnect(self.cidrelease)\n        self.rect.figure.canvas.mpl_disconnect(self.cidmotion)\n\nfig, ax = plt.subplots()\nrects = ax.bar(range(10), 20*np.random.rand(10))\ndrs = []\nfor rect in rects:\n    dr = DraggableRectangle(rect)\n    dr.connect()\n    drs.append(dr)\n\nplt.show()\n'}, {'text': 'Extra credit: Use blitting to make the animated drawing faster and\nsmoother.'}, {'text': 'Extra credit solution:'}, {'code': '# Draggable rectangle with blitting.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nclass DraggableRectangle:\n    lock = None  # only one can be animated at a time\n\n    def __init__(self, rect):\n        self.rect = rect\n        self.press = None\n        self.background = None\n\n    def connect(self):\n        '''Connect to all the events we need.'''\n        self.cidpress = self.rect.figure.canvas.mpl_connect(\n            'button_press_event', self.on_press)\n        self.cidrelease = self.rect.figure.canvas.mpl_connect(\n            'button_release_event', self.on_release)\n        self.cidmotion = self.rect.figure.canvas.mpl_connect(\n            'motion_notify_event', self.on_motion)\n\n    def on_press(self, event):\n        '''Check whether mouse is over us; if so, store some data.'''\n        if (event.inaxes != self.rect.axes\n                or DraggableRectangle.lock is not None):\n            return\n        contains, attrd = self.rect.contains(event)\n        if not contains:\n            return\n        print('event contains', self.rect.xy)\n        self.press = self.rect.xy, (event.xdata, event.ydata)\n        DraggableRectangle.lock = self\n\n        # draw everything but the selected rectangle and store the pixel buffer\n        canvas = self.rect.figure.canvas\n        axes = self.rect.axes\n        self.rect.set_animated(True)\n        canvas.draw()\n        self.background = canvas.copy_from_bbox(self.rect.axes.bbox)\n\n        # now redraw just the rectangle\n        axes.draw_artist(self.rect)\n\n        # and blit just the redrawn area\n        canvas.blit(axes.bbox)\n\n    def on_motion(self, event):\n        '''Move the rectangle if the mouse is over us.'''\n        if (event.inaxes != self.rect.axes\n                or DraggableRectangle.lock is not self):\n            return\n        (x0, y0), (xpress, ypress) = self.press\n        dx = event.xdata - xpress\n        dy = event.ydata - ypress\n        self.rect.set_x(x0+dx)\n        self.rect.set_y(y0+dy)\n\n        canvas = self.rect.figure.canvas\n        axes = self.rect.axes\n        # restore the background region\n        canvas.restore_region(self.background)\n\n        # redraw just the current rectangle\n        axes.draw_artist(self.rect)\n\n        # blit just the redrawn area\n        canvas.blit(axes.bbox)\n\n    def on_release(self, event):\n        '''Clear button press information.'''\n        if DraggableRectangle.lock is not self:\n            return\n\n        self.press = None\n        DraggableRectangle.lock = None\n\n        # turn off the rect animation property and reset the background\n        self.rect.set_animated(False)\n        self.background = None\n\n        # redraw the full figure\n        self.rect.figure.canvas.draw()\n\n    def disconnect(self):\n        '''Disconnect all callbacks.'''\n        self.rect.figure.canvas.mpl_disconnect(self.cidpress)\n        self.rect.figure.canvas.mpl_disconnect(self.cidrelease)\n        self.rect.figure.canvas.mpl_disconnect(self.cidmotion)\n\nfig, ax = plt.subplots()\nrects = ax.bar(range(10), 20*np.random.rand(10))\ndrs = []\nfor rect in rects:\n    dr = DraggableRectangle(rect)\n    dr.connect()\n    drs.append(dr)\n\nplt.show()\n'}, {'h2': 'Mouse enter and leave'}, {'text': 'If you want to be notified when the mouse enters or leaves a figure or\naxes, you can connect to the figure/axes enter/leave events. Here is\na simple example that changes the colors of the axes and figure\nbackground that the mouse is over:'}, {'code': ''''\nIllustrate the figure and axes enter and leave events by changing the\nframe colors on enter and leave\n'''\nimport matplotlib.pyplot as plt\n\ndef enter_axes(event):\n    print('enter_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('yellow')\n    event.canvas.draw()\n\ndef leave_axes(event):\n    print('leave_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('white')\n    event.canvas.draw()\n\ndef enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n\ndef leave_figure(event):\n    print('leave_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('grey')\n    event.canvas.draw()\n\nfig1, axs = plt.subplots(2)\nfig1.suptitle('mouse hover over figure or axes to trigger events')\n\nfig1.canvas.mpl_connect('figure_enter_event', enter_figure)\nfig1.canvas.mpl_connect('figure_leave_event', leave_figure)\nfig1.canvas.mpl_connect('axes_enter_event', enter_axes)\nfig1.canvas.mpl_connect('axes_leave_event', leave_axes)\n\nfig2, axs = plt.subplots(2)\nfig2.suptitle('mouse hover over figure or axes to trigger events')\n\nfig2.canvas.mpl_connect('figure_enter_event', enter_figure)\nfig2.canvas.mpl_connect('figure_leave_event', leave_figure)\nfig2.canvas.mpl_connect('axes_enter_event', enter_axes)\nfig2.canvas.mpl_connect('axes_leave_event', leave_axes)\n\nplt.show()\n'}, {'h2': 'Object picking'}, {'text': 'You can enable picking by setting the picker property of an Artist (such\nas Line2D, Text, Patch, Polygon, AxesImage, etc.)'}, {'text': 'The picker property can be set using various types:'}, {'text': 'Picking is disabled for this artist (default).'}, {'text': 'If True, then picking will be enabled and the artist will fire a\npick event if the mouse event is over the artist.'}, {'text': 'If picker is a callable, it is a user supplied function which\ndetermines whether the artist is hit by the mouse event. The\nsignature is hit, props = picker(artist, mouseevent) to\ndetermine the hit test. If the mouse event is over the artist,\nreturn hit = True; props is a dictionary of properties that\nbecome additional attributes on the PickEvent.'}, {'text': 'The artist's pickradius property can additionally be set to a tolerance\nvalue in points (there are 72 points per inch) that determines how far the\nmouse can be and still trigger a mouse event.'}, {'text': 'After you have enabled an artist for picking by setting the picker\nproperty, you need to connect a handler to the figure canvas pick_event to get\npick callbacks on mouse press events. The handler typically looks like'}, {'code': 'def pick_handler(event):\n    mouseevent = event.mouseevent\n    artist = event.artist\n    # now do something with this...\n'}, {'text': 'The PickEvent passed to your callback always has the following attributes:'}, {'text': 'The MouseEvent that generate the pick event. See event-attributes\nfor a list of useful attributes on the mouse event.'}, {'text': 'The Artist that generated the pick event.'}, {'text': 'Additionally, certain artists like Line2D and PatchCollection may attach\nadditional metadata, like the indices of the data that meet the\npicker criteria (e.g., all the points in the line that are within the\nspecified pickradius tolerance).'}, {'h3': 'Simple picking example'}, {'text': 'In the example below, we enable picking on the line and set a pick radius\ntolerance in points. The onpick\ncallback function will be called when the pick event it within the\ntolerance distance from the line, and has the indices of the data\nvertices that are within the pick distance tolerance. Our onpick\ncallback function simply prints the data that are under the pick\nlocation. Different Matplotlib Artists can attach different data to\nthe PickEvent. For example, Line2D attaches the ind property,\nwhich are the indices into the line data under the pick point. See\nLine2D.pick for details on the PickEvent properties of the line.'}, {'code': 'import numpy as np\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.set_title('click on points')\n\nline, = ax.plot(np.random.rand(100), 'o',\n                picker=True, pickradius=5)  # 5 points tolerance\n\ndef onpick(event):\n    thisline = event.artist\n    xdata = thisline.get_xdata()\n    ydata = thisline.get_ydata()\n    ind = event.ind\n    points = tuple(zip(xdata[ind], ydata[ind]))\n    print('onpick points:', points)\n\nfig.canvas.mpl_connect('pick_event', onpick)\n\nplt.show()\n'}, {'h3': 'Picking exercise'}, {'text': 'Create a data set of 100 arrays of 1000 Gaussian random numbers and\ncompute the sample mean and standard deviation of each of them (hint:\nNumPy arrays have a mean and std method) and make a xy marker plot of\nthe 100 means vs. the 100 standard deviations. Connect the line\ncreated by the plot command to the pick event, and plot the original\ntime series of the data that generated the clicked on points. If more\nthan one point is within the tolerance of the clicked on point, you\ncan use multiple subplots to plot the multiple time series.'}, {'text': 'Exercise solution:'}, {'code': ''''\nCompute the mean and stddev of 100 data sets and plot mean vs. stddev.\nWhen you click on one of the (mean, stddev) points, plot the raw dataset\nthat generated that point.\n'''\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nX = np.random.rand(100, 1000)\nxs = np.mean(X, axis=1)\nys = np.std(X, axis=1)\n\nfig, ax = plt.subplots()\nax.set_title('click on point to plot time series')\nline, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)  # 5 points tolerance\n\n\ndef onpick(event):\n    if event.artist != line:\n        return\n    n = len(event.ind)\n    if not n:\n        return\n    fig, axs = plt.subplots(n, squeeze=False)\n    for dataind, ax in zip(event.ind, axs.flat):\n        ax.plot(X[dataind])\n        ax.text(0.05, 0.9,\n                f'$\\\\\\\\mu$={xs[dataind]:1.3f}\\\n$\\\\\\\\sigma$={ys[dataind]:1.3f}',\n                transform=ax.transAxes, verticalalignment='top')\n        ax.set_ylim(-0.5, 1.5)\n    fig.show()\n    return True\n\n\nfig.canvas.mpl_connect('pick_event', onpick)\nplt.show()\n'}",
    "id": 8
},
{
    "raw_page": "{'h1': 'Writing a backend -- the pyplot interface'}, {'text': 'This page assumes general understanding of the information in the\nBackends page, and is instead intended as reference for\nthird-party backend implementers. It also only deals with the interaction\nbetween backends and pyplot, not with the rendering side, which is described\nin backend_template.'}, {'text': 'There are two APIs for defining backends: a new canvas-based API (introduced in\nMatplotlib 3.6), and an older function-based API. The new API is simpler to\nimplement because many methods can be inherited from 'parent backends'. It is\nrecommended if back-compatibility for Matplotlib < 3.6 is not a concern.\nHowever, the old API remains supported.'}, {'text': 'Fundamentally, a backend module needs to provide information to pyplot, so\nthat'}, {'text': 'pyplot.figure() can create a new Figure instance and associate it with\nan instance of a backend-provided canvas class, itself hosted in an instance\nof a backend-provided manager class.'}, {'text': 'pyplot.show() can show all figures and start the GUI event loop (if any).'}, {'text': 'To do so, the backend module must define a backend_module.FigureCanvas\nsubclass of FigureCanvasBase. In the canvas-based API, this is the only\nstrict requirement for backend modules. The function-based API additionally\nrequires many module-level functions to be defined.'}, {'h2': 'Canvas-based API (Matplotlib >= 3.6)'}, {'text': 'Creating a figure: pyplot.figure() calls\nfigure = Figure(); FigureCanvas.new_manager(figure, num)\n(new_manager is a classmethod) to instantiate a canvas and a manager and\nset up the figure.canvas and figure.canvas.manager attributes.\nFigure unpickling uses the same approach, but replaces the newly\ninstantiated Figure() by the unpickled figure.'}, {'text': 'Interactive backends should customize the effect of new_manager by\nsetting the FigureCanvas.manager_class attribute to the desired manager\nclass, and additionally (if the canvas cannot be created before the manager,\nas in the case of the wx backends) by overriding the\nFigureManager.create_with_canvas classmethod. (Non-interactive backends\ncan normally use a trivial FigureManagerBase and can therefore skip this\nstep.)'}, {'text': 'After a new figure is registered with pyplot (either via\npyplot.figure() or via unpickling), if in interactive mode, pyplot\nwill call its canvas' draw_idle() method, which can be overridden as\ndesired.'}, {'text': 'Showing figures: pyplot.show() calls\nFigureCanvas.manager_class.pyplot_show() (a classmethod), forwarding any\narguments, to start the main event loop.'}, {'text': 'By default, pyplot_show() checks whether there are any managers\nregistered with pyplot (exiting early if not), calls manager.show()\non all such managers, and then, if called with block=True (or with\nthe default block=None and out of IPython's pylab mode and not in\ninteractive mode), calls FigureCanvas.manager_class.start_main_loop()\n(a classmethod) to start the main event loop. Interactive backends should\ntherefore override the FigureCanvas.manager_class.start_main_loop\nclassmethod accordingly (or alternatively, they may also directly override\nFigureCanvas.manager_class.pyplot_show directly).'}, {'h2': 'Function-based API'}, {'text': 'Creating a figure: pyplot.figure() calls\nnew_figure_manager(num, *args, **kwargs) (which also takes care of\ncreating the new figure as Figure(*args, **kwargs)); unpickling calls\nnew_figure_manager_given_figure(num, figure).'}, {'text': 'Furthermore, in interactive mode, the first draw of the newly registered\nfigure can be customized by providing a module-level\ndraw_if_interactive() function. (In the new canvas-based API, this\nfunction is not taken into account anymore.)'}, {'text': 'Showing figures: pyplot.show() calls a module-level show()\nfunction, which is typically generated via the ShowBase class and its\nmainloop method.'}",
    "id": 9
},
{
    "raw_page": "{'h1': 'Axes and subplots'}, {'text': 'Matplotlib Axes are the gateway to creating your data visualizations.\nOnce an Axes is placed on a figure there are many methods that can be used to\nadd data to the Axes. An Axes typically has a pair of Axis\nArtists that define the data coordinate system, and include methods to add\nannotations like x- and y-labels, titles, and legends.'}, {'text': '(Source code, 2x.png, png)'}",
    "id": 10
},
{
    "raw_page": "{'h1': 'Introduction to Axes (or Subplots)'}, {'text': 'Matplotlib Axes are the gateway to creating your data visualizations.\nOnce an Axes is placed on a figure there are many methods that can be used to\nadd data to the Axes. An Axes typically has a pair of Axis\nArtists that define the data coordinate system, and include methods to add\nannotations like x- and y-labels, titles, and legends.'}, {'text': 'Anatomy of a Figure#'}, {'text': 'In the picture above, the Axes object was created with ax = fig.subplots().\nEverything else on the figure was created with methods on this ax object,\nor can be accessed from it. If we want to change the label on the x-axis, we\ncall ax.set_xlabel('New Label'), if we want to plot some data we call\nax.plot(x, y). Indeed, in the figure above, the only Artist that is not\npart of the Axes is the Figure itself, so the axes.Axes class is really the\ngateway to much of Matplotlib's functionality.'}, {'text': 'Note that Axes are so fundamental to the operation of Matplotlib that a lot of\nmaterial here is duplicate of that in Quick start guide.'}, {'h2': 'Creating Axes'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(ncols=2, nrows=2, figsize=(3.5, 2.5),\n                        layout='constrained')\n# for each Axes, add an artist, in this case a nice label in the middle...\nfor row in range(2):\n    for col in range(2):\n        axs[row, col].annotate(f'axs[{row}, {col}]', (0.5, 0.5),\n                            transform=axs[row, col].transAxes,\n                            ha='center', va='center', fontsize=18,\n                            color='darkgrey')\nfig.suptitle('plt.subplots()')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'Axes are added using methods on Figure objects, or via the pyplot interface. These methods are discussed in more detail in Creating Figures and Arranging multiple Axes in a Figure. However, for instance add_axes will manually position an Axes on the page. In the example above subplots put a grid of subplots on the figure, and axs is a (2, 2) array of Axes, each of which can have data added to them.'}, {'text': 'There are a number of other methods for adding Axes to a Figure:'}, {'text': 'Figure.add_axes: manually position an Axes. fig.add_axes([0, 0, 1,\n1]) makes an Axes that fills the whole figure.'}, {'text': 'pyplot.subplots and Figure.subplots: add a grid of Axes as in the example\nabove. The pyplot version returns both the Figure object and an array of\nAxes. Note that fig, ax = plt.subplots() adds a single Axes to a Figure.'}, {'text': 'pyplot.subplot_mosaic and Figure.subplot_mosaic: add a grid of named\nAxes and return a dictionary of axes. For fig, axs =\nplt.subplot_mosaic([['left right'], ['bottom bottom']]),\naxs['left'] is an Axes in the top row on the left, and axs['bottom']\nis an Axes that spans both columns on the bottom.'}, {'text': 'See Arranging multiple Axes in a Figure for more detail on how to arrange grids of Axes on a\nFigure.'}, {'h2': 'Axes plotting methods'}, {'text': 'Most of the high-level plotting methods are accessed from the axes.Axes\nclass. See the API documentation for a full curated list, and\nPlot types for examples. A basic example is axes.Axes.plot:'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 3))\nnp.random.seed(19680801)\nt = np.arange(100)\nx = np.cumsum(np.random.randn(100))\nlines = ax.plot(t, x)\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'Note that plot returns a list of lines Artists which can subsequently be\nmanipulated, as discussed in Introduction to Artists.'}, {'text': 'A very incomplete list of plotting methods is below. Again, see Plot types\nfor more examples, and axes.Axes for the full list of methods.'}, {'text': 'Pairwise data'}, {'text': 'plot, scatter,\nbar, step,'}, {'text': 'Array objects'}, {'text': 'pcolormesh, contour,\nquiver, streamplot,\nimshow'}, {'text': 'Statistical distributions'}, {'text': 'hist, errorbar,\nhist2d, pie,\nboxplot, violinplot'}, {'text': 'Irregularly gridded data'}, {'text': 'tricontour, tripcolor'}, {'h2': 'Axes labelling and annotation'}, {'text': 'Usually we want to label the Axes with an xlabel, ylabel, and title, and often we want to have a legend to differentiate plot elements. The Axes class has a number of methods to create these annotations.'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 3), layout='constrained')\nnp.random.seed(19680801)\nt = np.arange(200)\nx = np.cumsum(np.random.randn(200))\ny = np.cumsum(np.random.randn(200))\nlinesx = ax.plot(t, x, label='Random walk x')\nlinesy = ax.plot(t, y, label='Random walk y')\n\nax.set_xlabel('Time [s]')\nax.set_ylabel('Distance [km]')\nax.set_title('Random walk example')\nax.legend()\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'These methods are relatively straight-forward, though there are a number of Text properties and layout that can be set on the text objects, like fontsize, fontname, horizontalalignment. Legends can be much more complicated; see Legend guide for more details.'}, {'text': 'Note that text can also be added to axes using text, and annotate. This can be quite sophisticated: see Text properties and layout and Annotations for more information.'}, {'h2': 'Axes limits, scales, and ticking'}, {'text': 'Each Axes has two (or more) Axis objects, that can be accessed via xaxis and yaxis properties. These have substantial number of methods on them, and for highly customizable Axis-es it is useful to read the API at Axis. However, the Axes class offers a number of helpers for the most common of these methods. Indeed, the set_xlabel, discussed above, is a helper for the set_label_text.'}, {'text': 'Other important methods set the extent on the axes (set_xlim, set_ylim), or more fundamentally the scale of the axes. So for instance, we can make an Axis have a logarithmic scale, and zoom in on a sub-portion of the data:'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 2.5), layout='constrained')\nnp.random.seed(19680801)\nt = np.arange(200)\nx = 2**np.cumsum(np.random.randn(200))\nlinesx = ax.plot(t, x)\nax.set_yscale('log')\nax.set_xlim([20, 180])\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'The Axes class also has helpers to deal with Axis ticks and their labels. Most straight-forward is set_xticks and set_yticks which manually set the tick locations and optionally their labels. Minor ticks can be toggled with minorticks_on or minorticks_off.'}, {'text': 'Many aspects of Axes ticks and tick labeling can be adjusted using tick_params. For instance, to label the top of the axes instead of the bottom,color the ticks red, and color the ticklabels green:'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 2.5))\nax.plot(np.arange(10))\nax.tick_params(top=True, labeltop=True, color='red', axis='x',\n               labelcolor='green')\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'More fine-grained control on ticks, setting scales, and controlling the Axis can be highly customized beyond these Axes-level helpers.'}, {'h2': 'Axes layout'}, {'text': 'Sometimes it is important to set the aspect ratio of a plot in data space, which we can do with set_aspect:'}, {'code': 'fig, axs = plt.subplots(ncols=2, figsize=(7, 2.5), layout='constrained')\nnp.random.seed(19680801)\nt = np.arange(200)\nx = np.cumsum(np.random.randn(200))\naxs[0].plot(t, x)\naxs[0].set_title('aspect='auto'')\n\naxs[1].plot(t, x)\naxs[1].set_aspect(3)\naxs[1].set_title('aspect=3')\n'}, {'text': '(Source code, 2x.png, png)'}",
    "id": 11
},
{
    "raw_page": "{'h1': 'Arranging multiple Axes in a Figure'}, {'text': 'Often more than one Axes is wanted on a figure at a time, usually\norganized into a regular grid. Matplotlib has a variety of tools for\nworking with grids of Axes that have evolved over the history of the library.\nHere we will discuss the tools we think users should use most often, the tools\nthat underpin how Axes are organized, and mention some of the older tools.'}, {'text': 'Note'}, {'text': 'Matplotlib uses Axes to refer to the drawing area that contains\ndata, x- and y-axis, ticks, labels, title, etc. See Parts of a Figure\nfor more details. Another term that is often used is 'subplot', which\nrefers to an Axes that is in a grid with other Axes objects.'}, {'h2': 'Overview'}, {'h3': 'Create grid-shaped combinations of Axes'}, {'text': 'The primary function used to create figures and a grid of Axes. It\ncreates and places all Axes on the figure at once, and returns an\nobject array with handles for the Axes in the grid. See\nFigure.subplots.'}, {'text': 'or'}, {'text': 'A simple way to create figures and a grid of Axes, with the added\nflexibility that Axes can also span rows or columns. The Axes are returned\nin a labelled dictionary instead of an array. See also\nFigure.subplot_mosaic and\nComplex and semantic figure composition (subplot_mosaic).'}, {'text': 'Sometimes it is natural to have more than one distinct group of Axes grids,\nin which case Matplotlib has the concept of SubFigure:'}, {'text': 'A virtual figure within a figure.'}, {'h3': 'Underlying tools'}, {'text': 'Underlying these are the concept of a GridSpec and\na SubplotSpec:'}, {'text': 'Specifies the geometry of the grid that a subplot will be\nplaced. The number of rows and number of columns of the grid\nneed to be set. Optionally, the subplot layout parameters\n(e.g., left, right, etc.) can be tuned.'}, {'text': 'Specifies the location of the subplot in the given GridSpec.'}, {'h3': 'Adding single Axes at a time'}, {'text': 'The above functions create all Axes in a single function call. It is also\npossible to add Axes one at a time, and this was originally how Matplotlib\nused to work. Doing so is generally less elegant and flexible, though\nsometimes useful for interactive work or to place an Axes in a custom\nlocation:'}, {'text': 'Adds a single axes at a location specified by\n[left, bottom, width, height] in fractions of figure width or height.'}, {'text': 'Adds a single subplot on a figure, with 1-based indexing (inherited from\nMatlab). Columns and rows can be spanned by specifying a range of grid\ncells.'}, {'text': 'Similar to pyplot.subplot, but uses 0-based indexing and two-d python\nslicing to choose cells.'}, {'text': 'As a simple example of manually adding an axes a, lets add a 3 inch x 2 inch\nAxes to a 4 inch x 3 inch figure. Note that the location of the subplot is\ndefined as [left, bottom, width, height] in figure-normalized units:'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nw, h = 4, 3\nmargin = 0.5\nfig = plt.figure(figsize=(w, h), facecolor='lightblue')\nax = fig.add_axes([margin / w, margin / h, (w - 2 * margin) / w,\n                      (h - 2 * margin) / h])\n'}, {'h2': 'High-level methods for making grids'}, {'h3': 'Basic 2x2 grid'}, {'text': 'We can create a basic 2-by-2 grid of Axes using\nsubplots. It returns a Figure\ninstance and an array of Axes objects. The Axes\nobjects can be used to access methods to place artists on the Axes; here\nwe use annotate, but other examples could be plot,\npcolormesh, etc.'}, {'code': 'fig, axs = plt.subplots(ncols=2, nrows=2, figsize=(5.5, 3.5),\n                        layout='constrained')\n# add an artist, in this case a nice label in the middle...\nfor row in range(2):\n    for col in range(2):\n        axs[row, col].annotate(f'axs[{row}, {col}]', (0.5, 0.5),\n                               transform=axs[row, col].transAxes,\n                               ha='center', va='center', fontsize=18,\n                               color='darkgrey')\nfig.suptitle('plt.subplots()')\n'}, {'text': 'We will annotate a lot of Axes, so let's encapsulate the annotation, rather\nthan having that large piece of annotation code every time we need it:'}, {'code': 'def annotate_axes(ax, text, fontsize=18):\n    ax.text(0.5, 0.5, text, transform=ax.transAxes,\n            ha='center', va='center', fontsize=fontsize, color='darkgrey')\n'}, {'text': 'The same effect can be achieved with subplot_mosaic,\nbut the return type is a dictionary instead of an array, where the user\ncan give the keys useful meanings. Here we provide two lists, each list\nrepresenting a row, and each element in the list a key representing the\ncolumn.'}, {'code': 'fig, axd = plt.subplot_mosaic([['upper left', 'upper right'],\n                               ['lower left', 'lower right']],\n                              figsize=(5.5, 3.5), layout='constrained')\nfor k, ax in axd.items():\n    annotate_axes(ax, f'axd[{k!r}]', fontsize=14)\nfig.suptitle('plt.subplot_mosaic()')\n'}, {'h3': 'Grids of fixed-aspect ratio Axes'}, {'text': 'Fixed-aspect ratio axes are common for images or maps. However, they\npresent a challenge to layout because two sets of constraints are being\nimposed on the size of the Axes - that they fit in the figure and that they\nhave a set aspect ratio. This leads to large gaps between Axes by default:'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained',\n                        figsize=(5.5, 3.5), facecolor='lightblue')\nfor ax in axs.flat:\n    ax.set_aspect(1)\nfig.suptitle('Fixed aspect Axes')\n'}, {'text': 'One way to address this is to change the aspect of the figure to be close\nto the aspect ratio of the Axes, however that requires trial and error.\nMatplotlib also supplies layout='compressed', which will work with\nsimple grids to reduce the gaps between Axes. (The mpl_toolkits also\nprovides ImageGrid to accomplish\na similar effect, but with a non-standard Axes class).'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='compressed', figsize=(5.5, 3.5),\n                        facecolor='lightblue')\nfor ax in axs.flat:\n    ax.set_aspect(1)\nfig.suptitle('Fixed aspect Axes: compressed')\n'}, {'h3': 'Axes spanning rows or columns in a grid'}, {'text': 'Sometimes we want Axes to span rows or columns of the grid.\nThere are actually multiple ways to accomplish this, but the most\nconvenient is probably to use subplot_mosaic by repeating one\nof the keys:'}, {'code': 'fig, axd = plt.subplot_mosaic([['upper left', 'right'],\n                               ['lower left', 'right']],\n                              figsize=(5.5, 3.5), layout='constrained')\nfor k, ax in axd.items():\n    annotate_axes(ax, f'axd[{k!r}]', fontsize=14)\nfig.suptitle('plt.subplot_mosaic()')\n'}, {'text': 'See below for the description of how to do the same thing using\nGridSpec or subplot2grid.'}, {'h3': 'Variable widths or heights in a grid'}, {'text': 'Both subplots and subplot_mosaic allow the rows\nin the grid to be different heights, and the columns to be different\nwidths using the gridspec_kw keyword argument.\nSpacing parameters accepted by GridSpec\ncan be passed to subplots and\nsubplot_mosaic:'}, {'code': 'gs_kw = dict(width_ratios=[1.4, 1], height_ratios=[1, 2])\nfig, axd = plt.subplot_mosaic([['upper left', 'right'],\n                               ['lower left', 'right']],\n                              gridspec_kw=gs_kw, figsize=(5.5, 3.5),\n                              layout='constrained')\nfor k, ax in axd.items():\n    annotate_axes(ax, f'axd[{k!r}]', fontsize=14)\nfig.suptitle('plt.subplot_mosaic()')\n'}, {'h3': 'Nested Axes layouts'}, {'text': 'Sometimes it is helpful to have two or more grids of Axes that\nmay not need to be related to one another. The most simple way to\naccomplish this is to use Figure.subfigures. Note that the subfigure\nlayouts are independent, so the Axes spines in each subfigure are not\nnecessarily aligned. See below for a more verbose way to achieve the same\neffect with GridSpecFromSubplotSpec.'}, {'code': 'fig = plt.figure(layout='constrained')\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1.5, 1.])\naxs0 = subfigs[0].subplots(2, 2)\nsubfigs[0].set_facecolor('lightblue')\nsubfigs[0].suptitle('subfigs[0]\\\nLeft side')\nsubfigs[0].supxlabel('xlabel for subfigs[0]')\n\naxs1 = subfigs[1].subplots(3, 1)\nsubfigs[1].suptitle('subfigs[1]')\nsubfigs[1].supylabel('ylabel for subfigs[1]')\n'}, {'text': 'It is also possible to nest Axes using subplot_mosaic using\nnested lists. This method does not use subfigures, like above, so lacks\nthe ability to add per-subfigure suptitle and supxlabel, etc.\nRather it is a convenience wrapper around the subgridspec\nmethod described below.'}, {'code': 'inner = [['innerA'],\n         ['innerB']]\nouter = [['upper left',  inner],\n          ['lower left', 'lower right']]\n\nfig, axd = plt.subplot_mosaic(outer, layout='constrained')\nfor k, ax in axd.items():\n    annotate_axes(ax, f'axd[{k!r}]')\n'}, {'h2': 'Low-level and advanced grid methods'}, {'text': 'Internally, the arrangement of a grid of Axes is controlled by creating\ninstances of GridSpec and SubplotSpec. GridSpec defines a\n(possibly non-uniform) grid of cells. Indexing into the GridSpec returns\na SubplotSpec that covers one or more grid cells, and can be used to\nspecify the location of an Axes.'}, {'text': 'The following examples show how to use low-level methods to arrange Axes\nusing GridSpec objects.'}, {'h3': 'Basic 2x2 grid'}, {'text': 'We can accomplish a 2x2 grid in the same manner as\nplt.subplots(2, 2):'}, {'code': 'fig = plt.figure(figsize=(5.5, 3.5), layout='constrained')\nspec = fig.add_gridspec(ncols=2, nrows=2)\n\nax0 = fig.add_subplot(spec[0, 0])\nannotate_axes(ax0, 'ax0')\n\nax1 = fig.add_subplot(spec[0, 1])\nannotate_axes(ax1, 'ax1')\n\nax2 = fig.add_subplot(spec[1, 0])\nannotate_axes(ax2, 'ax2')\n\nax3 = fig.add_subplot(spec[1, 1])\nannotate_axes(ax3, 'ax3')\n\nfig.suptitle('Manually added subplots using add_gridspec')\n'}, {'h3': 'Axes spanning rows or grids in a grid'}, {'text': 'We can index the spec array using NumPy slice syntax\nand the new Axes will span the slice. This would be the same\nas fig, axd = plt.subplot_mosaic([['ax0 ax0'], ['ax1 ax2']], ...):'}, {'code': 'fig = plt.figure(figsize=(5.5, 3.5), layout='constrained')\nspec = fig.add_gridspec(2, 2)\n\nax0 = fig.add_subplot(spec[0, :])\nannotate_axes(ax0, 'ax0')\n\nax10 = fig.add_subplot(spec[1, 0])\nannotate_axes(ax10, 'ax10')\n\nax11 = fig.add_subplot(spec[1, 1])\nannotate_axes(ax11, 'ax11')\n\nfig.suptitle('Manually added subplots, spanning a column')\n'}, {'h3': 'Manual adjustments to a GridSpec layout'}, {'text': 'When a GridSpec is explicitly used, you can adjust the layout\nparameters of subplots that are created from the GridSpec. Note this\noption is not compatible with constrained layout or\nFigure.tight_layout which both ignore left and right and adjust\nsubplot sizes to fill the figure. Usually such manual placement\nrequires iterations to make the Axes tick labels not overlap the Axes.'}, {'text': 'These spacing parameters can also be passed to subplots and\nsubplot_mosaic as the gridspec_kw argument.'}, {'code': 'fig = plt.figure(layout=None, facecolor='lightblue')\ngs = fig.add_gridspec(nrows=3, ncols=3, left=0.05, right=0.75,\n                      hspace=0.1, wspace=0.05)\nax0 = fig.add_subplot(gs[:-1, :])\nannotate_axes(ax0, 'ax0')\nax1 = fig.add_subplot(gs[-1, :-1])\nannotate_axes(ax1, 'ax1')\nax2 = fig.add_subplot(gs[-1, -1])\nannotate_axes(ax2, 'ax2')\nfig.suptitle('Manual gridspec with right=0.75')\n'}, {'h3': 'Nested layouts with SubplotSpec'}, {'text': 'You can create nested layout similar to subfigures using\nsubgridspec. Here the Axes spines are\naligned.'}, {'text': 'Note this is also available from the more verbose\ngridspec.GridSpecFromSubplotSpec.'}, {'code': 'fig = plt.figure(layout='constrained')\ngs0 = fig.add_gridspec(1, 2)\n\ngs00 = gs0[0].subgridspec(2, 2)\ngs01 = gs0[1].subgridspec(3, 1)\n\nfor a in range(2):\n    for b in range(2):\n        ax = fig.add_subplot(gs00[a, b])\n        annotate_axes(ax, f'axLeft[{a}, {b}]', fontsize=10)\n        if a == 1 and b == 1:\n            ax.set_xlabel('xlabel')\nfor a in range(3):\n    ax = fig.add_subplot(gs01[a])\n    annotate_axes(ax, f'axRight[{a}, {b}]')\n    if a == 2:\n        ax.set_ylabel('ylabel')\n\nfig.suptitle('nested gridspecs')\n'}, {'text': 'Here's a more sophisticated example of nested GridSpec: We create an outer\n4x4 grid with each cell containing an inner 3x3 grid of Axes. We outline\nthe outer 4x4 grid by hiding appropriate spines in each of the inner 3x3\ngrids.'}, {'code': 'def squiggle_xy(a, b, c, d, i=np.arange(0.0, 2*np.pi, 0.05)):\n    return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)\n\nfig = plt.figure(figsize=(8, 8), layout='constrained')\nouter_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0)\n\nfor a in range(4):\n    for b in range(4):\n        # gridspec inside gridspec\n        inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0)\n        axs = inner_grid.subplots()  # Create all subplots for the inner grid.\n        for (c, d), ax in np.ndenumerate(axs):\n            ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1))\n            ax.set(xticks=[], yticks=[])\n\n# show only the outside spines\nfor ax in fig.get_axes():\n    ss = ax.get_subplotspec()\n    ax.spines.top.set_visible(ss.is_first_row())\n    ax.spines.bottom.set_visible(ss.is_last_row())\n    ax.spines.left.set_visible(ss.is_first_col())\n    ax.spines.right.set_visible(ss.is_last_col())\n\nplt.show()\n'}, {'h2': 'More reading'}, {'text': 'More details about subplot mosaic.'}, {'text': 'More details about constrained layout, used to align\nspacing in most of these examples.'}, {'text': 'References'}, {'text': 'The use of the following functions, methods, classes and modules is shown\nin this example:'}, {'text': 'matplotlib.pyplot.subplots'}, {'text': 'matplotlib.pyplot.subplot_mosaic'}, {'text': 'matplotlib.figure.Figure.add_gridspec'}, {'text': 'matplotlib.figure.Figure.add_subplot'}, {'text': 'matplotlib.gridspec.GridSpec'}, {'text': 'matplotlib.gridspec.SubplotSpec.subgridspec'}, {'text': 'matplotlib.gridspec.GridSpecFromSubplotSpec'}, {'text': 'Total running time of the script: (0 minutes 9.915 seconds)'}, {'text': 'Download Python source code: arranging_axes.py'}, {'text': 'Download Jupyter notebook: arranging_axes.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 12
},
{
    "raw_page": "{'h1': 'Placing Colorbars'}, {'text': 'Colorbars indicate the quantitative extent of image data. Placing in\na figure is non-trivial because room needs to be made for them.'}, {'text': 'The simplest case is just attaching a colorbar to each axes:'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(2, 2)\ncmaps = ['RdBu_r viridis']\nfor col in range(2):\n    for row in range(2):\n        ax = axs[row, col]\n        pcm = ax.pcolormesh(np.random.random((20, 20)) * (col + 1),\n                            cmap=cmaps[col])\n        fig.colorbar(pcm, ax=ax)\n'}, {'text': 'The first column has the same type of data in both rows, so it may\nbe desirable to combine the colorbar which we do by calling\nFigure.colorbar with a list of axes instead of a single axes.'}, {'code': 'fig, axs = plt.subplots(2, 2)\ncmaps = ['RdBu_r viridis']\nfor col in range(2):\n    for row in range(2):\n        ax = axs[row, col]\n        pcm = ax.pcolormesh(np.random.random((20, 20)) * (col + 1),\n                            cmap=cmaps[col])\n    fig.colorbar(pcm, ax=axs[:, col], shrink=0.6)\n'}, {'text': 'Relatively complicated colorbar layouts are possible using this\nparadigm. Note that this example works far better with\nlayout='constrained''}, {'code': 'fig, axs = plt.subplots(3, 3, layout='constrained')\nfor ax in axs.flat:\n    pcm = ax.pcolormesh(np.random.random((20, 20)))\n\nfig.colorbar(pcm, ax=axs[0, :2], shrink=0.6, location='bottom')\nfig.colorbar(pcm, ax=[axs[0, 2]], location='bottom')\nfig.colorbar(pcm, ax=axs[1:, :], location='right', shrink=0.6)\nfig.colorbar(pcm, ax=[axs[2, 1]], location='left')\n'}, {'h2': 'Colorbars with fixed-aspect-ratio axes'}, {'text': 'Placing colorbars for axes with a fixed aspect ratio pose a particular\nchallenge as the parent axes changes size depending on the data view.'}, {'code': 'fig, axs = plt.subplots(2, 2,  layout='constrained')\ncmaps = ['RdBu_r viridis']\nfor col in range(2):\n    for row in range(2):\n        ax = axs[row, col]\n        pcm = ax.pcolormesh(np.random.random((20, 20)) * (col + 1),\n                            cmap=cmaps[col])\n        if col == 0:\n            ax.set_aspect(2)\n        else:\n            ax.set_aspect(1/2)\n        if row == 1:\n            fig.colorbar(pcm, ax=ax, shrink=0.6)\n'}, {'text': 'One way around this issue is to use an Axes.inset_axes to locate the\naxes in axes coordinates. Note that if you zoom in on the axes, and\nchange the shape of the axes, the colorbar will also change position.'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained')\ncmaps = ['RdBu_r viridis']\nfor col in range(2):\n    for row in range(2):\n        ax = axs[row, col]\n        pcm = ax.pcolormesh(np.random.random((20, 20)) * (col + 1),\n                            cmap=cmaps[col])\n        if col == 0:\n            ax.set_aspect(2)\n        else:\n            ax.set_aspect(1/2)\n        if row == 1:\n            cax = ax.inset_axes([1.04, 0.2, 0.05, 0.6])\n            fig.colorbar(pcm, ax=ax, cax=cax)\n\nplt.show()\n'}, {'text': 'Total running time of the script: (0 minutes 3.335 seconds)'}, {'text': 'Download Python source code: colorbar_placement.py'}, {'text': 'Download Jupyter notebook: colorbar_placement.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 13
},
{
    "raw_page": "{'h1': 'Autoscaling'}, {'text': 'The limits on an axis can be set manually (e.g. ax.set_xlim(xmin, xmax))\nor Matplotlib can set them automatically based on the data already on the axes.\nThere are a number of options to this autoscaling behaviour, discussed below.'}, {'text': 'We will start with a simple line plot showing that autoscaling\nextends the axis limits 5% beyond the data limits (-2\u03c0, 2\u03c0).'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\nx = np.linspace(-2 * np.pi, 2 * np.pi, 100)\ny = np.sinc(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\n'}, {'h2': 'Margins'}, {'text': 'The default margin around the data limits is 5%, which is based on the\ndefault configuration setting of rcParamsaxes.xmargin (default: 0.05), rcParamsaxes.ymargin (default: 0.05),\nand rcParamsaxes.zmargin (default: 0.05):'}, {'code': 'print(ax.margins())\n'}, {'code': '(0.05, 0.05)\n'}, {'text': 'The margin size can be overridden to make them smaller or larger using\nmargins:'}, {'code': 'fig, ax = plt.subplots()\nax.plot(x, y)\nax.margins(0.2, 0.2)\n'}, {'text': 'In general, margins can be in the range (-0.5, \u221e), where negative margins set\nthe axes limits to a subrange of the data range, i.e. they clip data.\nUsing a single number for margins affects both axes, a single margin can be\ncustomized using keyword arguments x or y, but positional and keyword\ninterface cannot be combined.'}, {'code': 'fig, ax = plt.subplots()\nax.plot(x, y)\nax.margins(y=-0.2)\n'}, {'h2': 'Sticky edges'}, {'text': 'There are plot elements (Artists) that are usually used without margins.\nFor example false-color images (e.g. created with Axes.imshow) are not\nconsidered in the margins calculation.'}, {'code': 'xx, yy = np.meshgrid(x, x)\nzz = np.sinc(np.sqrt((xx - 1)**2 + (yy - 1)**2))\n\nfig, ax = plt.subplots(ncols=2, figsize=(12, 8))\nax[0].imshow(zz)\nax[0].set_title('default margins')\nax[1].imshow(zz)\nax[1].margins(0.2)\nax[1].set_title('margins(0.2)')\n'}, {'text': 'This override of margins is determined by 'sticky edges', a\nproperty of Artist class that can suppress adding margins to axis\nlimits. The effect of sticky edges can be disabled on an Axes by changing\nuse_sticky_edges.\nArtists have a property Artist.sticky_edges, and the values of\nsticky edges can be changed by writing to Artist.sticky_edges.x or\nArtist.sticky_edges.y.'}, {'text': 'The following example shows how overriding works and when it is needed.'}, {'code': 'fig, ax = plt.subplots(ncols=3, figsize=(16, 10))\nax[0].imshow(zz)\nax[0].margins(0.2)\nax[0].set_title('default use_sticky_edges\\\nmargins(0.2)')\nax[1].imshow(zz)\nax[1].margins(0.2)\nax[1].use_sticky_edges = False\nax[1].set_title('use_sticky_edges=False\\\nmargins(0.2)')\nax[2].imshow(zz)\nax[2].margins(-0.2)\nax[2].set_title('default use_sticky_edges\\\nmargins(-0.2)')\n'}, {'text': 'We can see that setting use_sticky_edges to False renders the image\nwith requested margins.'}, {'text': 'While sticky edges don't increase the axis limits through extra margins,\nnegative margins are still taken into account. This can be seen in\nthe reduced limits of the third image.'}, {'h2': 'Controlling autoscale'}, {'text': 'By default, the limits are\nrecalculated every time you add a new curve to the plot:'}, {'code': 'fig, ax = plt.subplots(ncols=2, figsize=(12, 8))\nax[0].plot(x, y)\nax[0].set_title('Single curve')\nax[1].plot(x, y)\nax[1].plot(x * 2.0, y)\nax[1].set_title('Two curves')\n'}, {'text': 'However, there are cases when you don't want to automatically adjust the\nviewport to new data.'}, {'text': 'One way to disable autoscaling is to manually set the\naxis limit. Let's say that we want to see only a part of the data in\ngreater detail. Setting the xlim persists even if we add more curves to\nthe data. To recalculate the new limits calling Axes.autoscale will\ntoggle the functionality manually.'}, {'code': 'fig, ax = plt.subplots(ncols=2, figsize=(12, 8))\nax[0].plot(x, y)\nax[0].set_xlim(left=-1, right=1)\nax[0].plot(x + np.pi * 0.5, y)\nax[0].set_title('set_xlim(left=-1, right=1)\\\n')\nax[1].plot(x, y)\nax[1].set_xlim(left=-1, right=1)\nax[1].plot(x + np.pi * 0.5, y)\nax[1].autoscale()\nax[1].set_title('set_xlim(left=-1, right=1)\\\nautoscale()')\n'}, {'text': 'We can check that the first plot has autoscale disabled and that the second\nplot has it enabled again by using Axes.get_autoscale_on():'}, {'code': 'print(ax[0].get_autoscale_on())  # False means disabled\nprint(ax[1].get_autoscale_on())  # True means enabled -> recalculated\n'}, {'code': 'False\nTrue\n'}, {'text': 'Arguments of the autoscale function give us precise control over the process\nof autoscaling. A combination of arguments enable, and axis sets the\nautoscaling feature for the selected axis (or both). The argument tight\nsets the margin of the selected axis to zero. To preserve settings of either\nenable or tight you can set the opposite one to None, that way\nit should not be modified. However, setting enable to None and tight\nto True affects both axes regardless of the axis argument.'}, {'code': 'fig, ax = plt.subplots()\nax.plot(x, y)\nax.margins(0.2, 0.2)\nax.autoscale(enable=None, axis='x', tight=True)\n\nprint(ax.margins())\n'}, {'code': '(0, 0)\n'}, {'h2': 'Working with collections'}, {'text': 'Autoscale works out of the box for all lines, patches, and images added to\nthe axes. One of the artists that it won't work with is a Collection.\nAfter adding a collection to the axes, one has to manually trigger the\nautoscale_view() to recalculate\naxes limits.'}, {'code': 'fig, ax = plt.subplots()\ncollection = mpl.collections.StarPolygonCollection(\n    5, rotation=0, sizes=(250,),  # five point star, zero angle, size 250px\n    offsets=np.column_stack([x, y]),  # Set the positions\n    offset_transform=ax.transData,  # Propagate transformations of the Axes\n)\nax.add_collection(collection)\nax.autoscale_view()\n'}, {'text': 'Total running time of the script: (0 minutes 4.916 seconds)'}, {'text': 'Download Python source code: autoscale.py'}, {'text': 'Download Jupyter notebook: autoscale.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 14
},
{
    "raw_page": "{'h1': 'Axis scales'}, {'text': 'By default Matplotlib displays data on the axis using a linear scale.\nMatplotlib also supports logarithmic scales, and other less common\nscales as well. Usually this can be done directly by using the\nset_xscale or set_yscale methods.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.scale as mscale\nfrom matplotlib.ticker import FixedLocator, NullFormatter\n\nfig, axs = plt.subplot_mosaic([['linear linear-log'],\n                               ['log-linear log-log']], layout='constrained')\n\nx = np.arange(0, 3*np.pi, 0.1)\ny = 2 * np.sin(x) + 3\n\nax = axs['linear']\nax.plot(x, y)\nax.set_xlabel('linear')\nax.set_ylabel('linear')\n\nax = axs['linear-log']\nax.plot(x, y)\nax.set_yscale('log')\nax.set_xlabel('linear')\nax.set_ylabel('log')\n\nax = axs['log-linear']\nax.plot(x, y)\nax.set_xscale('log')\nax.set_xlabel('log')\nax.set_ylabel('linear')\n\nax = axs['log-log']\nax.plot(x, y)\nax.set_xscale('log')\nax.set_yscale('log')\nax.set_xlabel('log')\nax.set_ylabel('log')\n'}, {'h2': 'loglog and semilogx/y'}, {'text': 'The logarithmic axis is used so often that there are a set\nhelper functions, that do the same thing: semilogy,\nsemilogx, and loglog.'}, {'code': 'fig, axs = plt.subplot_mosaic([['linear linear-log'],\n                               ['log-linear log-log']], layout='constrained')\n\nx = np.arange(0, 3*np.pi, 0.1)\ny = 2 * np.sin(x) + 3\n\nax = axs['linear']\nax.plot(x, y)\nax.set_xlabel('linear')\nax.set_ylabel('linear')\nax.set_title('plot(x, y)')\n\nax = axs['linear-log']\nax.semilogy(x, y)\nax.set_xlabel('linear')\nax.set_ylabel('log')\nax.set_title('semilogy(x, y)')\n\nax = axs['log-linear']\nax.semilogx(x, y)\nax.set_xlabel('log')\nax.set_ylabel('linear')\nax.set_title('semilogx(x, y)')\n\nax = axs['log-log']\nax.loglog(x, y)\nax.set_xlabel('log')\nax.set_ylabel('log')\nax.set_title('loglog(x, y)')\n'}, {'h2': 'Other built-in scales'}, {'text': 'There are other scales that can be used. The list of registered\nscales can be returned from scale.get_scale_names:'}, {'code': 'print(mscale.get_scale_names())\n'}, {'code': '['asinh function functionlog linear log logit mercator symlog']\n'}, {'code': 'fig, axs = plt.subplot_mosaic([['asinh symlog'],\n                               ['log logit']], layout='constrained')\n\nx = np.arange(0, 1000)\n\nfor name, ax in axs.items():\n    if name in ['asinh symlog']:\n        yy = x - np.mean(x)\n    elif name in ['logit']:\n        yy = (x-np.min(x))\n        yy = yy / np.max(np.abs(yy))\n    else:\n        yy = x\n\n    ax.plot(yy, yy)\n    ax.set_yscale(name)\n    ax.set_title(name)\n'}, {'h2': 'Optional arguments for scales'}, {'text': 'Some of the default scales have optional arguments. These are\ndocumented in the API reference for the respective scales at\nscale. One can change the base of the logarithm\nbeing plotted (eg 2 below) or the linear threshold range\nfor 'symlog'.'}, {'code': 'fig, axs = plt.subplot_mosaic([['log symlog']], layout='constrained',\n                              figsize=(6.4, 3))\n\nfor name, ax in axs.items():\n    if name in ['log']:\n        ax.plot(x, x)\n        ax.set_yscale('log', base=2)\n        ax.set_title('log base=2')\n    else:\n        ax.plot(x - np.mean(x), x - np.mean(x))\n        ax.set_yscale('symlog', linthresh=100)\n        ax.set_title('symlog linthresh=100')\n'}, {'h2': 'Arbitrary function scales'}, {'text': 'Users can define a full scale class and pass that to set_xscale\nand set_yscale (see Custom scale). A short cut for this\nis to use the 'function' scale, and pass as extra arguments a forward and\nan inverse function. The following performs a Mercator transform to the y-axis.'}, {'code': '# Function Mercator transform\ndef forward(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.log(np.abs(np.tan(a) + 1.0 / np.cos(a))))\n\n\ndef inverse(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.arctan(np.sinh(a)))\n\n\nt = np.arange(0, 170.0, 0.1)\ns = t / 2.\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(t, s, '-', lw=2)\n\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: Mercator')\nax.grid(True)\nax.set_xlim([0, 180])\nax.yaxis.set_minor_formatter(NullFormatter())\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 90, 10)))\n'}, {'h2': 'What is a 'scale'?'}, {'text': 'A scale is an object that gets attached to an axis. The class documentation\nis at scale. set_xscale and set_yscale\nset the scale on the respective Axis objects. You can determine the scale\non an axis with get_scale:'}, {'code': 'fig, ax = plt.subplots(layout='constrained',\n                              figsize=(3.2, 3))\nax.semilogy(x, x)\n\nprint(ax.xaxis.get_scale())\nprint(ax.yaxis.get_scale())\n'}, {'code': 'linear\nlog\n'}, {'text': 'Setting a scale does three things. First it defines a transform on the axis\nthat maps between data values to position along the axis. This transform can\nbe accessed via get_transform:'}, {'code': 'print(ax.yaxis.get_transform())\n'}, {'code': 'LogTransform(base=10, nonpositive='clip')\n'}, {'text': 'Transforms on the axis are a relatively low-level concept, but is one of the\nimportant roles played by set_scale.'}, {'text': 'Setting the scale also sets default tick locators (ticker) and tick\nformatters appropriate for the scale. An axis with a 'log' scale has a\nLogLocator to pick ticks at decade intervals, and a\nLogFormatter to use scientific notation on the decades.'}, {'code': 'print('X axis')\nprint(ax.xaxis.get_major_locator())\nprint(ax.xaxis.get_major_formatter())\n\nprint('Y axis')\nprint(ax.yaxis.get_major_locator())\nprint(ax.yaxis.get_major_formatter())\n'}, {'code': 'X axis\n<matplotlib.ticker.AutoLocator object at 0x7fc5c2dfbf90>\n<matplotlib.ticker.ScalarFormatter object at 0x7fc5c028f750>\nY axis\n<matplotlib.ticker.LogLocator object at 0x7fc5c2d12a10>\n<matplotlib.ticker.LogFormatterSciNotation object at 0x7fc5c0254390>\n'}, {'text': 'Total running time of the script: (0 minutes 4.246 seconds)'}, {'text': 'Download Python source code: axes_scales.py'}, {'text': 'Download Jupyter notebook: axes_scales.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 15
},
{
    "raw_page": "{'h1': 'Axis Ticks'}, {'text': 'The x and y Axis on each Axes have default tick 'locators' and 'formatters'\nthat depend on the scale being used (see Axis scales). It is\npossible to customize the ticks and tick labels with either high-level methods\nlike set_xticks or set the locators and formatters directly on\nthe axis.'}, {'h2': 'Manual location and formats'}, {'text': 'The simplest method to customize the tick locations and formats is to use\nset_xticks and set_yticks. These can be used on\neither the major or the minor ticks.'}, {'code': 'import numpy as np\nimport matplotlib.pyplot as plt\n\nimport matplotlib.ticker as ticker\n\n\nfig, axs = plt.subplots(2, 1, figsize=(5.4, 5.4), layout='constrained')\nx = np.arange(100)\nfor nn, ax in enumerate(axs):\n    ax.plot(x, x)\n    if nn == 1:\n        ax.set_title('Manual ticks')\n        ax.set_yticks(np.arange(0, 100.1, 100/3))\n        xticks = np.arange(0.50, 101, 20)\n        xlabels = [f'\\\\\\\\${x:1.2f}' for x in xticks]\n        ax.set_xticks(xticks, labels=xlabels)\n    else:\n        ax.set_title('Automatic ticks')\n'}, {'text': 'Note that the length of the labels argument must have the same length as\nthe array used to specify the ticks.'}, {'text': 'By default set_xticks and set_yticks act on the\nmajor ticks of an Axis, however it is possible to add minor ticks:'}, {'code': 'fig, axs = plt.subplots(2, 1, figsize=(5.4, 5.4), layout='constrained')\nx = np.arange(100)\nfor nn, ax in enumerate(axs):\n    ax.plot(x, x)\n    if nn == 1:\n        ax.set_title('Manual ticks')\n        ax.set_yticks(np.arange(0, 100.1, 100/3))\n        ax.set_yticks(np.arange(0, 100.1, 100/30), minor=True)\n    else:\n        ax.set_title('Automatic ticks')\n'}, {'h2': 'Locators and Formatters'}, {'text': 'Manually setting the ticks as above works well for specific final plots, but\ndoes not adapt as the user interacts with the axes. At a lower level,\nMatplotlib has Locators that are meant to automatically choose ticks\ndepending on the current view limits of the axis, and Formatters that are\nmeant to format the tick labels automatically.'}, {'text': 'The full list of locators provided by Matplotlib are listed at\nTick locating, and the formatters at Tick formatting.'}, {'code': 'def setup(ax, title):\n    '''Set up common parameters for the Axes in the example.'''\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig, axs = plt.subplots(8, 1, layout='constrained')\n\n# Null Locator\nsetup(axs[0], title='NullLocator()')\naxs[0].xaxis.set_major_locator(ticker.NullLocator())\naxs[0].xaxis.set_minor_locator(ticker.NullLocator())\n\n# Multiple Locator\nsetup(axs[1], title='MultipleLocator(0.5)')\naxs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5))\naxs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))\n\n# Fixed Locator\nsetup(axs[2], title='FixedLocator([0, 1, 5])')\naxs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5]))\naxs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))\n\n# Linear Locator\nsetup(axs[3], title='LinearLocator(numticks=3)')\naxs[3].xaxis.set_major_locator(ticker.LinearLocator(3))\naxs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))\n\n# Index Locator\nsetup(axs[4], title='IndexLocator(base=0.5, offset=0.25)')\naxs[4].plot(range(0, 5), [0]*5, color='white')\naxs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))\n\n# Auto Locator\nsetup(axs[5], title='AutoLocator()')\naxs[5].xaxis.set_major_locator(ticker.AutoLocator())\naxs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())\n\n# MaxN Locator\nsetup(axs[6], title='MaxNLocator(n=4)')\naxs[6].xaxis.set_major_locator(ticker.MaxNLocator(4))\naxs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))\n\n# Log Locator\nsetup(axs[7], title='LogLocator(base=10, numticks=15)')\naxs[7].set_xlim(10**3, 10**10)\naxs[7].set_xscale('log')\naxs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\nplt.show()\n'}, {'text': 'Similarly, we can specify 'Formatters' for the major and minor ticks on each\naxis.'}, {'text': 'The tick format is configured via the function set_major_formatter\nor set_minor_formatter. It accepts:'}, {'text': 'a format string, which implicitly creates a StrMethodFormatter.'}, {'text': 'a function, implicitly creates a FuncFormatter.'}, {'text': 'an instance of a Formatter subclass. The most common are'}, {'text': 'NullFormatter: No labels on the ticks.'}, {'text': 'StrMethodFormatter: Use string str.format method.'}, {'text': 'FormatStrFormatter: Use %-style formatting.'}, {'text': 'FuncFormatter: Define labels through a function.'}, {'text': 'FixedFormatter: Set the label strings explicitly.'}, {'text': 'ScalarFormatter: Default formatter for scalars: auto-pick the format string.'}, {'text': 'PercentFormatter: Format labels as a percentage.'}, {'text': 'See Tick formatting for the complete list.'}, {'code': 'def setup(ax, title):\n    '''Set up common parameters for the Axes in the example.'''\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    # define tick positions\n    ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00))\n    ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25))\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig = plt.figure(figsize=(8, 8), layout='constrained')\nfig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5])\n\nfig0.suptitle('String Formatting', fontsize=16, x=0, ha='left')\nax0 = fig0.subplots()\n\nsetup(ax0, title=''{x} km'')\nax0.xaxis.set_major_formatter('{x} km')\n\nfig1.suptitle('Function Formatting', fontsize=16, x=0, ha='left')\nax1 = fig1.subplots()\n\nsetup(ax1, title='def(x, pos): return str(x-5)')\nax1.xaxis.set_major_formatter(lambda x, pos: str(x-5))\n\nfig2.suptitle('Formatter Object Formatting', fontsize=16, x=0, ha='left')\naxs2 = fig2.subplots(7, 1)\n\nsetup(axs2[0], title='NullFormatter()')\naxs2[0].xaxis.set_major_formatter(ticker.NullFormatter())\n\nsetup(axs2[1], title='StrMethodFormatter('{x:.3f}')')\naxs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter('{x:.3f}'))\n\nsetup(axs2[2], title='FormatStrFormatter('#%d')')\naxs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter('#%d'))\n\n\ndef fmt_two_digits(x, pos):\n    return f'[{x:.2f}]'\n\n\nsetup(axs2[3], title='FuncFormatter('[{:.2f}]'.format)')\naxs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits))\n\nsetup(axs2[4], title='FixedFormatter(['A', 'B', 'C', 'D', 'E', 'F'])')\n# FixedFormatter should only be used together with FixedLocator.\n# Otherwise, one cannot be sure where the labels will end up.\npositions = [0, 1, 2, 3, 4, 5]\nlabels = ['A', 'B', 'C', 'D', 'E', 'F']\naxs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions))\naxs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels))\n\nsetup(axs2[5], title='ScalarFormatter()')\naxs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))\n\nsetup(axs2[6], title='PercentFormatter(xmax=5)')\naxs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5))\n'}, {'h2': 'Styling ticks (tick parameters)'}, {'text': 'The appearance of ticks can be controlled at a low level by finding the\nindividual Tick on the axis. However, usually it is simplest to\nuse tick_params to change all the objects at once.'}, {'text': 'The tick_params method can change the properties of ticks:'}, {'text': 'length'}, {'text': 'direction (in or out of the frame)'}, {'text': 'colors'}, {'text': 'width and length'}, {'text': 'and whether the ticks are drawn at the bottom, top, left, or right of the\nAxes.'}, {'text': 'It also can control the tick labels:'}, {'text': 'labelsize (fontsize)'}, {'text': 'labelcolor (color of the label)'}, {'text': 'labelrotation'}, {'text': 'labelbottom, labeltop, labelleft, labelright'}, {'text': 'In addition there is a pad keyword argument that specifies how far the tick\nlabel is from the tick.'}, {'text': 'Finally, the grid linestyles can be set:'}, {'text': 'grid_color'}, {'text': 'grid_alpha'}, {'text': 'grid_linewidth'}, {'text': 'grid_linestyle'}, {'text': 'All these properties can be restricted to one axis, and can be applied to\njust the major or minor ticks'}, {'code': 'fig, axs = plt.subplots(1, 2, figsize=(6.4, 3.2), layout='constrained')\n\nfor nn, ax in enumerate(axs):\n    ax.plot(np.arange(100))\n    if nn == 1:\n        ax.grid('on')\n        ax.tick_params(right=True, left=False, axis='y', color='r', length=16,\n                       grid_color='none')\n        ax.tick_params(axis='x', color='m', length=4, direction='in', width=4,\n                       labelcolor='g', grid_color='b')\n'}, {'text': 'Total running time of the script: (0 minutes 3.529 seconds)'}, {'text': 'Download Python source code: axes_ticks.py'}, {'text': 'Download Jupyter notebook: axes_ticks.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 16
},
{
    "raw_page": "{'h1': 'Legend guide'}, {'text': 'Generating legends flexibly in Matplotlib.'}, {'text': 'This legend guide is an extension of the documentation available at\nlegend() - please ensure you are familiar with\ncontents of that documentation before proceeding with this guide.'}, {'text': 'This guide makes use of some common terms, which are documented here for\nclarity:'}, {'text': 'A legend is made up of one or more legend entries. An entry is made up\nof exactly one key and one label.'}, {'text': 'The colored/patterned marker to the left of each legend label.'}, {'text': 'The text which describes the handle represented by the key.'}, {'text': 'The original object which is used to generate an appropriate entry in\nthe legend.'}, {'h2': 'Controlling the legend entries'}, {'text': 'Calling legend() with no arguments automatically fetches the legend\nhandles and their associated labels. This functionality is equivalent to:'}, {'code': 'handles, labels = ax.get_legend_handles_labels()\nax.legend(handles, labels)\n'}, {'text': 'The get_legend_handles_labels() function returns\na list of handles/artists which exist on the Axes which can be used to\ngenerate entries for the resulting legend - it is worth noting however that\nnot all artists can be added to a legend, at which point a 'proxy' will have\nto be created (see Creating artists specifically for adding to the legend (aka. Proxy artists) for further details).'}, {'text': 'Note'}, {'text': 'Artists with an empty string as label or with a label starting with an\nunderscore, '_', will be ignored.'}, {'text': 'For full control of what is being added to the legend, it is common to pass\nthe appropriate handles directly to legend():'}, {'code': 'fig, ax = plt.subplots()\nline_up, = ax.plot([1, 2, 3], label='Line 2')\nline_down, = ax.plot([3, 2, 1], label='Line 1')\nax.legend(handles=[line_up, line_down])\n'}, {'text': 'In some cases, it is not possible to set the label of the handle, so it is\npossible to pass through the list of labels to legend():'}, {'code': 'fig, ax = plt.subplots()\nline_up, = ax.plot([1, 2, 3], label='Line 2')\nline_down, = ax.plot([3, 2, 1], label='Line 1')\nax.legend([line_up, line_down], ['Line Up Line Down'])\n'}, {'h2': 'Creating artists specifically for adding to the legend (aka. Proxy artists)'}, {'text': 'Not all handles can be turned into legend entries automatically,\nso it is often necessary to create an artist which can. Legend handles\ndon't have to exist on the Figure or Axes in order to be used.'}, {'text': 'Suppose we wanted to create a legend which has an entry for some data which\nis represented by a red color:'}, {'code': 'import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nfig, ax = plt.subplots()\nred_patch = mpatches.Patch(color='red', label='The red data')\nax.legend(handles=[red_patch])\n\nplt.show()\n'}, {'text': 'There are many supported legend handles. Instead of creating a patch of color\nwe could have created a line with a marker:'}, {'code': 'import matplotlib.lines as mlines\n\nfig, ax = plt.subplots()\nblue_line = mlines.Line2D([], [], color='blue', marker='*',\n                          markersize=15, label='Blue stars')\nax.legend(handles=[blue_line])\n\nplt.show()\n'}, {'h2': 'Legend location'}, {'text': 'The location of the legend can be specified by the keyword argument\nloc. Please see the documentation at legend() for more details.'}, {'text': 'The bbox_to_anchor keyword gives a great degree of control for manual\nlegend placement. For example, if you want your axes legend located at the\nfigure's top right-hand corner instead of the axes' corner, simply specify\nthe corner's location and the coordinate system of that location:'}, {'code': 'ax.legend(bbox_to_anchor=(1, 1),\n          bbox_transform=fig.transFigure)\n'}, {'text': 'More examples of custom legend placement:'}, {'code': 'fig, ax_dict = plt.subplot_mosaic([['top', 'top'], ['bottom', 'BLANK']],\n                                  empty_sentinel='BLANK')\nax_dict['top'].plot([1, 2, 3], label='test1')\nax_dict['top'].plot([3, 2, 1], label='test2')\n# Place a legend above this subplot, expanding itself to\n# fully use the given bounding box.\nax_dict['top'].legend(bbox_to_anchor=(0., 1.02, 1., .102), loc='lower left',\n                      ncols=2, mode='expand', borderaxespad=0.)\n\nax_dict['bottom'].plot([1, 2, 3], label='test1')\nax_dict['bottom'].plot([3, 2, 1], label='test2')\n# Place a legend to the right of this smaller subplot.\nax_dict['bottom'].legend(bbox_to_anchor=(1.05, 1),\n                         loc='upper left', borderaxespad=0.)\n'}, {'h3': 'Figure legends'}, {'text': 'Sometimes it makes more sense to place a legend relative to the (sub)figure\nrather than individual Axes. By using constrained layout and\nspecifying 'outside' at the beginning of the loc keyword argument,\nthe legend is drawn outside the Axes on the (sub)figure.'}, {'code': 'fig, axs = plt.subplot_mosaic([['left', 'right']], layout='constrained')\n\naxs['left'].plot([1, 2, 3], label='test1')\naxs['left'].plot([3, 2, 1], label='test2')\n\naxs['right'].plot([1, 2, 3], 'C2', label='test3')\naxs['right'].plot([3, 2, 1], 'C3', label='test4')\n# Place a legend to the right of this smaller subplot.\nfig.legend(loc='outside upper right')\n'}, {'text': 'This accepts a slightly different grammar than the normal loc keyword,\nwhere 'outside right upper' is different from 'outside upper right'.'}, {'code': 'ucl = ['upper center lower']\nlcr = ['left center right']\nfig, ax = plt.subplots(figsize=(6, 4), layout='constrained', facecolor='0.7')\n\nax.plot([1, 2], [1, 2], label='TEST')\n# Place a legend to the right of this smaller subplot.\nfor loc in [\n        'outside upper left',\n        'outside upper center',\n        'outside upper right',\n        'outside lower left',\n        'outside lower center',\n        'outside lower right']:\n    fig.legend(loc=loc, title=loc)\n\nfig, ax = plt.subplots(figsize=(6, 4), layout='constrained', facecolor='0.7')\nax.plot([1, 2], [1, 2], label='test')\n\nfor loc in [\n        'outside left upper',\n        'outside right upper',\n        'outside left lower',\n        'outside right lower']:\n    fig.legend(loc=loc, title=loc)\n'}, {'h2': 'Multiple legends on the same Axes'}, {'text': 'Sometimes it is more clear to split legend entries across multiple\nlegends. Whilst the instinctive approach to doing this might be to call\nthe legend() function multiple times, you will find that only one\nlegend ever exists on the Axes. This has been done so that it is possible\nto call legend() repeatedly to update the legend to the latest\nhandles on the Axes. To keep old legend instances, we must add them\nmanually to the Axes:'}, {'code': 'fig, ax = plt.subplots()\nline1, = ax.plot([1, 2, 3], label='Line 1', linestyle='--')\nline2, = ax.plot([3, 2, 1], label='Line 2', linewidth=4)\n\n# Create a legend for the first line.\nfirst_legend = ax.legend(handles=[line1], loc='upper right')\n\n# Add the legend manually to the Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second line.\nax.legend(handles=[line2], loc='lower right')\n\nplt.show()\n'}, {'h2': 'Legend Handlers'}, {'text': 'In order to create legend entries, handles are given as an argument to an\nappropriate HandlerBase subclass.\nThe choice of handler subclass is determined by the following rules:'}, {'text': 'Update get_legend_handler_map()\nwith the value in the handler_map keyword.'}, {'text': 'Check if the handle is in the newly created handler_map.'}, {'text': 'Check if the type of handle is in the newly created handler_map.'}, {'text': 'Check if any of the types in the handle's mro is in the newly\ncreated handler_map.'}, {'text': 'For completeness, this logic is mostly implemented in\nget_legend_handler().'}, {'text': 'All of this flexibility means that we have the necessary hooks to implement\ncustom handlers for our own type of legend key.'}, {'text': 'The simplest example of using custom handlers is to instantiate one of the\nexisting legend_handler.HandlerBase subclasses. For the\nsake of simplicity, let's choose legend_handler.HandlerLine2D\nwhich accepts a numpoints argument (numpoints is also a keyword\non the legend() function for convenience). We can then pass the mapping\nof instance to Handler as a keyword to legend.'}, {'code': 'from matplotlib.legend_handler import HandlerLine2D\n\nfig, ax = plt.subplots()\nline1, = ax.plot([3, 2, 1], marker='o', label='Line 1')\nline2, = ax.plot([1, 2, 3], marker='o', label='Line 2')\n\nax.legend(handler_map={line1: HandlerLine2D(numpoints=4)})\n'}, {'text': 'As you can see, 'Line 1' now has 4 marker points, where 'Line 2' has 2 (the\ndefault). Try the above code, only change the map's key from line1 to\ntype(line1). Notice how now both Line2D instances get 4 markers.'}, {'text': 'Along with handlers for complex plot types such as errorbars, stem plots\nand histograms, the default handler_map has a special tuple handler\n(legend_handler.HandlerTuple) which simply plots the handles on top of one\nanother for each item in the given tuple. The following example demonstrates\ncombining two legend keys on top of one another:'}, {'code': 'from numpy.random import randn\n\nz = randn(10)\n\nfig, ax = plt.subplots()\nred_dot, = ax.plot(z, 'ro', markersize=15)\n# Put a white cross over some of the data.\nwhite_cross, = ax.plot(z[:5], 'w+', markeredgewidth=3, markersize=15)\n\nax.legend([red_dot, (red_dot, white_cross)], Attr A', 'Attr A+B)\n'}, {'text': 'The legend_handler.HandlerTuple class can also be used to\nassign several legend keys to the same entry:'}, {'code': 'from matplotlib.legend_handler import HandlerLine2D, HandlerTuple\n\nfig, ax = plt.subplots()\np1, = ax.plot([1, 2.5, 3], 'r-d')\np2, = ax.plot([3, 2, 1], 'k-o')\n\nl = ax.legend([(p1, p2)], ['Two keys'], numpoints=1,\n              handler_map={tuple: HandlerTuple(ndivide=None)})\n'}, {'h3': 'Implementing a custom legend handler'}, {'text': 'A custom handler can be implemented to turn any handle into a legend key\n(handles don't necessarily need to be matplotlib artists). The handler must\nimplement a legend_artist method which returns a single artist for the\nlegend to use. The required signature for legend_artist is documented at\nlegend_artist.'}, {'code': 'import matplotlib.patches as mpatches\n\n\nclass AnyObject:\n    pass\n\n\nclass AnyObjectHandler:\n    def legend_artist(self, legend, orig_handle, fontsize, handlebox):\n        x0, y0 = handlebox.xdescent, handlebox.ydescent\n        width, height = handlebox.width, handlebox.height\n        patch = mpatches.Rectangle([x0, y0], width, height, facecolor='red',\n                                   edgecolor='black', hatch='xx', lw=3,\n                                   transform=handlebox.get_transform())\n        handlebox.add_artist(patch)\n        return patch\n\nfig, ax = plt.subplots()\n\nax.legend([AnyObject()], ['My first handler'],\n          handler_map={AnyObject: AnyObjectHandler()})\n'}, {'text': 'Alternatively, had we wanted to globally accept AnyObject instances\nwithout needing to manually set the handler_map keyword all the time, we\ncould have registered the new handler with:'}, {'code': 'from matplotlib.legend import Legend\nLegend.update_default_handler_map({AnyObject: AnyObjectHandler()})\n'}, {'text': 'Whilst the power here is clear, remember that there are already many handlers\nimplemented and what you want to achieve may already be easily possible with\nexisting classes. For example, to produce elliptical legend keys, rather than\nrectangular ones:'}, {'code': 'from matplotlib.legend_handler import HandlerPatch\n\n\nclass HandlerEllipse(HandlerPatch):\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        center = 0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent\n        p = mpatches.Ellipse(xy=center, width=width + xdescent,\n                             height=height + ydescent)\n        self.update_prop(p, orig_handle, legend)\n        p.set_transform(trans)\n        return [p]\n\n\nc = mpatches.Circle((0.5, 0.5), 0.25, facecolor='green',\n                    edgecolor='red', linewidth=3)\n\nfig, ax = plt.subplots()\n\nax.add_patch(c)\nax.legend([c], An ellipse, not a rectangle,\n          handler_map={mpatches.Circle: HandlerEllipse()})\n'}, {'text': 'Total running time of the script: (0 minutes 3.565 seconds)'}, {'text': 'Download Python source code: legend_guide.py'}, {'text': 'Download Jupyter notebook: legend_guide.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 17
},
{
    "raw_page": "{'h1': 'Complex and semantic figure composition (subplot_mosaic)'}, {'text': 'Laying out Axes in a Figure in a non-uniform grid can be both tedious\nand verbose. For dense, even grids we have Figure.subplots but for\nmore complex layouts, such as Axes that span multiple columns / rows\nof the layout or leave some areas of the Figure blank, you can use\ngridspec.GridSpec (see Arranging multiple Axes in a Figure) or\nmanually place your axes. Figure.subplot_mosaic aims to provide an\ninterface to visually lay out your axes (as either ASCII art or nested\nlists) to streamline this process.'}, {'text': 'This interface naturally supports naming your axes.\nFigure.subplot_mosaic returns a dictionary keyed on the\nlabels used to lay out the Figure. By returning data structures with\nnames, it is easier to write plotting code that is independent of the\nFigure layout.'}, {'text': 'This is inspired by a proposed MEP and the\npatchwork library for R.\nWhile we do not implement the operator overloading style, we do\nprovide a Pythonic API for specifying (nested) Axes layouts.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Helper function used for visualization in the following examples\ndef identify_axes(ax_dict, fontsize=48):\n    '''\n    Helper to identify the Axes in the examples below.\n\n    Draws the label in a large font in the center of the Axes.\n\n    Parameters\n    ----------\n    ax_dict : dict[str, Axes]\n        Mapping between the title / label and the Axes.\n    fontsize : int, optional\n        How big the label should be.\n    '''\n    kw = dict(ha='center', va='center', fontsize=fontsize, color='darkgrey')\n    for k, ax in ax_dict.items():\n        ax.text(0.5, 0.5, k, transform=ax.transAxes, **kw)\n'}, {'text': 'If we want a 2x2 grid we can use Figure.subplots which returns a 2D array\nof axes.Axes which we can index into to do our plotting.'}, {'code': 'np.random.seed(19680801)\nhist_data = np.random.randn(1_500)\n\n\nfig = plt.figure(layout='constrained')\nax_array = fig.subplots(2, 2, squeeze=False)\n\nax_array[0, 0].bar(a', 'b', 'c, [5, 7, 9])\nax_array[0, 1].plot([1, 2, 3])\nax_array[1, 0].hist(hist_data, bins='auto')\nax_array[1, 1].imshow([[1, 2], [2, 1]])\n\nidentify_axes(\n    {(j, k): a for j, r in enumerate(ax_array) for k, a in enumerate(r)},\n)\n'}, {'text': 'Using Figure.subplot_mosaic we can produce the same mosaic but give the\naxes semantic names'}, {'code': 'fig = plt.figure(layout='constrained')\nax_dict = fig.subplot_mosaic(\n    [\n        bar', 'plot,\n        hist', 'image,\n    ],\n)\nax_dictbar.bar(a', 'b', 'c, [5, 7, 9])\nax_dictplot.plot([1, 2, 3])\nax_dicthist.hist(hist_data)\nax_dictimage.imshow([[1, 2], [2, 1]])\nidentify_axes(ax_dict)\n'}, {'text': 'A key difference between Figure.subplots and\nFigure.subplot_mosaic is the return value. While the former\nreturns an array for index access, the latter returns a dictionary\nmapping the labels to the axes.Axes instances created'}, {'code': 'print(ax_dict)\n'}, {'code': '{'bar': <Axes: label='bar'>, 'plot': <Axes: label='plot'>, 'hist': <Axes: label='hist'>, 'image': <Axes: label='image'>}\n'}, {'h2': 'String short-hand'}, {'text': 'By restricting our axes labels to single characters we can\n'draw' the Axes we want as 'ASCII art'. The following'}, {'code': 'mosaic = '''\n    AB\n    CD\n    '''\n'}, {'text': 'will give us 4 Axes laid out in a 2x2 grid and generates the same\nfigure mosaic as above (but now labeled with {'A', 'B', 'C',\n'D'} rather than {'bar', 'plot', 'hist', 'image'}).'}, {'code': 'fig = plt.figure(layout='constrained')\nax_dict = fig.subplot_mosaic(mosaic)\nidentify_axes(ax_dict)\n'}, {'text': 'Alternatively, you can use the more compact string notation'}, {'code': 'mosaic = 'AB;CD'\n'}, {'text': 'will give you the same composition, where the ';' is used\nas the row separator instead of newline.'}, {'code': 'fig = plt.figure(layout='constrained')\nax_dict = fig.subplot_mosaic(mosaic)\nidentify_axes(ax_dict)\n'}, {'h2': 'Axes spanning multiple rows/columns'}, {'text': 'Something we can do with Figure.subplot_mosaic, that we cannot\ndo with Figure.subplots, is to specify that an Axes should span\nseveral rows or columns.'}, {'text': 'If we want to re-arrange our four Axes to have 'C' be a horizontal\nspan on the bottom and 'D' be a vertical span on the right we would do'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    '''\n    ABD\n    CCD\n    '''\n)\nidentify_axes(axd)\n'}, {'text': 'If we do not want to fill in all the spaces in the Figure with Axes,\nwe can specify some spaces in the grid to be blank'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    '''\n    A.C\n    BBB\n    .D.\n    '''\n)\nidentify_axes(axd)\n'}, {'text': 'If we prefer to use another character (rather than a period '.')\nto mark the empty space, we can use empty_sentinel to specify the\ncharacter to use.'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    '''\n    aX\n    Xb\n    ''',\n    empty_sentinel='X',\n)\nidentify_axes(axd)\n'}, {'text': 'Internally there is no meaning attached to the letters we use, any\nUnicode code point is valid!'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    '''\u03b1\u0431\n       \u211d\u2622'''\n)\nidentify_axes(axd)\n'}, {'text': 'It is not recommended to use white space as either a label or an\nempty sentinel with the string shorthand because it may be stripped\nwhile processing the input.'}, {'h2': 'Controlling mosaic creation'}, {'text': 'This feature is built on top of gridspec and you can pass the\nkeyword arguments through to the underlying gridspec.GridSpec\n(the same as Figure.subplots).'}, {'text': 'In this case we want to use the input to specify the arrangement,\nbut set the relative widths of the rows / columns. For convenience,\ngridspec.GridSpec's height_ratios and width_ratios are exposed in the\nFigure.subplot_mosaic calling sequence.'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    '''\n    .a.\n    bAc\n    .d.\n    ''',\n    # set the height ratios between the rows\n    height_ratios=[1, 3.5, 1],\n    # set the width ratios between the columns\n    width_ratios=[1, 3.5, 1],\n)\nidentify_axes(axd)\n'}, {'text': 'Other gridspec.GridSpec keywords can be passed via gridspec_kw. For\nexample, use the {left, right, bottom, top} keyword arguments to\nposition the overall mosaic to put multiple versions of the same\nmosaic in a figure.'}, {'code': 'mosaic = '''AA\n            BC'''\nfig = plt.figure()\naxd = fig.subplot_mosaic(\n    mosaic,\n    gridspec_kw={\n        'bottom': 0.25,\n        'top': 0.95,\n        'left': 0.1,\n        'right': 0.5,\n        'wspace': 0.5,\n        'hspace': 0.5,\n    },\n)\nidentify_axes(axd)\n\naxd = fig.subplot_mosaic(\n    mosaic,\n    gridspec_kw={\n        'bottom': 0.05,\n        'top': 0.75,\n        'left': 0.6,\n        'right': 0.95,\n        'wspace': 0.5,\n        'hspace': 0.5,\n    },\n)\nidentify_axes(axd)\n'}, {'text': 'Alternatively, you can use the sub-Figure functionality:'}, {'code': 'mosaic = '''AA\n            BC'''\nfig = plt.figure(layout='constrained')\nleft, right = fig.subfigures(nrows=1, ncols=2)\naxd = left.subplot_mosaic(mosaic)\nidentify_axes(axd)\n\naxd = right.subplot_mosaic(mosaic)\nidentify_axes(axd)\n'}, {'h2': 'Controlling subplot creation'}, {'text': 'We can also pass through arguments used to create the subplots\n(again, the same as Figure.subplots) which will apply to all\nof the Axes created.'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    'AB', subplot_kw={'projection': 'polar'}\n)\nidentify_axes(axd)\n'}, {'h3': 'Per-Axes subplot keyword arguments'}, {'text': 'If you need to control the parameters passed to each subplot individually use\nper_subplot_kw to pass a mapping between the Axes identifiers (or\ntuples of Axes identifiers) to dictionaries of keywords to be passed.'}, {'text': 'New in version 3.7.'}, {'code': 'fig, axd = plt.subplot_mosaic(\n    'AB;CD',\n    per_subplot_kw={\n        'A': {'projection': 'polar'},\n        ('C', 'D'): {'xscale': 'log'}\n    },\n)\nidentify_axes(axd)\n'}, {'text': 'If the layout is specified with the string short-hand, then we know the\nAxes labels will be one character and can unambiguously interpret longer\nstrings in per_subplot_kw to specify a set of Axes to apply the\nkeywords to:'}, {'code': 'fig, axd = plt.subplot_mosaic(\n    'AB;CD',\n    per_subplot_kw={\n        'AD': {'projection': 'polar'},\n        'BC': {'facecolor': '.9'}\n    },\n)\nidentify_axes(axd)\n'}, {'text': 'If subplot_kw and per_subplot_kw are used together, then they are\nmerged with per_subplot_kw taking priority:'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    'AB;CD',\n    subplot_kw={'facecolor': 'xkcd:tangerine'},\n    per_subplot_kw={\n        'B': {'facecolor': 'xkcd:water blue'},\n        'D': {'projection': 'polar', 'facecolor': 'w'},\n    }\n)\nidentify_axes(axd)\n'}, {'h2': 'Nested list input'}, {'text': 'Everything we can do with the string shorthand we can also do when\npassing in a list (internally we convert the string shorthand to a nested\nlist), for example using spans, blanks, and gridspec_kw:'}, {'code': 'axd = plt.figure(layout='constrained').subplot_mosaic(\n    [\n        main', 'zoom,\n        main', 'BLANK,\n    ],\n    empty_sentinel='BLANK',\n    width_ratios=[2, 1],\n)\nidentify_axes(axd)\n'}, {'text': 'In addition, using the list input we can specify nested mosaics. Any element\nof the inner list can be another set of nested lists:'}, {'code': 'inner = [\n    inner A,\n    inner B,\n]\n\nouter_nested_mosaic = [\n    main', inner],\n    bottom', 'bottom,\n]\naxd = plt.figure(layout='constrained').subplot_mosaic(\n    outer_nested_mosaic, empty_sentinel=None\n)\nidentify_axes(axd, fontsize=36)\n'}, {'text': 'We can also pass in a 2D NumPy array to do things like'}, {'code': 'mosaic = np.zeros((4, 4), dtype=int)\nfor j in range(4):\n    mosaic[j, j] = j + 1\naxd = plt.figure(layout='constrained').subplot_mosaic(\n    mosaic,\n    empty_sentinel=0,\n)\nidentify_axes(axd)\n'}, {'text': 'Total running time of the script: (0 minutes 9.136 seconds)'}, {'text': 'Download Python source code: mosaic.py'}, {'text': 'Download Jupyter notebook: mosaic.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 18
},
{
    "raw_page": "{'h1': 'Constrained Layout Guide'}, {'text': 'Use constrained layout to fit plots within your figure cleanly.'}, {'text': 'Constrained layout automatically adjusts subplots so that decorations like tick\nlabels, legends, and colorbars do not overlap, while still preserving the\nlogical layout requested by the user.'}, {'text': 'Constrained layout is similar to Tight\nlayout, but is substantially more\nflexible. It handles colorbars placed on multiple Axes\n(Placing Colorbars) nested layouts (subfigures) and Axes that\nspan rows or columns (subplot_mosaic), striving to align spines from\nAxes in the same row or column. In addition, Compressed layout will try and move fixed aspect-ratio Axes closer together.\nThese features are described in this document, as well as some\nimplementation details discussed at the end.'}, {'text': 'Constrained layout typically needs to be activated before any Axes are added to\na figure. Two ways of doing so are'}, {'text': 'using the respective argument to subplots,\nfigure, subplot_mosaic e.g.:'}, {'code': 'plt.subplots(layout='constrained')\n'}, {'text': 'activate it via rcParams, like:'}, {'code': 'plt.rcParams['figure.constrained_layout.use'] = True\n'}, {'text': 'Those are described in detail throughout the following sections.'}, {'text': 'Warning'}, {'text': 'Calling plt.tight_layout() will turn off constrained layout!'}, {'h2': 'Simple example'}, {'text': 'In Matplotlib, the location of Axes (including subplots) are specified in\nnormalized figure coordinates. It can happen that your axis labels or titles\n(or sometimes even ticklabels) go outside the figure area, and are thus\nclipped.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as mcolors\nimport matplotlib.gridspec as gridspec\n\nplt.rcParams['savefig.facecolor'] = '0.8'\nplt.rcParams['figure.figsize'] = 4.5, 4.\nplt.rcParams['figure.max_open_warning'] = 50\n\n\ndef example_plot(ax, fontsize=12, hide_labels=False):\n    ax.plot([1, 2])\n\n    ax.locator_params(nbins=3)\n    if hide_labels:\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n    else:\n        ax.set_xlabel('x-label', fontsize=fontsize)\n        ax.set_ylabel('y-label', fontsize=fontsize)\n        ax.set_title('Title', fontsize=fontsize)\n\nfig, ax = plt.subplots(layout=None)\nexample_plot(ax, fontsize=24)\n'}, {'text': 'To prevent this, the location of Axes needs to be adjusted. For\nsubplots, this can be done manually by adjusting the subplot parameters\nusing Figure.subplots_adjust. However, specifying your figure with the\nlayout='constrained' keyword argument will do the adjusting\nautomatically.'}, {'code': 'fig, ax = plt.subplots(layout='constrained')\nexample_plot(ax, fontsize=24)\n'}, {'text': 'When you have multiple subplots, often you see labels of different\nAxes overlapping each other.'}, {'code': 'fig, axs = plt.subplots(2, 2, layout=None)\nfor ax in axs.flat:\n    example_plot(ax)\n'}, {'text': 'Specifying layout='constrained' in the call to plt.subplots\ncauses the layout to be properly constrained.'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained')\nfor ax in axs.flat:\n    example_plot(ax)\n'}, {'h2': 'Colorbars'}, {'text': 'If you create a colorbar with Figure.colorbar, you need to make room for\nit. Constrained layout does this automatically. Note that if you\nspecify use_gridspec=True it will be ignored because this option is made\nfor improving the layout via tight_layout.'}, {'text': 'Note'}, {'text': 'For the pcolormesh keyword arguments (pc_kwargs) we use a\ndictionary to keep the calls consistent across this document.'}, {'code': 'arr = np.arange(100).reshape((10, 10))\nnorm = mcolors.Normalize(vmin=0., vmax=100.)\n# see note above: this makes all pcolormesh calls consistent:\npc_kwargs = {'rasterized': True, 'cmap': 'viridis', 'norm': norm}\nfig, ax = plt.subplots(figsize=(4, 4), layout='constrained')\nim = ax.pcolormesh(arr, **pc_kwargs)\nfig.colorbar(im, ax=ax, shrink=0.6)\n'}, {'text': 'If you specify a list of Axes (or other iterable container) to the\nax argument of colorbar, constrained layout will take space from\nthe specified Axes.'}, {'code': 'fig, axs = plt.subplots(2, 2, figsize=(4, 4), layout='constrained')\nfor ax in axs.flat:\n    im = ax.pcolormesh(arr, **pc_kwargs)\nfig.colorbar(im, ax=axs, shrink=0.6)\n'}, {'text': 'If you specify a list of Axes from inside a grid of Axes, the colorbar\nwill steal space appropriately, and leave a gap, but all subplots will\nstill be the same size.'}, {'code': 'fig, axs = plt.subplots(3, 3, figsize=(4, 4), layout='constrained')\nfor ax in axs.flat:\n    im = ax.pcolormesh(arr, **pc_kwargs)\nfig.colorbar(im, ax=axs[1:, 1], shrink=0.8)\nfig.colorbar(im, ax=axs[:, -1], shrink=0.6)\n'}, {'h2': 'Suptitle'}, {'text': 'Constrained layout can also make room for suptitle.'}, {'code': 'fig, axs = plt.subplots(2, 2, figsize=(4, 4), layout='constrained')\nfor ax in axs.flat:\n    im = ax.pcolormesh(arr, **pc_kwargs)\nfig.colorbar(im, ax=axs, shrink=0.6)\nfig.suptitle('Big Suptitle')\n'}, {'h2': 'Legends'}, {'text': 'Legends can be placed outside of their parent axis.\nConstrained layout is designed to handle this for Axes.legend().\nHowever, constrained layout does not handle legends being created via\nFigure.legend() (yet).'}, {'code': 'fig, ax = plt.subplots(layout='constrained')\nax.plot(np.arange(10), label='This is a plot')\nax.legend(loc='center left', bbox_to_anchor=(0.8, 0.5))\n'}, {'text': 'However, this will steal space from a subplot layout:'}, {'code': 'fig, axs = plt.subplots(1, 2, figsize=(4, 2), layout='constrained')\naxs[0].plot(np.arange(10))\naxs[1].plot(np.arange(10), label='This is a plot')\naxs[1].legend(loc='center left', bbox_to_anchor=(0.8, 0.5))\n'}, {'text': 'In order for a legend or other artist to not steal space\nfrom the subplot layout, we can leg.set_in_layout(False).\nOf course this can mean the legend ends up\ncropped, but can be useful if the plot is subsequently called\nwith fig.savefig('outname.png', bbox_inches='tight'). Note,\nhowever, that the legend's get_in_layout status will have to be\ntoggled again to make the saved file work, and we must manually\ntrigger a draw if we want constrained layout to adjust the size\nof the Axes before printing.'}, {'code': 'fig, axs = plt.subplots(1, 2, figsize=(4, 2), layout='constrained')\n\naxs[0].plot(np.arange(10))\naxs[1].plot(np.arange(10), label='This is a plot')\nleg = axs[1].legend(loc='center left', bbox_to_anchor=(0.8, 0.5))\nleg.set_in_layout(False)\n# trigger a draw so that constrained layout is executed once\n# before we turn it off when printing....\nfig.canvas.draw()\n# we want the legend included in the bbox_inches='tight' calcs.\nleg.set_in_layout(True)\n# we don't want the layout to change at this point.\nfig.set_layout_engine('none')\ntry:\n    fig.savefig('../../../doc/_static/constrained_layout_1b.png',\n                bbox_inches='tight', dpi=100)\nexcept FileNotFoundError:\n    # this allows the script to keep going if run interactively and\n    # the directory above doesn't exist\n    pass\n'}, {'text': 'The saved file looks like:'}, {'text': 'A better way to get around this awkwardness is to simply\nuse the legend method provided by Figure.legend:'}, {'code': 'fig, axs = plt.subplots(1, 2, figsize=(4, 2), layout='constrained')\naxs[0].plot(np.arange(10))\nlines = axs[1].plot(np.arange(10), label='This is a plot')\nlabels = [l.get_label() for l in lines]\nleg = fig.legend(lines, labels, loc='center left',\n                 bbox_to_anchor=(0.8, 0.5), bbox_transform=axs[1].transAxes)\ntry:\n    fig.savefig('../../../doc/_static/constrained_layout_2b.png',\n                bbox_inches='tight', dpi=100)\nexcept FileNotFoundError:\n    # this allows the script to keep going if run interactively and\n    # the directory above doesn't exist\n    pass\n'}, {'text': 'The saved file looks like:'}, {'h2': 'Padding and spacing'}, {'text': 'Padding between Axes is controlled in the horizontal by w_pad and\nwspace, and vertical by h_pad and hspace. These can be edited\nvia set. w/h_pad are\nthe minimum space around the Axes in units of inches:'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained')\nfor ax in axs.flat:\n    example_plot(ax, hide_labels=True)\nfig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0,\n                            wspace=0)\n'}, {'text': 'Spacing between subplots is further set by wspace and hspace. These\nare specified as a fraction of the size of the subplot group as a whole.\nIf these values are smaller than w_pad or h_pad, then the fixed pads are\nused instead. Note in the below how the space at the edges doesn't change\nfrom the above, but the space between subplots does.'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained')\nfor ax in axs.flat:\n    example_plot(ax, hide_labels=True)\nfig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0.2,\n                            wspace=0.2)\n'}, {'text': 'If there are more than two columns, the wspace is shared between them,\nso here the wspace is divided in two, with a wspace of 0.1 between each\ncolumn:'}, {'code': 'fig, axs = plt.subplots(2, 3, layout='constrained')\nfor ax in axs.flat:\n    example_plot(ax, hide_labels=True)\nfig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0.2,\n                            wspace=0.2)\n'}, {'text': 'GridSpecs also have optional hspace and wspace keyword arguments,\nthat will be used instead of the pads set by constrained layout:'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained',\n                        gridspec_kw={'wspace': 0.3, 'hspace': 0.2})\nfor ax in axs.flat:\n    example_plot(ax, hide_labels=True)\n# this has no effect because the space set in the gridspec trumps the\n# space set in *constrained layout*.\nfig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0.0,\n                            wspace=0.0)\n'}, {'h3': 'Spacing with colorbars'}, {'text': 'Colorbars are placed a distance pad from their parent, where pad\nis a fraction of the width of the parent(s). The spacing to the\nnext subplot is then given by w/hspace.'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained')\npads = [0, 0.05, 0.1, 0.2]\nfor pad, ax in zip(pads, axs.flat):\n    pc = ax.pcolormesh(arr, **pc_kwargs)\n    fig.colorbar(pc, ax=ax, shrink=0.6, pad=pad)\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n    ax.set_title(f'pad: {pad}')\nfig.get_layout_engine().set(w_pad=2 / 72, h_pad=2 / 72, hspace=0.2,\n                            wspace=0.2)\n'}, {'h2': 'rcParams'}, {'text': 'There are five rcParams\nthat can be set, either in a script or in the matplotlibrc\nfile. They all have the prefix figure.constrained_layout:'}, {'text': 'use: Whether to use constrained layout. Default is False'}, {'text': 'w_pad, h_pad: Padding around Axes objects.\nFloat representing inches. Default is 3./72. inches (3 pts)'}, {'text': 'wspace, hspace: Space between subplot groups.\nFloat representing a fraction of the subplot widths being separated.\nDefault is 0.02.'}, {'code': 'plt.rcParams['figure.constrained_layout.use'] = True\nfig, axs = plt.subplots(2, 2, figsize=(3, 3))\nfor ax in axs.flat:\n    example_plot(ax)\n'}, {'h2': 'Use with GridSpec'}, {'text': 'Constrained layout is meant to be used\nwith subplots(),\nsubplot_mosaic(), or\nGridSpec() with\nadd_subplot().'}, {'text': 'Note that in what follows layout='constrained''}, {'code': 'plt.rcParams['figure.constrained_layout.use'] = False\nfig = plt.figure(layout='constrained')\n\ngs1 = gridspec.GridSpec(2, 1, figure=fig)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\n\nexample_plot(ax1)\nexample_plot(ax2)\n'}, {'text': 'More complicated gridspec layouts are possible. Note here we use the\nconvenience functions add_gridspec and\nsubgridspec.'}, {'code': 'fig = plt.figure(layout='constrained')\n\ngs0 = fig.add_gridspec(1, 2)\n\ngs1 = gs0[0].subgridspec(2, 1)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\n\nexample_plot(ax1)\nexample_plot(ax2)\n\ngs2 = gs0[1].subgridspec(3, 1)\n\nfor ss in gs2:\n    ax = fig.add_subplot(ss)\n    example_plot(ax)\n    ax.set_title('')\n    ax.set_xlabel('')\n\nax.set_xlabel('x-label', fontsize=12)\n'}, {'text': 'Note that in the above the left and right columns don't have the same\nvertical extent. If we want the top and bottom of the two grids to line up\nthen they need to be in the same gridspec. We need to make this figure\nlarger as well in order for the Axes not to collapse to zero height:'}, {'code': 'fig = plt.figure(figsize=(4, 6), layout='constrained')\n\ngs0 = fig.add_gridspec(6, 2)\n\nax1 = fig.add_subplot(gs0[:3, 0])\nax2 = fig.add_subplot(gs0[3:, 0])\n\nexample_plot(ax1)\nexample_plot(ax2)\n\nax = fig.add_subplot(gs0[0:2, 1])\nexample_plot(ax, hide_labels=True)\nax = fig.add_subplot(gs0[2:4, 1])\nexample_plot(ax, hide_labels=True)\nax = fig.add_subplot(gs0[4:, 1])\nexample_plot(ax, hide_labels=True)\nfig.suptitle('Overlapping Gridspecs')\n'}, {'text': 'This example uses two gridspecs to have the colorbar only pertain to\none set of pcolors. Note how the left column is wider than the\ntwo right-hand columns because of this. Of course, if you wanted the\nsubplots to be the same size you only needed one gridspec. Note that\nthe same effect can be achieved using subfigures.'}, {'code': 'fig = plt.figure(layout='constrained')\ngs0 = fig.add_gridspec(1, 2, figure=fig, width_ratios=[1, 2])\ngs_left = gs0[0].subgridspec(2, 1)\ngs_right = gs0[1].subgridspec(2, 2)\n\nfor gs in gs_left:\n    ax = fig.add_subplot(gs)\n    example_plot(ax)\naxs = []\nfor gs in gs_right:\n    ax = fig.add_subplot(gs)\n    pcm = ax.pcolormesh(arr, **pc_kwargs)\n    ax.set_xlabel('x-label')\n    ax.set_ylabel('y-label')\n    ax.set_title('title')\n    axs += [ax]\nfig.suptitle('Nested plots using subgridspec')\nfig.colorbar(pcm, ax=axs)\n'}, {'text': 'Rather than using subgridspecs, Matplotlib now provides subfigures\nwhich also work with constrained layout:'}, {'code': 'fig = plt.figure(layout='constrained')\nsfigs = fig.subfigures(1, 2, width_ratios=[1, 2])\n\naxs_left = sfigs[0].subplots(2, 1)\nfor ax in axs_left.flat:\n    example_plot(ax)\n\naxs_right = sfigs[1].subplots(2, 2)\nfor ax in axs_right.flat:\n    pcm = ax.pcolormesh(arr, **pc_kwargs)\n    ax.set_xlabel('x-label')\n    ax.set_ylabel('y-label')\n    ax.set_title('title')\nfig.colorbar(pcm, ax=axs_right)\nfig.suptitle('Nested plots using subfigures')\n'}, {'h2': 'Manually setting Axes positions'}, {'text': 'There can be good reasons to manually set an Axes position. A manual call\nto set_position will set the Axes so constrained layout has\nno effect on it anymore. (Note that constrained layout still leaves the\nspace for the Axes that is moved).'}, {'code': 'fig, axs = plt.subplots(1, 2, layout='constrained')\nexample_plot(axs[0], fontsize=12)\naxs[1].set_position([0.2, 0.2, 0.4, 0.4])\n'}, {'h2': 'Grids of fixed aspect-ratio Axes: 'compressed' layout'}, {'text': 'Constrained layout operates on the grid of 'original' positions for\nAxes. However, when Axes have fixed aspect ratios, one side is usually made\nshorter, and leaves large gaps in the shortened direction. In the following,\nthe Axes are square, but the figure quite wide so there is a horizontal gap:'}, {'code': 'fig, axs = plt.subplots(2, 2, figsize=(5, 3),\n                        sharex=True, sharey=True, layout='constrained')\nfor ax in axs.flat:\n    ax.imshow(arr)\nfig.suptitle('fixed-aspect plots, layout='constrained'')\n'}, {'text': 'One obvious way of fixing this is to make the figure size more square,\nhowever, closing the gaps exactly requires trial and error. For simple grids\nof Axes we can use layout='compressed' to do the job for us:'}, {'code': 'fig, axs = plt.subplots(2, 2, figsize=(5, 3),\n                        sharex=True, sharey=True, layout='compressed')\nfor ax in axs.flat:\n    ax.imshow(arr)\nfig.suptitle('fixed-aspect plots, layout='compressed'')\n'}, {'h2': 'Manually turning off constrained layout'}, {'text': 'Constrained layout usually adjusts the Axes positions on each draw\nof the figure. If you want to get the spacing provided by\nconstrained layout but not have it update, then do the initial\ndraw and then call fig.set_layout_engine('none').\nThis is potentially useful for animations where the tick labels may\nchange length.'}, {'text': 'Note that constrained layout is turned off for ZOOM and PAN\nGUI events for the backends that use the toolbar. This prevents the\nAxes from changing position during zooming and panning.'}, {'h2': 'Limitations'}, {'h3': 'Incompatible functions'}, {'text': 'Constrained layout will work with pyplot.subplot, but only if the\nnumber of rows and columns is the same for each call.\nThe reason is that each call to pyplot.subplot will create a new\nGridSpec instance if the geometry is not the same, and\nconstrained layout. So the following works fine:'}, {'code': 'fig = plt.figure(layout='constrained')\n\nax1 = plt.subplot(2, 2, 1)\nax2 = plt.subplot(2, 2, 3)\n# third Axes that spans both rows in second column:\nax3 = plt.subplot(2, 2, (2, 4))\n\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nplt.suptitle('Homogenous nrows, ncols')\n'}, {'text': 'but the following leads to a poor layout:'}, {'code': 'fig = plt.figure(layout='constrained')\n\nax1 = plt.subplot(2, 2, 1)\nax2 = plt.subplot(2, 2, 3)\nax3 = plt.subplot(1, 2, 2)\n\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nplt.suptitle('Mixed nrows, ncols')\n'}, {'text': 'Similarly,\nsubplot2grid works with the same limitation\nthat nrows and ncols cannot change for the layout to look good.'}, {'code': 'fig = plt.figure(layout='constrained')\n\nax1 = plt.subplot2grid((3, 3), (0, 0))\nax2 = plt.subplot2grid((3, 3), (0, 1), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 0), colspan=2, rowspan=2)\nax4 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\n\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nfig.suptitle('subplot2grid')\n'}, {'h3': 'Other caveats'}, {'text': 'Constrained layout only considers ticklabels, axis labels, titles, and\nlegends. Thus, other artists may be clipped and also may overlap.'}, {'text': 'It assumes that the extra space needed for ticklabels, axis labels,\nand titles is independent of original location of Axes. This is\noften true, but there are rare cases where it is not.'}, {'text': 'There are small differences in how the backends handle rendering fonts,\nso the results will not be pixel-identical.'}, {'text': 'An artist using Axes coordinates that extend beyond the Axes\nboundary will result in unusual layouts when added to an\nAxes. This can be avoided by adding the artist directly to the\nFigure using\nadd_artist(). See\nConnectionPatch for an example.'}, {'h2': 'Debugging'}, {'text': 'Constrained layout can fail in somewhat unexpected ways. Because it uses\na constraint solver the solver can find solutions that are mathematically\ncorrect, but that aren't at all what the user wants. The usual failure\nmode is for all sizes to collapse to their smallest allowable value. If\nthis happens, it is for one of two reasons:'}, {'text': 'There was not enough room for the elements you were requesting to draw.'}, {'text': 'There is a bug - in which case open an issue at\nmatplotlib/matplotlib#issues.'}, {'text': 'If there is a bug, please report with a self-contained example that does\nnot require outside data or dependencies (other than numpy).'}, {'h2': 'Notes on the algorithm'}, {'text': 'The algorithm for the constraint is relatively straightforward, but\nhas some complexity due to the complex ways we can lay out a figure.'}, {'text': 'Layout in Matplotlib is carried out with gridspecs\nvia the GridSpec class. A gridspec is a logical division of the figure\ninto rows and columns, with the relative width of the Axes in those\nrows and columns set by width_ratios and height_ratios.'}, {'text': 'In constrained layout, each gridspec gets a layoutgrid associated with\nit. The layoutgrid has a series of left and right variables\nfor each column, and bottom and top variables for each row, and\nfurther it has a margin for each of left, right, bottom and top. In each\nrow, the bottom/top margins are widened until all the decorators\nin that row are accommodated. Similarly, for columns and the left/right\nmargins.'}, {'h3': 'Simple case: one Axes'}, {'text': 'For a single Axes the layout is straight forward. There is one parent\nlayoutgrid for the figure consisting of one column and row, and\na child layoutgrid for the gridspec that contains the Axes, again\nconsisting of one row and column. Space is made for the 'decorations' on\neach side of the Axes. In the code, this is accomplished by the entries in\ndo_constrained_layout() like:'}, {'code': 'gridspec._layoutgrid[0, 0].edit_margin_min('left',\n      -bbox.x0 + pos.x0 + w_pad)\n'}, {'text': 'where bbox is the tight bounding box of the Axes, and pos its\nposition. Note how the four margins encompass the Axes decorations.'}, {'code': 'from matplotlib._layoutgrid import plot_children\n\nfig, ax = plt.subplots(layout='constrained')\nexample_plot(ax, fontsize=24)\nplot_children(fig)\n'}, {'h3': 'Simple case: two Axes'}, {'text': 'When there are multiple Axes they have their layouts bound in\nsimple ways. In this example the left Axes has much larger decorations\nthan the right, but they share a bottom margin, which is made large\nenough to accommodate the larger xlabel. Same with the shared top\nmargin. The left and right margins are not shared, and hence are\nallowed to be different.'}, {'code': 'fig, ax = plt.subplots(1, 2, layout='constrained')\nexample_plot(ax[0], fontsize=32)\nexample_plot(ax[1], fontsize=8)\nplot_children(fig)\n'}, {'h3': 'Two Axes and colorbar'}, {'text': 'A colorbar is simply another item that expands the margin of the parent\nlayoutgrid cell:'}, {'code': 'fig, ax = plt.subplots(1, 2, layout='constrained')\nim = ax[0].pcolormesh(arr, **pc_kwargs)\nfig.colorbar(im, ax=ax[0], shrink=0.6)\nim = ax[1].pcolormesh(arr, **pc_kwargs)\nplot_children(fig)\n'}, {'h3': 'Colorbar associated with a Gridspec'}, {'text': 'If a colorbar belongs to more than one cell of the grid, then\nit makes a larger margin for each:'}, {'code': 'fig, axs = plt.subplots(2, 2, layout='constrained')\nfor ax in axs.flat:\n    im = ax.pcolormesh(arr, **pc_kwargs)\nfig.colorbar(im, ax=axs, shrink=0.6)\nplot_children(fig)\n'}, {'h3': 'Uneven sized Axes'}, {'text': 'There are two ways to make Axes have an uneven size in a\nGridspec layout, either by specifying them to cross Gridspecs rows\nor columns, or by specifying width and height ratios.'}, {'text': 'The first method is used here. Note that the middle top and\nbottom margins are not affected by the left-hand column. This\nis a conscious decision of the algorithm, and leads to the case where\nthe two right-hand Axes have the same height, but it is not 1/2 the height\nof the left-hand Axes. This is consistent with how gridspec works\nwithout constrained layout.'}, {'code': 'fig = plt.figure(layout='constrained')\ngs = gridspec.GridSpec(2, 2, figure=fig)\nax = fig.add_subplot(gs[:, 0])\nim = ax.pcolormesh(arr, **pc_kwargs)\nax = fig.add_subplot(gs[0, 1])\nim = ax.pcolormesh(arr, **pc_kwargs)\nax = fig.add_subplot(gs[1, 1])\nim = ax.pcolormesh(arr, **pc_kwargs)\nplot_children(fig)\n'}, {'text': 'One case that requires finessing is if margins do not have any artists\nconstraining their width. In the case below, the right margin for column 0\nand the left margin for column 3 have no margin artists to set their width,\nso we take the maximum width of the margin widths that do have artists.\nThis makes all the Axes have the same size:'}, {'code': 'fig = plt.figure(layout='constrained')\ngs = fig.add_gridspec(2, 4)\nax00 = fig.add_subplot(gs[0, 0:2])\nax01 = fig.add_subplot(gs[0, 2:])\nax10 = fig.add_subplot(gs[1, 1:3])\nexample_plot(ax10, fontsize=14)\nplot_children(fig)\nplt.show()\n'}, {'text': 'Total running time of the script: (0 minutes 15.495 seconds)'}, {'text': 'Download Python source code: constrainedlayout_guide.py'}, {'text': 'Download Jupyter notebook: constrainedlayout_guide.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 19
},
{
    "raw_page": "{'h1': 'Tight Layout guide'}, {'text': 'How to use tight-layout to fit plots within your figure cleanly.'}, {'text': 'tight_layout automatically adjusts subplot params so that the\nsubplot(s) fits in to the figure area. This is an experimental\nfeature and may not work for some cases. It only checks the extents\nof ticklabels, axis labels, and titles.'}, {'text': 'An alternative to tight_layout is constrained_layout.'}, {'h2': 'Simple Example'}, {'text': 'In matplotlib, the location of axes (including subplots) are specified in\nnormalized figure coordinates. It can happen that your axis labels or\ntitles (or sometimes even ticklabels) go outside the figure area, and are thus\nclipped.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['savefig.facecolor'] = '0.8'\n\n\ndef example_plot(ax, fontsize=12):\n    ax.plot([1, 2])\n\n    ax.locator_params(nbins=3)\n    ax.set_xlabel('x-label', fontsize=fontsize)\n    ax.set_ylabel('y-label', fontsize=fontsize)\n    ax.set_title('Title', fontsize=fontsize)\n\nplt.close('all')\nfig, ax = plt.subplots()\nexample_plot(ax, fontsize=24)\n'}, {'text': 'To prevent this, the location of axes needs to be adjusted. For\nsubplots, this can be done manually by adjusting the subplot parameters\nusing Figure.subplots_adjust. Figure.tight_layout does this\nautomatically.'}, {'code': 'fig, ax = plt.subplots()\nexample_plot(ax, fontsize=24)\nplt.tight_layout()\n'}, {'text': 'Note that matplotlib.pyplot.tight_layout() will only adjust the\nsubplot params when it is called. In order to perform this adjustment each\ntime the figure is redrawn, you can call fig.set_tight_layout(True), or,\nequivalently, set rcParamsfigure.autolayout (default: False) to True.'}, {'text': 'When you have multiple subplots, often you see labels of different\naxes overlapping each other.'}, {'code': 'plt.close('all')\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\n'}, {'text': 'tight_layout() will also adjust spacing between\nsubplots to minimize the overlaps.'}, {'code': 'fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nplt.tight_layout()\n'}, {'text': 'tight_layout() can take keyword arguments of\npad, w_pad and h_pad. These control the extra padding around the\nfigure border and between subplots. The pads are specified in fraction\nof fontsize.'}, {'code': 'fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nplt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)\n'}, {'text': 'tight_layout() will work even if the sizes of\nsubplots are different as far as their grid specification is\ncompatible. In the example below, ax1 and ax2 are subplots of a 2x2\ngrid, while ax3 is of a 1x2 grid.'}, {'code': 'plt.close('all')\nfig = plt.figure()\n\nax1 = plt.subplot(221)\nax2 = plt.subplot(223)\nax3 = plt.subplot(122)\n\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\n\nplt.tight_layout()\n'}, {'text': 'It works with subplots created with\nsubplot2grid(). In general, subplots created\nfrom the gridspec (Arranging multiple Axes in a Figure) will work.'}, {'code': 'plt.close('all')\nfig = plt.figure()\n\nax1 = plt.subplot2grid((3, 3), (0, 0))\nax2 = plt.subplot2grid((3, 3), (0, 1), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 0), colspan=2, rowspan=2)\nax4 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\n\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\n\nplt.tight_layout()\n'}, {'text': 'Although not thoroughly tested, it seems to work for subplots with\naspect != 'auto' (e.g., axes with images).'}, {'code': 'arr = np.arange(100).reshape((10, 10))\n\nplt.close('all')\nfig = plt.figure(figsize=(5, 4))\n\nax = plt.subplot()\nim = ax.imshow(arr, interpolation='none')\n\nplt.tight_layout()\n'}, {'h2': 'Caveats'}, {'text': 'tight_layout considers all artists on the axes by\ndefault. To remove an artist from the layout calculation you can call\nArtist.set_in_layout.'}, {'text': 'tight_layout assumes that the extra space needed for artists is\nindependent of the original location of axes. This is often true, but there\nare rare cases where it is not.'}, {'text': 'pad=0 can clip some texts by a few pixels. This may be a bug or\na limitation of the current algorithm, and it is not clear why it\nhappens. Meanwhile, use of pad larger than 0.3 is recommended.'}, {'h2': 'Use with GridSpec'}, {'text': 'GridSpec has its own GridSpec.tight_layout method (the pyplot api\npyplot.tight_layout also works).'}, {'code': 'import matplotlib.gridspec as gridspec\n\nplt.close('all')\nfig = plt.figure()\n\ngs1 = gridspec.GridSpec(2, 1)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\n\nexample_plot(ax1)\nexample_plot(ax2)\n\ngs1.tight_layout(fig)\n'}, {'text': 'You may provide an optional rect parameter, which specifies the bounding\nbox that the subplots will be fit inside. The coordinates must be in\nnormalized figure coordinates and the default is (0, 0, 1, 1).'}, {'code': 'fig = plt.figure()\n\ngs1 = gridspec.GridSpec(2, 1)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\n\nexample_plot(ax1)\nexample_plot(ax2)\n\ngs1.tight_layout(fig, rect=[0, 0, 0.5, 1.0])\n'}, {'text': 'However, we do not recommend that this be used to manually construct more\ncomplicated layouts, like having one GridSpec in the left and one in the\nright side of the figure. For these use cases, one should instead take\nadvantage of Nested Gridspecs, or\nthe Figure subfigures.'}, {'h2': 'Legends and Annotations'}, {'text': 'Pre Matplotlib 2.2, legends and annotations were excluded from the bounding\nbox calculations that decide the layout. Subsequently, these artists were\nadded to the calculation, but sometimes it is undesirable to include them.\nFor instance in this case it might be good to have the axes shrink a bit\nto make room for the legend:'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 3))\nlines = ax.plot(range(10), label='A simple plot')\nax.legend(bbox_to_anchor=(0.7, 0.5), loc='center left',)\nfig.tight_layout()\nplt.show()\n'}, {'text': 'However, sometimes this is not desired (quite often when using\nfig.savefig('outname.png', bbox_inches='tight')). In order to\nremove the legend from the bounding box calculation, we simply set its\nbounding leg.set_in_layout(False) and the legend will be ignored.'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 3))\nlines = ax.plot(range(10), label='B simple plot')\nleg = ax.legend(bbox_to_anchor=(0.7, 0.5), loc='center left',)\nleg.set_in_layout(False)\nfig.tight_layout()\nplt.show()\n'}, {'h2': 'Use with AxesGrid1'}, {'text': 'While limited, mpl_toolkits.axes_grid1 is also supported.'}, {'code': 'from mpl_toolkits.axes_grid1 import Grid\n\nplt.close('all')\nfig = plt.figure()\ngrid = Grid(fig, rect=111, nrows_ncols=(2, 2),\n            axes_pad=0.25, label_mode='L',\n            )\n\nfor ax in grid:\n    example_plot(ax)\nax.title.set_visible(False)\n\nplt.tight_layout()\n'}, {'h2': 'Colorbar'}, {'text': 'If you create a colorbar with Figure.colorbar, the created colorbar is\ndrawn in a Subplot as long as the parent axes is also a Subplot, so\nFigure.tight_layout will work.'}, {'code': 'plt.close('all')\narr = np.arange(100).reshape((10, 10))\nfig = plt.figure(figsize=(4, 4))\nim = plt.imshow(arr, interpolation='none')\n\nplt.colorbar(im)\n\nplt.tight_layout()\n'}, {'text': 'Another option is to use the AxesGrid1 toolkit to\nexplicitly create an Axes for the colorbar.'}, {'code': 'from mpl_toolkits.axes_grid1 import make_axes_locatable\n\nplt.close('all')\narr = np.arange(100).reshape((10, 10))\nfig = plt.figure(figsize=(4, 4))\nim = plt.imshow(arr, interpolation='none')\n\ndivider = make_axes_locatable(plt.gca())\ncax = divider.append_axes('right', '5%', pad='3%')\nplt.colorbar(im, cax=cax)\n\nplt.tight_layout()\n'}, {'text': 'Total running time of the script: (0 minutes 4.682 seconds)'}, {'text': 'Download Python source code: tight_layout_guide.py'}, {'text': 'Download Jupyter notebook: tight_layout_guide.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 20
},
{
    "raw_page": "{'h1': 'Artists'}, {'text': 'Almost all objects you interact with on a Matplotlib plot are called 'Artist'\n(and are subclasses of the Artist class). Figure\nand Axes are Artists, and generally contain\nAxis Artists and Artists that contain data or annotation information.'}",
    "id": 21
},
{
    "raw_page": "{'h1': 'Introduction to Artists'}, {'text': 'Almost all objects you interact with on a Matplotlib plot are called 'Artist'\n(and are subclasses of the Artist class). Figure\nand Axes are Artists, and generally contain\nAxis Artists and Artists that contain data or annotation information.'}, {'h2': 'Creating Artists'}, {'text': 'Usually we do not instantiate Artists directly, but rather use a plotting\nmethod on Axes. Some examples of plotting methods and the Artist\nobject they create is given below:'}, {'text': 'Axes helper method'}, {'text': 'Artist'}, {'text': 'annotate - text annotations'}, {'text': 'Annotation'}, {'text': 'bar - bar charts'}, {'text': 'Rectangle'}, {'text': 'errorbar - error bar plots'}, {'text': 'Line2D and\nRectangle'}, {'text': 'fill - shared area'}, {'text': 'Polygon'}, {'text': 'hist - histograms'}, {'text': 'Rectangle'}, {'text': 'imshow - image data'}, {'text': 'AxesImage'}, {'text': 'legend - Axes legend'}, {'text': 'Legend'}, {'text': 'plot - xy plots'}, {'text': 'Line2D'}, {'text': 'scatter - scatter charts'}, {'text': 'PolyCollection'}, {'text': 'text - text'}, {'text': 'Text'}, {'text': 'As an example, we can save the Line2D Artist returned from axes.Axes.plot:'}, {'code': 'In [209]: import matplotlib.pyplot as plt\nIn [210]: import matplotlib.artist as martist\nIn [211]: import numpy as np\n\nIn [212]: fig, ax = plt.subplots()\nIn [213]: x, y = np.random.rand(2, 100)\nIn [214]: lines = ax.plot(x, y, '-', label='example')\nIn [215]: print(lines)\n[<matplotlib.lines.Line2D at 0xd378b0c>]\n'}, {'text': 'Note that plot returns a _list_ of lines because you can pass in multiple x,\ny pairs to plot. The line has been added to the Axes, and we can retrieve the\nArtist via get_lines():'}, {'code': 'In [216]: print(ax.get_lines())\n<a list of 1 Line2D objects>\nIn [217]: print(ax.get_lines()[0])\nLine2D(example)\n'}, {'h2': 'Changing Artist properties'}, {'text': 'Getting the lines object gives us access to all the properties of the\nLine2D object. So if we want to change the linewidth after the fact, we can do so using Artist.set.'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 2.5))\nx = np.arange(0, 13, 0.2)\ny = np.sin(x)\nlines = ax.plot(x, y, '-', label='example', linewidth=0.2, color='blue')\nlines[0].set(color='green', linewidth=2)\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'We can interrogate the full list of settable properties with\nmatplotlib.artist.getp:'}, {'code': 'In [218]: martist.getp(lines[0])\nagg_filter = None\nalpha = None\nanimated = False\nantialiased or aa = True\nbbox = Bbox(x0=0.004013842290585101, y0=0.013914221641967...\nchildren = []\nclip_box = TransformedBbox(     Bbox(x0=0.0, y0=0.0, x1=1.0, ...\nclip_on = True\nclip_path = None\ncolor or c = blue\ndash_capstyle = butt\ndash_joinstyle = round\ndata = (array([0.91377845, 0.58456834, 0.36492019, 0.0379...\ndrawstyle or ds = default\nfigure = Figure(550x450)\nfillstyle = full\ngapcolor = None\ngid = None\nin_layout = True\nlabel = example\nlinestyle or ls = -\nlinewidth or lw = 2.0\nmarker = None\nmarkeredgecolor or mec = blue\nmarkeredgewidth or mew = 1.0\nmarkerfacecolor or mfc = blue\nmarkerfacecoloralt or mfcalt = none\nmarkersize or ms = 6.0\nmarkevery = None\nmouseover = False\npath = Path(array([[0.91377845, 0.51224793],        [0.58...\npath_effects = []\npicker = None\npickradius = 5\nrasterized = False\nsketch_params = None\nsnap = None\nsolid_capstyle = projecting\nsolid_joinstyle = round\ntightbbox = Bbox(x0=70.4609002763619, y0=54.321277798941786, x...\ntransform = CompositeGenericTransform(     TransformWrapper(  ...\ntransformed_clip_path_and_affine = (None, None)\nurl = None\nvisible = True\nwindow_extent = Bbox(x0=70.4609002763619, y0=54.321277798941786, x...\nxdata = [0.91377845 0.58456834 0.36492019 0.03796664 0.884...\nxydata = [[0.91377845 0.51224793]  [0.58456834 0.9820474 ] ...\nydata = [0.51224793 0.9820474  0.24469912 0.61647032 0.483...\nzorder = 2\n'}, {'text': 'Note most Artists also have a distinct list of setters; e.g.\nLine2D.set_color or Line2D.set_linewidth.'}, {'h2': 'Changing Artist data'}, {'text': 'In addition to styling properties like color and linewidth, the Line2D\nobject has a data property. You can set the data after the line has been\ncreated using Line2D.set_data. This is often used for Animations, where the\nsame line is shown evolving over time (see Animations using Matplotlib)'}, {'code': 'fig, ax = plt.subplots(figsize=(4, 2.5))\nx = np.arange(0, 13, 0.2)\ny = np.sin(x)\nlines = ax.plot(x, y, '-', label='example')\nlines[0].set_data([x, np.cos(x)])\n'}, {'text': '(Source code, 2x.png, png)'}, {'h2': 'Manually adding Artists'}, {'text': 'Not all Artists have helper methods, or you may want to use a low-level method\nfor some reason. For example the patches.Circle Artist does not have a\nhelper, but we can still create and add to an Axes using the\naxes.Axes.add_artist method:'}, {'code': 'import matplotlib.patches as mpatches\n\nfig, ax = plt.subplots(figsize=(4, 2.5))\ncircle = mpatches.Circle((0.5, 0.5), 0.25, ec='none')\nax.add_artist(circle)\nclipped_circle = mpatches.Circle((1, 0.5), 0.125, ec='none', facecolor='C1')\nax.add_artist(clipped_circle)\nax.set_aspect(1)\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'The Circle takes the center and radius of the Circle as arguments to its\nconstructor; optional arguments are passed as keyword arguments.'}, {'text': 'Note that when we add an Artist manually like this, it doesn't necessarily\nadjust the axis limits like most of the helper methods do, so the Artists can\nbe clipped, as is the case above for the clipped_circle patch.'}, {'text': 'See Reference for Matplotlib artists for other patches.'}, {'h2': 'Removing Artists'}, {'text': 'Sometimes we want to remove an Artist from a figure without re-specifying the\nwhole figure from scratch. Most Artists have a usable remove method that\nwill remove the Artist from its Axes list. For instance lines[0].remove()\nwould remove the Line2D artist created in the example above.'}",
    "id": 22
},
{
    "raw_page": "{'h1': 'Styling with cycler'}, {'text': 'Demo of custom property-cycle settings to control colors and other style\nproperties for multi-line plots.'}, {'text': 'Note'}, {'text': 'More complete documentation of the cycler API can be found\nhere.'}, {'text': 'This example demonstrates two different APIs:'}, {'text': 'Setting the rc parameter specifying the default property cycle.\nThis affects all subsequent axes (but not axes already created).'}, {'text': 'Setting the property cycle for a single pair of axes.'}, {'code': 'from cycler import cycler\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n'}, {'text': 'First we'll generate some sample data, in this case, four offset sine\ncurves.'}, {'code': 'x = np.linspace(0, 2 * np.pi, 50)\noffsets = np.linspace(0, 2 * np.pi, 4, endpoint=False)\nyy = np.transpose([np.sin(x + phi) for phi in offsets])\n'}, {'text': 'Now yy has shape'}, {'code': 'print(yy.shape)\n'}, {'code': '(50, 4)\n'}, {'text': 'So yy[:, i] will give you the i-th offset sine curve. Let's set the\ndefault prop_cycle using matplotlib.pyplot.rc(). We'll combine a\ncolor cycler and a linestyle cycler by adding (+) two cycler's\ntogether. See the bottom of this tutorial for more information about\ncombining different cyclers.'}, {'code': 'default_cycler = (cycler(color=['r g b y']) +\n                  cycler(linestyle=['- -- : -.']))\n\nplt.rc('lines', linewidth=4)\nplt.rc('axes', prop_cycle=default_cycler)\n'}, {'text': 'Now we'll generate a figure with two axes, one on top of the other. On the\nfirst axis, we'll plot with the default cycler. On the second axis, we'll\nset the prop_cycle using matplotlib.axes.Axes.set_prop_cycle(),\nwhich will only set the prop_cycle for this matplotlib.axes.Axes\ninstance. We'll use a second cycler that combines a color cycler and a\nlinewidth cycler.'}, {'code': 'custom_cycler = (cycler(color=['c m y k']) +\n                 cycler(lw=[1, 2, 3, 4]))\n\nfig, (ax0, ax1) = plt.subplots(nrows=2)\nax0.plot(yy)\nax0.set_title('Set default color cycle to rgby')\nax1.set_prop_cycle(custom_cycler)\nax1.plot(yy)\nax1.set_title('Set axes color cycle to cmyk')\n\n# Add a bit more space between the two plots.\nfig.subplots_adjust(hspace=0.3)\nplt.show()\n'}, {'h2': 'Setting prop_cycle in the matplotlibrc file or style files'}, {'text': 'Remember, a custom cycler can be set in your matplotlibrc\nfile or a style file (style.mplstyle) under axes.prop_cycle:'}, {'code': 'axes.prop_cycle : cycler(color='bgrcmyk')\n'}, {'h2': 'Cycling through multiple properties'}, {'text': 'You can add cyclers:'}, {'code': 'from cycler import cycler\ncc = (cycler(color=list('rgb')) +\n      cycler(linestyle=['- -- -.']))\nfor d in cc:\n    print(d)\n'}, {'text': 'Results in:'}, {'code': '{'color': 'r linestyle': '-'}\n{'color': 'g linestyle': '--'}\n{'color': 'b linestyle': '-.'}\n'}, {'text': 'You can multiply cyclers:'}, {'code': 'from cycler import cycler\ncc = (cycler(color=list('rgb')) *\n      cycler(linestyle=['- -- -.']))\nfor d in cc:\n    print(d)\n'}, {'text': 'Results in:'}, {'code': '{'color': 'r linestyle': '-'}\n{'color': 'r linestyle': '--'}\n{'color': 'r linestyle': '-.'}\n{'color': 'g linestyle': '-'}\n{'color': 'g linestyle': '--'}\n{'color': 'g linestyle': '-.'}\n{'color': 'b linestyle': '-'}\n{'color': 'b linestyle': '--'}\n{'color': 'b linestyle': '-.'}\n'}, {'text': 'Download Python source code: color_cycle.py'}, {'text': 'Download Jupyter notebook: color_cycle.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 23
},
{
    "raw_page": "{'h1': 'Performance'}, {'text': 'Whether exploring data in interactive mode or programmatically\nsaving lots of plots, rendering performance can be a challenging\nbottleneck in your pipeline. Matplotlib provides multiple\nways to greatly reduce rendering time at the cost of a slight\nchange (to a settable tolerance) in your plot's appearance.\nThe methods available to reduce rendering time depend on the\ntype of plot that is being created.'}, {'h2': 'Line segment simplification'}, {'text': 'For plots that have line segments (e.g. typical line plots, outlines\nof polygons, etc.), rendering performance can be controlled by\nrcParamspath.simplify (default: True) and rcParamspath.simplify_threshold (default: 0.111111111111), which\ncan be defined e.g. in the matplotlibrc file (see\nCustomizing Matplotlib with style sheets and rcParams for more information about\nthe matplotlibrc file). rcParamspath.simplify (default: True) is a Boolean\nindicating whether or not line segments are simplified at all.\nrcParamspath.simplify_threshold (default: 0.111111111111) controls how much line segments are simplified;\nhigher thresholds result in quicker rendering.'}, {'text': 'The following script will first display the data without any\nsimplification, and then display the same data with simplification.\nTry interacting with both of them:'}, {'code': 'import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n# Setup, and create the data to plot\ny = np.random.rand(100000)\ny[50000:] *= 2\ny[np.geomspace(10, 50000, 400).astype(int)] = -1\nmpl.rcParams['path.simplify'] = True\n\nmpl.rcParams['path.simplify_threshold'] = 0.0\nplt.plot(y)\nplt.show()\n\nmpl.rcParams['path.simplify_threshold'] = 1.0\nplt.plot(y)\nplt.show()\n'}, {'text': 'Matplotlib currently defaults to a conservative simplification\nthreshold of 1/9. To change default settings to use a different\nvalue, change the matplotlibrc file. Alternatively, users\ncan create a new style for interactive plotting (with maximal\nsimplification) and another style for publication quality plotting\n(with minimal simplification) and activate them as necessary. See\nCustomizing Matplotlib with style sheets and rcParams for instructions on\nhow to perform these actions.'}, {'text': 'The simplification works by iteratively merging line segments\ninto a single vector until the next line segment's perpendicular\ndistance to the vector (measured in display-coordinate space)\nis greater than the path.simplify_threshold parameter.'}, {'text': 'Note'}, {'text': 'Changes related to how line segments are simplified were made\nin version 2.1. Rendering time will still be improved by these\nparameters prior to 2.1, but rendering time for some kinds of\ndata will be vastly improved in versions 2.1 and greater.'}, {'h2': 'Marker subsampling'}, {'text': 'Markers can also be simplified, albeit less robustly than line\nsegments. Marker subsampling is only available to Line2D objects\n(through the markevery property). Wherever Line2D construction\nparameters are passed through, such as pyplot.plot and Axes.plot,\nthe markevery parameter can be used:'}, {'code': 'plt.plot(x, y, markevery=10)\n'}, {'text': 'The markevery argument allows for naive subsampling, or an\nattempt at evenly spaced (along the x axis) sampling. See the\nMarkevery Demo\nfor more information.'}, {'h2': 'Splitting lines into smaller chunks'}, {'text': 'If you are using the Agg backend (see What is a backend?),\nthen you can make use of rcParamsagg.path.chunksize (default: 0)\nThis allows users to specify a chunk size, and any lines with\ngreater than that many vertices will be split into multiple\nlines, each of which has no more than agg.path.chunksize\nmany vertices. (Unless agg.path.chunksize is zero, in\nwhich case there is no chunking.) For some kind of data,\nchunking the line up into reasonable sizes can greatly\ndecrease rendering time.'}, {'text': 'The following script will first display the data without any\nchunk size restriction, and then display the same data with\na chunk size of 10,000. The difference can best be seen when\nthe figures are large, try maximizing the GUI and then\ninteracting with them:'}, {'code': 'import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams['path.simplify_threshold'] = 1.0\n\n# Setup, and create the data to plot\ny = np.random.rand(100000)\ny[50000:] *= 2\ny[np.geomspace(10, 50000, 400).astype(int)] = -1\nmpl.rcParams['path.simplify'] = True\n\nmpl.rcParams['agg.path.chunksize'] = 0\nplt.plot(y)\nplt.show()\n\nmpl.rcParams['agg.path.chunksize'] = 10000\nplt.plot(y)\nplt.show()\n'}, {'h2': 'Legends'}, {'text': 'The default legend behavior for axes attempts to find the location\nthat covers the fewest data points (loc='best'). This can be a\nvery expensive computation if there are lots of data points. In\nthis case, you may want to provide a specific location.'}, {'h2': 'Using the fast style'}, {'text': 'The fast style can be used to automatically set\nsimplification and chunking parameters to reasonable\nsettings to speed up plotting large amounts of data.\nThe following code runs it:'}, {'code': 'import matplotlib.style as mplstyle\nmplstyle.use('fast')\n'}, {'text': 'It is very lightweight, so it works well with other\nstyles. Be sure the fast style is applied last\nso that other styles do not overwrite the settings:'}, {'code': 'mplstyle.use(['dark_background ggplot fast'])\n'}",
    "id": 24
},
{
    "raw_page": "{'h1': 'Path Tutorial'}, {'text': 'Defining paths in your Matplotlib visualization.'}, {'text': 'The object underlying all of the matplotlib.patches objects is\nthe Path, which supports the standard set of\nmoveto, lineto, curveto commands to draw simple and compound outlines\nconsisting of line segments and splines. The Path is instantiated\nwith a (N, 2) array of (x, y) vertices, and an N-length array of path\ncodes. For example to draw the unit rectangle from (0, 0) to (1, 1), we\ncould use this code:'}, {'code': 'import numpy as np\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\n\nverts = [\n   (0., 0.),  # left, bottom\n   (0., 1.),  # left, top\n   (1., 1.),  # right, top\n   (1., 0.),  # right, bottom\n   (0., 0.),  # ignored\n]\n\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO,\n    Path.LINETO,\n    Path.CLOSEPOLY,\n]\n\npath = Path(verts, codes)\n\nfig, ax = plt.subplots()\npatch = patches.PathPatch(path, facecolor='orange', lw=2)\nax.add_patch(patch)\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\nplt.show()\n'}, {'text': 'The following path codes are recognized'}, {'text': 'Code'}, {'text': 'Vertices'}, {'text': 'Description'}, {'text': 'STOP'}, {'text': '1 (ignored)'}, {'text': 'A marker for the end of the entire\npath (currently not required and\nignored).'}, {'text': 'MOVETO'}, {'text': '1'}, {'text': 'Pick up the pen and move to the given\nvertex.'}, {'text': 'LINETO'}, {'text': '1'}, {'text': 'Draw a line from the current position\nto the given vertex.'}, {'text': 'CURVE3'}, {'text': '2:\n1 control point,\n1 end point'}, {'text': 'Draw a quadratic B\u00e9zier curve from the\ncurrent position, with the given\ncontrol point, to the given end point.'}, {'text': 'CURVE4'}, {'text': '3:\n2 control points,\n1 end point'}, {'text': 'Draw a cubic B\u00e9zier curve from the\ncurrent position, with the given\ncontrol points, to the given end\npoint.'}, {'text': 'CLOSEPOLY'}, {'text': '1 (the point is ignored)'}, {'text': 'Draw a line segment to the start point\nof the current polyline.'}, {'h2': 'B\u00e9zier example'}, {'text': 'Some of the path components require multiple vertices to specify them:\nfor example CURVE 3 is a B\u00e9zier curve with one\ncontrol point and one end point, and CURVE4 has three vertices for the\ntwo control points and the end point. The example below shows a\nCURVE4 B\u00e9zier spline -- the B\u00e9zier curve will be contained in the\nconvex hull of the start point, the two control points, and the end\npoint'}, {'code': 'verts = [\n   (0., 0.),   # P0\n   (0.2, 1.),  # P1\n   (1., 0.8),  # P2\n   (0.8, 0.),  # P3\n]\n\ncodes = [\n    Path.MOVETO,\n    Path.CURVE4,\n    Path.CURVE4,\n    Path.CURVE4,\n]\n\npath = Path(verts, codes)\n\nfig, ax = plt.subplots()\npatch = patches.PathPatch(path, facecolor='none', lw=2)\nax.add_patch(patch)\n\nxs, ys = zip(*verts)\nax.plot(xs, ys, 'x--', lw=2, color='black', ms=10)\n\nax.text(-0.05, -0.05, 'P0')\nax.text(0.15, 1.05, 'P1')\nax.text(1.05, 0.85, 'P2')\nax.text(0.85, -0.05, 'P3')\n\nax.set_xlim(-0.1, 1.1)\nax.set_ylim(-0.1, 1.1)\nplt.show()\n'}, {'h2': 'Compound paths'}, {'text': 'All of the simple patch primitives in matplotlib, Rectangle, Circle,\nPolygon, etc, are implemented with simple path. Plotting functions\nlike hist() and\nbar(), which create a number of\nprimitives, e.g., a bunch of Rectangles, can usually be implemented more\nefficiently using a compound path. The reason bar creates a list\nof rectangles and not a compound path is largely historical: the\nPath code is comparatively new and bar\npredates it. While we could change it now, it would break old code,\nso here we will cover how to create compound paths, replacing the\nfunctionality in bar, in case you need to do so in your own code for\nefficiency reasons, e.g., you are creating an animated bar plot.'}, {'text': 'We will make the histogram chart by creating a series of rectangles\nfor each histogram bar: the rectangle width is the bin width and the\nrectangle height is the number of datapoints in that bin. First we'll\ncreate some random normally distributed data and compute the\nhistogram. Because NumPy returns the bin edges and not centers, the\nlength of bins is one greater than the length of n in the\nexample below:'}, {'code': '# histogram our data with numpy\ndata = np.random.randn(1000)\nn, bins = np.histogram(data, 100)\n'}, {'text': 'We'll now extract the corners of the rectangles. Each of the\nleft, bottom, etc., arrays below is len(n), where n is\nthe array of counts for each histogram bar:'}, {'code': '# get the corners of the rectangles for the histogram\nleft = np.array(bins[:-1])\nright = np.array(bins[1:])\nbottom = np.zeros(len(left))\ntop = bottom + n\n'}, {'text': 'Now we have to construct our compound path, which will consist of a\nseries of MOVETO, LINETO and CLOSEPOLY for each rectangle.\nFor each rectangle, we need five vertices: one for the MOVETO,\nthree for the LINETO, and one for the CLOSEPOLY. As indicated\nin the table above, the vertex for the closepoly is ignored, but we still\nneed it to keep the codes aligned with the vertices:'}, {'code': 'nverts = nrects*(1+3+1)\nverts = np.zeros((nverts, 2))\ncodes = np.ones(nverts, int) * path.Path.LINETO\ncodes[0::5] = path.Path.MOVETO\ncodes[4::5] = path.Path.CLOSEPOLY\nverts[0::5, 0] = left\nverts[0::5, 1] = bottom\nverts[1::5, 0] = left\nverts[1::5, 1] = top\nverts[2::5, 0] = right\nverts[2::5, 1] = top\nverts[3::5, 0] = right\nverts[3::5, 1] = bottom\n'}, {'text': 'All that remains is to create the path, attach it to a\nPathPatch, and add it to our axes:'}, {'code': 'barpath = path.Path(verts, codes)\npatch = patches.PathPatch(barpath, facecolor='green',\n  edgecolor='yellow', alpha=0.5)\nax.add_patch(patch)\n'}, {'code': 'fig, ax = plt.subplots()\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# histogram our data with numpy\ndata = np.random.randn(1000)\nn, bins = np.histogram(data, 100)\n\n# get the corners of the rectangles for the histogram\nleft = np.array(bins[:-1])\nright = np.array(bins[1:])\nbottom = np.zeros(len(left))\ntop = bottom + n\nnrects = len(left)\n\nnverts = nrects*(1+3+1)\nverts = np.zeros((nverts, 2))\ncodes = np.full(nverts, Path.LINETO, dtype=int)\ncodes[0::5] = Path.MOVETO\ncodes[4::5] = Path.CLOSEPOLY\nverts[0::5, 0] = left\nverts[0::5, 1] = bottom\nverts[1::5, 0] = left\nverts[1::5, 1] = top\nverts[2::5, 0] = right\nverts[2::5, 1] = top\nverts[3::5, 0] = right\nverts[3::5, 1] = bottom\n\nbarpath = Path(verts, codes)\npatch = patches.PathPatch(barpath, facecolor='green',\n                          edgecolor='yellow', alpha=0.5)\nax.add_patch(patch)\n\nax.set_xlim(left[0], right[-1])\nax.set_ylim(bottom.min(), top.max())\n\nplt.show()\n'}, {'text': 'Download Python source code: paths.py'}, {'text': 'Download Jupyter notebook: paths.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 25
},
{
    "raw_page": "{'h1': 'Path effects guide'}, {'text': 'Defining paths that objects follow on a canvas.'}, {'text': 'Matplotlib's patheffects module provides functionality to apply a\nmultiple draw stage to any Artist which can be rendered via a path.Path.'}, {'text': 'Artists which can have a path effect applied to them include patches.Patch,\nlines.Line2D, collections.Collection and even text.Text. Each artist's\npath effects can be controlled via the Artist.set_path_effects method,\nwhich takes an iterable of AbstractPathEffect instances.'}, {'text': 'The simplest path effect is the Normal effect, which simply draws the artist\nwithout any effect:'}, {'code': 'import matplotlib.pyplot as plt\n\nimport matplotlib.patheffects as path_effects\n\nfig = plt.figure(figsize=(5, 1.5))\ntext = fig.text(0.5, 0.5, 'Hello path effects world!\\\nThis is the normal '\n                          'path effect.\\\nPretty dull, huh?',\n                ha='center', va='center', size=20)\ntext.set_path_effects([path_effects.Normal()])\nplt.show()\n'}, {'text': 'Whilst the plot doesn't look any different to what you would expect without\nany path effects, the drawing of the text has now been changed to use the\npath effects framework, opening up the possibilities for more interesting\nexamples.'}, {'h2': 'Adding a shadow'}, {'text': 'A far more interesting path effect than Normal is the drop-shadow, which we\ncan apply to any of our path based artists. The classes SimplePatchShadow\nand SimpleLineShadow do precisely this by drawing either a filled patch or\na line patch below the original artist:'}, {'code': 'import matplotlib.patheffects as path_effects\n\ntext = plt.text(0.5, 0.5, 'Hello path effects world!',\n                path_effects=[path_effects.withSimplePatchShadow()])\n\nplt.plot([0, 3, 2, 5], linewidth=5, color='blue',\n         path_effects=[path_effects.SimpleLineShadow(),\n                       path_effects.Normal()])\nplt.show()\n'}, {'text': 'Notice the two approaches to setting the path effects in this example. The\nfirst uses the with* classes to include the desired functionality\nautomatically followed with the 'normal' effect, whereas the latter\nexplicitly defines the two path effects to draw.'}, {'h2': 'Making an artist stand out'}, {'text': 'One nice way of making artists visually stand out is to draw an outline in\na bold color below the actual artist. The Stroke path effect makes\nthis a relatively simple task:'}, {'code': 'fig = plt.figure(figsize=(7, 1))\ntext = fig.text(0.5, 0.5, 'This text stands out because of\\\n'\n                          'its black border.', color='white',\n                          ha='center', va='center', size=30)\ntext.set_path_effects([path_effects.Stroke(linewidth=3, foreground='black'),\n                       path_effects.Normal()])\nplt.show()\n'}, {'text': 'It is important to note that this effect only works because we have drawn\nthe text path twice; once with a thick black line, and then once with the\noriginal text path on top.'}, {'text': 'You may have noticed that the keywords to Stroke and SimplePatchShadow\nand SimpleLineShadow are not the usual Artist keywords (facecolor\nedgecolor, etc.). This is because with these path effects we are operating\nat lower level of Matplotlib. In fact, the keywords which are accepted are\nthose for a matplotlib.backend_bases.GraphicsContextBase instance, which\nhave been designed for making it easy to create new backends - and not for\nits user interface.'}, {'h2': 'Greater control of the path effect artist'}, {'text': 'As already mentioned, some of the path effects operate at a lower level\nthan most users will be used to, meaning that setting keywords such as\nfacecolor and edgecolor raise an AttributeError. Luckily there is a\ngeneric PathPatchEffect path effect which creates a patches.PathPatch\nclass with the original path. The keywords to this effect are identical to\nthose of patches.PathPatch:'}, {'code': 'fig = plt.figure(figsize=(8.5, 1))\nt = fig.text(0.02, 0.5, 'Hatch shadow', fontsize=75, weight=1000, va='center')\nt.set_path_effects([\n    path_effects.PathPatchEffect(\n        offset=(4, -4), hatch='xxxx', facecolor='gray'),\n    path_effects.PathPatchEffect(\n        edgecolor='white', linewidth=1.1, facecolor='black')])\nplt.show()\n'}, {'text': 'Download Python source code: patheffects_guide.py'}, {'text': 'Download Jupyter notebook: patheffects_guide.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 26
},
{
    "raw_page": "{'h1': 'origin and extent in imshow'}, {'text': 'imshow() allows you to render an image (either a 2D array which\nwill be color-mapped (based on norm and cmap) or a 3D RGB(A) array which\nwill be used as-is) to a rectangular region in data space. The orientation of\nthe image in the final rendering is controlled by the origin and extent\nkeyword arguments (and attributes on the resulting AxesImage instance) and\nthe data limits of the axes.'}, {'text': 'The extent keyword arguments controls the bounding box in data coordinates\nthat the image will fill specified as (left, right, bottom, top) in data\ncoordinates, the origin keyword argument controls how the image fills that\nbounding box, and the orientation in the final rendered image is also affected\nby the axes limits.'}, {'text': 'Hint'}, {'text': 'Most of the code below is used for adding labels and informative\ntext to the plots. The described effects of origin and extent can be\nseen in the plots without the need to follow all code details.'}, {'text': 'For a quick understanding, you may want to skip the code details below and\ndirectly continue with the discussion of the results.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef index_to_coordinate(index, extent, origin):\n    '''Return the pixel center of an index.'''\n    left, right, bottom, top = extent\n\n    hshift = 0.5 * np.sign(right - left)\n    left, right = left + hshift, right - hshift\n    vshift = 0.5 * np.sign(top - bottom)\n    bottom, top = bottom + vshift, top - vshift\n\n    if origin == 'upper':\n        bottom, top = top, bottom\n\n    return {\n        '[0, 0]': (left, bottom),\n        '[M', 0]': (left, top),\n        '[0, N']': (right, bottom),\n        '[M', N']': (right, top),\n    }[index]\n\n\ndef get_index_label_pos(index, extent, origin, inverted_xindex):\n    '''\n    Return the desired position and horizontal alignment of an index label.\n    '''\n    if extent is None:\n        extent = lookup_extent(origin)\n    left, right, bottom, top = extent\n    x, y = index_to_coordinate(index, extent, origin)\n\n    is_x0 = index[-2:] == '0]'\n    halign = 'left' if is_x0 ^ inverted_xindex else 'right'\n    hshift = 0.5 * np.sign(left - right)\n    x += hshift * (1 if is_x0 else -1)\n    return x, y, halign\n\n\ndef get_color(index, data, cmap):\n    '''Return the data color of an index.'''\n    val = {\n        '[0, 0]': data[0, 0],\n        '[0, N']': data[0, -1],\n        '[M', 0]': data[-1, 0],\n        '[M', N']': data[-1, -1],\n    }[index]\n    return cmap(val / data.max())\n\n\ndef lookup_extent(origin):\n    '''Return extent for label positioning when not given explicitly.'''\n    if origin == 'lower':\n        return (-0.5, 6.5, -0.5, 5.5)\n    else:\n        return (-0.5, 6.5, 5.5, -0.5)\n\n\ndef set_extent_None_text(ax):\n    ax.text(3, 2.5, 'equals\\\nextent=None', size='large',\n            ha='center', va='center', color='w')\n\n\ndef plot_imshow_with_labels(ax, data, extent, origin, xlim, ylim):\n    '''Actually run ``imshow()`` and add extent and index labels.'''\n    im = ax.imshow(data, origin=origin, extent=extent)\n\n    # extent labels (left, right, bottom, top)\n    left, right, bottom, top = im.get_extent()\n    if xlim is None or top > bottom:\n        upper_string, lower_string = 'top', 'bottom'\n    else:\n        upper_string, lower_string = 'bottom', 'top'\n    if ylim is None or left < right:\n        port_string, starboard_string = 'left', 'right'\n        inverted_xindex = False\n    else:\n        port_string, starboard_string = 'right', 'left'\n        inverted_xindex = True\n    bbox_kwargs = {'fc': 'w', 'alpha': .75, 'boxstyle': 'round4'}\n    ann_kwargs = {'xycoords': 'axes fraction',\n                  'textcoords': 'offset points',\n                  'bbox': bbox_kwargs}\n    ax.annotate(upper_string, xy=(.5, 1), xytext=(0, -1),\n                ha='center', va='top', **ann_kwargs)\n    ax.annotate(lower_string, xy=(.5, 0), xytext=(0, 1),\n                ha='center', va='bottom', **ann_kwargs)\n    ax.annotate(port_string, xy=(0, .5), xytext=(1, 0),\n                ha='left', va='center', rotation=90,\n                **ann_kwargs)\n    ax.annotate(starboard_string, xy=(1, .5), xytext=(-1, 0),\n                ha='right', va='center', rotation=-90,\n                **ann_kwargs)\n    ax.set_title(f'origin: {origin}')\n\n    # index labels\n    for index in [0, 0]', '[0, N']', '[M', 0]', '[M', N']:\n        tx, ty, halign = get_index_label_pos(index, extent, origin,\n                                             inverted_xindex)\n        facecolor = get_color(index, data, im.get_cmap())\n        ax.text(tx, ty, index, color='white', ha=halign, va='center',\n                bbox={'boxstyle': 'square', 'facecolor': facecolor})\n    if xlim:\n        ax.set_xlim(*xlim)\n    if ylim:\n        ax.set_ylim(*ylim)\n\n\ndef generate_imshow_demo_grid(extents, xlim=None, ylim=None):\n    N = len(extents)\n    fig = plt.figure(tight_layout=True)\n    fig.set_size_inches(6, N * (11.25) / 5)\n    gs = GridSpec(N, 5, figure=fig)\n\n    columns = {'label': [fig.add_subplot(gs[j, 0]) for j in range(N)],\n               'upper': [fig.add_subplot(gs[j, 1:3]) for j in range(N)],\n               'lower': [fig.add_subplot(gs[j, 3:5]) for j in range(N)]}\n    x, y = np.ogrid[0:6, 0:7]\n    data = x + y\n\n    for origin in ['upper', 'lower']:\n        for ax, extent in zip(columns[origin], extents):\n            plot_imshow_with_labels(ax, data, extent, origin, xlim, ylim)\n\n    columns['label'][0].set_title('extent=')\n    for ax, extent in zip(columns['label'], extents):\n        if extent is None:\n            text = 'None'\n        else:\n            left, right, bottom, top = extent\n            text = (f'left: {left:0.1f}\\\nright: {right:0.1f}\\\n'\n                    f'bottom: {bottom:0.1f}\\\ntop: {top:0.1f}\\\n')\n        ax.text(1., .5, text, transform=ax.transAxes, ha='right', va='center')\n        ax.axis('off')\n    return columns\n'}, {'h2': 'Default extent'}, {'text': 'First, let's have a look at the default extent=None'}, {'code': 'generate_imshow_demo_grid(extents=[None])\n'}, {'text': 'Generally, for an array of shape (M, N), the first index runs along the\nvertical, the second index runs along the horizontal.\nThe pixel centers are at integer positions ranging from 0 to N' = N - 1\nhorizontally and from 0 to M' = M - 1 vertically.\norigin determines how the data is filled in the bounding box.'}, {'text': 'For origin='lower':'}, {'text': '[0, 0] is at (left, bottom)'}, {'text': '[M', 0] is at (left, top)'}, {'text': '[0, N'] is at (right, bottom)'}, {'text': '[M', N'] is at (right, top)'}, {'text': 'origin='upper' reverses the vertical axes direction and filling:'}, {'text': '[0, 0] is at (left, top)'}, {'text': '[M', 0] is at (left, bottom)'}, {'text': '[0, N'] is at (right, top)'}, {'text': '[M', N'] is at (right, bottom)'}, {'text': 'In summary, the position of the [0, 0] index as well as the extent are\ninfluenced by origin:'}, {'text': 'origin'}, {'text': '[0, 0] position'}, {'text': 'extent'}, {'text': 'upper'}, {'text': 'top left'}, {'text': '(-0.5, numcols-0.5, numrows-0.5, -0.5)'}, {'text': 'lower'}, {'text': 'bottom left'}, {'text': '(-0.5, numcols-0.5, -0.5, numrows-0.5)'}, {'text': 'The default value of origin is set by rcParamsimage.origin (default: 'upper') which defaults\nto 'upper' to match the matrix indexing conventions in math and\ncomputer graphics image indexing conventions.'}, {'h2': 'Explicit extent'}, {'text': 'By setting extent we define the coordinates of the image area. The\nunderlying image data is interpolated/resampled to fill that area.'}, {'text': 'If the axes is set to autoscale, then the view limits of the axes are set\nto match the extent which ensures that the coordinate set by\n(left, bottom) is at the bottom left of the axes! However, this\nmay invert the axis so they do not increase in the 'natural' direction.'}, {'code': 'extents = [(-0.5, 6.5, -0.5, 5.5),\n           (-0.5, 6.5, 5.5, -0.5),\n           (6.5, -0.5, -0.5, 5.5),\n           (6.5, -0.5, 5.5, -0.5)]\n\ncolumns = generate_imshow_demo_grid(extents)\nset_extent_None_text(columns['upper'][1])\nset_extent_None_text(columns['lower'][0])\n'}, {'h2': 'Explicit extent and axes limits'}, {'text': 'If we fix the axes limits by explicitly setting set_xlim /\nset_ylim, we force a certain size and orientation of the axes.\nThis can decouple the 'left-right' and 'top-bottom' sense of the image from\nthe orientation on the screen.'}, {'text': 'In the example below we have chosen the limits slightly larger than the\nextent (note the white areas within the Axes).'}, {'text': 'While we keep the extents as in the examples before, the coordinate (0, 0)\nis now explicitly put at the bottom left and values increase to up and to\nthe right (from the viewer's point of view).\nWe can see that:'}, {'text': 'The coordinate (left, bottom) anchors the image which then fills the\nbox going towards the (right, top) point in data space.'}, {'text': 'The first column is always closest to the 'left'.'}, {'text': 'origin controls if the first row is closest to 'top' or 'bottom'.'}, {'text': 'The image may be inverted along either direction.'}, {'text': 'The 'left-right' and 'top-bottom' sense of the image may be uncoupled from\nthe orientation on the screen.'}, {'code': 'generate_imshow_demo_grid(extents=[None] + extents,\n                          xlim=(-2, 8), ylim=(-1, 6))\n\nplt.show()\n'}, {'text': 'Total running time of the script: (0 minutes 3.709 seconds)'}, {'text': 'Download Python source code: imshow_extent.py'}, {'text': 'Download Jupyter notebook: imshow_extent.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 27
},
{
    "raw_page": "{'h1': 'Transformations Tutorial'}, {'text': 'Like any graphics packages, Matplotlib is built on top of a transformation\nframework to easily move between coordinate systems, the userland data\ncoordinate system, the axes coordinate system, the figure coordinate\nsystem, and the display coordinate system. In 95% of your plotting, you\nwon't need to think about this, as it happens under the hood, but as you push\nthe limits of custom figure generation, it helps to have an understanding of\nthese objects, so you can reuse the existing transformations Matplotlib makes\navailable to you, or create your own (see matplotlib.transforms). The\ntable below summarizes some useful coordinate systems, a description of each\nsystem, and the transformation object for going from each coordinate system to\nthe display coordinates. In the 'Transformation Object' column, ax is a\nAxes instance, fig is a\nFigure instance, and subfigure is a\nSubFigure instance.'}, {'text': 'Coordinate\nsystem'}, {'text': 'Description'}, {'text': 'Transformation object\nfrom system to display'}, {'text': ''data''}, {'text': 'The coordinate system of the data\nin the Axes.'}, {'text': 'ax.transData'}, {'text': ''axes''}, {'text': 'The coordinate system of the\nAxes; (0, 0)\nis bottom left of the axes, and\n(1, 1) is top right of the axes.'}, {'text': 'ax.transAxes'}, {'text': ''subfigure''}, {'text': 'The coordinate system of the\nSubFigure; (0, 0) is bottom left\nof the subfigure, and (1, 1) is top\nright of the subfigure. If a\nfigure has no subfigures, this is\nthe same as transFigure.'}, {'text': 'subfigure.transSubfigure'}, {'text': ''figure''}, {'text': 'The coordinate system of the\nFigure; (0, 0) is bottom left\nof the figure, and (1, 1) is top\nright of the figure.'}, {'text': 'fig.transFigure'}, {'text': ''figure-inches''}, {'text': 'The coordinate system of the\nFigure in inches; (0, 0) is\nbottom left of the figure, and\n(width, height) is the top right\nof the figure in inches.'}, {'text': 'fig.dpi_scale_trans'}, {'text': ''xaxis',\n'yaxis''}, {'text': 'Blended coordinate systems, using\ndata coordinates on one direction\nand axes coordinates on the other.'}, {'text': 'ax.get_xaxis_transform(),\nax.get_yaxis_transform()'}, {'text': ''display''}, {'text': 'The native coordinate system of the\noutput ; (0, 0) is the bottom left\nof the window, and (width, height)\nis top right of the output in\n'display units'.'}, {'text': 'The exact interpretation of the\nunits depends on the back end. For\nexample it is pixels for Agg and\npoints for svg/pdf.'}, {'text': 'None, or\nIdentityTransform()'}, {'text': 'The Transform objects are naive to the source and\ndestination coordinate systems, however the objects referred to in the table\nabove are constructed to take inputs in their coordinate system, and transform\nthe input to the display coordinate system. That is why the display\ncoordinate system has None for the 'Transformation Object' column -- it\nalready is in display coordinates. The naming and destination conventions\nare an aid to keeping track of the available 'standard' coordinate systems and\ntransforms.'}, {'text': 'The transformations also know how to invert themselves (via\nTransform.inverted) to generate a transform from output coordinate system\nback to the input coordinate system. For example, ax.transData converts\nvalues in data coordinates to display coordinates and\nax.transData.inversed() is a matplotlib.transforms.Transform that\ngoes from display coordinates to data coordinates. This is particularly useful\nwhen processing events from the user interface, which typically occur in\ndisplay space, and you want to know where the mouse click or key-press occurred\nin your data coordinate system.'}, {'text': 'Note that specifying the position of Artists in display coordinates may\nchange their relative location if the dpi or size of the figure changes.\nThis can cause confusion when printing or changing screen resolution, because\nthe object can change location and size. Therefore, it is most common for\nartists placed in an Axes or figure to have their transform set to something\nother than the IdentityTransform(); the default when an artist\nis added to an Axes using add_artist is for the transform to be\nax.transData so that you can work and think in data coordinates and let\nMatplotlib take care of the transformation to display.'}, {'h2': 'Data coordinates'}, {'text': 'Let's start with the most commonly used coordinate, the data coordinate\nsystem. Whenever you add data to the axes, Matplotlib updates the datalimits,\nmost commonly updated with the set_xlim() and\nset_ylim() methods. For example, in the figure\nbelow, the data limits stretch from 0 to 10 on the x-axis, and -1 to 1 on the\ny-axis.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nplt.show()\n'}, {'text': 'You can use the ax.transData instance to transform from your\ndata to your display coordinate system, either a single point or a\nsequence of points as shown below:'}, {'code': 'In [14]: type(ax.transData)\nOut[14]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n\nIn [15]: ax.transData.transform((5, 0))\nOut[15]: array([ 335.175,  247.   ])\n\nIn [16]: ax.transData.transform([(5, 0), (1, 2)])\nOut[16]:\narray([[ 335.175,  247.   ],\n       [ 132.435,  642.2  ]])\n'}, {'text': 'You can use the inverted()\nmethod to create a transform which will take you from display to data\ncoordinates:'}, {'code': 'In [41]: inv = ax.transData.inverted()\n\nIn [42]: type(inv)\nOut[42]: <class 'matplotlib.transforms.CompositeGenericTransform'>\n\nIn [43]: inv.transform((335.175,  247.))\nOut[43]: array([ 5.,  0.])\n'}, {'text': 'If your are typing along with this tutorial, the exact values of the\ndisplay coordinates may differ if you have a different window size or\ndpi setting. Likewise, in the figure below, the display labeled\npoints are probably not the same as in the ipython session because the\ndocumentation figure size defaults are different.'}, {'code': 'x = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nxdata, ydata = 5, 0\n# This computing the transform now, if anything\n# (figure size, dpi, axes placement, data limits, scales..)\n# changes re-calling transform will get a different value.\nxdisplay, ydisplay = ax.transData.transform((xdata, ydata))\n\nbbox = dict(boxstyle='round', fc='0.8')\narrowprops = dict(\n    arrowstyle='->',\n    connectionstyle='angle,angleA=0,angleB=90,rad=10')\n\noffset = 72\nax.annotate(f'data = ({xdata:.1f}, {ydata:.1f})',\n            (xdata, ydata), xytext=(-2*offset, offset), textcoords='offset points',\n            bbox=bbox, arrowprops=arrowprops)\n\ndisp = ax.annotate(f'display = ({xdisplay:.1f}, {ydisplay:.1f})',\n                   (xdisplay, ydisplay), xytext=(0.5*offset, -offset),\n                   xycoords='figure pixels',\n                   textcoords='offset points',\n                   bbox=bbox, arrowprops=arrowprops)\n\nplt.show()\n'}, {'text': 'Warning'}, {'text': 'If you run the source code in the example above in a GUI backend,\nyou may also find that the two arrows for the data and display\nannotations do not point to exactly the same point. This is because\nthe display point was computed before the figure was displayed, and\nthe GUI backend may slightly resize the figure when it is created.\nThe effect is more pronounced if you resize the figure yourself.\nThis is one good reason why you rarely want to work in display\nspace, but you can connect to the 'on_draw'\nEvent to update figure\ncoordinates on figure draws; see Event handling and picking.'}, {'text': 'When you change the x or y limits of your axes, the data limits are\nupdated so the transformation yields a new display point. Note that\nwhen we just change the ylim, only the y-display coordinate is\naltered, and when we change the xlim too, both are altered. More on\nthis later when we talk about the\nBbox.'}, {'code': 'In [54]: ax.transData.transform((5, 0))\nOut[54]: array([ 335.175,  247.   ])\n\nIn [55]: ax.set_ylim(-1, 2)\nOut[55]: (-1, 2)\n\nIn [56]: ax.transData.transform((5, 0))\nOut[56]: array([ 335.175     ,  181.13333333])\n\nIn [57]: ax.set_xlim(10, 20)\nOut[57]: (10, 20)\n\nIn [58]: ax.transData.transform((5, 0))\nOut[58]: array([-171.675     ,  181.13333333])\n'}, {'h2': 'Axes coordinates'}, {'text': 'After the data coordinate system, axes is probably the second most\nuseful coordinate system. Here the point (0, 0) is the bottom left of\nyour axes or subplot, (0.5, 0.5) is the center, and (1.0, 1.0) is the\ntop right. You can also refer to points outside the range, so (-0.1,\n1.1) is to the left and above your axes. This coordinate system is\nextremely useful when placing text in your axes, because you often\nwant a text bubble in a fixed, location, e.g., the upper left of the axes\npane, and have that location remain fixed when you pan or zoom. Here\nis a simple example that creates four panels and labels them 'A B',\n'C D' as you often see in journals.'}, {'code': 'fig = plt.figure()\nfor i, label in enumerate(('A B C D')):\n    ax = fig.add_subplot(2, 2, i+1)\n    ax.text(0.05, 0.95, label, transform=ax.transAxes,\n            fontsize=16, fontweight='bold', va='top')\n\nplt.show()\n'}, {'text': 'You can also make lines or patches in the axes coordinate system, but\nthis is less useful in my experience than using ax.transAxes for\nplacing text. Nonetheless, here is a silly example which plots some\nrandom dots in data space, and overlays a semi-transparent\nCircle centered in the middle of the axes\nwith a radius one quarter of the axes -- if your axes does not\npreserve aspect ratio (see set_aspect()),\nthis will look like an ellipse. Use the pan/zoom tool to move around,\nor manually change the data xlim and ylim, and you will see the data\nmove, but the circle will remain fixed because it is not in data\ncoordinates and will always remain at the center of the axes.'}, {'code': 'fig, ax = plt.subplots()\nx, y = 10*np.random.rand(2, 1000)\nax.plot(x, y, 'go', alpha=0.2)  # plot some data in data coordinates\n\ncirc = mpatches.Circle((0.5, 0.5), 0.25, transform=ax.transAxes,\n                       facecolor='blue', alpha=0.75)\nax.add_patch(circ)\nplt.show()\n'}, {'h2': 'Blended transformations'}, {'text': 'Drawing in blended coordinate spaces which mix axes with data\ncoordinates is extremely useful, for example to create a horizontal\nspan which highlights some region of the y-data but spans across the\nx-axis regardless of the data limits, pan or zoom level, etc. In fact\nthese blended lines and spans are so useful, we have built-in\nfunctions to make them easy to plot (see\naxhline(),\naxvline(),\naxhspan(),\naxvspan()) but for didactic purposes we\nwill implement the horizontal span here using a blended\ntransformation. This trick only works for separable transformations,\nlike you see in normal Cartesian coordinate systems, but not on\ninseparable transformations like the\nPolarTransform.'}, {'code': 'import matplotlib.transforms as transforms\n\nfig, ax = plt.subplots()\nx = np.random.randn(1000)\n\nax.hist(x, 30)\nax.set_title(r'$\\\\sigma=1 \\\\/ \\\\dots \\\\/ \\\\sigma=2$', fontsize=16)\n\n# the x coords of this transformation are data, and the y coord are axes\ntrans = transforms.blended_transform_factory(\n    ax.transData, ax.transAxes)\n# highlight the 1..2 stddev region with a span.\n# We want x to be in data coordinates and y to span from 0..1 in axes coords.\nrect = mpatches.Rectangle((1, 0), width=1, height=1, transform=trans,\n                          color='yellow', alpha=0.5)\nax.add_patch(rect)\n\nplt.show()\n'}, {'text': 'Note'}, {'text': 'The blended transformations where x is in data coords and y in axes\ncoordinates is so useful that we have helper methods to return the\nversions Matplotlib uses internally for drawing ticks, ticklabels, etc.\nThe methods are matplotlib.axes.Axes.get_xaxis_transform() and\nmatplotlib.axes.Axes.get_yaxis_transform(). So in the example\nabove, the call to\nblended_transform_factory() can be\nreplaced by get_xaxis_transform:'}, {'code': 'trans = ax.get_xaxis_transform()\n'}, {'h2': 'Plotting in physical coordinates'}, {'text': 'Sometimes we want an object to be a certain physical size on the plot.\nHere we draw the same circle as above, but in physical coordinates. If done\ninteractively, you can see that changing the size of the figure does\nnot change the offset of the circle from the lower-left corner,\ndoes not change its size, and the circle remains a circle regardless of\nthe aspect ratio of the axes.'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 4))\nx, y = 10*np.random.rand(2, 1000)\nax.plot(x, y*10., 'go', alpha=0.2)  # plot some data in data coordinates\n# add a circle in fixed-coordinates\ncirc = mpatches.Circle((2.5, 2), 1.0, transform=fig.dpi_scale_trans,\n                       facecolor='blue', alpha=0.75)\nax.add_patch(circ)\nplt.show()\n'}, {'text': 'If we change the figure size, the circle does not change its absolute\nposition and is cropped.'}, {'code': 'fig, ax = plt.subplots(figsize=(7, 2))\nx, y = 10*np.random.rand(2, 1000)\nax.plot(x, y*10., 'go', alpha=0.2)  # plot some data in data coordinates\n# add a circle in fixed-coordinates\ncirc = mpatches.Circle((2.5, 2), 1.0, transform=fig.dpi_scale_trans,\n                       facecolor='blue', alpha=0.75)\nax.add_patch(circ)\nplt.show()\n'}, {'text': 'Another use is putting a patch with a set physical dimension around a\ndata point on the axes. Here we add together two transforms. The\nfirst sets the scaling of how large the ellipse should be and the second\nsets its position. The ellipse is then placed at the origin, and then\nwe use the helper transform ScaledTranslation\nto move it\nto the right place in the ax.transData coordinate system.\nThis helper is instantiated with:'}, {'code': 'trans = ScaledTranslation(xt, yt, scale_trans)\n'}, {'text': 'where xt and yt are the translation offsets, and scale_trans is\na transformation which scales xt and yt at transformation time\nbefore applying the offsets.'}, {'text': 'Note the use of the plus operator on the transforms below.\nThis code says: first apply the scale transformation fig.dpi_scale_trans\nto make the ellipse the proper size, but still centered at (0, 0),\nand then translate the data to xdata[0] and ydata[0] in data space.'}, {'text': 'In interactive use, the ellipse stays the same size even if the\naxes limits are changed via zoom.'}, {'code': 'fig, ax = plt.subplots()\nxdata, ydata = (0.2, 0.7), (0.5, 0.5)\nax.plot(xdata, ydata, 'o')\nax.set_xlim((0, 1))\n\ntrans = (fig.dpi_scale_trans +\n         transforms.ScaledTranslation(xdata[0], ydata[0], ax.transData))\n\n# plot an ellipse around the point that is 150 x 130 points in diameter...\ncircle = mpatches.Ellipse((0, 0), 150/72, 130/72, angle=40,\n                          fill=None, transform=trans)\nax.add_patch(circle)\nplt.show()\n'}, {'text': 'Note'}, {'text': 'The order of transformation matters. Here the ellipse\nis given the right dimensions in display space first and then moved\nin data space to the correct spot.\nIf we had done the ScaledTranslation first, then\nxdata[0] and ydata[0] would\nfirst be transformed to display coordinates ([ 358.4\\xa0 475.2] on\na 200-dpi monitor) and then those coordinates\nwould be scaled by fig.dpi_scale_trans pushing the center of\nthe ellipse well off the screen (i.e. [ 71680.\\xa0 95040.]).'}, {'h2': 'Using offset transforms to create a shadow effect'}, {'text': 'Another use of ScaledTranslation is to create\na new transformation that is\noffset from another transformation, e.g., to place one object shifted a\nbit relative to another object. Typically, you want the shift to be in\nsome physical dimension, like points or inches rather than in data\ncoordinates, so that the shift effect is constant at different zoom\nlevels and dpi settings.'}, {'text': 'One use for an offset is to create a shadow effect, where you draw one\nobject identical to the first just to the right of it, and just below\nit, adjusting the zorder to make sure the shadow is drawn first and\nthen the object it is shadowing above it.'}, {'text': 'Here we apply the transforms in the opposite order to the use of\nScaledTranslation above. The plot is\nfirst made in data coordinates (ax.transData) and then shifted by\ndx and dy points using fig.dpi_scale_trans. (In typography,\na point is\n1/72 inches, and by specifying your offsets in points, your figure\nwill look the same regardless of the dpi resolution it is saved in.)'}, {'code': 'fig, ax = plt.subplots()\n\n# make a simple sine wave\nx = np.arange(0., 2., 0.01)\ny = np.sin(2*np.pi*x)\nline, = ax.plot(x, y, lw=3, color='blue')\n\n# shift the object over 2 points, and down 2 points\ndx, dy = 2/72., -2/72.\noffset = transforms.ScaledTranslation(dx, dy, fig.dpi_scale_trans)\nshadow_transform = ax.transData + offset\n\n# now plot the same data with our offset transform;\n# use the zorder to make sure we are below the line\nax.plot(x, y, lw=3, color='gray',\n        transform=shadow_transform,\n        zorder=0.5*line.get_zorder())\n\nax.set_title('creating a shadow effect with an offset transform')\nplt.show()\n'}, {'text': 'Note'}, {'text': 'The dpi and inches offset is a\ncommon-enough use case that we have a special helper function to\ncreate it in matplotlib.transforms.offset_copy(), which returns\na new transform with an added offset. So above we could have done:'}, {'code': 'shadow_transform = transforms.offset_copy(ax.transData,\n         fig, dx, dy, units='inches')\n'}, {'h2': 'The transformation pipeline'}, {'text': 'The ax.transData transform we have been working with in this\ntutorial is a composite of three different transformations that\ncomprise the transformation pipeline from data -> display\ncoordinates. Michael Droettboom implemented the transformations\nframework, taking care to provide a clean API that segregated the\nnonlinear projections and scales that happen in polar and logarithmic\nplots, from the linear affine transformations that happen when you pan\nand zoom. There is an efficiency here, because you can pan and zoom\nin your axes which affects the affine transformation, but you may not\nneed to compute the potentially expensive nonlinear scales or\nprojections on simple navigation events. It is also possible to\nmultiply affine transformation matrices together, and then apply them\nto coordinates in one step. This is not true of all possible\ntransformations.'}, {'text': 'Here is how the ax.transData instance is defined in the basic\nseparable axis Axes class:'}, {'code': 'self.transData = self.transScale + (self.transLimits + self.transAxes)\n'}, {'text': 'We've been introduced to the transAxes instance above in\nAxes coordinates, which maps the (0, 0), (1, 1) corners of the\naxes or subplot bounding box to display space, so let's look at\nthese other two pieces.'}, {'text': 'self.transLimits is the transformation that takes you from\ndata to axes coordinates; i.e., it maps your view xlim and ylim\nto the unit space of the axes (and transAxes then takes that unit\nspace to display space). We can see this in action here'}, {'code': 'In [80]: ax = plt.subplot()\n\nIn [81]: ax.set_xlim(0, 10)\nOut[81]: (0, 10)\n\nIn [82]: ax.set_ylim(-1, 1)\nOut[82]: (-1, 1)\n\nIn [84]: ax.transLimits.transform((0, -1))\nOut[84]: array([ 0.,  0.])\n\nIn [85]: ax.transLimits.transform((10, -1))\nOut[85]: array([ 1.,  0.])\n\nIn [86]: ax.transLimits.transform((10, 1))\nOut[86]: array([ 1.,  1.])\n\nIn [87]: ax.transLimits.transform((5, 0))\nOut[87]: array([ 0.5,  0.5])\n'}, {'text': 'and we can use this same inverted transformation to go from the unit\naxes coordinates back to data coordinates.'}, {'code': 'In [90]: inv.transform((0.25, 0.25))\nOut[90]: array([ 2.5, -0.5])\n'}, {'text': 'The final piece is the self.transScale attribute, which is\nresponsible for the optional non-linear scaling of the data, e.g., for\nlogarithmic axes. When an Axes is initially setup, this is just set to\nthe identity transform, since the basic Matplotlib axes has linear\nscale, but when you call a logarithmic scaling function like\nsemilogx() or explicitly set the scale to\nlogarithmic with set_xscale(), then the\nax.transScale attribute is set to handle the nonlinear projection.\nThe scales transforms are properties of the respective xaxis and\nyaxis Axis instances. For example, when\nyou call ax.set_xscale('log'), the xaxis updates its scale to a\nmatplotlib.scale.LogScale instance.'}, {'text': 'For non-separable axes the PolarAxes, there is one more piece to\nconsider, the projection transformation. The transData\nmatplotlib.projections.polar.PolarAxes is similar to that for\nthe typical separable matplotlib Axes, with one additional piece\ntransProjection:'}, {'code': 'self.transData = (\n    self.transScale + self.transShift + self.transProjection +\n    (self.transProjectionAffine + self.transWedge + self.transAxes))\n'}, {'text': 'transProjection handles the projection from the space,\ne.g., latitude and longitude for map data, or radius and theta for polar\ndata, to a separable Cartesian coordinate system. There are several\nprojection examples in the matplotlib.projections package, and the\nbest way to learn more is to open the source for those packages and\nsee how to make your own, since Matplotlib supports extensible axes\nand projections. Michael Droettboom has provided a nice tutorial\nexample of creating a Hammer projection axes; see\nCustom projection.'}, {'text': 'Total running time of the script: (0 minutes 2.596 seconds)'}, {'text': 'Download Python source code: transforms_tutorial.py'}, {'text': 'Download Jupyter notebook: transforms_tutorial.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 28
},
{
    "raw_page": "{'h1': 'Customizing Matplotlib with style sheets and rcParams'}, {'text': 'Tips for customizing the properties and default styles of Matplotlib.'}, {'text': 'There are three ways to customize Matplotlib:'}, {'text': 'Setting rcParams at runtime.'}, {'text': 'Using style sheets.'}, {'text': 'Changing your matplotlibrc file.'}, {'text': 'Setting rcParams at runtime takes precedence over style sheets, style\nsheets take precedence over matplotlibrc files.'}, {'h2': 'Runtime rc settings'}, {'text': 'You can dynamically change the default rc (runtime configuration)\nsettings in a python script or interactively from the python shell. All\nrc settings are stored in a dictionary-like variable called\nmatplotlib.rcParams, which is global to the matplotlib package.\nSee matplotlib.rcParams for a full list of configurable rcParams.\nrcParams can be modified directly, for example:'}, {'code': 'from cycler import cycler\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\nmpl.rcParams['lines.linewidth'] = 2\nmpl.rcParams['lines.linestyle'] = '--'\ndata = np.random.randn(50)\nplt.plot(data)\n'}, {'text': 'Note, that in order to change the usual plot color you have to\nchange the prop_cycle property of axes:'}, {'code': 'mpl.rcParams['axes.prop_cycle'] = cycler(color=['r g b y'])\nplt.plot(data)  # first color is red\n'}, {'text': 'Matplotlib also provides a couple of convenience functions for modifying rc\nsettings. matplotlib.rc can be used to modify multiple\nsettings in a single group at once, using keyword arguments:'}, {'code': 'mpl.rc('lines', linewidth=4, linestyle='-.')\nplt.plot(data)\n'}, {'h3': 'Temporary rc settings'}, {'text': 'The matplotlib.rcParams object can also be changed temporarily using\nthe matplotlib.rc_context context manager:'}, {'code': 'with mpl.rc_context({'lines.linewidth': 2, 'lines.linestyle': ':'}):\n    plt.plot(data)\n'}, {'text': 'matplotlib.rc_context can also be used as a decorator to modify the\ndefaults within a function:'}, {'code': '@mpl.rc_context({'lines.linewidth': 3, 'lines.linestyle': '-'})\ndef plotting_function():\n    plt.plot(data)\n\nplotting_function()\n'}, {'text': 'matplotlib.rcdefaults will restore the standard Matplotlib\ndefault settings.'}, {'text': 'There is some degree of validation when setting the values of rcParams, see\nmatplotlib.rcsetup for details.'}, {'h2': 'Using style sheets'}, {'text': 'Another way to change the visual appearance of plots is to set the\nrcParams in a so-called style sheet and import that style sheet with\nmatplotlib.style.use. In this way you can switch easily between\ndifferent styles by simply changing the imported style sheet. A style\nsheets looks the same as a matplotlibrc\nfile, but in a style sheet you can only set rcParams that are related\nto the actual style of a plot. Other rcParams, like backend, will be\nignored. matplotlibrc files support all rcParams. The\nrationale behind this is to make style sheets portable between\ndifferent machines without having to worry about dependencies which\nmight or might not be installed on another machine. For a full list of\nrcParams see matplotlib.rcParams. For a list of rcParams that are\nignored in style sheets see matplotlib.style.use.'}, {'text': 'There are a number of pre-defined styles provided by Matplotlib. For\nexample, there's a pre-defined style called 'ggplot', which emulates the\naesthetics of ggplot (a popular plotting package for R). To use this\nstyle, add:'}, {'code': 'plt.style.use('ggplot')\n'}, {'text': 'To list all available styles, use:'}, {'code': 'print(plt.style.available)\n'}, {'code': '['Solarize_Light2 _classic_test_patch _mpl-gallery _mpl-gallery-nogrid bmh classic dark_background fast fivethirtyeight ggplot grayscale seaborn-v0_8 seaborn-v0_8-bright seaborn-v0_8-colorblind seaborn-v0_8-dark seaborn-v0_8-dark-palette seaborn-v0_8-darkgrid seaborn-v0_8-deep seaborn-v0_8-muted seaborn-v0_8-notebook seaborn-v0_8-paper seaborn-v0_8-pastel seaborn-v0_8-poster seaborn-v0_8-talk seaborn-v0_8-ticks seaborn-v0_8-white seaborn-v0_8-whitegrid tableau-colorblind10']\n'}, {'h3': 'Defining your own style'}, {'text': 'You can create custom styles and use them by calling style.use with\nthe path or URL to the style sheet.'}, {'text': 'For example, you might want to create\n./images/presentation.mplstyle with the following:'}, {'code': 'axes.titlesize : 24\naxes.labelsize : 20\nlines.linewidth : 3\nlines.markersize : 10\nxtick.labelsize : 16\nytick.labelsize : 16\n'}, {'text': 'Then, when you want to adapt a plot designed for a paper to one that looks\ngood in a presentation, you can just add:'}, {'code': '>>> import matplotlib.pyplot as plt\n>>> plt.style.use('./images/presentation.mplstyle')\n'}, {'h3': 'Distributing styles'}, {'text': 'You can include style sheets into standard importable Python packages (which\ncan be e.g. distributed on PyPI). If your package is importable as\nimport mypackage, with a mypackage/__init__.py module, and you add\na mypackage/presentation.mplstyle style sheet, then it can be used as\nplt.style.use('mypackage.presentation'). Subpackages (e.g.\ndotted.package.name) are also supported.'}, {'text': 'Alternatively, you can make your style known to Matplotlib by placing\nyour <style-name>.mplstyle file into mpl_configdir/stylelib. You\ncan then load your custom style sheet with a call to\nstyle.use(<style-name>). By default mpl_configdir should be\n~/.config/matplotlib, but you can check where yours is with\nmatplotlib.get_configdir(); you may need to create this directory. You\nalso can change the directory where Matplotlib looks for the stylelib/\nfolder by setting the MPLCONFIGDIR environment variable, see\nmatplotlib configuration and cache directory locations.'}, {'text': 'Note that a custom style sheet in mpl_configdir/stylelib will override a\nstyle sheet defined by Matplotlib if the styles have the same name.'}, {'text': 'Once your <style-name>.mplstyle file is in the appropriate\nmpl_configdir you can specify your style with:'}, {'code': '>>> import matplotlib.pyplot as plt\n>>> plt.style.use(<style-name>)\n'}, {'h3': 'Composing styles'}, {'text': 'Style sheets are designed to be composed together. So you can have a style\nsheet that customizes colors and a separate style sheet that alters element\nsizes for presentations. These styles can easily be combined by passing\na list of styles:'}, {'code': '>>> import matplotlib.pyplot as plt\n>>> plt.style.use(['dark_background presentation'])\n'}, {'text': 'Note that styles further to the right will overwrite values that are already\ndefined by styles on the left.'}, {'h3': 'Temporary styling'}, {'text': 'If you only want to use a style for a specific block of code but don't want\nto change the global styling, the style package provides a context manager\nfor limiting your changes to a specific scope. To isolate your styling\nchanges, you can write something like the following:'}, {'code': 'with plt.style.context('dark_background'):\n    plt.plot(np.sin(np.linspace(0, 2 * np.pi)), 'r-o')\nplt.show()\n'}, {'h2': 'The matplotlibrc file'}, {'text': 'Matplotlib uses matplotlibrc configuration files to customize all\nkinds of properties, which we call 'rc settings' or 'rc parameters'. You can\ncontrol the defaults of almost every property in Matplotlib: figure size and\nDPI, line width, color and style, axes, axis and grid properties, text and\nfont properties and so on. The matplotlibrc is read at startup to\nconfigure Matplotlib. Matplotlib looks for matplotlibrc in four\nlocations, in the following order:'}, {'text': 'matplotlibrc in the current working directory, usually used for\nspecific customizations that you do not want to apply elsewhere.'}, {'text': '$MATPLOTLIBRC if it is a file, else\n$MATPLOTLIBRC/matplotlibrc.'}, {'text': 'It next looks in a user-specific place, depending on your platform:'}, {'text': 'On Linux and FreeBSD, it looks in\n.config/matplotlib/matplotlibrc (or\n$XDG_CONFIG_HOME/matplotlib/matplotlibrc) if you've customized\nyour environment.'}, {'text': 'On other platforms, it looks in .matplotlib/matplotlibrc.'}, {'text': 'See matplotlib configuration and cache directory locations.'}, {'text': 'INSTALL/matplotlib/mpl-data/matplotlibrc, where\nINSTALL is something like\n/usr/lib/python3.9/site-packages on Linux, and maybe\nC:\\\\Python39\\\\Lib\\\\site-packages on Windows. Every time you\ninstall matplotlib, this file will be overwritten, so if you want\nyour customizations to be saved, please move this file to your\nuser-specific matplotlib directory.'}, {'text': 'Once a matplotlibrc file has been found, it will not search\nany of the other paths. When a\nstyle sheet is given with\nstyle.use('<path>/<style-name>.mplstyle'), settings specified in\nthe style sheet take precedence over settings in the\nmatplotlibrc file.'}, {'text': 'To display where the currently active matplotlibrc file was\nloaded from, one can do the following:'}, {'code': '>>> import matplotlib\n>>> matplotlib.matplotlib_fname()\n'/home/foo/.config/matplotlib/matplotlibrc'\n'}, {'text': 'See below for a sample matplotlibrc file\nand see matplotlib.rcParams for a full list of configurable rcParams.'}, {'h3': 'The default matplotlibrc file'}, {'code': '#### MATPLOTLIBRC FORMAT\n\n## NOTE FOR END USERS: DO NOT EDIT THIS FILE!\n##\n## This is a sample Matplotlib configuration file - you can find a copy\n## of it on your system in site-packages/matplotlib/mpl-data/matplotlibrc\n## (relative to your Python installation location).\n## DO NOT EDIT IT!\n##\n## If you wish to change your default style, copy this file to one of the\n## following locations:\n##     Unix/Linux:\n##         $HOME/.config/matplotlib/matplotlibrc OR\n##         $XDG_CONFIG_HOME/matplotlib/matplotlibrc (if $XDG_CONFIG_HOME is set)\n##     Other platforms:\n##         $HOME/.matplotlib/matplotlibrc\n## and edit that copy.\n##\n## See https://matplotlib.org/stable/users/explain/customizing.html#customizing-with-matplotlibrc-files\n## for more details on the paths which are checked for the configuration file.\n##\n## Blank lines, or lines starting with a comment symbol, are ignored, as are\n## trailing comments.  Other lines must have the format:\n##     key: val  # optional comment\n##\n## Formatting: Use PEP8-like style (as enforced in the rest of the codebase).\n## All lines start with an additional '#', so that removing all leading '#'s\n## yields a valid style file.\n##\n## Colors: for the color values below, you can either use\n##     - a Matplotlib color string, such as r, k, or b\n##     - an RGB tuple, such as (1.0, 0.5, 0.0)\n##     - a double-quoted hex string, such as '#ff00ff'.\n##       The unquoted string ff00ff is also supported for backward\n##       compatibility, but is discouraged.\n##     - a scalar grayscale intensity such as 0.75\n##     - a legal html color name, e.g., red, blue, darkslategray\n##\n## String values may optionally be enclosed in double quotes, which allows\n## using the comment character # in the string.\n##\n## This file (and other style files) must be encoded as utf-8.\n##\n## Matplotlib configuration are currently divided into following parts:\n##     - BACKENDS\n##     - LINES\n##     - PATCHES\n##     - HATCHES\n##     - BOXPLOT\n##     - FONT\n##     - TEXT\n##     - LaTeX\n##     - AXES\n##     - DATES\n##     - TICKS\n##     - GRIDS\n##     - LEGEND\n##     - FIGURE\n##     - IMAGES\n##     - CONTOUR PLOTS\n##     - ERRORBAR PLOTS\n##     - HISTOGRAM PLOTS\n##     - SCATTER PLOTS\n##     - AGG RENDERING\n##     - PATHS\n##     - SAVING FIGURES\n##     - INTERACTIVE KEYMAPS\n##     - ANIMATION\n\n##### CONFIGURATION BEGINS HERE\n\n\n## ***************************************************************************\n## * BACKENDS                                                                *\n## ***************************************************************************\n## The default backend.  If you omit this parameter, the first working\n## backend from the following list is used:\n##     MacOSX QtAgg Gtk4Agg Gtk3Agg TkAgg WxAgg Agg\n## Other choices include:\n##     QtCairo GTK4Cairo GTK3Cairo TkCairo WxCairo Cairo\n##     Qt5Agg Qt5Cairo Wx  # deprecated.\n##     PS PDF SVG Template\n## You can also deploy your own backend outside of Matplotlib by referring to\n## the module name (which must be in the PYTHONPATH) as 'module://my_backend'.\n##backend: Agg\n\n## The port to use for the web server in the WebAgg backend.\n#webagg.port: 8988\n\n## The address on which the WebAgg web server should be reachable\n#webagg.address: 127.0.0.1\n\n## If webagg.port is unavailable, a number of other random ports will\n## be tried until one that is available is found.\n#webagg.port_retries: 50\n\n## When True, open the web browser to the plot that is shown\n#webagg.open_in_browser: True\n\n## If you are running pyplot inside a GUI and your backend choice\n## conflicts, we will automatically try to find a compatible one for\n## you if backend_fallback is True\n#backend_fallback: True\n\n#interactive: False\n#figure.hooks:          # list of dotted.module.name:dotted.callable.name\n#toolbar:     toolbar2  # {None, toolbar2, toolmanager}\n#timezone:    UTC       # a pytz timezone string, e.g., US/Central or Europe/Paris\n\n\n## ***************************************************************************\n## * LINES                                                                   *\n## ***************************************************************************\n## See https://matplotlib.org/stable/api/artist_api.html#module-matplotlib.lines\n## for more information on line properties.\n#lines.linewidth: 1.5               # line width in points\n#lines.linestyle: -                 # solid line\n#lines.color:     C0                # has no affect on plot(); see axes.prop_cycle\n#lines.marker:          None        # the default marker\n#lines.markerfacecolor: auto        # the default marker face color\n#lines.markeredgecolor: auto        # the default marker edge color\n#lines.markeredgewidth: 1.0         # the line width around the marker symbol\n#lines.markersize:      6           # marker size, in points\n#lines.dash_joinstyle:  round       # {miter, round, bevel}\n#lines.dash_capstyle:   butt        # {butt, round, projecting}\n#lines.solid_joinstyle: round       # {miter, round, bevel}\n#lines.solid_capstyle:  projecting  # {butt, round, projecting}\n#lines.antialiased: True            # render lines in antialiased (no jaggies)\n\n## The three standard dash patterns.  These are scaled by the linewidth.\n#lines.dashed_pattern: 3.7, 1.6\n#lines.dashdot_pattern: 6.4, 1.6, 1, 1.6\n#lines.dotted_pattern: 1, 1.65\n#lines.scale_dashes: True\n\n#markers.fillstyle: full  # {full, left, right, bottom, top, none}\n\n#pcolor.shading: auto\n#pcolormesh.snap: True  # Whether to snap the mesh to pixel boundaries. This is\n                        # provided solely to allow old test images to remain\n                        # unchanged. Set to False to obtain the previous behavior.\n\n## ***************************************************************************\n## * PATCHES                                                                 *\n## ***************************************************************************\n## Patches are graphical objects that fill 2D space, like polygons or circles.\n## See https://matplotlib.org/stable/api/artist_api.html#module-matplotlib.patches\n## for more information on patch properties.\n#patch.linewidth:       1.0    # edge width in points.\n#patch.facecolor:       C0\n#patch.edgecolor:       black  # if forced, or patch is not filled\n#patch.force_edgecolor: False  # True to always use edgecolor\n#patch.antialiased:     True   # render patches in antialiased (no jaggies)\n\n\n## ***************************************************************************\n## * HATCHES                                                                 *\n## ***************************************************************************\n#hatch.color:     black\n#hatch.linewidth: 1.0\n\n\n## ***************************************************************************\n## * BOXPLOT                                                                 *\n## ***************************************************************************\n#boxplot.notch:       False\n#boxplot.vertical:    True\n#boxplot.whiskers:    1.5\n#boxplot.bootstrap:   None\n#boxplot.patchartist: False\n#boxplot.showmeans:   False\n#boxplot.showcaps:    True\n#boxplot.showbox:     True\n#boxplot.showfliers:  True\n#boxplot.meanline:    False\n\n#boxplot.flierprops.color:           black\n#boxplot.flierprops.marker:          o\n#boxplot.flierprops.markerfacecolor: none\n#boxplot.flierprops.markeredgecolor: black\n#boxplot.flierprops.markeredgewidth: 1.0\n#boxplot.flierprops.markersize:      6\n#boxplot.flierprops.linestyle:       none\n#boxplot.flierprops.linewidth:       1.0\n\n#boxplot.boxprops.color:     black\n#boxplot.boxprops.linewidth: 1.0\n#boxplot.boxprops.linestyle: -\n\n#boxplot.whiskerprops.color:     black\n#boxplot.whiskerprops.linewidth: 1.0\n#boxplot.whiskerprops.linestyle: -\n\n#boxplot.capprops.color:     black\n#boxplot.capprops.linewidth: 1.0\n#boxplot.capprops.linestyle: -\n\n#boxplot.medianprops.color:     C1\n#boxplot.medianprops.linewidth: 1.0\n#boxplot.medianprops.linestyle: -\n\n#boxplot.meanprops.color:           C2\n#boxplot.meanprops.marker:          ^\n#boxplot.meanprops.markerfacecolor: C2\n#boxplot.meanprops.markeredgecolor: C2\n#boxplot.meanprops.markersize:       6\n#boxplot.meanprops.linestyle:       --\n#boxplot.meanprops.linewidth:       1.0\n\n\n## ***************************************************************************\n## * FONT                                                                    *\n## ***************************************************************************\n## The font properties used by `text.Text`.\n## See https://matplotlib.org/stable/api/font_manager_api.html for more information\n## on font properties.  The 6 font properties used for font matching are\n## given below with their default values.\n##\n## The font.family property can take either a single or multiple entries of any\n## combination of concrete font names (not supported when rendering text with\n## usetex) or the following five generic values:\n##     - 'serif' (e.g., Times),\n##     - 'sans-serif' (e.g., Helvetica),\n##     - 'cursive' (e.g., Zapf-Chancery),\n##     - 'fantasy' (e.g., Western), and\n##     - 'monospace' (e.g., Courier).\n## Each of these values has a corresponding default list of font names\n## (font.serif, etc.); the first available font in the list is used.  Note that\n## for font.serif, font.sans-serif, and font.monospace, the first element of\n## the list (a DejaVu font) will always be used because DejaVu is shipped with\n## Matplotlib and is thus guaranteed to be available; the other entries are\n## left as examples of other possible values.\n##\n## The font.style property has three values: normal (or roman), italic\n## or oblique.  The oblique style will be used for italic, if it is not\n## present.\n##\n## The font.variant property has two values: normal or small-caps.  For\n## TrueType fonts, which are scalable fonts, small-caps is equivalent\n## to using a font size of 'smaller', or about 83 % of the current font\n## size.\n##\n## The font.weight property has effectively 13 values: normal, bold,\n## bolder, lighter, 100, 200, 300, ..., 900.  Normal is the same as\n## 400, and bold is 700.  bolder and lighter are relative values with\n## respect to the current weight.\n##\n## The font.stretch property has 11 values: ultra-condensed,\n## extra-condensed, condensed, semi-condensed, normal, semi-expanded,\n## expanded, extra-expanded, ultra-expanded, wider, and narrower.  This\n## property is not currently implemented.\n##\n## The font.size property is the default font size for text, given in points.\n## 10 pt is the standard value.\n##\n## Note that font.size controls default text sizes.  To configure\n## special text sizes tick labels, axes, labels, title, etc., see the rc\n## settings for axes and ticks.  Special text sizes can be defined\n## relative to font.size, using the following values: xx-small, x-small,\n## small, medium, large, x-large, xx-large, larger, or smaller\n\n#font.family:  sans-serif\n#font.style:   normal\n#font.variant: normal\n#font.weight:  normal\n#font.stretch: normal\n#font.size:    10.0\n\n#font.serif:      DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif\n#font.sans-serif: DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif\n#font.cursive:    Apple Chancery, Textile, Zapf Chancery, Sand, Script MT, Felipa, Comic Neue, Comic Sans MS, cursive\n#font.fantasy:    Chicago, Charcoal, Impact, Western, Humor Sans, xkcd, fantasy\n#font.monospace:  DejaVu Sans Mono, Bitstream Vera Sans Mono, Computer Modern Typewriter, Andale Mono, Nimbus Mono L, Courier New, Courier, Fixed, Terminal, monospace\n\n\n## ***************************************************************************\n## * TEXT                                                                    *\n## ***************************************************************************\n## The text properties used by `text.Text`.\n## See https://matplotlib.org/stable/api/artist_api.html#module-matplotlib.text\n## for more information on text properties\n#text.color: black\n\n## FreeType hinting flag ('foo' corresponds to FT_LOAD_FOO); may be one of the\n## following (Proprietary Matplotlib-specific synonyms are given in parentheses,\n## but their use is discouraged):\n## - default: Use the font's native hinter if possible, else FreeType's auto-hinter.\n##            ('either' is a synonym).\n## - no_autohint: Use the font's native hinter if possible, else don't hint.\n##                ('native' is a synonym.)\n## - force_autohint: Use FreeType's auto-hinter.  ('auto' is a synonym.)\n## - no_hinting: Disable hinting.  ('none' is a synonym.)\n#text.hinting: force_autohint\n\n#text.hinting_factor: 8  # Specifies the amount of softness for hinting in the\n                         # horizontal direction.  A value of 1 will hint to full\n                         # pixels.  A value of 2 will hint to half pixels etc.\n#text.kerning_factor: 0  # Specifies the scaling factor for kerning values.  This\n                         # is provided solely to allow old test images to remain\n                         # unchanged.  Set to 6 to obtain previous behavior.\n                         # Values  other than 0 or 6 have no defined meaning.\n#text.antialiased: True  # If True (default), the text will be antialiased.\n                         # This only affects raster outputs.\n#text.parse_math: True  # Use mathtext if there is an even number of unescaped\n                        # dollar signs.\n\n\n## ***************************************************************************\n## * LaTeX                                                                   *\n## ***************************************************************************\n## For more information on LaTeX properties, see\n## https://matplotlib.org/stable/users/explain/text/usetex.html\n#text.usetex: False  # use latex for all text handling. The following fonts\n                     # are supported through the usual rc parameter settings:\n                     # new century schoolbook, bookman, times, palatino,\n                     # zapf chancery, charter, serif, sans-serif, helvetica,\n                     # avant garde, courier, monospace, computer modern roman,\n                     # computer modern sans serif, computer modern typewriter\n#text.latex.preamble:   # IMPROPER USE OF THIS FEATURE WILL LEAD TO LATEX FAILURES\n                        # AND IS THEREFORE UNSUPPORTED. PLEASE DO NOT ASK FOR HELP\n                        # IF THIS FEATURE DOES NOT DO WHAT YOU EXPECT IT TO.\n                        # text.latex.preamble is a single line of LaTeX code that\n                        # will be passed on to the LaTeX system. It may contain\n                        # any code that is valid for the LaTeX 'preamble', i.e.\n                        # between the '\\\\documentclass' and '\\\\begin{document}'\n                        # statements.\n                        # Note that it has to be put on a single line, which may\n                        # become quite long.\n                        # The following packages are always loaded with usetex,\n                        # so beware of package collisions:\n                        #   geometry, inputenc, type1cm.\n                        # PostScript (PSNFSS) font packages may also be\n                        # loaded, depending on your font settings.\n\n## The following settings allow you to select the fonts in math mode.\n#mathtext.fontset: dejavusans  # Should be 'dejavusans' (default),\n                               # 'dejavuserif', 'cm' (Computer Modern), 'stix',\n                               # 'stixsans' or 'custom'\n## 'mathtext.fontset: custom' is defined by the mathtext.bf, .cal, .it, ...\n## settings which map a TeX font name to a fontconfig font pattern.  (These\n## settings are not used for other font sets.)\n#mathtext.bf:  sans:bold\n#mathtext.bfit: sans:italic:bold\n#mathtext.cal: cursive\n#mathtext.it:  sans:italic\n#mathtext.rm:  sans\n#mathtext.sf:  sans\n#mathtext.tt:  monospace\n#mathtext.fallback: cm  # Select fallback font from ['cm' (Computer Modern), 'stix'\n                        # 'stixsans'] when a symbol cannot be found in one of the\n                        # custom math fonts. Select 'None' to not perform fallback\n                        # and replace the missing character by a dummy symbol.\n#mathtext.default: it  # The default font to use for math.\n                       # Can be any of the LaTeX font names, including\n                       # the special name 'regular' for the same font\n                       # used in regular text.\n\n\n## ***************************************************************************\n## * AXES                                                                    *\n## ***************************************************************************\n## Following are default face and edge colors, default tick sizes,\n## default font sizes for tick labels, and so on.  See\n## https://matplotlib.org/stable/api/axes_api.html#module-matplotlib.axes\n#axes.facecolor:     white   # axes background color\n#axes.edgecolor:     black   # axes edge color\n#axes.linewidth:     0.8     # edge line width\n#axes.grid:          False   # display grid or not\n#axes.grid.axis:     both    # which axis the grid should apply to\n#axes.grid.which:    major   # grid lines at {major, minor, both} ticks\n#axes.titlelocation: center  # alignment of the title: {left, right, center}\n#axes.titlesize:     large   # font size of the axes title\n#axes.titleweight:   normal  # font weight of title\n#axes.titlecolor:    auto    # color of the axes title, auto falls back to\n                             # text.color as default value\n#axes.titley:        None    # position title (axes relative units).  None implies auto\n#axes.titlepad:      6.0     # pad between axes and title in points\n#axes.labelsize:     medium  # font size of the x and y labels\n#axes.labelpad:      4.0     # space between label and axis\n#axes.labelweight:   normal  # weight of the x and y labels\n#axes.labelcolor:    black\n#axes.axisbelow:     line    # draw axis gridlines and ticks:\n                             #     - below patches (True)\n                             #     - above patches but below lines ('line')\n                             #     - above all (False)\n\n#axes.formatter.limits: -5, 6  # use scientific notation if log10\n                               # of the axis range is smaller than the\n                               # first or larger than the second\n#axes.formatter.use_locale: False  # When True, format tick labels\n                                   # according to the user's locale.\n                                   # For example, use ',' as a decimal\n                                   # separator in the fr_FR locale.\n#axes.formatter.use_mathtext: False  # When True, use mathtext for scientific\n                                     # notation.\n#axes.formatter.min_exponent: 0  # minimum exponent to format in scientific notation\n#axes.formatter.useoffset: True  # If True, the tick label formatter\n                                 # will default to labeling ticks relative\n                                 # to an offset when the data range is\n                                 # small compared to the minimum absolute\n                                 # value of the data.\n#axes.formatter.offset_threshold: 4  # When useoffset is True, the offset\n                                     # will be used when it can remove\n                                     # at least this number of significant\n                                     # digits from tick labels.\n\n#axes.spines.left:   True  # display axis spines\n#axes.spines.bottom: True\n#axes.spines.top:    True\n#axes.spines.right:  True\n\n#axes.unicode_minus: True  # use Unicode for the minus symbol rather than hyphen.  See\n                           # https://en.wikipedia.org/wiki/Plus_and_minus_signs#Character_codes\n#axes.prop_cycle: cycler('color', ['1f77b4', 'ff7f0e', '2ca02c', 'd62728', '9467bd', '8c564b', 'e377c2', '7f7f7f', 'bcbd22', '17becf'])\n                  # color cycle for plot lines as list of string color specs:\n                  # single letter, long name, or web-style hex\n                  # As opposed to all other parameters in this file, the color\n                  # values must be enclosed in quotes for this parameter,\n                  # e.g. '1f77b4', instead of 1f77b4.\n                  # See also https://matplotlib.org/stable/users/explain/artists/color_cycle.html\n                  # for more details on prop_cycle usage.\n#axes.xmargin:   .05  # x margin.  See `axes.Axes.margins`\n#axes.ymargin:   .05  # y margin.  See `axes.Axes.margins`\n#axes.zmargin:   .05  # z margin.  See `axes.Axes.margins`\n#axes.autolimit_mode: data  # If 'data', use axes.xmargin and axes.ymargin as is.\n                            # If 'round_numbers', after application of margins, axis\n                            # limits are further expanded to the nearest 'round' number.\n#polaraxes.grid: True  # display grid on polar axes\n#axes3d.grid:    True  # display grid on 3D axes\n\n#axes3d.xaxis.panecolor:    (0.95, 0.95, 0.95, 0.5)  # background pane on 3D axes\n#axes3d.yaxis.panecolor:    (0.90, 0.90, 0.90, 0.5)  # background pane on 3D axes\n#axes3d.zaxis.panecolor:    (0.925, 0.925, 0.925, 0.5)  # background pane on 3D axes\n\n## ***************************************************************************\n## * AXIS                                                                    *\n## ***************************************************************************\n#xaxis.labellocation: center  # alignment of the xaxis label: {left, right, center}\n#yaxis.labellocation: center  # alignment of the yaxis label: {bottom, top, center}\n\n\n## ***************************************************************************\n## * DATES                                                                   *\n## ***************************************************************************\n## These control the default format strings used in AutoDateFormatter.\n## Any valid format datetime format string can be used (see the python\n## `datetime` for details).  For example, by using:\n##     - '%x' will use the locale date representation\n##     - '%X' will use the locale time representation\n##     - '%c' will use the full locale datetime representation\n## These values map to the scales:\n##     {'year': 365, 'month': 30, 'day': 1, 'hour': 1/24, 'minute': 1 / (24 * 60)}\n\n#date.autoformatter.year:        %Y\n#date.autoformatter.month:       %Y-%m\n#date.autoformatter.day:         %Y-%m-%d\n#date.autoformatter.hour:        %m-%d %H\n#date.autoformatter.minute:      %d %H:%M\n#date.autoformatter.second:      %H:%M:%S\n#date.autoformatter.microsecond: %M:%S.%f\n## The reference date for Matplotlib's internal date representation\n## See https://matplotlib.org/stable/gallery/ticks/date_precision_and_epochs.html\n#date.epoch: 1970-01-01T00:00:00\n## 'auto', 'concise':\n#date.converter:                  auto\n## For auto converter whether to use interval_multiples:\n#date.interval_multiples:         True\n\n## ***************************************************************************\n## * TICKS                                                                   *\n## ***************************************************************************\n## See https://matplotlib.org/stable/api/axis_api.html#matplotlib.axis.Tick\n#xtick.top:           False   # draw ticks on the top side\n#xtick.bottom:        True    # draw ticks on the bottom side\n#xtick.labeltop:      False   # draw label on the top\n#xtick.labelbottom:   True    # draw label on the bottom\n#xtick.major.size:    3.5     # major tick size in points\n#xtick.minor.size:    2       # minor tick size in points\n#xtick.major.width:   0.8     # major tick width in points\n#xtick.minor.width:   0.6     # minor tick width in points\n#xtick.major.pad:     3.5     # distance to major tick label in points\n#xtick.minor.pad:     3.4     # distance to the minor tick label in points\n#xtick.color:         black   # color of the ticks\n#xtick.labelcolor:    inherit # color of the tick labels or inherit from xtick.color\n#xtick.labelsize:     medium  # font size of the tick labels\n#xtick.direction:     out     # direction: {in, out, inout}\n#xtick.minor.visible: False   # visibility of minor ticks on x-axis\n#xtick.major.top:     True    # draw x axis top major ticks\n#xtick.major.bottom:  True    # draw x axis bottom major ticks\n#xtick.minor.top:     True    # draw x axis top minor ticks\n#xtick.minor.bottom:  True    # draw x axis bottom minor ticks\n#xtick.minor.ndivs:   auto    # number of minor ticks between the major ticks on x-axis\n#xtick.alignment:     center  # alignment of xticks\n\n#ytick.left:          True    # draw ticks on the left side\n#ytick.right:         False   # draw ticks on the right side\n#ytick.labelleft:     True    # draw tick labels on the left side\n#ytick.labelright:    False   # draw tick labels on the right side\n#ytick.major.size:    3.5     # major tick size in points\n#ytick.minor.size:    2       # minor tick size in points\n#ytick.major.width:   0.8     # major tick width in points\n#ytick.minor.width:   0.6     # minor tick width in points\n#ytick.major.pad:     3.5     # distance to major tick label in points\n#ytick.minor.pad:     3.4     # distance to the minor tick label in points\n#ytick.color:         black   # color of the ticks\n#ytick.labelcolor:    inherit # color of the tick labels or inherit from ytick.color\n#ytick.labelsize:     medium  # font size of the tick labels\n#ytick.direction:     out     # direction: {in, out, inout}\n#ytick.minor.visible: False   # visibility of minor ticks on y-axis\n#ytick.major.left:    True    # draw y axis left major ticks\n#ytick.major.right:   True    # draw y axis right major ticks\n#ytick.minor.left:    True    # draw y axis left minor ticks\n#ytick.minor.right:   True    # draw y axis right minor ticks\n#ytick.minor.ndivs:   auto    # number of minor ticks between the major ticks on y-axis\n#ytick.alignment:     center_baseline  # alignment of yticks\n\n\n## ***************************************************************************\n## * GRIDS                                                                   *\n## ***************************************************************************\n#grid.color:     '#b0b0b0'  # grid color\n#grid.linestyle: -          # solid\n#grid.linewidth: 0.8        # in points\n#grid.alpha:     1.0        # transparency, between 0.0 and 1.0\n\n\n## ***************************************************************************\n## * LEGEND                                                                  *\n## ***************************************************************************\n#legend.loc:           best\n#legend.frameon:       True     # if True, draw the legend on a background patch\n#legend.framealpha:    0.8      # legend patch transparency\n#legend.facecolor:     inherit  # inherit from axes.facecolor; or color spec\n#legend.edgecolor:     0.8      # background patch boundary color\n#legend.fancybox:      True     # if True, use a rounded box for the\n                                # legend background, else a rectangle\n#legend.shadow:        False    # if True, give background a shadow effect\n#legend.numpoints:     1        # the number of marker points in the legend line\n#legend.scatterpoints: 1        # number of scatter points\n#legend.markerscale:   1.0      # the relative size of legend markers vs. original\n#legend.fontsize:      medium\n#legend.labelcolor:    None\n#legend.title_fontsize: None    # None sets to the same as the default axes.\n\n## Dimensions as fraction of font size:\n#legend.borderpad:     0.4  # border whitespace\n#legend.labelspacing:  0.5  # the vertical space between the legend entries\n#legend.handlelength:  2.0  # the length of the legend lines\n#legend.handleheight:  0.7  # the height of the legend handle\n#legend.handletextpad: 0.8  # the space between the legend line and legend text\n#legend.borderaxespad: 0.5  # the border between the axes and legend edge\n#legend.columnspacing: 2.0  # column separation\n\n\n## ***************************************************************************\n## * FIGURE                                                                  *\n## ***************************************************************************\n## See https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure\n#figure.titlesize:   large     # size of the figure title (``Figure.suptitle()``)\n#figure.titleweight: normal    # weight of the figure title\n#figure.labelsize:   large     # size of the figure label (``Figure.sup[x|y]label()``)\n#figure.labelweight: normal    # weight of the figure label\n#figure.figsize:     6.4, 4.8  # figure size in inches\n#figure.dpi:         100       # figure dots per inch\n#figure.facecolor:   white     # figure face color\n#figure.edgecolor:   white     # figure edge color\n#figure.frameon:     True      # enable figure frame\n#figure.max_open_warning: 20   # The maximum number of figures to open through\n                               # the pyplot interface before emitting a warning.\n                               # If less than one this feature is disabled.\n#figure.raise_window : True    # Raise the GUI window to front when show() is called.\n\n## The figure subplot parameters.  All dimensions are a fraction of the figure width and height.\n#figure.subplot.left:   0.125  # the left side of the subplots of the figure\n#figure.subplot.right:  0.9    # the right side of the subplots of the figure\n#figure.subplot.bottom: 0.11   # the bottom of the subplots of the figure\n#figure.subplot.top:    0.88   # the top of the subplots of the figure\n#figure.subplot.wspace: 0.2    # the amount of width reserved for space between subplots,\n                               # expressed as a fraction of the average axis width\n#figure.subplot.hspace: 0.2    # the amount of height reserved for space between subplots,\n                               # expressed as a fraction of the average axis height\n\n## Figure layout\n#figure.autolayout: False  # When True, automatically adjust subplot\n                           # parameters to make the plot fit the figure\n                           # using `tight_layout`\n#figure.constrained_layout.use: False  # When True, automatically make plot\n                                       # elements fit on the figure. (Not\n                                       # compatible with `autolayout`, above).\n## Padding (in inches) around axes; defaults to 3/72 inches, i.e. 3 points.\n#figure.constrained_layout.h_pad:  0.04167\n#figure.constrained_layout.w_pad:  0.04167\n## Spacing between subplots, relative to the subplot sizes.  Much smaller than for\n## tight_layout (figure.subplot.hspace, figure.subplot.wspace) as constrained_layout\n## already takes surrounding texts (titles, labels, # ticklabels) into account.\n#figure.constrained_layout.hspace: 0.02\n#figure.constrained_layout.wspace: 0.02\n\n\n## ***************************************************************************\n## * IMAGES                                                                  *\n## ***************************************************************************\n#image.aspect:          equal        # {equal, auto} or a number\n#image.interpolation:   antialiased  # see help(imshow) for options\n#image.cmap:            viridis      # A colormap name (plasma, magma, etc.)\n#image.lut:             256          # the size of the colormap lookup table\n#image.origin:          upper        # {lower, upper}\n#image.resample:        True\n#image.composite_image: True  # When True, all the images on a set of axes are\n                              # combined into a single composite image before\n                              # saving a figure as a vector graphics file,\n                              # such as a PDF.\n\n\n## ***************************************************************************\n## * CONTOUR PLOTS                                                           *\n## ***************************************************************************\n#contour.negative_linestyle: dashed  # string or on-off ink sequence\n#contour.corner_mask:        True    # {True, False}\n#contour.linewidth:          None    # {float, None} Size of the contour line\n                                     # widths. If set to None, it falls back to\n                                     # `line.linewidth`.\n#contour.algorithm:          mpl2014 # {mpl2005, mpl2014, serial, threaded}\n\n\n## ***************************************************************************\n## * ERRORBAR PLOTS                                                          *\n## ***************************************************************************\n#errorbar.capsize: 0  # length of end cap on error bars in pixels\n\n\n## ***************************************************************************\n## * HISTOGRAM PLOTS                                                         *\n## ***************************************************************************\n#hist.bins: 10  # The default number of histogram bins or 'auto'.\n\n\n## ***************************************************************************\n## * SCATTER PLOTS                                                           *\n## ***************************************************************************\n#scatter.marker: o         # The default marker type for scatter plots.\n#scatter.edgecolors: face  # The default edge colors for scatter plots.\n\n\n## ***************************************************************************\n## * AGG RENDERING                                                           *\n## ***************************************************************************\n## Warning: experimental, 2008/10/10\n#agg.path.chunksize: 0  # 0 to disable; values in the range\n                        # 10000 to 100000 can improve speed slightly\n                        # and prevent an Agg rendering failure\n                        # when plotting very large data sets,\n                        # especially if they are very gappy.\n                        # It may cause minor artifacts, though.\n                        # A value of 20000 is probably a good\n                        # starting point.\n\n\n## ***************************************************************************\n## * PATHS                                                                   *\n## ***************************************************************************\n#path.simplify: True  # When True, simplify paths by removing 'invisible'\n                      # points to reduce file size and increase rendering\n                      # speed\n#path.simplify_threshold: 0.111111111111  # The threshold of similarity below\n                                          # which vertices will be removed in\n                                          # the simplification process.\n#path.snap: True  # When True, rectilinear axis-aligned paths will be snapped\n                  # to the nearest pixel when certain criteria are met.\n                  # When False, paths will never be snapped.\n#path.sketch: None  # May be None, or a 3-tuple of the form:\n                    # (scale, length, randomness).\n                    #     - *scale* is the amplitude of the wiggle\n                    #         perpendicular to the line (in pixels).\n                    #     - *length* is the length of the wiggle along the\n                    #         line (in pixels).\n                    #     - *randomness* is the factor by which the length is\n                    #         randomly scaled.\n#path.effects:\n\n\n## ***************************************************************************\n## * SAVING FIGURES                                                          *\n## ***************************************************************************\n## The default savefig parameters can be different from the display parameters\n## e.g., you may want a higher resolution, or to make the figure\n## background white\n#savefig.dpi:       figure      # figure dots per inch or 'figure'\n#savefig.facecolor: auto        # figure face color when saving\n#savefig.edgecolor: auto        # figure edge color when saving\n#savefig.format:    png         # {png, ps, pdf, svg}\n#savefig.bbox:      standard    # {tight, standard}\n                                # 'tight' is incompatible with generating frames\n                                # for animation\n#savefig.pad_inches:  0.1       # padding to be used, when bbox is set to 'tight'\n#savefig.directory:   ~         # default directory in savefig dialog, gets updated after\n                                # interactive saves, unless set to the empty string (i.e.\n                                # the current directory); use '.' to start at the current\n                                # directory but update after interactive saves\n#savefig.transparent: False     # whether figures are saved with a transparent\n                                # background by default\n#savefig.orientation: portrait  # orientation of saved figure, for PostScript output only\n\n### macosx backend params\n#macosx.window_mode : system   # How to open new figures (system, tab, window)\n                               # system uses the MacOS system preferences\n\n### tk backend params\n#tk.window_focus:   False  # Maintain shell focus for TkAgg\n\n### ps backend params\n#ps.papersize:      letter  # {figure, letter, legal, ledger, A0-A10, B0-B10}\n#ps.useafm:         False   # use AFM fonts, results in small files\n#ps.usedistiller:   False   # {ghostscript, xpdf, None}\n                            # Experimental: may produce smaller files.\n                            # xpdf intended for production of publication quality files,\n                            # but requires ghostscript, xpdf and ps2eps\n#ps.distiller.res:  6000    # dpi\n#ps.fonttype:       3       # Output Type 3 (Type3) or Type 42 (TrueType)\n\n### PDF backend params\n#pdf.compression:    6  # integer from 0 to 9\n                        # 0 disables compression (good for debugging)\n#pdf.fonttype:       3  # Output Type 3 (Type3) or Type 42 (TrueType)\n#pdf.use14corefonts: False\n#pdf.inheritcolor:   False\n\n### SVG backend params\n#svg.image_inline: True  # Write raster image data directly into the SVG file\n#svg.fonttype: path      # How to handle SVG fonts:\n                         #     path: Embed characters as paths -- supported\n                         #           by most SVG renderers\n                         #     None: Assume fonts are installed on the\n                         #           machine where the SVG will be viewed.\n#svg.hashsalt: None      # If not None, use this string as hash salt instead of uuid4\n\n### pgf parameter\n## See https://matplotlib.org/stable/tutorials/text/pgf.html for more information.\n#pgf.rcfonts: True\n#pgf.preamble:  # See text.latex.preamble for documentation\n#pgf.texsystem: xelatex\n\n### docstring params\n#docstring.hardcopy: False  # set this when you want to generate hardcopy docstring\n\n\n## ***************************************************************************\n## * INTERACTIVE KEYMAPS                                                     *\n## ***************************************************************************\n## Event keys to interact with figures/plots via keyboard.\n## See https://matplotlib.org/stable/users/explain/interactive.html for more\n## details on interactive navigation.  Customize these settings according to\n## your needs. Leave the field(s) empty if you don't need a key-map. (i.e.,\n## fullscreen : '')\n#keymap.fullscreen: f, ctrl+f   # toggling\n#keymap.home: h, r, home        # home or reset mnemonic\n#keymap.back: left, c, backspace, MouseButton.BACK  # forward / backward keys\n#keymap.forward: right, v, MouseButton.FORWARD      # for quick navigation\n#keymap.pan: p                  # pan mnemonic\n#keymap.zoom: o                 # zoom mnemonic\n#keymap.save: s, ctrl+s         # saving current figure\n#keymap.help: f1                # display help about active tools\n#keymap.quit: ctrl+w, cmd+w, q  # close the current figure\n#keymap.quit_all:               # close all figures\n#keymap.grid: g                 # switching on/off major grids in current axes\n#keymap.grid_minor: G           # switching on/off minor grids in current axes\n#keymap.yscale: l               # toggle scaling of y-axes ('log'/'linear')\n#keymap.xscale: k, L            # toggle scaling of x-axes ('log'/'linear')\n#keymap.copy: ctrl+c, cmd+c     # copy figure to clipboard\n\n\n## ***************************************************************************\n## * ANIMATION                                                               *\n## ***************************************************************************\n#animation.html: none  # How to display the animation as HTML in\n                       # the IPython notebook:\n                       #     - 'html5' uses HTML5 video tag\n                       #     - 'jshtml' creates a JavaScript animation\n#animation.writer:  ffmpeg        # MovieWriter 'backend' to use\n#animation.codec:   h264          # Codec to use for writing movie\n#animation.bitrate: -1            # Controls size/quality trade-off for movie.\n                                  # -1 implies let utility auto-determine\n#animation.frame_format: png      # Controls frame format used by temp files\n\n## Path to ffmpeg binary.  Unqualified paths are resolved by subprocess.Popen.\n#animation.ffmpeg_path:  ffmpeg\n## Additional arguments to pass to ffmpeg.\n#animation.ffmpeg_args:\n\n## Path to ImageMagick's convert binary.  Unqualified paths are resolved by\n## subprocess.Popen, except that on Windows, we look up an install of\n## ImageMagick in the registry (as convert is also the name of a system tool).\n#animation.convert_path: convert\n## Additional arguments to pass to convert.\n#animation.convert_args: -layers, OptimizePlus\n#\n#animation.embed_limit:  20.0     # Limit, in MB, of size of base64 encoded\n                                  # animation in HTML (i.e. IPython notebook)\n'}, {'text': 'Total running time of the script: (0 minutes 2.072 seconds)'}, {'text': 'Download Python source code: customizing.py'}, {'text': 'Download Jupyter notebook: customizing.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 29
},
{
    "raw_page": "{'h1': 'Colors'}, {'text': 'Matplotlib has support for visualizing information with a wide array\nof colors and colormaps. These tutorials cover the basics of how\nthese colormaps look, how you can create your own, and how you can\ncustomize colormaps for your use case.'}, {'text': 'For even more information see the examples page.'}, {'text': 'Specifying colors'}, {'text': 'Customized Colorbars Tutorial'}, {'text': 'Creating Colormaps in Matplotlib'}, {'text': 'Colormap Normalization'}, {'text': 'Choosing Colormaps in Matplotlib'}",
    "id": 30
},
{
    "raw_page": "{'h1': 'Specifying colors'}, {'h2': 'Color formats'}, {'text': 'Matplotlib recognizes the following formats to specify a color.'}, {'text': 'Format'}, {'text': 'Example'}, {'text': 'RGB or RGBA (red, green, blue, alpha)\ntuple of float values in a closed\ninterval [0, 1].'}, {'text': '(0.1, 0.2, 0.5)'}, {'text': '(0.1, 0.2, 0.5, 0.3)'}, {'text': 'Case-insensitive hex RGB or RGBA\nstring.'}, {'text': ''#0f0f0f''}, {'text': ''#0f0f0f80''}, {'text': 'Case-insensitive RGB or RGBA string\nequivalent hex shorthand of\nduplicated characters.'}, {'text': ''#abc' as '#aabbcc''}, {'text': ''#fb1' as '#ffbb11''}, {'text': 'String representation of float value\nin closed interval [0, 1] for\ngrayscale values.'}, {'text': ''0' as black'}, {'text': ''1' as white'}, {'text': ''0.8' as light gray'}, {'text': 'Single character shorthand notation\nfor some basic colors.'}, {'text': 'Note'}, {'text': 'The colors green, cyan, magenta,\nand yellow do not coincide with\nX11/CSS4 colors. Their particular\nshades were chosen for better\nvisibility of colored lines\nagainst typical backgrounds.'}, {'text': ''b' as blue'}, {'text': ''g' as green'}, {'text': ''r' as red'}, {'text': ''c' as cyan'}, {'text': ''m' as magenta'}, {'text': ''y' as yellow'}, {'text': ''k' as black'}, {'text': ''w' as white'}, {'text': 'Case-insensitive X11/CSS4 color name\nwith no spaces.'}, {'text': ''aquamarine''}, {'text': ''mediumseagreen''}, {'text': 'Case-insensitive color name from\nxkcd color survey with 'xkcd:'\nprefix.'}, {'text': ''xkcd:sky blue''}, {'text': ''xkcd:eggshell''}, {'text': 'Case-insensitive Tableau Colors from\n'T10' categorical palette.'}, {'text': 'Note'}, {'text': 'This is the default color\ncycle.'}, {'text': ''tab:blue''}, {'text': ''tab:orange''}, {'text': ''tab:green''}, {'text': ''tab:red''}, {'text': ''tab:purple''}, {'text': ''tab:brown''}, {'text': ''tab:pink''}, {'text': ''tab:gray''}, {'text': ''tab:olive''}, {'text': ''tab:cyan''}, {'text': ''CN' color spec where 'C'\nprecedes a number acting as an index\ninto the default property cycle.'}, {'text': 'Note'}, {'text': 'Matplotlib indexes color\nat draw time and defaults\nto black if cycle does not\ninclude color.'}, {'text': ''C0''}, {'text': ''C1''}, {'text': 'rcParamsaxes.prop_cycle (default: cycler('color', ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']))'}, {'text': 'Tuple of one of the above color\nformats and an alpha float.'}, {'text': 'New in version 3.8.'}, {'text': '('green', 0.3)'}, {'text': '('#f00', 0.9)'}, {'text': 'See also'}, {'text': 'Color Demo Example'}, {'text': 'matplotlib.colors API'}, {'text': 'List of named colors Example'}, {'text': ''Red', 'Green', and 'Blue' are the intensities of those colors. In combination,\nthey represent the colorspace.'}, {'h2': 'Transparency'}, {'text': 'The alpha value of a color specifies its transparency, where 0 is fully\ntransparent and 1 is fully opaque. When a color is semi-transparent, the\nbackground color will show through.'}, {'text': 'The alpha value determines the resulting color by blending the\nforeground color with the background color according to the formula'}, {'text': 'The following plot illustrates the effect of transparency.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Rectangle\n\nfig, ax = plt.subplots(figsize=(6.5, 1.65), layout='constrained')\nax.add_patch(Rectangle((-0.2, -0.35), 11.2, 0.7, color='C1', alpha=0.8))\nfor i, alpha in enumerate(np.linspace(0, 1, 11)):\n    ax.add_patch(Rectangle((i, 0.05), 0.8, 0.6, alpha=alpha, zorder=0))\n    ax.text(i+0.4, 0.85, f'{alpha:.1f}', ha='center')\n    ax.add_patch(Rectangle((i, -0.05), 0.8, -0.6, alpha=alpha, zorder=2))\nax.set_xlim(-0.2, 13)\nax.set_ylim(-1, 1)\nax.set_title('alpha values')\nax.text(11.3, 0.6, 'zorder=1', va='center', color='C0')\nax.text(11.3, 0, 'zorder=2\\\nalpha=0.8', va='center', color='C1')\nax.text(11.3, -0.6, 'zorder=3', va='center', color='C0')\nax.axis('off')\n'}, {'text': 'The orange rectangle is semi-transparent with alpha = 0.8. The top row of\nblue squares is drawn below and the bottom row of blue squares is drawn on\ntop of the orange rectangle.'}, {'text': 'See also Zorder Demo to learn more on the drawing order.'}, {'h2': ''CN' color selection'}, {'text': 'Matplotlib converts 'CN' colors to RGBA when drawing Artists. The\nStyling with cycler section contains additional\ninformation about controlling colors and style properties.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\nth = np.linspace(0, 2*np.pi, 128)\n\n\ndef demo(sty):\n    mpl.style.use(sty)\n    fig, ax = plt.subplots(figsize=(3, 3))\n\n    ax.set_title(f'style: {sty!r}', color='C0')\n\n    ax.plot(th, np.cos(th), 'C1', label='C1')\n    ax.plot(th, np.sin(th), 'C2', label='C2')\n    ax.legend()\n\n\ndemo('default')\ndemo('seaborn-v0_8')\n'}, {'text': 'The first color 'C0' is the title. Each plot uses the second and third\ncolors of each style's rcParamsaxes.prop_cycle (default: cycler('color', ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'])). They are 'C1' and 'C2',\nrespectively.'}, {'h2': 'Comparison between X11/CSS4 and xkcd colors'}, {'text': 'The xkcd colors come from a user survey conducted by the webcomic xkcd.'}, {'text': '95 out of the 148 X11/CSS4 color names also appear in the xkcd color survey.\nAlmost all of them map to different color values in the X11/CSS4 and in\nthe xkcd palette. Only 'black white' and 'cyan' are identical.'}, {'text': 'For example, 'blue' maps to '#0000FF' whereas 'xkcd:blue' maps to\n'#0343DF'. Due to these name collisions, all xkcd colors have the\n'xkcd:' prefix.'}, {'text': 'The visual below shows name collisions. Color names where color values agree\nare in bold.'}, {'code': 'import matplotlib.colors as mcolors\nimport matplotlib.patches as mpatch\n\noverlap = {name for name in mcolors.CSS4_COLORS\n           if f'xkcd:{name}' in mcolors.XKCD_COLORS}\n\nfig = plt.figure(figsize=[9, 5])\nax = fig.add_axes([0, 0, 1, 1])\n\nn_groups = 3\nn_rows = len(overlap) // n_groups + 1\n\nfor j, color_name in enumerate(sorted(overlap)):\n    css4 = mcolors.CSS4_COLORS[color_name]\n    xkcd = mcolors.XKCD_COLORS[f'xkcd:{color_name}'].upper()\n\n    # Pick text colour based on perceived luminance.\n    rgba = mcolors.to_rgba_array([css4, xkcd])\n    luma = 0.299 * rgba[:, 0] + 0.587 * rgba[:, 1] + 0.114 * rgba[:, 2]\n    css4_text_color = 'k' if luma[0] > 0.5 else 'w'\n    xkcd_text_color = 'k' if luma[1] > 0.5 else 'w'\n\n    col_shift = (j // n_rows) * 3\n    y_pos = j % n_rows\n    text_args = dict(fontsize=10, weight='bold' if css4 == xkcd else None)\n    ax.add_patch(mpatch.Rectangle((0 + col_shift, y_pos), 1, 1, color=css4))\n    ax.add_patch(mpatch.Rectangle((1 + col_shift, y_pos), 1, 1, color=xkcd))\n    ax.text(0.5 + col_shift, y_pos + .7, css4,\n            color=css4_text_color, ha='center', **text_args)\n    ax.text(1.5 + col_shift, y_pos + .7, xkcd,\n            color=xkcd_text_color, ha='center', **text_args)\n    ax.text(2 + col_shift, y_pos + .7, f'  {color_name}', **text_args)\n\nfor g in range(n_groups):\n    ax.hlines(range(n_rows), 3*g, 3*g + 2.8, color='0.7', linewidth=1)\n    ax.text(0.5 + 3*g, -0.3, 'X11/CSS4', ha='center')\n    ax.text(1.5 + 3*g, -0.3, 'xkcd', ha='center')\n\nax.set_xlim(0, 3 * n_groups)\nax.set_ylim(n_rows, -1)\nax.axis('off')\n\nplt.show()\n'}, {'text': 'Total running time of the script: (0 minutes 1.241 seconds)'}, {'text': 'Download Python source code: colors.py'}, {'text': 'Download Jupyter notebook: colors.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 31
},
{
    "raw_page": "{'h1': 'Customized Colorbars Tutorial'}, {'text': 'This tutorial shows how to build and customize standalone colorbars, i.e.\nwithout an attached plot.'}, {'h2': 'Customized Colorbars'}, {'text': 'A colorbar needs a 'mappable' (matplotlib.cm.ScalarMappable)\nobject (typically, an image) which indicates the colormap and the norm to be\nused. In order to create a colorbar without an attached image, one can instead\nuse a ScalarMappable with no associated data.'}, {'h3': 'Basic continuous colorbar'}, {'text': 'Here we create a basic continuous colorbar with ticks and labels.'}, {'text': 'The arguments to the colorbar call are the ScalarMappable\n(constructed using the norm and cmap arguments), the axes where the\ncolorbar should be drawn, and the colorbar's orientation.'}, {'text': 'For more information see the colorbar API.'}, {'code': 'import matplotlib.pyplot as plt\n\nimport matplotlib as mpl\n\nfig, ax = plt.subplots(figsize=(6, 1))\nfig.subplots_adjust(bottom=0.5)\n\ncmap = mpl.cm.cool\nnorm = mpl.colors.Normalize(vmin=5, vmax=10)\n\nfig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n             cax=ax, orientation='horizontal', label='Some Units')\n'}, {'h3': 'Extended colorbar with continuous colorscale'}, {'text': 'The second example shows how to make a discrete colorbar based on a\ncontinuous cmap. With the 'extend' keyword argument the appropriate colors\nare chosen to fill the colorspace, including the extensions:'}, {'code': 'fig, ax = plt.subplots(figsize=(6, 1))\nfig.subplots_adjust(bottom=0.5)\n\ncmap = mpl.cm.viridis\nbounds = [-1, 2, 5, 7, 12, 15]\nnorm = mpl.colors.BoundaryNorm(bounds, cmap.N, extend='both')\n\nfig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap),\n             cax=ax, orientation='horizontal',\n             label='Discrete intervals with extend='both' keyword')\n'}, {'h3': 'Discrete intervals colorbar'}, {'text': 'The third example illustrates the use of a\nListedColormap which generates a colormap from a\nset of listed colors, colors.BoundaryNorm which generates a colormap\nindex based on discrete intervals and extended ends to show the 'over' and\n'under' value colors. Over and under are used to display data outside of the\nnormalized [0, 1] range. Here we pass colors as gray shades as a string\nencoding a float in the 0-1 range.'}, {'text': 'If a ListedColormap is used, the length of the\nbounds array must be one greater than the length of the color list. The\nbounds must be monotonically increasing.'}, {'text': 'This time we pass additional arguments to\ncolorbar. For the out-of-range values to display on the colorbar\nwithout using the extend keyword with\ncolors.BoundaryNorm, we have to use the extend keyword argument directly\nin the colorbar call. Here we also\nuse the spacing argument to make\nthe length of each colorbar segment proportional to its corresponding\ninterval.'}, {'code': 'fig, ax = plt.subplots(figsize=(6, 1))\nfig.subplots_adjust(bottom=0.5)\n\ncmap = (mpl.colors.ListedColormap(['red green blue cyan'])\n        .with_extremes(over='0.25', under='0.75'))\n\nbounds = [1, 2, 4, 7, 8]\nnorm = mpl.colors.BoundaryNorm(bounds, cmap.N)\nfig.colorbar(\n    mpl.cm.ScalarMappable(cmap=cmap, norm=norm),\n    cax=ax,\n    extend='both',\n    ticks=bounds,\n    spacing='proportional',\n    orientation='horizontal',\n    label='Discrete intervals, some other units',\n)\n'}, {'h3': 'Colorbar with custom extension lengths'}, {'text': 'Here we illustrate the use of custom length colorbar extensions, on a\ncolorbar with discrete intervals. To make the length of each extension the\nsame as the length of the interior colors, use extendfrac='auto'.'}, {'code': 'fig, ax = plt.subplots(figsize=(6, 1))\nfig.subplots_adjust(bottom=0.5)\n\ncmap = (mpl.colors.ListedColormap(['royalblue cyan yellow orange'])\n        .with_extremes(over='red', under='blue'))\n\nbounds = [-1.0, -0.5, 0.0, 0.5, 1.0]\nnorm = mpl.colors.BoundaryNorm(bounds, cmap.N)\nfig.colorbar(\n    mpl.cm.ScalarMappable(cmap=cmap, norm=norm),\n    cax=ax,\n    extend='both',\n    extendfrac='auto',\n    ticks=bounds,\n    spacing='uniform',\n    orientation='horizontal',\n    label='Custom extension lengths, some other units',\n)\n\nplt.show()\n'}, {'text': 'Download Python source code: colorbar_only.py'}, {'text': 'Download Jupyter notebook: colorbar_only.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 32
},
{
    "raw_page": "{'h1': 'Creating Colormaps in Matplotlib'}, {'text': 'Matplotlib has a number of built-in colormaps accessible via\nmatplotlib.colormaps. There are also external libraries like\npalettable that have many extra colormaps.'}, {'text': 'However, we often want to create or manipulate colormaps in Matplotlib.\nThis can be done using the class ListedColormap or\nLinearSegmentedColormap.\nSeen from the outside, both colormap classes map values between 0 and 1 to\na bunch of colors. There are, however, slight differences, some of which are\nshown in the following.'}, {'text': 'Before manually creating or manipulating colormaps, let us first see how we\ncan obtain colormaps and their colors from existing colormap classes.'}, {'h2': 'Getting colormaps and accessing their values'}, {'text': 'First, getting a named colormap, most of which are listed in\nChoosing Colormaps in Matplotlib, may be done using matplotlib.colormaps,\nwhich returns a colormap object. The length of the list of colors used\ninternally to define the colormap can be adjusted via Colormap.resampled.\nBelow we use a modest value of 8 so there are not a lot of values to look at.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.colors import LinearSegmentedColormap, ListedColormap\n\nviridis = mpl.colormaps['viridis'].resampled(8)\n'}, {'text': 'The object viridis is a callable, that when passed a float between\n0 and 1 returns an RGBA value from the colormap:'}, {'code': 'print(viridis(0.56))\n'}, {'code': '(0.122312, 0.633153, 0.530398, 1.0)\n'}, {'h3': 'ListedColormap'}, {'text': 'ListedColormaps store their color values in a .colors attribute.\nThe list of colors that comprise the colormap can be directly accessed using\nthe colors property,\nor it can be accessed indirectly by calling viridis with an array of\nvalues matching the length of the colormap. Note that the returned list is\nin the form of an RGBA (N, 4) array, where N is the length of the colormap.'}, {'code': 'print('viridis.colors', viridis.colors)\nprint('viridis(range(8))', viridis(range(8)))\nprint('viridis(np.linspace(0, 1, 8))', viridis(np.linspace(0, 1, 8)))\n'}, {'code': 'viridis.colors [[0.267004 0.004874 0.329415 1.      ]\n [0.275191 0.194905 0.496005 1.      ]\n [0.212395 0.359683 0.55171  1.      ]\n [0.153364 0.497    0.557724 1.      ]\n [0.122312 0.633153 0.530398 1.      ]\n [0.288921 0.758394 0.428426 1.      ]\n [0.626579 0.854645 0.223353 1.      ]\n [0.993248 0.906157 0.143936 1.      ]]\nviridis(range(8)) [[0.267004 0.004874 0.329415 1.      ]\n [0.275191 0.194905 0.496005 1.      ]\n [0.212395 0.359683 0.55171  1.      ]\n [0.153364 0.497    0.557724 1.      ]\n [0.122312 0.633153 0.530398 1.      ]\n [0.288921 0.758394 0.428426 1.      ]\n [0.626579 0.854645 0.223353 1.      ]\n [0.993248 0.906157 0.143936 1.      ]]\nviridis(np.linspace(0, 1, 8)) [[0.267004 0.004874 0.329415 1.      ]\n [0.275191 0.194905 0.496005 1.      ]\n [0.212395 0.359683 0.55171  1.      ]\n [0.153364 0.497    0.557724 1.      ]\n [0.122312 0.633153 0.530398 1.      ]\n [0.288921 0.758394 0.428426 1.      ]\n [0.626579 0.854645 0.223353 1.      ]\n [0.993248 0.906157 0.143936 1.      ]]\n'}, {'text': 'The colormap is a lookup table, so 'oversampling' the colormap returns\nnearest-neighbor interpolation (note the repeated colors in the list below)'}, {'code': 'print('viridis(np.linspace(0, 1, 12))', viridis(np.linspace(0, 1, 12)))\n'}, {'code': 'viridis(np.linspace(0, 1, 12)) [[0.267004 0.004874 0.329415 1.      ]\n [0.267004 0.004874 0.329415 1.      ]\n [0.275191 0.194905 0.496005 1.      ]\n [0.212395 0.359683 0.55171  1.      ]\n [0.212395 0.359683 0.55171  1.      ]\n [0.153364 0.497    0.557724 1.      ]\n [0.122312 0.633153 0.530398 1.      ]\n [0.288921 0.758394 0.428426 1.      ]\n [0.288921 0.758394 0.428426 1.      ]\n [0.626579 0.854645 0.223353 1.      ]\n [0.993248 0.906157 0.143936 1.      ]\n [0.993248 0.906157 0.143936 1.      ]]\n'}, {'h3': 'LinearSegmentedColormap'}, {'text': 'LinearSegmentedColormaps do not have a .colors attribute.\nHowever, one may still call the colormap with an integer array, or with a\nfloat array between 0 and 1.'}, {'code': 'copper = mpl.colormaps['copper'].resampled(8)\n\nprint('copper(range(8))', copper(range(8)))\nprint('copper(np.linspace(0, 1, 8))', copper(np.linspace(0, 1, 8)))\n'}, {'code': 'copper(range(8)) [[0.         0.         0.         1.        ]\n [0.17647055 0.1116     0.07107143 1.        ]\n [0.35294109 0.2232     0.14214286 1.        ]\n [0.52941164 0.3348     0.21321429 1.        ]\n [0.70588219 0.4464     0.28428571 1.        ]\n [0.88235273 0.558      0.35535714 1.        ]\n [1.         0.6696     0.42642857 1.        ]\n [1.         0.7812     0.4975     1.        ]]\ncopper(np.linspace(0, 1, 8)) [[0.         0.         0.         1.        ]\n [0.17647055 0.1116     0.07107143 1.        ]\n [0.35294109 0.2232     0.14214286 1.        ]\n [0.52941164 0.3348     0.21321429 1.        ]\n [0.70588219 0.4464     0.28428571 1.        ]\n [0.88235273 0.558      0.35535714 1.        ]\n [1.         0.6696     0.42642857 1.        ]\n [1.         0.7812     0.4975     1.        ]]\n'}, {'h2': 'Creating listed colormaps'}, {'text': 'Creating a colormap is essentially the inverse operation of the above where\nwe supply a list or array of color specifications to ListedColormap to\nmake a new colormap.'}, {'text': 'Before continuing with the tutorial, let us define a helper function that\ntakes one of more colormaps as input, creates some random data and applies\nthe colormap(s) to an image plot of that dataset.'}, {'code': 'def plot_examples(colormaps):\n    '''\n    Helper function to plot data with associated colormap.\n    '''\n    np.random.seed(19680801)\n    data = np.random.randn(30, 30)\n    n = len(colormaps)\n    fig, axs = plt.subplots(1, n, figsize=(n * 2 + 2, 3),\n                            layout='constrained', squeeze=False)\n    for [ax, cmap] in zip(axs.flat, colormaps):\n        psm = ax.pcolormesh(data, cmap=cmap, rasterized=True, vmin=-4, vmax=4)\n        fig.colorbar(psm, ax=ax)\n    plt.show()\n'}, {'text': 'In the simplest case we might type in a list of color names to create a\ncolormap from those.'}, {'code': 'cmap = ListedColormap(darkorange', 'gold', 'lawngreen', 'lightseagreen)\nplot_examples([cmap])\n'}, {'text': 'In fact, that list may contain any valid\nMatplotlib color specification.\nParticularly useful for creating custom colormaps are (N, 4)-shaped arrays.\nBecause with the variety of numpy operations that we can do on a such an\narray, carpentry of new colormaps from existing colormaps become quite\nstraight forward.'}, {'text': 'For example, suppose we want to make the first 25 entries of a 256-length\n'viridis' colormap pink for some reason:'}, {'code': 'viridis = mpl.colormaps['viridis'].resampled(256)\nnewcolors = viridis(np.linspace(0, 1, 256))\npink = np.array([248/256, 24/256, 148/256, 1])\nnewcolors[:25, :] = pink\nnewcmp = ListedColormap(newcolors)\n\nplot_examples([viridis, newcmp])\n'}, {'text': 'We can reduce the dynamic range of a colormap; here we choose the\nmiddle half of the colormap. Note, however, that because viridis is a\nlisted colormap, we will end up with 128 discrete values instead of the 256\nvalues that were in the original colormap. This method does not interpolate\nin color-space to add new colors.'}, {'code': 'viridis_big = mpl.colormaps['viridis']\nnewcmp = ListedColormap(viridis_big(np.linspace(0.25, 0.75, 128)))\nplot_examples([viridis, newcmp])\n'}, {'text': 'and we can easily concatenate two colormaps:'}, {'code': 'top = mpl.colormaps['Oranges_r'].resampled(128)\nbottom = mpl.colormaps['Blues'].resampled(128)\n\nnewcolors = np.vstack((top(np.linspace(0, 1, 128)),\n                       bottom(np.linspace(0, 1, 128))))\nnewcmp = ListedColormap(newcolors, name='OrangeBlue')\nplot_examples([viridis, newcmp])\n'}, {'text': 'Of course we need not start from a named colormap, we just need to create\nthe (N, 4) array to pass to ListedColormap. Here we create a colormap that\ngoes from brown (RGB: 90, 40, 40) to white (RGB: 255, 255, 255).'}, {'code': 'N = 256\nvals = np.ones((N, 4))\nvals[:, 0] = np.linspace(90/256, 1, N)\nvals[:, 1] = np.linspace(40/256, 1, N)\nvals[:, 2] = np.linspace(40/256, 1, N)\nnewcmp = ListedColormap(vals)\nplot_examples([viridis, newcmp])\n'}, {'h2': 'Creating linear segmented colormaps'}, {'text': 'The LinearSegmentedColormap class specifies colormaps using anchor points\nbetween which RGB(A) values are interpolated.'}, {'text': 'The format to specify these colormaps allows discontinuities at the anchor\npoints. Each anchor point is specified as a row in a matrix of the\nform [x[i] yleft[i] yright[i]], where x[i] is the anchor, and\nyleft[i] and yright[i] are the values of the color on either\nside of the anchor point.'}, {'text': 'If there are no discontinuities, then yleft[i] == yright[i]:'}, {'code': 'cdict = {'red':   [[0.0,  0.0, 0.0],\n                   [0.5,  1.0, 1.0],\n                   [1.0,  1.0, 1.0]],\n         'green': [[0.0,  0.0, 0.0],\n                   [0.25, 0.0, 0.0],\n                   [0.75, 1.0, 1.0],\n                   [1.0,  1.0, 1.0]],\n         'blue':  [[0.0,  0.0, 0.0],\n                   [0.5,  0.0, 0.0],\n                   [1.0,  1.0, 1.0]]}\n\n\ndef plot_linearmap(cdict):\n    newcmp = LinearSegmentedColormap('testCmap', segmentdata=cdict, N=256)\n    rgba = newcmp(np.linspace(0, 1, 256))\n    fig, ax = plt.subplots(figsize=(4, 3), layout='constrained')\n    col = ['r g b']\n    for xx in [0.25, 0.5, 0.75]:\n        ax.axvline(xx, color='0.7', linestyle='--')\n    for i in range(3):\n        ax.plot(np.arange(256)/256, rgba[:, i], color=col[i])\n    ax.set_xlabel('index')\n    ax.set_ylabel('RGB')\n    plt.show()\n\nplot_linearmap(cdict)\n'}, {'text': 'In order to make a discontinuity at an anchor point, the third column is\ndifferent than the second. The matrix for each of 'red', 'green', 'blue',\nand optionally 'alpha' is set up as:'}, {'code': 'cdict['red'] = [...\n                [x[i]      yleft[i]     yright[i]],\n                [x[i+1]    yleft[i+1]   yright[i+1]],\n               ...]\n'}, {'text': 'and for values passed to the colormap between x[i] and x[i+1],\nthe interpolation is between yright[i] and yleft[i+1].'}, {'text': 'In the example below there is a discontinuity in red at 0.5. The\ninterpolation between 0 and 0.5 goes from 0.3 to 1, and between 0.5 and 1\nit goes from 0.9 to 1. Note that red[0, 1], and red[2, 2] are both\nsuperfluous to the interpolation because red[0, 1] (i.e., yleft[0])\nis the value to the left of 0, and red[2, 2] (i.e., yright[2]) is the\nvalue to the right of 1, which are outside the color mapping domain.'}, {'code': 'cdict['red'] = [[0.0,  0.0, 0.3],\n                [0.5,  1.0, 0.9],\n                [1.0,  1.0, 1.0]]\nplot_linearmap(cdict)\n'}, {'h3': 'Directly creating a segmented colormap from a list'}, {'text': 'The approach described above is very versatile, but admittedly a bit\ncumbersome to implement. For some basic cases, the use of\nLinearSegmentedColormap.from_list may be easier. This creates a segmented\ncolormap with equal spacings from a supplied list of colors.'}, {'code': 'colors = darkorange', 'gold', 'lawngreen', 'lightseagreen\ncmap1 = LinearSegmentedColormap.from_list('mycmap', colors)\n'}, {'text': 'If desired, the nodes of the colormap can be given as numbers between 0 and\n1. For example, one could have the reddish part take more space in the\ncolormap.'}, {'code': 'nodes = [0.0, 0.4, 0.8, 1.0]\ncmap2 = LinearSegmentedColormap.from_list('mycmap', list(zip(nodes, colors)))\n\nplot_examples([cmap1, cmap2])\n'}, {'h2': 'Reversing a colormap'}, {'text': 'Colormap.reversed creates a new colormap that is a reversed version of\nthe original colormap.'}, {'code': 'colors = #ffffcc', '#a1dab4', '#41b6c4', '#2c7fb8', '#253494\nmy_cmap = ListedColormap(colors, name='my_cmap')\n\nmy_cmap_r = my_cmap.reversed()\n\nplot_examples([my_cmap, my_cmap_r])\n'}, {'text': 'If no name is passed in, .reversed also names the copy by\nappending '_r' to the original colormap's\nname.'}, {'h2': 'Registering a colormap'}, {'text': 'Colormaps can be added to the matplotlib.colormaps list of named colormaps.\nThis allows the colormaps to be accessed by name in plotting functions:'}, {'code': '# my_cmap, my_cmap_r from reversing a colormap\nmpl.colormaps.register(cmap=my_cmap)\nmpl.colormaps.register(cmap=my_cmap_r)\n\ndata = [[1, 2, 3, 4, 5]]\n\nfig, (ax1, ax2) = plt.subplots(nrows=2)\n\nax1.imshow(data, cmap='my_cmap')\nax2.imshow(data, cmap='my_cmap_r')\n\nplt.show()\n'}, {'text': 'References'}, {'text': 'The use of the following functions, methods, classes and modules is shown\nin this example:'}, {'text': 'matplotlib.axes.Axes.pcolormesh'}, {'text': 'matplotlib.figure.Figure.colorbar'}, {'text': 'matplotlib.colors'}, {'text': 'matplotlib.colors.LinearSegmentedColormap'}, {'text': 'matplotlib.colors.ListedColormap'}, {'text': 'matplotlib.cm'}, {'text': 'matplotlib.colormaps'}, {'text': 'Total running time of the script: (0 minutes 3.959 seconds)'}, {'text': 'Download Python source code: colormap-manipulation.py'}, {'text': 'Download Jupyter notebook: colormap-manipulation.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 33
},
{
    "raw_page": "{'h1': 'Colormap Normalization'}, {'text': 'Objects that use colormaps by default linearly map the colors in the\ncolormap from data values vmin to vmax. For example:'}, {'code': 'pcm = ax.pcolormesh(x, y, Z, vmin=-1., vmax=1., cmap='RdBu_r')\n'}, {'text': 'will map the data in Z linearly from -1 to +1, so Z=0 will\ngive a color at the center of the colormap RdBu_r (white in this\ncase).'}, {'text': 'Matplotlib does this mapping in two steps, with a normalization from\nthe input data to [0, 1] occurring first, and then mapping onto the\nindices in the colormap. Normalizations are classes defined in the\nmatplotlib.colors() module. The default, linear normalization\nis matplotlib.colors.Normalize().'}, {'text': 'Artists that map data to color pass the arguments vmin and vmax to\nconstruct a matplotlib.colors.Normalize() instance, then call it:'}, {'code': '>>> import matplotlib as mpl\n>>> norm = mpl.colors.Normalize(vmin=-1, vmax=1)\n>>> norm(0)\n0.5\n'}, {'text': 'However, there are sometimes cases where it is useful to map data to\ncolormaps in a non-linear fashion.'}, {'h2': 'Logarithmic'}, {'text': 'One of the most common transformations is to plot data by taking its logarithm\n(to the base-10). This transformation is useful to display changes across\ndisparate scales. Using colors.LogNorm normalizes the data via\n\\\\(log_{10}\\\\). In the example below, there are two bumps, one much smaller\nthan the other. Using colors.LogNorm, the shape and location of each bump\ncan clearly be seen:'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nimport matplotlib.cbook as cbook\nimport matplotlib.colors as colors\n\nN = 100\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\n\n# A low hump with a spike coming out of the top right.  Needs to have\n# z/colour axis on a log scale, so we see both hump and spike. A linear\n# scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolor(X, Y, Z,\n                   norm=colors.LogNorm(vmin=Z.min(), vmax=Z.max()),\n                   cmap='PuBu_r', shading='auto')\nfig.colorbar(pcm, ax=ax[0], extend='max')\n\npcm = ax[1].pcolor(X, Y, Z, cmap='PuBu_r', shading='auto')\nfig.colorbar(pcm, ax=ax[1], extend='max')\nplt.show()\n'}, {'h2': 'Centered'}, {'text': 'In many cases, data is symmetrical around a center, for example, positive and\nnegative anomalies around a center 0. In this case, we would like the center\nto be mapped to 0.5 and the datapoint with the largest deviation from the\ncenter to be mapped to 1.0, if its value is greater than the center, or 0.0\notherwise. The norm colors.CenteredNorm creates such a mapping\nautomatically. It is well suited to be combined with a divergent colormap\nwhich uses different colors edges that meet in the center at an unsaturated\ncolor.'}, {'text': 'If the center of symmetry is different from 0, it can be set with the\nvcenter argument. For logarithmic scaling on both sides of the center, see\ncolors.SymLogNorm below; to apply a different mapping above and below the\ncenter, use colors.TwoSlopeNorm below.'}, {'code': 'delta = 0.1\nx = np.arange(-3.0, 4.001, delta)\ny = np.arange(-4.0, 3.001, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (0.9*Z1 - 0.5*Z2) * 2\n\n# select a divergent colormap\ncmap = cm.coolwarm\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\npc = ax1.pcolormesh(Z, cmap=cmap)\nfig.colorbar(pc, ax=ax1)\nax1.set_title('Normalize()')\n\npc = ax2.pcolormesh(Z, norm=colors.CenteredNorm(), cmap=cmap)\nfig.colorbar(pc, ax=ax2)\nax2.set_title('CenteredNorm()')\n\nplt.show()\n'}, {'h2': 'Symmetric logarithmic'}, {'text': 'Similarly, it sometimes happens that there is data that is positive\nand negative, but we would still like a logarithmic scaling applied to\nboth. In this case, the negative numbers are also scaled\nlogarithmically, and mapped to smaller numbers; e.g., if vmin=-vmax,\nthen the negative numbers are mapped from 0 to 0.5 and the\npositive from 0.5 to 1.'}, {'text': 'Since the logarithm of values close to zero tends toward infinity, a\nsmall range around zero needs to be mapped linearly. The parameter\nlinthresh allows the user to specify the size of this range\n(-linthresh, linthresh). The size of this range in the colormap is\nset by linscale. When linscale == 1.0 (the default), the space used\nfor the positive and negative halves of the linear range will be equal\nto one decade in the logarithmic range.'}, {'code': 'N = 100\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=0.03, linscale=0.03,\n                                              vmin=-1.0, vmax=1.0, base=10),\n                       cmap='RdBu_r', shading='auto')\nfig.colorbar(pcm, ax=ax[0], extend='both')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z), shading='auto')\nfig.colorbar(pcm, ax=ax[1], extend='both')\nplt.show()\n'}, {'h2': 'Power-law'}, {'text': 'Sometimes it is useful to remap the colors onto a power-law\nrelationship (i.e. \\\\(y=x^{\\\\gamma}\\\\), where \\\\(\\\\gamma\\\\) is the\npower). For this we use the colors.PowerNorm. It takes as an\nargument gamma (gamma == 1.0 will just yield the default linear\nnormalization):'}, {'text': 'Note'}, {'text': 'There should probably be a good reason for plotting the data using\nthis type of transformation. Technical viewers are used to linear\nand logarithmic axes and data transformations. Power laws are less\ncommon, and viewers should explicitly be made aware that they have\nbeen used.'}, {'code': 'N = 100\nX, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]\nZ1 = (1 + np.sin(Y * 10.)) * X**2\n\nfig, ax = plt.subplots(2, 1, layout='constrained')\n\npcm = ax[0].pcolormesh(X, Y, Z1, norm=colors.PowerNorm(gamma=0.5),\n                       cmap='PuBu_r', shading='auto')\nfig.colorbar(pcm, ax=ax[0], extend='max')\nax[0].set_title('PowerNorm()')\n\npcm = ax[1].pcolormesh(X, Y, Z1, cmap='PuBu_r', shading='auto')\nfig.colorbar(pcm, ax=ax[1], extend='max')\nax[1].set_title('Normalize()')\nplt.show()\n'}, {'h2': 'Discrete bounds'}, {'text': 'Another normalization that comes with Matplotlib is colors.BoundaryNorm.\nIn addition to vmin and vmax, this takes as arguments boundaries between\nwhich data is to be mapped. The colors are then linearly distributed between\nthese 'bounds'. It can also take an extend argument to add upper and/or\nlower out-of-bounds values to the range over which the colors are\ndistributed. For instance:'}, {'code': '>>> import matplotlib.colors as colors\n>>> bounds = np.array([-0.25, -0.125, 0, 0.5, 1])\n>>> norm = colors.BoundaryNorm(boundaries=bounds, ncolors=4)\n>>> print(norm([-0.2, -0.15, -0.02, 0.3, 0.8, 0.99]))\n[0 0 1 2 3 3]\n'}, {'text': 'Note: Unlike the other norms, this norm returns values from 0 to ncolors-1.'}, {'code': 'N = 100\nX, Y = np.meshgrid(np.linspace(-3, 3, N), np.linspace(-2, 2, N))\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = ((Z1 - Z2) * 2)[:-1, :-1]\n\nfig, ax = plt.subplots(2, 2, figsize=(8, 6), layout='constrained')\nax = ax.flatten()\n\n# Default norm:\npcm = ax[0].pcolormesh(X, Y, Z, cmap='RdBu_r')\nfig.colorbar(pcm, ax=ax[0], orientation='vertical')\nax[0].set_title('Default norm')\n\n# Even bounds give a contour-like effect:\nbounds = np.linspace(-1.5, 1.5, 7)\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[1].pcolormesh(X, Y, Z, norm=norm, cmap='RdBu_r')\nfig.colorbar(pcm, ax=ax[1], extend='both', orientation='vertical')\nax[1].set_title('BoundaryNorm: 7 boundaries')\n\n# Bounds may be unevenly spaced:\nbounds = np.array([-0.2, -0.1, 0, 0.5, 1])\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[2].pcolormesh(X, Y, Z, norm=norm, cmap='RdBu_r')\nfig.colorbar(pcm, ax=ax[2], extend='both', orientation='vertical')\nax[2].set_title('BoundaryNorm: nonuniform')\n\n# With out-of-bounds colors:\nbounds = np.linspace(-1.5, 1.5, 7)\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256, extend='both')\npcm = ax[3].pcolormesh(X, Y, Z, norm=norm, cmap='RdBu_r')\n# The colorbar inherits the 'extend' argument from BoundaryNorm.\nfig.colorbar(pcm, ax=ax[3], orientation='vertical')\nax[3].set_title('BoundaryNorm: extend='both'')\nplt.show()\n'}, {'h2': 'TwoSlopeNorm: Different mapping on either side of a center'}, {'text': 'Sometimes we want to have a different colormap on either side of a\nconceptual center point, and we want those two colormaps to have\ndifferent linear scales. An example is a topographic map where the land\nand ocean have a center at zero, but land typically has a greater\nelevation range than the water has depth range, and they are often\nrepresented by a different colormap.'}, {'code': 'dem = cbook.get_sample_data('topobathy.npz')\ntopo = dem['topo']\nlongitude = dem['longitude']\nlatitude = dem['latitude']\n\nfig, ax = plt.subplots()\n# make a colormap that has land and ocean clearly delineated and of the\n# same length (256 + 256)\ncolors_undersea = plt.cm.terrain(np.linspace(0, 0.17, 256))\ncolors_land = plt.cm.terrain(np.linspace(0.25, 1, 256))\nall_colors = np.vstack((colors_undersea, colors_land))\nterrain_map = colors.LinearSegmentedColormap.from_list(\n    'terrain_map', all_colors)\n\n# make the norm:  Note the center is offset so that the land has more\n# dynamic range:\ndivnorm = colors.TwoSlopeNorm(vmin=-500., vcenter=0, vmax=4000)\n\npcm = ax.pcolormesh(longitude, latitude, topo, rasterized=True, norm=divnorm,\n                    cmap=terrain_map, shading='auto')\n# Simple geographic plot, set aspect ratio because distance between lines of\n# longitude depends on latitude.\nax.set_aspect(1 / np.cos(np.deg2rad(49)))\nax.set_title('TwoSlopeNorm(x)')\ncb = fig.colorbar(pcm, shrink=0.6)\ncb.set_ticks([-500, 0, 1000, 2000, 3000, 4000])\nplt.show()\n'}, {'h2': 'FuncNorm: Arbitrary function normalization'}, {'text': 'If the above norms do not provide the normalization you want, you can use\nFuncNorm to define your own. Note that this example is the same\nas PowerNorm with a power of 0.5:'}, {'code': 'def _forward(x):\n    return np.sqrt(x)\n\n\ndef _inverse(x):\n    return x**2\n\nN = 100\nX, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]\nZ1 = (1 + np.sin(Y * 10.)) * X**2\nfig, ax = plt.subplots()\n\nnorm = colors.FuncNorm((_forward, _inverse), vmin=0, vmax=20)\npcm = ax.pcolormesh(X, Y, Z1, norm=norm, cmap='PuBu_r', shading='auto')\nax.set_title('FuncNorm(x)')\nfig.colorbar(pcm, shrink=0.6)\nplt.show()\n'}, {'h2': 'Custom normalization: Manually implement two linear ranges'}, {'text': 'The TwoSlopeNorm described above makes a useful example for\ndefining your own norm. Note for the colorbar to work, you must\ndefine an inverse for your norm:'}, {'code': 'class MidpointNormalize(colors.Normalize):\n    def __init__(self, vmin=None, vmax=None, vcenter=None, clip=False):\n        self.vcenter = vcenter\n        super().__init__(vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        # Note also that we must extrapolate beyond vmin/vmax\n        x, y = [self.vmin, self.vcenter, self.vmax], [0, 0.5, 1.]\n        return np.ma.masked_array(np.interp(value, x, y,\n                                            left=-np.inf, right=np.inf))\n\n    def inverse(self, value):\n        y, x = [self.vmin, self.vcenter, self.vmax], [0, 0.5, 1]\n        return np.interp(value, x, y, left=-np.inf, right=np.inf)\n\n\nfig, ax = plt.subplots()\nmidnorm = MidpointNormalize(vmin=-500., vcenter=0, vmax=4000)\n\npcm = ax.pcolormesh(longitude, latitude, topo, rasterized=True, norm=midnorm,\n                    cmap=terrain_map, shading='auto')\nax.set_aspect(1 / np.cos(np.deg2rad(49)))\nax.set_title('Custom norm')\ncb = fig.colorbar(pcm, shrink=0.6, extend='both')\ncb.set_ticks([-500, 0, 1000, 2000, 3000, 4000])\n\nplt.show()\n'}, {'text': 'Total running time of the script: (0 minutes 4.561 seconds)'}, {'text': 'Download Python source code: colormapnorms.py'}, {'text': 'Download Jupyter notebook: colormapnorms.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 34
},
{
    "raw_page": "{'h1': 'Choosing Colormaps in Matplotlib'}, {'text': 'Matplotlib has a number of built-in colormaps accessible via\nmatplotlib.colormaps. There are also external libraries that\nhave many extra colormaps, which can be viewed in the\nThird-party colormaps section of the Matplotlib documentation.\nHere we briefly discuss how to choose between the many options. For\nhelp on creating your own colormaps, see\nCreating Colormaps in Matplotlib.'}, {'h2': 'Overview'}, {'text': 'The idea behind choosing a good colormap is to find a good representation in 3D\ncolorspace for your data set. The best colormap for any given data set depends\non many things including:'}, {'text': 'Whether representing form or metric data ([Ware])'}, {'text': 'Your knowledge of the data set (e.g., is there a critical value\nfrom which the other values deviate?)'}, {'text': 'If there is an intuitive color scheme for the parameter you are plotting'}, {'text': 'If there is a standard in the field the audience may be expecting'}, {'text': 'For many applications, a perceptually uniform colormap is the best choice;\ni.e. a colormap in which equal steps in data are perceived as equal\nsteps in the color space. Researchers have found that the human brain\nperceives changes in the lightness parameter as changes in the data\nmuch better than, for example, changes in hue. Therefore, colormaps\nwhich have monotonically increasing lightness through the colormap\nwill be better interpreted by the viewer. Wonderful examples of\nperceptually uniform colormaps can be found in the\nThird-party colormaps section as well.'}, {'text': 'Color can be represented in 3D space in various ways. One way to represent color\nis using CIELAB. In CIELAB, color space is represented by lightness,\n\\\\(L^*\\\\); red-green, \\\\(a^*\\\\); and yellow-blue, \\\\(b^*\\\\). The lightness\nparameter \\\\(L^*\\\\) can then be used to learn more about how the matplotlib\ncolormaps will be perceived by viewers.'}, {'text': 'An excellent starting resource for learning about human perception of colormaps\nis from [IBM].'}, {'h2': 'Classes of colormaps'}, {'text': 'Colormaps are often split into several categories based on their function (see,\ne.g., [Moreland]):'}, {'text': 'Sequential: change in lightness and often saturation of color\nincrementally, often using a single hue; should be used for\nrepresenting information that has ordering.'}, {'text': 'Diverging: change in lightness and possibly saturation of two\ndifferent colors that meet in the middle at an unsaturated color;\nshould be used when the information being plotted has a critical\nmiddle value, such as topography or when the data deviates around\nzero.'}, {'text': 'Cyclic: change in lightness of two different colors that meet in\nthe middle and beginning/end at an unsaturated color; should be\nused for values that wrap around at the endpoints, such as phase\nangle, wind direction, or time of day.'}, {'text': 'Qualitative: often are miscellaneous colors; should be used to\nrepresent information which does not have ordering or\nrelationships.'}, {'code': 'from colorspacious import cspace_converter\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n'}, {'text': 'First, we'll show the range of each colormap. Note that some seem\nto change more 'quickly' than others.'}, {'code': 'cmaps = {}\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(category, cmap_list):\n    # Create figure and adjust figure height to number of colormaps\n    nrows = len(cmap_list)\n    figh = 0.35 + 0.15 + (nrows + (nrows - 1) * 0.1) * 0.22\n    fig, axs = plt.subplots(nrows=nrows + 1, figsize=(6.4, figh))\n    fig.subplots_adjust(top=1 - 0.35 / figh, bottom=0.15 / figh,\n                        left=0.2, right=0.99)\n    axs[0].set_title(f'{category} colormaps', fontsize=14)\n\n    for ax, name in zip(axs, cmap_list):\n        ax.imshow(gradient, aspect='auto', cmap=mpl.colormaps[name])\n        ax.text(-0.01, 0.5, name, va='center', ha='right', fontsize=10,\n                transform=ax.transAxes)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs:\n        ax.set_axis_off()\n\n    # Save colormap list for later.\n    cmaps[category] = cmap_list\n'}, {'h3': 'Sequential'}, {'text': 'For the Sequential plots, the lightness value increases monotonically through\nthe colormaps. This is good. Some of the \\\\(L^*\\\\) values in the colormaps\nspan from 0 to 100 (binary and the other grayscale), and others start around\n\\\\(L^*=20\\\\). Those that have a smaller range of \\\\(L^*\\\\) will accordingly\nhave a smaller perceptual range. Note also that the \\\\(L^*\\\\) function varies\namongst the colormaps: some are approximately linear in \\\\(L^*\\\\) and others\nare more curved.'}, {'code': 'plot_color_gradients('Perceptually Uniform Sequential',\n                     ['viridis plasma inferno magma cividis'])\n'}, {'code': 'plot_color_gradients('Sequential',\n                     ['Greys Purples Blues Greens Oranges Reds',\n                      'YlOrBr YlOrRd OrRd PuRd RdPu BuPu',\n                      'GnBu PuBu YlGnBu PuBuGn BuGn YlGn'])\n'}, {'h3': 'Sequential2'}, {'text': 'Many of the \\\\(L^*\\\\) values from the Sequential2 plots are monotonically\nincreasing, but some (autumn, cool, spring, and winter) plateau or even go both\nup and down in \\\\(L^*\\\\) space. Others (afmhot, copper, gist_heat, and hot)\nhave kinks in the \\\\(L^*\\\\) functions. Data that is being represented in a\nregion of the colormap that is at a plateau or kink will lead to a perception of\nbanding of the data in those values in the colormap (see [mycarta-banding] for\nan excellent example of this).'}, {'code': 'plot_color_gradients('Sequential (2)',\n                     ['binary gist_yarg gist_gray gray bone',\n                      'pink spring summer autumn winter cool',\n                      'Wistia hot afmhot gist_heat copper'])\n'}, {'h3': 'Diverging'}, {'text': 'For the Diverging maps, we want to have monotonically increasing \\\\(L^*\\\\)\nvalues up to a maximum, which should be close to \\\\(L^*=100\\\\), followed by\nmonotonically decreasing \\\\(L^*\\\\) values. We are looking for approximately\nequal minimum \\\\(L^*\\\\) values at opposite ends of the colormap. By these\nmeasures, BrBG and RdBu are good options. coolwarm is a good option, but it\ndoesn't span a wide range of \\\\(L^*\\\\) values (see grayscale section below).'}, {'code': 'plot_color_gradients('Diverging',\n                     ['PiYG PRGn BrBG PuOr RdGy RdBu RdYlBu',\n                      'RdYlGn Spectral coolwarm bwr seismic'])\n'}, {'h3': 'Cyclic'}, {'text': 'For Cyclic maps, we want to start and end on the same color, and meet a\nsymmetric center point in the middle. \\\\(L^*\\\\) should change monotonically\nfrom start to middle, and inversely from middle to end. It should be symmetric\non the increasing and decreasing side, and only differ in hue. At the ends and\nmiddle, \\\\(L^*\\\\) will reverse direction, which should be smoothed in\n\\\\(L^*\\\\) space to reduce artifacts. See [kovesi-colormaps] for more\ninformation on the design of cyclic maps.'}, {'text': 'The often-used HSV colormap is included in this set of colormaps, although it\nis not symmetric to a center point. Additionally, the \\\\(L^*\\\\) values vary\nwidely throughout the colormap, making it a poor choice for representing data\nfor viewers to see perceptually. See an extension on this idea at\n[mycarta-jet].'}, {'code': 'plot_color_gradients('Cyclic', ['twilight twilight_shifted hsv'])\n'}, {'h3': 'Qualitative'}, {'text': 'Qualitative colormaps are not aimed at being perceptual maps, but looking at the\nlightness parameter can verify that for us. The \\\\(L^*\\\\) values move all over\nthe place throughout the colormap, and are clearly not monotonically increasing.\nThese would not be good options for use as perceptual colormaps.'}, {'code': 'plot_color_gradients('Qualitative',\n                     ['Pastel1 Pastel2 Paired Accent Dark2',\n                      'Set1 Set2 Set3 tab10 tab20 tab20b',\n                      'tab20c'])\n'}, {'h3': 'Miscellaneous'}, {'text': 'Some of the miscellaneous colormaps have particular uses for which\nthey have been created. For example, gist_earth, ocean, and terrain\nall seem to be created for plotting topography (green/brown) and water\ndepths (blue) together. We would expect to see a divergence in these\ncolormaps, then, but multiple kinks may not be ideal, such as in\ngist_earth and terrain. CMRmap was created to convert well to\ngrayscale, though it does appear to have some small kinks in\n\\\\(L^*\\\\). cubehelix was created to vary smoothly in both lightness\nand hue, but appears to have a small hump in the green hue area. turbo\nwas created to display depth and disparity data.'}, {'text': 'The often-used jet colormap is included in this set of colormaps. We can see\nthat the \\\\(L^*\\\\) values vary widely throughout the colormap, making it a\npoor choice for representing data for viewers to see perceptually. See an\nextension on this idea at [mycarta-jet] and [turbo].'}, {'code': 'plot_color_gradients('Miscellaneous',\n                     ['flag prism ocean gist_earth terrain',\n                      'gist_stern gnuplot gnuplot2 CMRmap',\n                      'cubehelix brg gist_rainbow rainbow jet',\n                      'turbo nipy_spectral gist_ncar'])\n\nplt.show()\n'}, {'h2': 'Lightness of Matplotlib colormaps'}, {'text': 'Here we examine the lightness values of the matplotlib colormaps.\nNote that some documentation on the colormaps is available\n([list-colormaps]).'}, {'code': 'mpl.rcParams.update({'font.size': 12})\n\n# Number of colormap per subplot for particular cmap categories\n_DSUBS = {'Perceptually Uniform Sequential': 5, 'Sequential': 6,\n          'Sequential (2)': 6, 'Diverging': 6, 'Cyclic': 3,\n          'Qualitative': 4, 'Miscellaneous': 6}\n\n# Spacing between the colormaps of a subplot\n_DC = {'Perceptually Uniform Sequential': 1.4, 'Sequential': 0.7,\n       'Sequential (2)': 1.4, 'Diverging': 1.4, 'Cyclic': 1.4,\n       'Qualitative': 1.4, 'Miscellaneous': 1.4}\n\n# Indices to step through colormap\nx = np.linspace(0.0, 1.0, 100)\n\n# Do plot\nfor cmap_category, cmap_list in cmaps.items():\n\n    # Do subplots so that colormaps have enough space.\n    # Default is 6 colormaps per subplot.\n    dsub = _DSUBS.get(cmap_category, 6)\n    nsubplots = int(np.ceil(len(cmap_list) / dsub))\n\n    # squeeze=False to handle similarly the case of a single subplot\n    fig, axs = plt.subplots(nrows=nsubplots, squeeze=False,\n                            figsize=(7, 2.6*nsubplots))\n\n    for i, ax in enumerate(axs.flat):\n\n        locs = []  # locations for text labels\n\n        for j, cmap in enumerate(cmap_list[i*dsub:(i+1)*dsub]):\n\n            # Get RGB values for colormap and convert the colormap in\n            # CAM02-UCS colorspace.  lab[0, :, 0] is the lightness.\n            rgb = mpl.colormaps[cmap](x)[np.newaxis, :, :3]\n            lab = cspace_converter('sRGB1', 'CAM02-UCS')(rgb)\n\n            # Plot colormap L values.  Do separately for each category\n            # so each plot can be pretty.  To make scatter markers change\n            # color along plot:\n            # https://stackoverflow.com/q/8202605/\n\n            if cmap_category == 'Sequential':\n                # These colormaps all start at high lightness, but we want them\n                # reversed to look nice in the plot, so reverse the order.\n                y_ = lab[0, ::-1, 0]\n                c_ = x[::-1]\n            else:\n                y_ = lab[0, :, 0]\n                c_ = x\n\n            dc = _DC.get(cmap_category, 1.4)  # cmaps horizontal spacing\n            ax.scatter(x + j*dc, y_, c=c_, cmap=cmap, s=300, linewidths=0.0)\n\n            # Store locations for colormap labels\n            if cmap_category in ('Perceptually Uniform Sequential',\n                                 'Sequential'):\n                locs.append(x[-1] + j*dc)\n            elif cmap_category in ('Diverging', 'Qualitative', 'Cyclic',\n                                   'Miscellaneous', 'Sequential (2)'):\n                locs.append(x[int(x.size/2.)] + j*dc)\n\n        # Set up the axis limits:\n        #   * the 1st subplot is used as a reference for the x-axis limits\n        #   * lightness values goes from 0 to 100 (y-axis limits)\n        ax.set_xlim(axs[0, 0].get_xlim())\n        ax.set_ylim(0.0, 100.0)\n\n        # Set up labels for colormaps\n        ax.xaxis.set_ticks_position('top')\n        ticker = mpl.ticker.FixedLocator(locs)\n        ax.xaxis.set_major_locator(ticker)\n        formatter = mpl.ticker.FixedFormatter(cmap_list[i*dsub:(i+1)*dsub])\n        ax.xaxis.set_major_formatter(formatter)\n        ax.xaxis.set_tick_params(rotation=50)\n        ax.set_ylabel('Lightness $L^*$', fontsize=12)\n\n    ax.set_xlabel(cmap_category + ' colormaps', fontsize=14)\n\n    fig.tight_layout(h_pad=0.0, pad=1.5)\n    plt.show()\n'}, {'h2': 'Grayscale conversion'}, {'text': 'It is important to pay attention to conversion to grayscale for color\nplots, since they may be printed on black and white printers. If not\ncarefully considered, your readers may end up with indecipherable\nplots because the grayscale changes unpredictably through the\ncolormap.'}, {'text': 'Conversion to grayscale is done in many different ways [bw]. Some of the\nbetter ones use a linear combination of the rgb values of a pixel, but\nweighted according to how we perceive color intensity. A nonlinear method of\nconversion to grayscale is to use the \\\\(L^*\\\\) values of the pixels. In\ngeneral, similar principles apply for this question as they do for presenting\none's information perceptually; that is, if a colormap is chosen that is\nmonotonically increasing in \\\\(L^*\\\\) values, it will print in a reasonable\nmanner to grayscale.'}, {'text': 'With this in mind, we see that the Sequential colormaps have reasonable\nrepresentations in grayscale. Some of the Sequential2 colormaps have decent\nenough grayscale representations, though some (autumn, spring, summer,\nwinter) have very little grayscale change. If a colormap like this was used\nin a plot and then the plot was printed to grayscale, a lot of the\ninformation may map to the same gray values. The Diverging colormaps mostly\nvary from darker gray on the outer edges to white in the middle. Some\n(PuOr and seismic) have noticeably darker gray on one side than the other\nand therefore are not very symmetric. coolwarm has little range of gray scale\nand would print to a more uniform plot, losing a lot of detail. Note that\noverlaid, labeled contours could help differentiate between one side of the\ncolormap vs. the other since color cannot be used once a plot is printed to\ngrayscale. Many of the Qualitative and Miscellaneous colormaps, such as\nAccent, hsv, jet and turbo, change from darker to lighter and back to darker\ngrey throughout the colormap. This would make it impossible for a viewer to\ninterpret the information in a plot once it is printed in grayscale.'}, {'code': 'mpl.rcParams.update({'font.size': 14})\n\n# Indices to step through colormap.\nx = np.linspace(0.0, 1.0, 100)\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(cmap_category, cmap_list):\n    fig, axs = plt.subplots(nrows=len(cmap_list), ncols=2)\n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99,\n                        wspace=0.05)\n    fig.suptitle(cmap_category + ' colormaps', fontsize=14, y=1.0, x=0.6)\n\n    for ax, name in zip(axs, cmap_list):\n\n        # Get RGB values for colormap.\n        rgb = mpl.colormaps[name](x)[np.newaxis, :, :3]\n\n        # Get colormap in CAM02-UCS colorspace. We want the lightness.\n        lab = cspace_converter('sRGB1', 'CAM02-UCS')(rgb)\n        L = lab[0, :, 0]\n        L = np.float32(np.vstack((L, L, L)))\n\n        ax[0].imshow(gradient, aspect='auto', cmap=mpl.colormaps[name])\n        ax[1].imshow(L, aspect='auto', cmap='binary_r', vmin=0., vmax=100.)\n        pos = list(ax[0].get_position().bounds)\n        x_text = pos[0] - 0.01\n        y_text = pos[1] + pos[3]/2.\n        fig.text(x_text, y_text, name, va='center', ha='right', fontsize=10)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs.flat:\n        ax.set_axis_off()\n\n    plt.show()\n\n\nfor cmap_category, cmap_list in cmaps.items():\n\n    plot_color_gradients(cmap_category, cmap_list)\n'}, {'h2': 'Color vision deficiencies'}, {'text': 'There is a lot of information available about color blindness (e.g.,\n[colorblindness]). Additionally, there are tools available to convert images\nto how they look for different types of color vision deficiencies.'}, {'text': 'The most common form of color vision deficiency involves differentiating\nbetween red and green. Thus, avoiding colormaps with both red and green will\navoid many problems in general.'}, {'h2': 'References'}, {'text': 'http://ccom.unh.edu/sites/default/files/publications/Ware_1988_CGA_Color_sequences_univariate_maps.pdf'}, {'text': 'http://www.kennethmoreland.com/color-maps/ColorMapsExpanded.pdf'}, {'text': 'https://gist.github.com/endolith/2719900#id7'}, {'text': 'https://mycarta.wordpress.com/2012/10/14/the-rainbow-is-deadlong-live-the-rainbow-part-4-cie-lab-heated-body/'}, {'text': 'https://mycarta.wordpress.com/2012/10/06/the-rainbow-is-deadlong-live-the-rainbow-part-3/'}, {'text': 'https://arxiv.org/abs/1509.03700'}, {'text': 'https://tannerhelland.com/3643/grayscale-image-algorithm-vb6/'}, {'text': 'http://www.color-blindness.com/'}, {'text': 'https://doi.org/10.1109/VISUAL.1995.480803'}, {'text': 'https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html'}, {'text': 'Total running time of the script: (0 minutes 11.203 seconds)'}, {'text': 'Download Python source code: colormaps.py'}, {'text': 'Download Jupyter notebook: colormaps.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 35
},
{
    "raw_page": "{'h1': 'Text'}, {'text': 'Matplotlib has extensive text support, including support for\nmathematical expressions, TrueType support for raster and\nvector outputs, newline separated text with arbitrary\nrotations, and Unicode support. These tutorials cover\nthe basics of working with text in Matplotlib.'}, {'text': 'For even more information see the examples page.'}, {'text': 'Text in Matplotlib Plots'}, {'text': 'Text properties and layout'}, {'text': 'Annotations'}, {'text': 'Fonts in Matplotlib'}, {'text': 'Writing mathematical expressions'}, {'text': 'Text rendering with XeLaTeX/LuaLaTeX via the pgf backend'}, {'text': 'Text rendering with LaTeX'}",
    "id": 36
},
{
    "raw_page": "{'h1': 'Text in Matplotlib Plots'}, {'text': 'Introduction to plotting and working with text in Matplotlib.'}, {'text': 'Matplotlib has extensive text support, including support for\nmathematical expressions, truetype support for raster and\nvector outputs, newline separated text with arbitrary\nrotations, and Unicode support.'}, {'text': 'Because it embeds fonts directly in output documents, e.g., for postscript\nor PDF, what you see on the screen is what you get in the hardcopy.\nFreeType support\nproduces very nice, antialiased fonts, that look good even at small\nraster sizes. Matplotlib includes its own\nmatplotlib.font_manager (thanks to Paul Barrett), which\nimplements a cross platform, W3C\ncompliant font finding algorithm.'}, {'text': 'The user has a great deal of control over text properties (font size, font\nweight, text location and color, etc.) with sensible defaults set in\nthe rc file.\nAnd significantly, for those interested in mathematical\nor scientific figures, Matplotlib implements a large number of TeX\nmath symbols and commands, supporting mathematical expressions anywhere in your figure.'}, {'h2': 'Basic text commands'}, {'text': 'The following commands are used to create text in the implicit and explicit\ninterfaces (see Matplotlib Application Interfaces (APIs) for an explanation of the tradeoffs):'}, {'text': 'implicit API'}, {'text': 'explicit API'}, {'text': 'description'}, {'text': 'text'}, {'text': 'text'}, {'text': 'Add text at an arbitrary location of\nthe Axes.'}, {'text': 'annotate'}, {'text': 'annotate'}, {'text': 'Add an annotation, with an optional\narrow, at an arbitrary location of the\nAxes.'}, {'text': 'xlabel'}, {'text': 'set_xlabel'}, {'text': 'Add a label to the\nAxes's x-axis.'}, {'text': 'ylabel'}, {'text': 'set_ylabel'}, {'text': 'Add a label to the\nAxes's y-axis.'}, {'text': 'title'}, {'text': 'set_title'}, {'text': 'Add a title to the\nAxes.'}, {'text': 'figtext'}, {'text': 'text'}, {'text': 'Add text at an arbitrary location of\nthe Figure.'}, {'text': 'suptitle'}, {'text': 'suptitle'}, {'text': 'Add a title to the Figure.'}, {'text': 'All of these functions create and return a Text instance, which can be\nconfigured with a variety of font and other properties. The example below\nshows all of these commands in action, and more detail is provided in the\nsections that follow.'}, {'code': 'import matplotlib.pyplot as plt\n\nimport matplotlib\n\nfig = plt.figure()\nax = fig.add_subplot()\nfig.subplots_adjust(top=0.85)\n\n# Set titles for the figure and the subplot respectively\nfig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')\nax.set_title('axes title')\n\nax.set_xlabel('xlabel')\nax.set_ylabel('ylabel')\n\n# Set both x- and y-axis limits to [0, 10] instead of default [0, 1]\nax.axis([0, 10, 0, 10])\n\nax.text(3, 8, 'boxed italics text in data coords', style='italic',\n        bbox={'facecolor': 'red alpha': 0.5, 'pad': 10})\n\nax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)\n\nax.text(3, 2, 'Unicode: Institut f\u00fcr Festk\u00f6rperphysik')\n\nax.text(0.95, 0.01, 'colored text in axes coords',\n        verticalalignment='bottom', horizontalalignment='right',\n        transform=ax.transAxes,\n        color='green', fontsize=15)\n\nax.plot([2], [1], 'o')\nax.annotate('annotate', xy=(2, 1), xytext=(3, 4),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nplt.show()\n'}, {'h2': 'Labels for x- and y-axis'}, {'text': 'Specifying the labels for the x- and y-axis is straightforward, via the\nset_xlabel and set_ylabel\nmethods.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nx1 = np.linspace(0.0, 5.0, 100)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\n\nfig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(bottom=0.15, left=0.2)\nax.plot(x1, y1)\nax.set_xlabel('Time [s]')\nax.set_ylabel('Damped oscillation [V]')\n\nplt.show()\n'}, {'text': 'The x- and y-labels are automatically placed so that they clear the x- and\ny-ticklabels. Compare the plot below with that above, and note the y-label\nis to the left of the one above.'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(bottom=0.15, left=0.2)\nax.plot(x1, y1*10000)\nax.set_xlabel('Time [s]')\nax.set_ylabel('Damped oscillation [V]')\n\nplt.show()\n'}, {'text': 'If you want to move the labels, you can specify the labelpad keyword\nargument, where the value is points (1/72', the same unit used to specify\nfontsizes).'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(bottom=0.15, left=0.2)\nax.plot(x1, y1*10000)\nax.set_xlabel('Time [s]')\nax.set_ylabel('Damped oscillation [V]', labelpad=18)\n\nplt.show()\n'}, {'text': 'Or, the labels accept all the Text keyword arguments, including\nposition, via which we can manually specify the label positions. Here we\nput the xlabel to the far left of the axis. Note, that the y-coordinate of\nthis position has no effect - to adjust the y-position we need to use the\nlabelpad keyword argument.'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(bottom=0.15, left=0.2)\nax.plot(x1, y1)\nax.set_xlabel('Time [s]', position=(0., 1e6), horizontalalignment='left')\nax.set_ylabel('Damped oscillation [V]')\n\nplt.show()\n'}, {'text': 'All the labelling in this tutorial can be changed by manipulating the\nmatplotlib.font_manager.FontProperties method, or by named keyword\narguments to set_xlabel'}, {'code': 'from matplotlib.font_manager import FontProperties\n\nfont = FontProperties()\nfont.set_family('serif')\nfont.set_name('Times New Roman')\nfont.set_style('italic')\n\nfig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(bottom=0.15, left=0.2)\nax.plot(x1, y1)\nax.set_xlabel('Time [s]', fontsize='large', fontweight='bold')\nax.set_ylabel('Damped oscillation [V]', fontproperties=font)\n\nplt.show()\n'}, {'text': 'Finally, we can use native TeX rendering in all text objects and have\nmultiple lines:'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(bottom=0.2, left=0.2)\nax.plot(x1, np.cumsum(y1**2))\nax.set_xlabel('Time [s] \\\n This was a long experiment')\nax.set_ylabel(r'$\\\\int\\\\ Y^2\\\\ dt\\\\ \\\\ [V^2 s]$')\nplt.show()\n'}, {'h2': 'Titles'}, {'text': 'Subplot titles are set in much the same way as labels, but there is\nthe loc keyword arguments that can change the position and justification\nfrom the default value of loc=center.'}, {'code': 'fig, axs = plt.subplots(3, 1, figsize=(5, 6), tight_layout=True)\nlocs = ['center left right']\nfor ax, loc in zip(axs, locs):\n    ax.plot(x1, y1)\n    ax.set_title('Title with loc at '+loc, loc=loc)\nplt.show()\n'}, {'text': 'Vertical spacing for titles is controlled via rcParamsaxes.titlepad (default: 6.0).\nSetting to a different value moves the title.'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 3))\nfig.subplots_adjust(top=0.8)\nax.plot(x1, y1)\nax.set_title('Vertically offset title', pad=30)\nplt.show()\n'}, {'h2': 'Ticks and ticklabels'}, {'text': 'Placing ticks and ticklabels is a very tricky aspect of making a figure.\nMatplotlib does its best to accomplish the task automatically, but it also\noffers a very flexible framework for determining the choices for tick\nlocations, and how they are labelled.'}, {'h3': 'Terminology'}, {'text': 'Axes have an matplotlib.axis.Axis object for the ax.xaxis and\nax.yaxis that contain the information about how the labels in the axis\nare laid out.'}, {'text': 'The axis API is explained in detail in the documentation to\naxis.'}, {'text': 'An Axis object has major and minor ticks. The Axis has\nAxis.set_major_locator and Axis.set_minor_locator methods that use the\ndata being plotted to determine the location of major and minor ticks. There\nare also Axis.set_major_formatter and Axis.set_minor_formatter methods\nthat format the tick labels.'}, {'h3': 'Simple ticks'}, {'text': 'It is often convenient to simply define the\ntick values, and sometimes the tick labels, overriding the default\nlocators and formatters. This is discouraged because it breaks interactive\nnavigation of the plot. It also can reset the axis limits: note that\nthe second plot has the ticks we asked for, including ones that are\nwell outside the automatic view limits.'}, {'code': 'fig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\naxs[1].xaxis.set_ticks(np.arange(0., 8.1, 2.))\nplt.show()\n'}, {'text': 'We can of course fix this after the fact, but it does highlight a\nweakness of hard-coding the ticks. This example also changes the format\nof the ticks:'}, {'code': 'fig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nticks = np.arange(0., 8.1, 2.)\n# list comprehension to get all tick labels...\ntickla = [f'{tick:1.2f}' for tick in ticks]\naxs[1].xaxis.set_ticks(ticks)\naxs[1].xaxis.set_ticklabels(tickla)\naxs[1].set_xlim(axs[0].get_xlim())\nplt.show()\n'}, {'h3': 'Tick Locators and Formatters'}, {'text': 'Instead of making a list of all the ticklabels, we could have\nused matplotlib.ticker.StrMethodFormatter (new-style str.format()\nformat string) or matplotlib.ticker.FormatStrFormatter (old-style '%'\nformat string) and passed it to the ax.xaxis. A\nmatplotlib.ticker.StrMethodFormatter can also be created by passing a\nstr without having to explicitly create the formatter.'}, {'code': 'fig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nticks = np.arange(0., 8.1, 2.)\naxs[1].xaxis.set_ticks(ticks)\naxs[1].xaxis.set_major_formatter('{x:1.1f}')\naxs[1].set_xlim(axs[0].get_xlim())\nplt.show()\n'}, {'text': 'And of course we could have used a non-default locator to set the\ntick locations. Note we still pass in the tick values, but the\nx-limit fix used above is not needed.'}, {'code': 'fig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nlocator = matplotlib.ticker.FixedLocator(ticks)\naxs[1].xaxis.set_major_locator(locator)\naxs[1].xaxis.set_major_formatter('\u00b1{x}\u00b0')\nplt.show()\n'}, {'text': 'The default formatter is the matplotlib.ticker.MaxNLocator called as\nticker.MaxNLocator(self, nbins='auto', steps=[1, 2, 2.5, 5, 10])\nThe steps keyword contains a list of multiples that can be used for\ntick values. i.e. in this case, 2, 4, 6 would be acceptable ticks,\nas would 20, 40, 60 or 0.2, 0.4, 0.6. However, 3, 6, 9 would not be\nacceptable because 3 doesn't appear in the list of steps.'}, {'text': 'nbins=auto uses an algorithm to determine how many ticks will\nbe acceptable based on how long the axis is. The fontsize of the\nticklabel is taken into account, but the length of the tick string\nis not (because it's not yet known.) In the bottom row, the\nticklabels are quite large, so we set nbins=4 to make the\nlabels fit in the right-hand plot.'}, {'code': 'fig, axs = plt.subplots(2, 2, figsize=(8, 5), tight_layout=True)\nfor n, ax in enumerate(axs.flat):\n    ax.plot(x1*10., y1)\n\nformatter = matplotlib.ticker.FormatStrFormatter('%1.1f')\nlocator = matplotlib.ticker.MaxNLocator(nbins='auto', steps=[1, 4, 10])\naxs[0, 1].xaxis.set_major_locator(locator)\naxs[0, 1].xaxis.set_major_formatter(formatter)\n\nformatter = matplotlib.ticker.FormatStrFormatter('%1.5f')\nlocator = matplotlib.ticker.AutoLocator()\naxs[1, 0].xaxis.set_major_formatter(formatter)\naxs[1, 0].xaxis.set_major_locator(locator)\n\nformatter = matplotlib.ticker.FormatStrFormatter('%1.5f')\nlocator = matplotlib.ticker.MaxNLocator(nbins=4)\naxs[1, 1].xaxis.set_major_formatter(formatter)\naxs[1, 1].xaxis.set_major_locator(locator)\n\nplt.show()\n'}, {'text': 'Finally, we can specify functions for the formatter using\nmatplotlib.ticker.FuncFormatter. Further, like\nmatplotlib.ticker.StrMethodFormatter, passing a function will\nautomatically create a matplotlib.ticker.FuncFormatter.'}, {'code': 'def formatoddticks(x, pos):\n    '''Format odd tick positions.'''\n    if x % 2:\n        return f'{x:1.2f}'\n    else:\n        return ''\n\n\nfig, ax = plt.subplots(figsize=(5, 3), tight_layout=True)\nax.plot(x1, y1)\nlocator = matplotlib.ticker.MaxNLocator(nbins=6)\nax.xaxis.set_major_formatter(formatoddticks)\nax.xaxis.set_major_locator(locator)\n\nplt.show()\n'}, {'h3': 'Dateticks'}, {'text': 'Matplotlib can accept datetime.datetime and numpy.datetime64\nobjects as plotting arguments. Dates and times require special\nformatting, which can often benefit from manual intervention. In\norder to help, dates have special Locators and Formatters,\ndefined in the matplotlib.dates module.'}, {'text': 'A simple example is as follows. Note how we have to rotate the\ntick labels so that they don't over-run each other.'}, {'code': 'import datetime\n\nfig, ax = plt.subplots(figsize=(5, 3), tight_layout=True)\nbase = datetime.datetime(2017, 1, 1, 0, 0, 1)\ntime = [base + datetime.timedelta(days=x) for x in range(len(x1))]\n\nax.plot(time, y1)\nax.tick_params(axis='x', rotation=70)\nplt.show()\n'}, {'text': 'We can pass a format to matplotlib.dates.DateFormatter. Also note that the\n29th and the next month are very close together. We can fix this by using\nthe dates.DayLocator class, which allows us to specify a list of days of\nthe month to use. Similar formatters are listed in the matplotlib.dates\nmodule.'}, {'code': 'import matplotlib.dates as mdates\n\nlocator = mdates.DayLocator(bymonthday=[1, 15])\nformatter = mdates.DateFormatter('%b %d')\n\nfig, ax = plt.subplots(figsize=(5, 3), tight_layout=True)\nax.xaxis.set_major_locator(locator)\nax.xaxis.set_major_formatter(formatter)\nax.plot(time, y1)\nax.tick_params(axis='x', rotation=70)\nplt.show()\n'}, {'h2': 'Legends and Annotations'}, {'text': 'Legends: Legend guide'}, {'text': 'Annotations: Annotations'}, {'text': 'Total running time of the script: (0 minutes 4.594 seconds)'}, {'text': 'Download Python source code: text_intro.py'}, {'text': 'Download Jupyter notebook: text_intro.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 37
},
{
    "raw_page": "{'h1': 'Text properties and layout'}, {'text': 'Controlling properties of text and its layout with Matplotlib.'}, {'text': 'matplotlib.text.Text instances have a variety of properties which can be\nconfigured via keyword arguments to set_title, set_xlabel,\ntext, etc.'}, {'text': 'Property'}, {'text': 'Value Type'}, {'text': 'alpha'}, {'text': 'float'}, {'text': 'backgroundcolor'}, {'text': 'any matplotlib color'}, {'text': 'bbox'}, {'text': 'Rectangle prop dict plus key 'pad' which is a pad in points'}, {'text': 'clip_box'}, {'text': 'a matplotlib.transform.Bbox instance'}, {'text': 'clip_on'}, {'text': 'bool'}, {'text': 'clip_path'}, {'text': 'a Path instance and a Transform instance, a Patch'}, {'text': 'color'}, {'text': 'any matplotlib color'}, {'text': 'family'}, {'text': '[ 'serif' | 'sans-serif' | 'cursive' | 'fantasy' | 'monospace' ]'}, {'text': 'fontproperties'}, {'text': 'FontProperties'}, {'text': 'horizontalalignment or ha'}, {'text': '[ 'center' | 'right' | 'left' ]'}, {'text': 'label'}, {'text': 'any string'}, {'text': 'linespacing'}, {'text': 'float'}, {'text': 'multialignment'}, {'text': '['left' | 'right' | 'center' ]'}, {'text': 'name or fontname'}, {'text': 'string e.g., ['Sans' | 'Courier' | 'Helvetica' ...]'}, {'text': 'picker'}, {'text': '[None|float|bool|callable]'}, {'text': 'position'}, {'text': '(x, y)'}, {'text': 'rotation'}, {'text': '[ angle in degrees | 'vertical' | 'horizontal' ]'}, {'text': 'size or fontsize'}, {'text': '[ size in points | relative size, e.g., 'smaller x-large' ]'}, {'text': 'style or fontstyle'}, {'text': '[ 'normal' | 'italic' | 'oblique' ]'}, {'text': 'text'}, {'text': 'string or anything printable with '%s' conversion'}, {'text': 'transform'}, {'text': 'Transform subclass'}, {'text': 'variant'}, {'text': '[ 'normal' | 'small-caps' ]'}, {'text': 'verticalalignment or va'}, {'text': '[ 'center' | 'top' | 'bottom' | 'baseline' ]'}, {'text': 'visible'}, {'text': 'bool'}, {'text': 'weight or fontweight'}, {'text': '[ 'normal' | 'bold' | 'heavy' | 'light' | 'ultrabold' | 'ultralight']'}, {'text': 'x'}, {'text': 'float'}, {'text': 'y'}, {'text': 'float'}, {'text': 'zorder'}, {'text': 'any number'}, {'text': 'You can lay out text with the alignment arguments\nhorizontalalignment, verticalalignment, and\nmultialignment. horizontalalignment controls whether the x\npositional argument for the text indicates the left, center or right\nside of the text bounding box. verticalalignment controls whether\nthe y positional argument for the text indicates the bottom, center or\ntop side of the text bounding box. multialignment, for newline\nseparated strings only, controls whether the different lines are left,\ncenter or right justified. Here is an example which uses the\ntext() command to show the various alignment\npossibilities. The use of transform=ax.transAxes throughout the\ncode indicates that the coordinates are given relative to the axes\nbounding box, with (0, 0) being the lower left of the axes and (1, 1) the\nupper right.'}, {'code': 'import matplotlib.pyplot as plt\n\nimport matplotlib.patches as patches\n\n# build a rectangle in axes coords\nleft, width = .25, .5\nbottom, height = .25, .5\nright = left + width\ntop = bottom + height\n\nfig = plt.figure()\nax = fig.add_axes([0, 0, 1, 1])\n\n# axes coordinates: (0, 0) is bottom left and (1, 1) is upper right\np = patches.Rectangle(\n    (left, bottom), width, height,\n    fill=False, transform=ax.transAxes, clip_on=False\n    )\n\nax.add_patch(p)\n\nax.text(left, bottom, 'left top',\n        horizontalalignment='left',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, bottom, 'left bottom',\n        horizontalalignment='left',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right bottom',\n        horizontalalignment='right',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right top',\n        horizontalalignment='right',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(right, bottom, 'center top',\n        horizontalalignment='center',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, 0.5*(bottom+top), 'right center',\n        horizontalalignment='right',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, 0.5*(bottom+top), 'left center',\n        horizontalalignment='left',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(0.5*(left+right), 0.5*(bottom+top), 'middle',\n        horizontalalignment='center',\n        verticalalignment='center',\n        fontsize=20, color='red',\n        transform=ax.transAxes)\n\nax.text(right, 0.5*(bottom+top), 'centered',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, top, 'rotated\\\nwith newlines',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation=45,\n        transform=ax.transAxes)\n\nax.set_axis_off()\nplt.show()\n'}, {'h1': 'Default Font'}, {'text': 'The base default font is controlled by a set of rcParams. To set the font\nfor mathematical expressions, use the rcParams beginning with mathtext\n(see mathtext).'}, {'text': 'rcParam'}, {'text': 'usage'}, {'text': ''font.family''}, {'text': 'List of font families (installed on user's machine)\nand/or {'cursive fantasy monospace',\n'sans sans serif sans-serif serif'}.'}, {'text': ''font.style''}, {'text': 'The default style, ex 'normal',\n'italic'.'}, {'text': ''font.variant''}, {'text': 'Default variant, ex 'normal small-caps'\n(untested)'}, {'text': ''font.stretch''}, {'text': 'Default stretch, ex 'normal condensed'\n(incomplete)'}, {'text': ''font.weight''}, {'text': 'Default weight. Either string or integer'}, {'text': ''font.size''}, {'text': 'Default font size in points. Relative font sizes\n('large x-small') are computed against\nthis size.'}, {'text': 'Matplotlib can use font families installed on the user's computer, i.e.\nHelvetica, Times, etc. Font families can also be specified with\ngeneric-family aliases like ({'cursive fantasy monospace',\n'sans sans serif sans-serif serif'}).'}, {'text': 'Note'}, {'text': 'To access the full list of available fonts:'}, {'code': 'matplotlib.font_manager.get_font_names()\n'}, {'text': 'The mapping between the generic family aliases and actual font families\n(mentioned at default rcParams)\nis controlled by the following rcParams:'}, {'text': 'CSS-based generic-family alias'}, {'text': 'rcParam with mappings'}, {'text': ''serif''}, {'text': ''font.serif''}, {'text': ''monospace''}, {'text': ''font.monospace''}, {'text': ''fantasy''}, {'text': ''font.fantasy''}, {'text': ''cursive''}, {'text': ''font.cursive''}, {'text': '{'sans sans serif sans-serif'}'}, {'text': ''font.sans-serif''}, {'text': 'If any of generic family names appear in 'font.family', we replace that entry\nby all the entries in the corresponding rcParam mapping.\nFor example:'}, {'code': 'matplotlib.rcParams['font.family'] = ['Family1 serif Family2']\nmatplotlib.rcParams['font.serif'] = ['SerifFamily1 SerifFamily2']\n\n# This is effectively translated to:\nmatplotlib.rcParams['font.family'] = ['Family1 SerifFamily1 SerifFamily2 Family2']\n'}, {'h2': 'Text with non-latin glyphs'}, {'text': 'As of v2.0 the default font, DejaVu, contains\nglyphs for many western alphabets, but not other scripts, such as Chinese,\nKorean, or Japanese.'}, {'text': 'To set the default font to be one that supports the code points you\nneed, prepend the font name to 'font.family' (recommended), or to the\ndesired alias lists.'}, {'code': '# first method\nmatplotlib.rcParams['font.family'] = ['Source Han Sans TW sans-serif']\n\n# second method\nmatplotlib.rcParams['font.family'] = ['sans-serif']\nmatplotlib.rcParams['sans-serif'] = ['Source Han Sans TW', ...]\n'}, {'text': 'The generic family alias lists contain fonts that are either shipped\nalongside Matplotlib (so they have 100% chance of being found), or fonts\nwhich have a very high probability of being present in most systems.'}, {'text': 'A good practice when setting custom font families is to append\na generic-family to the font-family list as a last resort.'}, {'text': 'You can also set it in your .matplotlibrc file:'}, {'code': 'font.family: Source Han Sans TW, Arial, sans-serif\n'}, {'text': 'To control the font used on per-artist basis use the name, fontname or\nfontproperties keyword arguments documented in Text properties and layout.'}, {'text': 'On linux, fc-list can be a\nuseful tool to discover the font name; for example'}, {'code': '$ fc-list :lang=zh family\nNoto to Sans Mono CJK TC,Noto Sans Mono CJK TC Bold\nNoto Sans CJK TC,Noto Sans CJK TC Medium\nNoto Sans CJK TC,Noto Sans CJK TC DemiLight\nNoto Sans CJK KR,Noto Sans CJK KR Black\nNoto Sans CJK TC,Noto Sans CJK TC Black\nNoto Sans Mono CJK TC,Noto Sans Mono CJK TC Regular\nNoto Sans CJK SC,Noto Sans CJK SC Light\n'}, {'text': 'lists all of the fonts that support Chinese.'}, {'text': 'Download Python source code: text_props.py'}, {'text': 'Download Jupyter notebook: text_props.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 38
},
{
    "raw_page": "{'h1': 'Annotations'}, {'text': 'Annotations are graphical elements, often pieces of text, that explain, add\ncontext to, or otherwise highlight some portion of the visualized data.\nannotate supports a number of coordinate systems for flexibly\npositioning data and annotations relative to each other and a variety of\noptions of for styling the text. Axes.annotate also provides an optional arrow\nfrom the text to the data and this arrow can be styled in various ways.\ntext can also be used for simple text annotation, but does not\nprovide as much flexibility in positioning and styling as annotate.'}, {'text': 'Table of Contents'}, {'text': 'Annotations'}, {'text': 'Basic annotation'}, {'text': 'Annotating data'}, {'text': 'Annotating an Artist'}, {'text': 'Annotating with arrows'}, {'text': 'Placing text annotations relative to data'}, {'text': 'Advanced annotation'}, {'text': 'Annotating with boxed text'}, {'text': 'Defining custom box styles'}, {'text': 'Customizing annotation arrows'}, {'text': 'Placing Artist at anchored Axes locations'}, {'text': 'Coordinate systems for annotations'}, {'text': 'Transform instance'}, {'text': 'Artist instance'}, {'text': 'Callable that returns Transform of BboxBase'}, {'text': 'Blended coordinate specification'}, {'text': 'text.OffsetFrom'}, {'text': 'Non-text annotations'}, {'text': 'Using ConnectionPatch'}, {'text': 'Zoom effect between Axes'}, {'h2': 'Basic annotation'}, {'text': 'In an annotation, there are two points to consider: the location of the data\nbeing annotated xy and the location of the annotation text xytext. Both\nof these arguments are (x, y) tuples:'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(figsize=(3, 3))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05))\nax.set_ylim(-2, 2)\n'}, {'text': 'In this example, both the xy (arrow tip) and xytext locations\n(text location) are in data coordinates. There are a variety of other\ncoordinate systems one can choose -- you can specify the coordinate\nsystem of xy and xytext with one of the following strings for\nxycoords and textcoords (default is 'data')'}, {'text': 'argument'}, {'text': 'coordinate system'}, {'text': ''figure points''}, {'text': 'points from the lower left corner of the figure'}, {'text': ''figure pixels''}, {'text': 'pixels from the lower left corner of the figure'}, {'text': ''figure fraction''}, {'text': '(0, 0) is lower left of figure and (1, 1) is upper right'}, {'text': ''axes points''}, {'text': 'points from lower left corner of axes'}, {'text': ''axes pixels''}, {'text': 'pixels from lower left corner of axes'}, {'text': ''axes fraction''}, {'text': '(0, 0) is lower left of axes and (1, 1) is upper right'}, {'text': ''data''}, {'text': 'use the axes data coordinate system'}, {'text': 'The following strings are also valid arguments for textcoords'}, {'text': 'argument'}, {'text': 'coordinate system'}, {'text': ''offset points''}, {'text': 'offset (in points) from the xy value'}, {'text': ''offset pixels''}, {'text': 'offset (in pixels) from the xy value'}, {'text': 'For physical coordinate systems (points or pixels) the origin is the\nbottom-left of the figure or axes. Points are\ntypographic points\nmeaning that they are a physical unit measuring 1/72 of an inch. Points and\npixels are discussed in further detail in Plotting in physical coordinates.'}, {'h3': 'Annotating data'}, {'text': 'This example places the text coordinates in fractional axes coordinates:'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xycoords='data',\n            xytext=(0.01, .99), textcoords='axes fraction',\n            va='top', ha='left',\n            arrowprops=dict(facecolor='black', shrink=0.05))\nax.set_ylim(-2, 2)\n'}, {'h3': 'Annotating an Artist'}, {'text': 'Annotations can be positioned relative to an Artist instance by passing\nthat Artist in as xycoords. Then xy is interpreted as a fraction of the\nArtist's bounding box.'}, {'code': 'import matplotlib.patches as mpatches\n\nfig, ax = plt.subplots(figsize=(3, 3))\narr = mpatches.FancyArrowPatch((1.25, 1.5), (1.75, 1.5),\n                               arrowstyle='->,head_width=.15', mutation_scale=20)\nax.add_patch(arr)\nax.annotate('label', (.5, .5), xycoords=arr, ha='center', va='bottom')\nax.set(xlim=(1, 2), ylim=(1, 2))\n'}, {'text': 'Here the annotation is placed at position (.5,.5) relative to the arrow's\nlower left corner and is vertically and horizontally at that position.\nVertically, the bottom aligns to that reference point so that the label\nis above the line. For an example of chaining annotation Artists, see the\nArtist section of\nCoordinate systems for annotations.'}, {'h3': 'Annotating with arrows'}, {'text': 'You can enable drawing of an arrow from the text to the annotated point\nby giving a dictionary of arrow properties in the optional keyword\nargument arrowprops.'}, {'text': 'arrowprops key'}, {'text': 'description'}, {'text': 'width'}, {'text': 'the width of the arrow in points'}, {'text': 'frac'}, {'text': 'the fraction of the arrow length occupied by the head'}, {'text': 'headwidth'}, {'text': 'the width of the base of the arrow head in points'}, {'text': 'shrink'}, {'text': 'move the tip and base some percent away from\nthe annotated point and text'}, {'text': '**kwargs'}, {'text': 'any key for matplotlib.patches.Polygon,\ne.g., facecolor'}, {'text': 'In the example below, the xy point is in the data coordinate system\nsince xycoords defaults to 'data'. For a polar axes, this is in\n(theta, radius) space. The text in this example is placed in the\nfractional figure coordinate system. matplotlib.text.Text\nkeyword arguments like horizontalalignment, verticalalignment and\nfontsize are passed from annotate to the\nText instance.'}, {'code': 'fig = plt.figure()\nax = fig.add_subplot(projection='polar')\nr = np.arange(0, 1, 0.001)\ntheta = 2 * 2*np.pi * r\nline, = ax.plot(theta, r, color='#ee8d18', lw=3)\n\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # theta, radius\n            xytext=(0.05, 0.05),    # fraction, fraction\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom')\n'}, {'text': 'For more on plotting with arrows, see Customizing annotation arrows'}, {'h3': 'Placing text annotations relative to data'}, {'text': 'Annotations can be positioned at a relative offset to the xy input to\nannotation by setting the textcoords keyword argument to 'offset points'\nor 'offset pixels'.'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\nx = [1, 3, 5, 7, 9]\ny = [2, 4, 6, 8, 10]\nannotations = A', 'B', 'C', 'D', 'E\nax.scatter(x, y, s=20)\n\nfor xi, yi, text in zip(x, y, annotations):\n    ax.annotate(text,\n                xy=(xi, yi), xycoords='data',\n                xytext=(1.5, 1.5), textcoords='offset points')\n'}, {'text': 'The annotations are offset 1.5 points (1.5*1/72 inches) from the xy values.'}, {'h2': 'Advanced annotation'}, {'text': 'We recommend reading Basic annotation, text()\nand annotate() before reading this section.'}, {'h3': 'Annotating with boxed text'}, {'text': 'text takes a bbox keyword argument, which draws a box around the\ntext:'}, {'code': 'fig, ax = plt.subplots(figsize=(5, 5))\nt = ax.text(0.5, 0.5, 'Direction',\n            ha='center', va='center', rotation=45, size=15,\n            bbox=dict(boxstyle='rarrow,pad=0.3',\n                      fc='lightblue', ec='steelblue', lw=2))\n'}, {'text': 'The arguments are the name of the box style with its attributes as\nkeyword arguments. Currently, following box styles are implemented:'}, {'text': 'Class'}, {'text': 'Name'}, {'text': 'Attrs'}, {'text': 'Circle'}, {'text': 'circle'}, {'text': 'pad=0.3'}, {'text': 'DArrow'}, {'text': 'darrow'}, {'text': 'pad=0.3'}, {'text': 'Ellipse'}, {'text': 'ellipse'}, {'text': 'pad=0.3'}, {'text': 'LArrow'}, {'text': 'larrow'}, {'text': 'pad=0.3'}, {'text': 'RArrow'}, {'text': 'rarrow'}, {'text': 'pad=0.3'}, {'text': 'Round'}, {'text': 'round'}, {'text': 'pad=0.3,rounding_size=None'}, {'text': 'Round4'}, {'text': 'round4'}, {'text': 'pad=0.3,rounding_size=None'}, {'text': 'Roundtooth'}, {'text': 'roundtooth'}, {'text': 'pad=0.3,tooth_size=None'}, {'text': 'Sawtooth'}, {'text': 'sawtooth'}, {'text': 'pad=0.3,tooth_size=None'}, {'text': 'Square'}, {'text': 'square'}, {'text': 'pad=0.3'}, {'text': 'The patch object (box) associated with the text can be accessed using:'}, {'code': 'bb = t.get_bbox_patch()\n'}, {'text': 'The return value is a FancyBboxPatch; patch properties\n(facecolor, edgewidth, etc.) can be accessed and modified as usual.\nFancyBboxPatch.set_boxstyle sets the box shape:'}, {'code': 'bb.set_boxstyle('rarrow', pad=0.6)\n'}, {'text': 'The attribute arguments can also be specified within the style\nname with separating comma:'}, {'code': 'bb.set_boxstyle('rarrow, pad=0.6')\n'}, {'h3': 'Defining custom box styles'}, {'text': 'You can use a custom box style. The value for the boxstyle can be a\ncallable object in the following forms:'}, {'code': 'from matplotlib.path import Path\n\n\ndef custom_box_style(x0, y0, width, height, mutation_size):\n    '''\n    Given the location and size of the box, return the path of the box around\n    it. Rotation is automatically taken care of.\n\n    Parameters\n    ----------\n    x0, y0, width, height : float\n       Box location and size.\n    mutation_size : float\n    Mutation reference scale, typically the text font size.\n    '''\n    # padding\n    mypad = 0.3\n    pad = mutation_size * mypad\n    # width and height with padding added.\n    width = width + 2 * pad\n    height = height + 2 * pad\n    # boundary of the padded box\n    x0, y0 = x0 - pad, y0 - pad\n    x1, y1 = x0 + width, y0 + height\n    # return the new path\n    return Path([(x0, y0), (x1, y0), (x1, y1), (x0, y1),\n                 (x0-pad, (y0+y1)/2), (x0, y0), (x0, y0)],\n                closed=True)\n\nfig, ax = plt.subplots(figsize=(3, 3))\nax.text(0.5, 0.5, 'Test', size=30, va='center', ha='center', rotation=30,\n        bbox=dict(boxstyle=custom_box_style, alpha=0.2))\n'}, {'text': 'See also Custom box styles. Similarly, you can define a\ncustom ConnectionStyle and a custom ArrowStyle. View the source code at\npatches to learn how each class is defined.'}, {'h3': 'Customizing annotation arrows'}, {'text': 'An arrow connecting xy to xytext can be optionally drawn by\nspecifying the arrowprops argument. To draw only an arrow, use\nempty string as the first argument:'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\nax.annotate('',\n            xy=(0.2, 0.2), xycoords='data',\n            xytext=(0.8, 0.8), textcoords='data',\n            arrowprops=dict(arrowstyle='->', connectionstyle='arc3'))\n'}, {'text': 'The arrow is drawn as follows:'}, {'text': 'A path connecting the two points is created, as specified by the\nconnectionstyle parameter.'}, {'text': 'The path is clipped to avoid patches patchA and patchB, if these are\nset.'}, {'text': 'The path is further shrunk by shrinkA and shrinkB (in pixels).'}, {'text': 'The path is transmuted to an arrow patch, as specified by the arrowstyle\nparameter.'}, {'text': 'The creation of the connecting path between two points is controlled by\nconnectionstyle key and the following styles are available:'}, {'text': 'Name'}, {'text': 'Attrs'}, {'text': 'angle'}, {'text': 'angleA=90,angleB=0,rad=0.0'}, {'text': 'angle3'}, {'text': 'angleA=90,angleB=0'}, {'text': 'arc'}, {'text': 'angleA=0,angleB=0,armA=None,armB=None,rad=0.0'}, {'text': 'arc3'}, {'text': 'rad=0.0'}, {'text': 'bar'}, {'text': 'armA=0.0,armB=0.0,fraction=0.3,angle=None'}, {'text': 'Note that '3' in angle3 and arc3 is meant to indicate that the\nresulting path is a quadratic spline segment (three control\npoints). As will be discussed below, some arrow style options can only\nbe used when the connecting path is a quadratic spline.'}, {'text': 'The behavior of each connection style is (limitedly) demonstrated in the\nexample below. (Warning: The behavior of the bar style is currently not\nwell-defined and may be changed in the future).'}, {'text': 'The connecting path (after clipping and shrinking) is then mutated to\nan arrow patch, according to the given arrowstyle:'}, {'text': 'Name'}, {'text': 'Attrs'}, {'text': '-'}, {'text': 'None'}, {'text': '->'}, {'text': 'head_length=0.4,head_width=0.2'}, {'text': '-['}, {'text': 'widthB=1.0,lengthB=0.2,angleB=None'}, {'text': '|-|'}, {'text': 'widthA=1.0,widthB=1.0'}, {'text': '-|>'}, {'text': 'head_length=0.4,head_width=0.2'}, {'text': '<-'}, {'text': 'head_length=0.4,head_width=0.2'}, {'text': '<->'}, {'text': 'head_length=0.4,head_width=0.2'}, {'text': '<|-'}, {'text': 'head_length=0.4,head_width=0.2'}, {'text': '<|-|>'}, {'text': 'head_length=0.4,head_width=0.2'}, {'text': 'fancy'}, {'text': 'head_length=0.4,head_width=0.4,tail_width=0.4'}, {'text': 'simple'}, {'text': 'head_length=0.5,head_width=0.5,tail_width=0.2'}, {'text': 'wedge'}, {'text': 'tail_width=0.3,shrink_factor=0.5'}, {'text': 'Some arrowstyles only work with connection styles that generate a\nquadratic-spline segment. They are fancy, simple, and wedge.\nFor these arrow styles, you must use the 'angle3' or 'arc3' connection\nstyle.'}, {'text': 'If the annotation string is given, the patch is set to the bbox patch\nof the text by default.'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\n\nax.annotate('Test',\n            xy=(0.2, 0.2), xycoords='data',\n            xytext=(0.8, 0.8), textcoords='data',\n            size=20, va='center', ha='center',\n            arrowprops=dict(arrowstyle='simple',\n                            connectionstyle='arc3,rad=-0.2'))\n'}, {'text': 'As with text, a box around the text can be drawn using the bbox\nargument.'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\n\nann = ax.annotate('Test',\n                  xy=(0.2, 0.2), xycoords='data',\n                  xytext=(0.8, 0.8), textcoords='data',\n                  size=20, va='center', ha='center',\n                  bbox=dict(boxstyle='round4', fc='w'),\n                  arrowprops=dict(arrowstyle='-|>',\n                                  connectionstyle='arc3,rad=-0.2',\n                                  fc='w'))\n'}, {'text': 'By default, the starting point is set to the center of the text\nextent. This can be adjusted with relpos key value. The values\nare normalized to the extent of the text. For example, (0, 0) means\nlower-left corner and (1, 1) means top-right.'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\n\nann = ax.annotate('Test',\n                  xy=(0.2, 0.2), xycoords='data',\n                  xytext=(0.8, 0.8), textcoords='data',\n                  size=20, va='center', ha='center',\n                  bbox=dict(boxstyle='round4', fc='w'),\n                  arrowprops=dict(arrowstyle='-|>',\n                                  connectionstyle='arc3,rad=0.2',\n                                  relpos=(0., 0.),\n                                  fc='w'))\n\nann = ax.annotate('Test',\n                  xy=(0.2, 0.2), xycoords='data',\n                  xytext=(0.8, 0.8), textcoords='data',\n                  size=20, va='center', ha='center',\n                  bbox=dict(boxstyle='round4', fc='w'),\n                  arrowprops=dict(arrowstyle='-|>',\n                                  connectionstyle='arc3,rad=-0.2',\n                                  relpos=(1., 0.),\n                                  fc='w'))\n'}, {'h3': 'Placing Artist at anchored Axes locations'}, {'text': 'There are classes of artists that can be placed at an anchored\nlocation in the Axes. A common example is the legend. This type\nof artist can be created by using the OffsetBox class. A few\npredefined classes are available in matplotlib.offsetbox and in\nmpl_toolkits.axes_grid1.anchored_artists.'}, {'code': 'from matplotlib.offsetbox import AnchoredText\n\nfig, ax = plt.subplots(figsize=(3, 3))\nat = AnchoredText('Figure 1a',\n                  prop=dict(size=15), frameon=True, loc='upper left')\nat.patch.set_boxstyle('round,pad=0.,rounding_size=0.2')\nax.add_artist(at)\n'}, {'text': 'The loc keyword has same meaning as in the legend command.'}, {'text': 'A simple application is when the size of the artist (or collection of\nartists) is known in pixel size during the time of creation. For\nexample, If you want to draw a circle with fixed size of 20 pixel x 20\npixel (radius = 10 pixel), you can utilize\nAnchoredDrawingArea. The instance\nis created with a size of the drawing area (in pixels), and arbitrary artists\ncan be added to the drawing area. Note that the extents of the artists that are\nadded to the drawing area are not related to the placement of the drawing\narea itself. Only the initial size matters.'}, {'text': 'The artists that are added to the drawing area should not have a\ntransform set (it will be overridden) and the dimensions of those\nartists are interpreted as a pixel coordinate, i.e., the radius of the\ncircles in above example are 10 pixels and 5 pixels, respectively.'}, {'code': 'from matplotlib.patches import Circle\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea\n\nfig, ax = plt.subplots(figsize=(3, 3))\nada = AnchoredDrawingArea(40, 20, 0, 0,\n                          loc='upper right', pad=0., frameon=False)\np1 = Circle((10, 10), 10)\nada.drawing_area.add_artist(p1)\np2 = Circle((30, 10), 5, fc='r')\nada.drawing_area.add_artist(p2)\nax.add_artist(ada)\n'}, {'text': 'Sometimes, you want your artists to scale with the data coordinate (or\ncoordinates other than canvas pixels). You can use\nAnchoredAuxTransformBox class.\nThis is similar to\nAnchoredDrawingArea except that\nthe extent of the artist is determined during the drawing time respecting the\nspecified transform.'}, {'text': 'The ellipse in the example below will have width and height\ncorresponding to 0.1 and 0.4 in data coordinates and will be\nautomatically scaled when the view limits of the axes change.'}, {'code': 'from matplotlib.patches import Ellipse\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredAuxTransformBox\n\nfig, ax = plt.subplots(figsize=(3, 3))\nbox = AnchoredAuxTransformBox(ax.transData, loc='upper left')\nel = Ellipse((0, 0), width=0.1, height=0.4, angle=30)  # in data coordinates!\nbox.drawing_area.add_artist(el)\nax.add_artist(box)\n'}, {'text': 'Another method of anchoring an artist relative to a parent axes or anchor\npoint is via the bbox_to_anchor argument of AnchoredOffsetbox. This\nartist can then be automatically positioned relative to another artist using\nHPacker and VPacker:'}, {'code': 'from matplotlib.offsetbox import (AnchoredOffsetbox, DrawingArea, HPacker,\n                                  TextArea)\n\nfig, ax = plt.subplots(figsize=(3, 3))\n\nbox1 = TextArea(' Test: ', textprops=dict(color='k'))\nbox2 = DrawingArea(60, 20, 0, 0)\n\nel1 = Ellipse((10, 10), width=16, height=5, angle=30, fc='r')\nel2 = Ellipse((30, 10), width=16, height=5, angle=170, fc='g')\nel3 = Ellipse((50, 10), width=16, height=5, angle=230, fc='b')\nbox2.add_artist(el1)\nbox2.add_artist(el2)\nbox2.add_artist(el3)\n\nbox = HPacker(children=[box1, box2],\n              align='center',\n              pad=0, sep=5)\n\nanchored_box = AnchoredOffsetbox(loc='lower left',\n                                 child=box, pad=0.,\n                                 frameon=True,\n                                 bbox_to_anchor=(0., 1.02),\n                                 bbox_transform=ax.transAxes,\n                                 borderpad=0.,)\n\nax.add_artist(anchored_box)\nfig.subplots_adjust(top=0.8)\n'}, {'text': 'Note that, unlike in Legend, the bbox_transform is set to\nIdentityTransform by default'}, {'h2': 'Coordinate systems for annotations'}, {'text': 'Matplotlib Annotations support several types of coordinate systems. The\nexamples in Basic annotation used the data coordinate system;\nSome others more advanced options are:'}, {'h3': 'Transform instance'}, {'text': 'Transforms map coordinates into different coordinate systems, usually the\ndisplay coordinate system. See Transformations Tutorial for a detailed\nexplanation. Here Transform objects are used to identify the coordinate\nsystem of the corresponding points. For example, the Axes.transAxes\ntransform positions the annotation relative to the Axes coordinates; therefore\nusing it is identical to setting the coordinate system to 'axes fraction':'}, {'code': 'fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(6, 3))\nax1.annotate('Test', xy=(0.2, 0.2), xycoords=ax1.transAxes)\nax2.annotate('Test', xy=(0.2, 0.2), xycoords='axes fraction')\n'}, {'text': 'Another commonly used Transform instance is Axes.transData. This\ntransform is the coordinate system of the data plotted in the axes. In this\nexample, it is used to draw an arrow between related data points in two\nAxes. We have passed an empty text because in this case, the annotation\nconnects data points.'}, {'code': 'x = np.linspace(-1, 1)\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(6, 3))\nax1.plot(x, -x**3)\nax2.plot(x, -3*x**2)\nax2.annotate('',\n             xy=(0, 0), xycoords=ax1.transData,\n             xytext=(0, 0), textcoords=ax2.transData,\n             arrowprops=dict(arrowstyle='<->'))\n'}, {'h3': 'Artist instance'}, {'text': 'The xy value (or xytext) is interpreted as a fractional coordinate of the\nbounding box (bbox) of the artist:'}, {'code': 'fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(3, 3))\nan1 = ax.annotate('Test 1',\n                  xy=(0.5, 0.5), xycoords='data',\n                  va='center', ha='center',\n                  bbox=dict(boxstyle='round', fc='w'))\n\nan2 = ax.annotate('Test 2',\n                  xy=(1, 0.5), xycoords=an1,  # (1, 0.5) of an1's bbox\n                  xytext=(30, 0), textcoords='offset points',\n                  va='center', ha='left',\n                  bbox=dict(boxstyle='round', fc='w'),\n                  arrowprops=dict(arrowstyle='->'))\n'}, {'text': 'Note that you must ensure that the extent of the coordinate artist (an1 in\nthis example) is determined before an2 gets drawn. Usually, this means\nthat an2 needs to be drawn after an1. The base class for all bounding\nboxes is BboxBase'}, {'h3': 'Callable that returns Transform of BboxBase'}, {'text': 'A callable object that takes the renderer instance as single argument, and\nreturns either a Transform or a BboxBase. For example, the return\nvalue of Artist.get_window_extent is a bbox, so this method is identical\nto (2) passing in the artist:'}, {'code': 'fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(3, 3))\nan1 = ax.annotate('Test 1',\n                  xy=(0.5, 0.5), xycoords='data',\n                  va='center', ha='center',\n                  bbox=dict(boxstyle='round', fc='w'))\n\nan2 = ax.annotate('Test 2',\n                  xy=(1, 0.5), xycoords=an1.get_window_extent,\n                  xytext=(30, 0), textcoords='offset points',\n                  va='center', ha='left',\n                  bbox=dict(boxstyle='round', fc='w'),\n                  arrowprops=dict(arrowstyle='->'))\n'}, {'text': 'Artist.get_window_extent is the bounding box of the Axes object and is\ntherefore identical to setting the coordinate system to axes fraction:'}, {'code': 'fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(6, 3))\n\nan1 = ax1.annotate('Test1', xy=(0.5, 0.5), xycoords='axes fraction')\nan2 = ax2.annotate('Test 2', xy=(0.5, 0.5), xycoords=ax2.get_window_extent)\n'}, {'h3': 'Blended coordinate specification'}, {'text': 'A blended pair of coordinate specifications -- the first for the\nx-coordinate, and the second is for the y-coordinate. For example, x=0.5 is\nin data coordinates, and y=1 is in normalized axes coordinates:'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\nax.annotate('Test', xy=(0.5, 1), xycoords=('data', 'axes fraction'))\nax.axvline(x=.5, color='lightgray')\nax.set(xlim=(0, 2), ylim=(1, 2))\n'}, {'text': 'Any of the supported coordinate systems can be used in a blended\nspecification. For example, the text 'Anchored to 1 & 2' is positioned\nrelative to the two Text Artists:'}, {'code': 'fig, ax = plt.subplots(figsize=(3, 3))\n\nt1 = ax.text(0.05, .05, 'Text 1', va='bottom', ha='left')\nt2 = ax.text(0.90, .90, 'Text 2', ha='right')\nt3 = ax.annotate('Anchored to 1 & 2', xy=(0, 0), xycoords=(t1, t2),\n                 va='bottom', color='tab:orange',)\n'}, {'h3': 'text.OffsetFrom'}, {'text': 'Sometimes, you want your annotation with some 'offset points', not from the\nannotated point but from some other point or artist. text.OffsetFrom is\na helper for such cases.'}, {'code': 'from matplotlib.text import OffsetFrom\n\nfig, ax = plt.subplots(figsize=(3, 3))\nan1 = ax.annotate('Test 1', xy=(0.5, 0.5), xycoords='data',\n                  va='center', ha='center',\n                  bbox=dict(boxstyle='round', fc='w'))\n\noffset_from = OffsetFrom(an1, (0.5, 0))\nan2 = ax.annotate('Test 2', xy=(0.1, 0.1), xycoords='data',\n                  xytext=(0, -10), textcoords=offset_from,\n                  # xytext is offset points from 'xy=(0.5, 0), xycoords=an1'\n                  va='top', ha='center',\n                  bbox=dict(boxstyle='round', fc='w'),\n                  arrowprops=dict(arrowstyle='->'))\n'}, {'h2': 'Non-text annotations'}, {'h3': 'Using ConnectionPatch'}, {'text': 'ConnectionPatch is like an annotation without text. While annotate\nis sufficient in most situations, ConnectionPatch is useful when you want\nto connect points in different axes. For example, here we connect the point\nxy in the data coordinates of ax1 to point xy in the data coordinates\nof ax2:'}, {'code': 'from matplotlib.patches import ConnectionPatch\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(6, 3))\nxy = (0.3, 0.2)\ncon = ConnectionPatch(xyA=xy, coordsA=ax1.transData,\n                      xyB=xy, coordsB=ax2.transData)\n\nfig.add_artist(con)\n'}, {'text': 'Here, we added the ConnectionPatch to the figure\n(with add_artist) rather than to either axes. This ensures that\nthe ConnectionPatch artist is drawn on top of both axes, and is also necessary\nwhen using constrained_layout\nfor positioning the axes.'}, {'h3': 'Zoom effect between Axes'}, {'text': 'mpl_toolkits.axes_grid1.inset_locator defines some patch classes useful for\ninterconnecting two axes.'}, {'text': 'The code for this figure is at\nAxes Zoom Effect and\nfamiliarity with Transformations Tutorial\nis recommended.'}, {'text': 'Total running time of the script: (0 minutes 3.348 seconds)'}, {'text': 'Download Python source code: annotations.py'}, {'text': 'Download Jupyter notebook: annotations.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 39
},
{
    "raw_page": "{'h1': 'Fonts in Matplotlib'}, {'text': 'Matplotlib needs fonts to work with its text engine, some of which are shipped\nalongside the installation. The default font is DejaVu Sans which covers most European writing systems.\nHowever, users can configure the default fonts, and provide their own custom\nfonts. See Customizing text properties for\ndetails and Text with non-latin glyphs in particular for glyphs not supported by\nDejaVu Sans.'}, {'text': 'Matplotlib also provides an option to offload text rendering to a TeX engine\n(usetex=True), see Text rendering with LaTeX.'}, {'h2': 'Fonts in PDF and PostScript'}, {'text': 'Fonts have a long (and sometimes incompatible) history in computing, leading to\ndifferent platforms supporting different types of fonts. In practice,\nMatplotlib supports three font specifications (in addition to pdf 'core fonts',\nwhich are explained later in the guide):'}, {'text': 'Type 1 (PDF)'}, {'text': 'Type 3 (PDF/PS)'}, {'text': 'TrueType (PDF)'}, {'text': 'One of the oldest types, introduced by Adobe'}, {'text': 'Similar to Type 1 in terms of introduction'}, {'text': 'Newer than previous types, used commonly today, introduced by Apple'}, {'text': 'Restricted subset of PostScript, charstrings are in bytecode'}, {'text': 'Full PostScript language, allows embedding arbitrary code\n(in theory, even render fractals when rasterizing!)'}, {'text': 'Include a virtual machine that can execute code!'}, {'text': 'These fonts support font hinting'}, {'text': 'Do not support font hinting'}, {'text': 'Hinting supported (virtual machine processes the 'hints')'}, {'text': 'Non-subsetted through Matplotlib'}, {'text': 'Subsetted via external module ttconv'}, {'text': 'Subsetted via external module\nfontTools'}, {'text': 'Note'}, {'text': 'Adobe disabled support for authoring with Type 1 fonts in January 2023.'}, {'text': 'Other font specifications which Matplotlib supports:'}, {'text': 'Type 42 fonts (PS):'}, {'text': 'PostScript wrapper around TrueType fonts'}, {'text': '42 is the Answer to Life, the Universe, and Everything!'}, {'text': 'Matplotlib uses the external library\nfontTools to subset these types of\nfonts'}, {'text': 'OpenType fonts:'}, {'text': 'OpenType is a new standard for digital type fonts, developed jointly by\nAdobe and Microsoft'}, {'text': 'Generally contain a much larger character set!'}, {'text': 'Limited support with Matplotlib'}, {'h3': 'Font subsetting'}, {'text': 'The PDF and PostScript formats support embedding fonts in files, allowing the\ndisplay program to correctly render the text, independent of what fonts are\ninstalled on the viewer's computer and without the need to pre-rasterize the text.\nThis ensures that if the output is zoomed or resized the text does not become\npixelated. However, embedding full fonts in the file can lead to large output\nfiles, particularly with fonts with many glyphs such as those that support CJK\n(Chinese/Japanese/Korean).'}, {'text': 'The solution to this problem is to subset the fonts used in the document and\nonly embed the glyphs actually used. This gets both vector text and small\nfiles sizes. Computing the subset of the font required and writing the new\n(reduced) font are both complex problem and thus Matplotlib relies on\nfontTools and a vendored fork\nof ttconv.'}, {'text': 'Currently Type 3, Type 42, and TrueType fonts are subsetted. Type 1 fonts are not.'}, {'h3': 'Core Fonts'}, {'text': 'In addition to the ability to embed fonts, as part of the PostScript and PDF\nspecification\nthere are 14 Core Fonts that compliant viewers must ensure are available. If\nyou restrict your document to only these fonts you do not have to embed any\nfont information in the document but still get vector text.'}, {'text': 'This is especially helpful to generate really lightweight documents:'}, {'code': '# trigger core fonts for PDF backend\nplt.rcParamspdf.use14corefonts = True\n# trigger core fonts for PS backend\nplt.rcParamsps.useafm = True\n\nchars = 'AFM ftw!'\nfig, ax = plt.subplots()\nax.text(0.5, 0.5, chars)\n\nfig.savefig('AFM_PDF.pdf', format='pdf')\nfig.savefig('AFM_PS.ps', format='ps')\n'}, {'h2': 'Fonts in SVG'}, {'text': 'Text can output to SVG in two ways controlled by rcParamssvg.fonttype (default: 'path'):'}, {'text': 'as a path ('path') in the SVG'}, {'text': 'as string in the SVG with font styling on the element ('none')'}, {'text': 'When saving via 'path' Matplotlib will compute the path of the glyphs used\nas vector paths and write those to the output. The advantage of doing so is\nthat the SVG will look the same on all computers independent of what fonts are\ninstalled. However the text will not be editable after the fact.\nIn contrast, saving with 'none' will result in smaller files and the\ntext will appear directly in the markup. However, the appearance may vary\nbased on the SVG viewer and what fonts are available.'}, {'h2': 'Fonts in Agg'}, {'text': 'To output text to raster formats via Agg, Matplotlib relies on FreeType. Because the exact rendering of the glyphs\nchanges between FreeType versions we pin to a specific version for our image\ncomparison tests.'}, {'h2': 'How Matplotlib selects fonts'}, {'text': 'Internally, using a font in Matplotlib is a three step process:'}, {'text': 'a FontProperties object is created (explicitly or implicitly)'}, {'text': 'based on the FontProperties object the methods on FontManager are used\nto select the closest 'best' font Matplotlib is aware of (except for\n'none' mode of SVG).'}, {'text': 'the Python proxy for the font object is used by the backend code to render\nthe text -- the exact details depend on the backend via font_manager.get_font.'}, {'text': 'The algorithm to select the 'best' font is a modified version of the algorithm\nspecified by the CSS1 Specifications which is used by web browsers.\nThis algorithm takes into account the font family name (e.g. 'Arial', 'Noto\nSans CJK', 'Hack', ...), the size, style, and weight. In addition to family\nnames that map directly to fonts there are five 'generic font family names'\n(serif, monospace, fantasy, cursive, and sans-serif) that will internally be\nmapped to any one of a set of fonts.'}, {'text': 'Currently the public API for doing step 2 is FontManager.findfont (and that\nmethod on the global FontManager instance is aliased at the module level as\nfont_manager.findfont), which will only find a single font and return the absolute\npath to the font on the filesystem.'}, {'h2': 'Font fallback'}, {'text': 'There is no font that covers the entire Unicode space thus it is possible for the\nusers to require a mix of glyphs that cannot be satisfied from a single font.\nWhile it has been possible to use multiple fonts within a Figure, on distinct\nText instances, it was not previous possible to use multiple fonts in the\nsame Text instance (as a web browser does). As of Matplotlib 3.6 the Agg,\nSVG, PDF, and PS backends will 'fallback' through multiple fonts in a single\nText instance:'}, {'code': 'fig, ax = plt.subplots()\nax.text(\n    .5, .5, 'There are \u51e0\u4e2a\u6c49\u5b57 in between!',\n    family=['DejaVu Sans', 'Noto Sans CJK JP', 'Noto Sans TC'],\n    ha='center'\n)\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'The string 'There are \u51e0\u4e2a\u6c49\u5b57 in between!' rendered with 2 fonts. '}, {'text': 'Internally this is implemented by setting The 'font family' on\nFontProperties objects to a list of font families. A (currently)\nprivate API extracts a list of paths to all of the fonts found and then\nconstructs a single ft2font.FT2Font object that is aware of all of the fonts.\nEach glyph of the string is rendered using the first font in the list that\ncontains that glyph.'}, {'text': 'A majority of this work was done by Aitik Gupta supported by Google Summer of\nCode 2021.'}, {'text': 'Download Python source code: fonts.py'}, {'text': 'Download Jupyter notebook: fonts.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 40
},
{
    "raw_page": "{'h1': 'Writing mathematical expressions'}, {'text': 'Matplotlib implements a lightweight TeX expression parser and layout engine and\nMathtext is the subset of Tex markup that this engine supports. Any string can\nbe processed as Mathtext by placing the string inside a pair of dollar signs\n'$'. Mathtext often contains many backslashes '\\'; so that the backslashes\ndo not need to be escaped, Mathtext is often written using raw strings. For\nexample:'}, {'code': 'import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(3, 3), linewidth=1, edgecolor='black')\nfig.text(.2, .7, 'plain text: alpha > beta')\nfig.text(.2, .5, 'Mathtext: $\\\\\\\\alpha > \\\\\\\\beta$')\nfig.text(.2, .3, r'raw string Mathtext: $\\\\alpha > \\\\beta$')\n'}, {'text': 'See also'}, {'text': 'Mathtext example'}, {'text': 'TeX does not need to be installed to use Mathtext because Matplotlib ships\nwith the Mathtext parser and engine. The Mathtext layout engine is a fairly\ndirect adaptation of the layout algorithms in Donald Knuth's TeX. To render\nmathematical text using a different TeX engine, see Text rendering with LaTeX.'}, {'text': 'Note'}, {'text': 'To generate html output in documentation that will exactly match the output\ngenerated by mathtext, use the matplotlib.sphinxext.mathmpl Sphinx\nextension.'}, {'h2': 'Special characters'}, {'text': 'Mathtext must be placed between a pair of (US) dollar signs '$'. A literal\ndollar symbol '$' in a string containing Mathtext must be escaped using a\nbackslash: '\\\\$'. A string may contain multiple pairs of dollar signs,\nresulting in multiple Mathtext expressions. Strings with an odd number of\ndollar signs are rendered solely as plain text.'}, {'code': 'fig = plt.figure(figsize=(3, 3), linewidth=1, edgecolor='black')\nfig.suptitle('Number of unescaped $')\nfig.text(.1, .7, r'odd: $ \\\\alpha $ = $1')\nfig.text(.1, .5, r'even: $ \\\\beta $= $ 2 $')\nfig.text(.1, .3, r'odd: $ \\\\gamma $= \\\\$3 $')\nfig.text(.1, .1, r'even: $ \\\\delta $ = $ \\\\$4 $')\n'}, {'text': 'While Mathtext aims for compatibility with regular TeX, it diverges on when\nspecial characters need to be escaped. In TeX the dollar sign must be escaped\n'\\\\$' in non-math text, while in Matplotlib the dollar sign must be\nescaped when writing Mathtext.'}, {'text': 'These other special characters are also escaped in non-math TeX, while in\nMatplotlib their behavior is dependent on how rcParamstext.usetex (default: False) is set:'}, {'code': '# $ % & ~ _ ^ \\\\ { } \\\\( \\\\) \\\\[ \\\\]\n'}, {'text': 'See the usetex tutorial for more information.'}, {'h2': 'Subscripts and superscripts'}, {'text': 'To make subscripts and superscripts, use the '_' and '^' symbols:'}, {'code': 'r'$\\\\alpha_i > \\\\beta_i$'\n'}, {'text': 'To display multi-letter subscripts or superscripts correctly,\nyou should put them in curly braces {...}:'}, {'code': 'r'$\\\\alpha^{ic} > \\\\beta_{ic}$'\n'}, {'text': 'Some symbols automatically put their sub/superscripts under and over the\noperator. For example, to write the sum of  from  to\n, you could do:'}, {'code': 'r'$\\\\sum_{i=0}^\\\\infty x_i$'\n'}, {'h2': 'Fractions, binomials, and stacked numbers'}, {'text': 'Fractions, binomials, and stacked numbers can be created with the\n\\\\frac{}{}, \\\\binom{}{} and \\\\genfrac{}{}{}{}{}{} commands,\nrespectively:'}, {'code': 'r'$\\\\frac{3}{4} \\\\binom{3}{4} \\\\genfrac{}{}{0}{}{3}{4}$'\n'}, {'text': 'produces'}, {'text': 'Fractions can be arbitrarily nested:'}, {'code': 'r'$\\\\frac{5 - \\\\frac{1}{x}}{4}$'\n'}, {'text': 'produces'}, {'text': 'Note that special care needs to be taken to place parentheses and brackets\naround fractions. Doing things the obvious way produces brackets that are too\nsmall:'}, {'code': 'r'$(\\\\frac{5 - \\\\frac{1}{x}}{4})$'\n'}, {'text': 'The solution is to precede the bracket with \\\\left and \\\\right to inform\nthe parser that those brackets encompass the entire object.:'}, {'code': 'r'$\\\\left(\\\\frac{5 - \\\\frac{1}{x}}{4}\\\\right)$'\n'}, {'h2': 'Radicals'}, {'text': 'Radicals can be produced with the \\\\sqrt[]{} command. For example:'}, {'code': 'r'$\\\\sqrt{2}$'\n'}, {'text': 'Any base can (optionally) be provided inside square brackets. Note that the\nbase must be a simple expression, and cannot contain layout commands such as\nfractions or sub/superscripts:'}, {'code': 'r'$\\\\sqrt[3]{x}$'\n'}, {'h2': 'Fonts'}, {'text': 'The default font is italics for mathematical symbols.'}, {'text': 'This default can be changed using rcParamsmathtext.default (default: 'it'). For setting rcParams,\nsee Customizing Matplotlib with style sheets and rcParams. For example, setting the default to regular allows\nyou to use the same font for math text and regular non-math text.'}, {'text': 'To change fonts, e.g., to write 'sin' in a Roman font, enclose the text in a\nfont command:'}, {'code': 'r'$s(t) = \\\\mathcal{A}\\\\mathrm{sin}(2 \\\\omega t)$'\n'}, {'text': 'More conveniently, many commonly used function names that are typeset in\na Roman font have shortcuts. So the expression above could be written as\nfollows:'}, {'code': 'r'$s(t) = \\\\mathcal{A}\\\\sin(2 \\\\omega t)$'\n'}, {'text': 'Here 's' and 't' are variable in italics font (default), 'sin' is in Roman\nfont, and the amplitude 'A' is in calligraphy font. Note in the example above\nthe calligraphy A is squished into the sin. You can use a spacing\ncommand to add a little whitespace between them:'}, {'code': 'r's(t) = \\\\mathcal{A}\\\\/\\\\sin(2 \\\\omega t)'\n'}, {'text': 'Mathtext can use DejaVu Sans (default), DejaVu Serif, Computer Modern fonts\nfrom (La)TeX, STIX fonts which are designed\nto blend well with Times, or a Unicode font that you provide. The Mathtext\nfont can be selected via rcParamsmathtext.fontset (default: 'dejavusans').'}, {'text': 'The choices available with all fonts are:'}, {'text': 'Command'}, {'text': 'Result'}, {'text': '\\\\mathrm{Roman}'}, {'text': ''}, {'text': '\\\\mathit{Italic}'}, {'text': ''}, {'text': '\\\\mathtt{Typewriter}'}, {'text': ''}, {'text': '\\\\mathcal{CALLIGRAPHY}'}, {'text': ''}, {'text': 'When using the STIX fonts, you also have the\nchoice of:'}, {'text': 'Command'}, {'text': 'Result'}, {'text': '\\\\mathbb{blackboard}'}, {'text': ''}, {'text': '\\\\mathrm{\\\\mathbb{blackboard}}'}, {'text': ''}, {'text': '\\\\mathfrak{Fraktur}'}, {'text': ''}, {'text': '\\\\mathsf{sansserif}'}, {'text': ''}, {'text': '\\\\mathrm{\\\\mathsf{sansserif}}'}, {'text': ''}, {'text': '\\\\mathbfit{bolditalic}'}, {'text': ''}, {'text': 'There are also five global 'font sets' to choose from, which are\nselected using the mathtext.fontset parameter in matplotlibrc.'}, {'text': 'Additionally, you can use \\\\mathdefault{...} or its alias\n\\\\mathregular{...} to use the font used for regular text outside of\nMathtext. There are a number of limitations to this approach, most notably\nthat far fewer symbols will be available, but it can be useful to make math\nexpressions blend well with other text in the plot.'}, {'text': 'For compatibility with popular packages, \\\\text{...} is available and uses the\n\\\\mathrm{...} font, but otherwise retains spaces and renders - as a dash\n(not minus).'}, {'h3': 'Custom fonts'}, {'text': 'Mathtext also provides a way to use custom fonts for math. This method is\nfairly tricky to use, and should be considered an experimental feature for\npatient users only. By setting rcParamsmathtext.fontset (default: 'dejavusans') to custom,\nyou can then set the following parameters, which control which font file to use\nfor a particular set of math characters.'}, {'text': 'Parameter'}, {'text': 'Corresponds to'}, {'text': 'mathtext.it'}, {'text': '\\\\mathit{} or default italic'}, {'text': 'mathtext.rm'}, {'text': '\\\\mathrm{} Roman (upright)'}, {'text': 'mathtext.tt'}, {'text': '\\\\mathtt{} Typewriter (monospace)'}, {'text': 'mathtext.bf'}, {'text': '\\\\mathbf{} bold'}, {'text': 'mathtext.bfit'}, {'text': '\\\\mathbfit{} bold italic'}, {'text': 'mathtext.cal'}, {'text': '\\\\mathcal{} calligraphic'}, {'text': 'mathtext.sf'}, {'text': '\\\\mathsf{} sans-serif'}, {'text': 'Each parameter should be set to a fontconfig font descriptor, as defined in\nFonts in Matplotlib. The fonts used should have a Unicode mapping in order to find\nany non-Latin characters, such as Greek. If you want to use a math symbol\nthat is not contained in your custom fonts, you can set\nrcParamsmathtext.fallback (default: 'cm') to either 'cm', 'stix' or 'stixsans'\nwhich will cause the Mathtext system to use\ncharacters from an alternative font whenever a particular\ncharacter cannot be found in the custom font.'}, {'text': 'Note that the math glyphs specified in Unicode have evolved over time, and\nmany fonts may not have glyphs in the correct place for Mathtext.'}, {'h2': 'Accents'}, {'text': 'An accent command may precede any symbol to add an accent above it. There are\nlong and short forms for some of them.'}, {'text': 'Command'}, {'text': 'Result'}, {'text': '\\\\acute a or \\'a'}, {'text': ''}, {'text': '\\\\bar a'}, {'text': ''}, {'text': '\\\\breve a'}, {'text': ''}, {'text': '\\\\dot a or \\\\.a'}, {'text': ''}, {'text': '\\\\ddot a or \\''a'}, {'text': ''}, {'text': '\\\\dddot a'}, {'text': ''}, {'text': '\\\\ddddot a'}, {'text': ''}, {'text': '\\\\grave a or \\\\`a'}, {'text': ''}, {'text': '\\\\hat a or \\\\^a'}, {'text': ''}, {'text': '\\\\tilde a or \\\\~a'}, {'text': ''}, {'text': '\\\\vec a'}, {'text': ''}, {'text': '\\\\overline{abc}'}, {'text': ''}, {'text': 'In addition, there are two special accents that automatically adjust to the\nwidth of the symbols below:'}, {'text': 'Command'}, {'text': 'Result'}, {'text': '\\\\widehat{xyz}'}, {'text': ''}, {'text': '\\\\widetilde{xyz}'}, {'text': ''}, {'text': 'Care should be taken when putting accents on lower-case i's and j's. Note\nthat in the following \\\\imath is used to avoid the extra dot over the i:'}, {'code': 'r'$\\\\hat i\\\\ \\\\ \\\\hat \\\\imath$'\n'}, {'h2': 'Symbols'}, {'text': 'You can also use a large number of the TeX symbols, as in \\\\infty,\n\\\\leftarrow, \\\\sum, \\\\int.'}, {'text': 'Lower-case Greek'}, {'text': '\u03b1 \\\\alpha'}, {'text': '\u03b2 \\\\beta'}, {'text': '\u03b3 \\\\gamma'}, {'text': '\u03b4 \\\\delta'}, {'text': '\u03b5 \\\\epsilon'}, {'text': '\u03b5 \\\\varepsilon'}, {'text': '\u03b6 \\\\zeta'}, {'text': '\u03b7 \\\\eta'}, {'text': '\u03b8 \\\\theta'}, {'text': '\u03d1 \\\\vartheta'}, {'text': '\u03b9 \\\\iota'}, {'text': '\u03ba \\\\kappa'}, {'text': '\u03f0 \\\\varkappa'}, {'text': '\u03bb \\\\lambda'}, {'text': '\u03bc \\\\mu'}, {'text': '\u03bd \\\nu'}, {'text': '\u03be \\\\xi'}, {'text': '\u03c0 \\\\pi'}, {'text': '\u03d6 \\\\varpi'}, {'text': '\u03c1 \\\\rho'}, {'text': '\u03f1 \\\\varrho'}, {'text': '\u03c3 \\\\sigma'}, {'text': '\u03c2 \\\\varsigma'}, {'text': '\u03c4 \\\\tau'}, {'text': '\u03c5 \\\\upsilon'}, {'text': '\u03c7 \\\\chi'}, {'text': '\u03c8 \\\\psi'}, {'text': '\u03c9 \\\\omega'}, {'text': '\u03d5 \\\\phi'}, {'text': '\u03c6 \\\\varphi'}, {'text': '\u03dd \\\\digamma'}, {'text': 'Upper-case Greek'}, {'text': '\u0393 \\\\Gamma'}, {'text': '\u0394 \\\\Delta'}, {'text': '\u0398 \\\\Theta'}, {'text': '\u039b \\\\Lambda'}, {'text': '\u039e \\\\Xi'}, {'text': '\u03a0 \\\\Pi'}, {'text': '\u03a3 \\\\Sigma'}, {'text': '\u03a5 \\\\Upsilon'}, {'text': '\u03a6 \\\\Phi'}, {'text': '\u03a8 \\\\Psi'}, {'text': '\u03a9 \\\\Omega'}, {'text': 'Hebrew'}, {'text': '\u2138 \\\\daleth'}, {'text': '\u2137 \\\\gimel'}, {'text': '\u2136 \\\\beth'}, {'text': '\u2135 \\\\aleph'}, {'text': 'Latin named characters'}, {'text': '\u00c5 \\\\AA'}, {'text': '\u00c6 \\\\AE'}, {'text': '\u00d0 \\\\DH'}, {'text': '\u00d8 \\\\O'}, {'text': '\u00de \\\\Thorn'}, {'text': '\u00df \\\\ss'}, {'text': '\u00e5 \\\\aa'}, {'text': '\u00e6 \\\\ae'}, {'text': '\u00f0 \\\\eth'}, {'text': '\u00f0 \\\\dh'}, {'text': '\u00f8 \\\\o'}, {'text': '\u00fe \\\\thorn'}, {'text': '\u0152 \\\\OE'}, {'text': '\u0153 \\\\oe'}, {'text': 'Delimiters'}, {'text': '( ('}, {'text': '( \\\\leftparen'}, {'text': ') )'}, {'text': ') \\\\rightparen'}, {'text': '. .'}, {'text': '/ /'}, {'text': '< <'}, {'text': '> >'}, {'text': '[ \\\\lbrack'}, {'text': '[ ['}, {'text': '\\\\ \\\\backslash'}, {'text': '| \\\\vert'}, {'text': '| |'}, {'text': '] \\\\rbrack'}, {'text': '] ]'}, {'text': '{ \\\\leftbrace'}, {'text': '{ \\\\lbrace'}, {'text': '{ \\\\{'}, {'text': '} \\\\rbrace'}, {'text': '} \\\\rightbrace'}, {'text': '} \\\\}'}, {'text': '\u2016 \\\\Vert'}, {'text': '\u2016 \\\\|'}, {'text': '\u2191 \\\\uparrow'}, {'text': '\u2193 \\\\downarrow'}, {'text': '\u2195 \\\\updownarrow'}, {'text': '\u21d1 \\\\Uparrow'}, {'text': '\u21d3 \\\\Downarrow'}, {'text': '\u21d5 \\\\Updownarrow'}, {'text': '\u2308 \\\\lceil'}, {'text': '\u2309 \\\\rceil'}, {'text': '\u230a \\\\lfloor'}, {'text': '\u230b \\\\rfloor'}, {'text': '\u27e8 \\\\langle'}, {'text': '\u27e9 \\\\rangle'}, {'text': '\u27ee \\\\lgroup'}, {'text': '\u27ef \\\\rgroup'}, {'text': 'Big symbols'}, {'text': '\u220f \\\\prod'}, {'text': '\u2210 \\\\coprod'}, {'text': '\u2211 \\\\sum'}, {'text': '\u222b \\\\int'}, {'text': '\u222c \\\\iint'}, {'text': '\u222d \\\\iiint'}, {'text': '\u222e \\\\oint'}, {'text': '\u222f \\\\oiint'}, {'text': '\u2230 \\\\oiiint'}, {'text': '\u22c0 \\\\bigwedge'}, {'text': '\u22c1 \\\\bigvee'}, {'text': '\u22c2 \\\\bigcap'}, {'text': '\u22c3 \\\\bigcup'}, {'text': '\u2a00 \\\\bigodot'}, {'text': '\u2a01 \\\\bigoplus'}, {'text': '\u2a02 \\\\bigotimes'}, {'text': '\u2a04 \\\\biguplus'}, {'text': '\u2a06 \\\\bigsqcup'}, {'text': '\u2a0c \\\\iiiint'}, {'text': 'Standard function names'}, {'text': 'Pr \\\\Pr'}, {'text': 'arccos \\\\arccos'}, {'text': 'arcsin \\\\arcsin'}, {'text': 'arctan \\\\arctan'}, {'text': 'arg \\\\arg'}, {'text': 'cos \\\\cos'}, {'text': 'cosh \\\\cosh'}, {'text': 'cot \\\\cot'}, {'text': 'coth \\\\coth'}, {'text': 'csc \\\\csc'}, {'text': 'deg \\\\deg'}, {'text': 'det \\\\det'}, {'text': 'dim \\\\dim'}, {'text': 'exp \\\\exp'}, {'text': 'gcd \\\\gcd'}, {'text': 'hom \\\\hom'}, {'text': 'inf \\\\inf'}, {'text': 'ker \\\\ker'}, {'text': 'lg \\\\lg'}, {'text': 'lim \\\\lim'}, {'text': 'liminf \\\\liminf'}, {'text': 'limsup \\\\limsup'}, {'text': 'ln \\\\ln'}, {'text': 'log \\\\log'}, {'text': 'max \\\\max'}, {'text': 'min \\\\min'}, {'text': 'sec \\\\sec'}, {'text': 'sin \\\\sin'}, {'text': 'sinh \\\\sinh'}, {'text': 'sup \\\\sup'}, {'text': 'tan \\\\tan'}, {'text': 'tanh \\\\tanh'}, {'text': 'Binary operation symbols'}, {'text': '* *'}, {'text': '+ +'}, {'text': '- -'}, {'text': '\u00b1 \\\\pm'}, {'text': '\u00d7 \\\\times'}, {'text': '\u00f7 \\\\div'}, {'text': '\u2020 \\\\dagger'}, {'text': '\u2021 \\\\ddagger'}, {'text': '\u2212 \u2212'}, {'text': '\u2213 \\\\mp'}, {'text': '\u2214 \\\\dotplus'}, {'text': '\u2215 \\\\slash'}, {'text': '\u2216 \\\\setminus'}, {'text': '\u2217 \\\\ast'}, {'text': '\u2218 \\\\circ'}, {'text': '\u2219 \\\\bullet'}, {'text': '\u2227 \\\\wedge'}, {'text': '\u2228 \\\\vee'}, {'text': '\u2229 \\\\cap'}, {'text': '\u222a \\\\cup'}, {'text': '\u2238 \\\\dotminus'}, {'text': '\u2239 \\\\minuscolon'}, {'text': '\u223a \\\\dotsminusdots'}, {'text': '\u2240 \\\\wr'}, {'text': '\u228d \\\\cupdot'}, {'text': '\u228e \\\\uplus'}, {'text': '\u2293 \\\\sqcap'}, {'text': '\u2294 \\\\sqcup'}, {'text': '\u2295 \\\\oplus'}, {'text': '\u2296 \\\\ominus'}, {'text': '\u2297 \\\\otimes'}, {'text': '\u2298 \\\\oslash'}, {'text': '\u2299 \\\\odot'}, {'text': '\u229a \\\\circledcirc'}, {'text': '\u229b \\\\circledast'}, {'text': '\u229d \\\\circleddash'}, {'text': '\u229e \\\\boxplus'}, {'text': '\u229f \\\\boxminus'}, {'text': '\u22a0 \\\\boxtimes'}, {'text': '\u22a1 \\\\boxdot'}, {'text': '\u22b4 \\\\unlhd'}, {'text': '\u22b5 \\\\unrhd'}, {'text': '\u22ba \\\\intercal'}, {'text': '\u22bb \\\\veebar'}, {'text': '\u22bc \\\\barwedge'}, {'text': '\u22bd \\\\barvee'}, {'text': '\u22c4 \\\\diamond'}, {'text': '\u22c5 \\\\cdot'}, {'text': '\u22c6 \\\\star'}, {'text': '\u22c7 \\\\divideontimes'}, {'text': '\u22cb \\\\leftthreetimes'}, {'text': '\u22cc \\\\rightthreetimes'}, {'text': '\u22ce \\\\curlyvee'}, {'text': '\u22cf \\\\curlywedge'}, {'text': '\u22d2 \\\\Cap'}, {'text': '\u22d3 \\\\Cup'}, {'text': '\u2306 \\\\doublebarwedge'}, {'text': '\u233d \\\\obar'}, {'text': '\u25b3 \\\\bigtriangleup'}, {'text': '\u25b7 \\\\triangleright'}, {'text': '\u25b7 \\\\rhd'}, {'text': '\u25bd \\\\bigtriangledown'}, {'text': '\u25c1 \\\\triangleleft'}, {'text': '\u25c1 \\\\lhd'}, {'text': '\u25cb \\\\bigcirc'}, {'text': '\u25eb \\\\boxbar'}, {'text': '\u2a3f \\\\amalg'}, {'text': '\u2a55 \\\\merge'}, {'text': 'Relation symbols'}, {'text': ': :'}, {'text': '< <'}, {'text': '= ='}, {'text': '= \\\\equal'}, {'text': '> >'}, {'text': '\u03f6 \\\\backepsilon'}, {'text': '\u2026 \\\\dots'}, {'text': '\u2208 \\\\in'}, {'text': '\u2209 \\\notin'}, {'text': '\u220a \\\\smallin'}, {'text': '\u220b \\\ni'}, {'text': '\u220c \\\notsmallowns'}, {'text': '\u220d \\\\smallowns'}, {'text': '\u221d \\\\propto'}, {'text': '\u221d \\\\varpropto'}, {'text': '\u221f \\\\rightangle'}, {'text': '\u2223 \\\\mid'}, {'text': '\u2224 \\\nmid'}, {'text': '\u2225 \\\\parallel'}, {'text': '\u2226 \\\nparallel'}, {'text': '\u2234 \\\\therefore'}, {'text': '\u2235 \\\\because'}, {'text': '\u2236 \\\\ratio'}, {'text': '\u223c \\\\sim'}, {'text': '\u223d \\\\backsim'}, {'text': '\u2241 \\\nsim'}, {'text': '\u2242 \\\\eqsim'}, {'text': '\u2243 \\\\simeq'}, {'text': '\u2244 \\\nsimeq'}, {'text': '\u2245 \\\\cong'}, {'text': '\u2246 \\\\simneqq'}, {'text': '\u2247 \\\ncong'}, {'text': '\u2248 \\\\approx'}, {'text': '\u2249 \\\napprox'}, {'text': '\u224a \\\\approxeq'}, {'text': '\u224b \\\\approxident'}, {'text': '\u224c \\\\backcong'}, {'text': '\u224d \\\\asymp'}, {'text': '\u224e \\\\Bumpeq'}, {'text': '\u224f \\\\bumpeq'}, {'text': '\u2250 \\\\doteq'}, {'text': '\u2251 \\\\Doteq'}, {'text': '\u2251 \\\\doteqdot'}, {'text': '\u2252 \\\\fallingdotseq'}, {'text': '\u2253 \\\\risingdotseq'}, {'text': '\u2254 \\\\coloneq'}, {'text': '\u2255 \\\\eqcolon'}, {'text': '\u2256 \\\\eqcirc'}, {'text': '\u2257 \\\\circeq'}, {'text': '\u2258 \\\\arceq'}, {'text': '\u2259 \\\\wedgeq'}, {'text': '\u225a \\\\veeeq'}, {'text': '\u225b \\\\stareq'}, {'text': '\u225c \\\\triangleq'}, {'text': '\u225c \\\\triangleeq'}, {'text': '\u225d \\\\eqdef'}, {'text': '\u225e \\\\measeq'}, {'text': '\u225f \\\\questeq'}, {'text': '\u2260 \\\ne'}, {'text': '\u2260 \\\neq'}, {'text': '\u2261 \\\\equiv'}, {'text': '\u2262 \\\nequiv'}, {'text': '\u2263 \\\\Equiv'}, {'text': '\u2264 \\\\leq'}, {'text': '\u2265 \\\\geq'}, {'text': '\u2266 \\\\leqq'}, {'text': '\u2267 \\\\geqq'}, {'text': '\u2268 \\\\lneqq'}, {'text': '\u2269 \\\\gneqq'}, {'text': '\u226a \\\\ll'}, {'text': '\u226b \\\\gg'}, {'text': '\u226c \\\\between'}, {'text': '\u226e \\\nless'}, {'text': '\u226f \\\ngtr'}, {'text': '\u2270 \\\nleq'}, {'text': '\u2271 \\\ngeq'}, {'text': '\u2272 \\\\lesssim'}, {'text': '\u2273 \\\\gtrsim'}, {'text': '\u2274 \\\nlesssim'}, {'text': '\u2275 \\\ngtrsim'}, {'text': '\u2276 \\\\lessgtr'}, {'text': '\u2277 \\\\gtrless'}, {'text': '\u2278 \\\nlessgtr'}, {'text': '\u2279 \\\ngtrless'}, {'text': '\u227a \\\\prec'}, {'text': '\u227b \\\\succ'}, {'text': '\u227c \\\\preceq'}, {'text': '\u227c \\\\preccurlyeq'}, {'text': '\u227d \\\\succeq'}, {'text': '\u227d \\\\succcurlyeq'}, {'text': '\u227e \\\\precsim'}, {'text': '\u227f \\\\succsim'}, {'text': '\u2280 \\\nprec'}, {'text': '\u2281 \\\nsucc'}, {'text': '\u2282 \\\\subset'}, {'text': '\u2283 \\\\supset'}, {'text': '\u2284 \\\nsubset'}, {'text': '\u2285 \\\nsupset'}, {'text': '\u2286 \\\\subseteq'}, {'text': '\u2287 \\\\supseteq'}, {'text': '\u2288 \\\nsubseteq'}, {'text': '\u2289 \\\nsupseteq'}, {'text': '\u228a \\\\subsetneq'}, {'text': '\u228b \\\\supsetneq'}, {'text': '\u228f \\\\sqsubset'}, {'text': '\u2290 \\\\sqsupset'}, {'text': '\u2291 \\\\sqsubseteq'}, {'text': '\u2292 \\\\sqsupseteq'}, {'text': '\u229c \\\\oequal'}, {'text': '\u22a2 \\\\vdash'}, {'text': '\u22a3 \\\\dashv'}, {'text': '\u22a4 \\\\top'}, {'text': '\u22a5 \\\\bot'}, {'text': '\u22a6 \\\\rightassert'}, {'text': '\u22a7 \\\\models'}, {'text': '\u22a8 \\\\vDash'}, {'text': '\u22a9 \\\\Vdash'}, {'text': '\u22aa \\\\Vvdash'}, {'text': '\u22ab \\\\rightModels'}, {'text': '\u22ac \\\nvdash'}, {'text': '\u22ad \\\nvDash'}, {'text': '\u22ae \\\nVdash'}, {'text': '\u22af \\\nVDash'}, {'text': '\u22b1 \\\\scurel'}, {'text': '\u22b4 \\\\trianglelefteq'}, {'text': '\u22b5 \\\\trianglerighteq'}, {'text': '\u22be \\\\measuredrightangle'}, {'text': '\u22bf \\\\varlrtriangle'}, {'text': '\u22c8 \\\\bowtie'}, {'text': '\u22c9 \\\\ltimes'}, {'text': '\u22ca \\\\rtimes'}, {'text': '\u22cd \\\\backsimeq'}, {'text': '\u22d0 \\\\Subset'}, {'text': '\u22d1 \\\\Supset'}, {'text': '\u22d4 \\\\pitchfork'}, {'text': '\u22d5 \\\\equalparallel'}, {'text': '\u22d6 \\\\lessdot'}, {'text': '\u22d7 \\\\gtrdot'}, {'text': '\u22d8 \\\\lll'}, {'text': '\u22d9 \\\\ggg'}, {'text': '\u22da \\\\lesseqgtr'}, {'text': '\u22db \\\\gtreqless'}, {'text': '\u22dc \\\\eqless'}, {'text': '\u22dd \\\\eqgtr'}, {'text': '\u22de \\\\curlyeqprec'}, {'text': '\u22df \\\\curlyeqsucc'}, {'text': '\u22e0 \\\npreccurlyeq'}, {'text': '\u22e1 \\\nsucccurlyeq'}, {'text': '\u22e2 \\\nsqsubseteq'}, {'text': '\u22e3 \\\nsqsupseteq'}, {'text': '\u22e4 \\\\sqsubsetneq'}, {'text': '\u22e5 \\\\sqsupsetneq'}, {'text': '\u22e6 \\\\lnsim'}, {'text': '\u22e7 \\\\gnsim'}, {'text': '\u22e8 \\\\precnsim'}, {'text': '\u22e9 \\\\succnsim'}, {'text': '\u22ea \\\ntriangleleft'}, {'text': '\u22eb \\\ntriangleright'}, {'text': '\u22ec \\\ntrianglelefteq'}, {'text': '\u22ed \\\ntrianglerighteq'}, {'text': '\u22f2 \\\\disin'}, {'text': '\u22f4 \\\\isins'}, {'text': '\u22f3 \\\\varisins'}, {'text': '\u22f5 \\\\isindot'}, {'text': '\u22f7 \\\\isinobar'}, {'text': '\u22f6 \\\\varisinobar'}, {'text': '\u22f8 \\\\isinvb'}, {'text': '\u22f9 \\\\isinE'}, {'text': '\u22fa \\\nisd'}, {'text': '\u22fc \\\nis'}, {'text': '\u22fb \\\\varnis'}, {'text': '\u22fe \\\niobar'}, {'text': '\u22fd \\\\varniobar'}, {'text': '\u22ff \\\\bagmember'}, {'text': '\u2322 \\\\frown'}, {'text': '\u2323 \\\\smile'}, {'text': '\u25b3 \\\\triangle'}, {'text': '\u25b6 \\\\blacktriangleright'}, {'text': '\u25b7 \\\\triangleright'}, {'text': '\u22b3 \\\\vartriangleright'}, {'text': '\u25c0 \\\\blacktriangleleft'}, {'text': '\u25c1 \\\\triangleleft'}, {'text': '\u22b2 \\\\vartriangleleft'}, {'text': '\u27c2 \\\\perp'}, {'text': '\u2a1d \\\\Join'}, {'text': '\u2a7d \\\\leqslant'}, {'text': '\u2a7e \\\\geqslant'}, {'text': '\u2a85 \\\\lessapprox'}, {'text': '\u2a86 \\\\gtrapprox'}, {'text': '\u2a89 \\\\lnapprox'}, {'text': '\u2a8a \\\\gnapprox'}, {'text': '\u2a8b \\\\lesseqqgtr'}, {'text': '\u2a8c \\\\gtreqqless'}, {'text': '\u2a95 \\\\eqslantless'}, {'text': '\u2a96 \\\\eqslantgtr'}, {'text': '\u2ab7 \\\\precapprox'}, {'text': '\u2ab8 \\\\succapprox'}, {'text': '\u2ab9 \\\\precnapprox'}, {'text': '\u2aba \\\\succnapprox'}, {'text': '\u2ac5 \\\\subseteqq'}, {'text': '\u2ac6 \\\\supseteqq'}, {'text': '\u2acb \\\\subsetneqq'}, {'text': '\u2acc \\\\supsetneqq'}, {'text': 'Arrow symbols'}, {'text': '\u20d6 \\\\overleftarrow'}, {'text': '\\\\overleftrightarrow'}, {'text': '\u2190 \\\\leftarrow'}, {'text': '\u2191 \\\\uparrow'}, {'text': '\u2192 \\\\to'}, {'text': '\u2192 \\\\rightarrow'}, {'text': '\u2193 \\\\downarrow'}, {'text': '\u2194 \\\\leftrightarrow'}, {'text': '\u2195 \\\\updownarrow'}, {'text': '\u2196 \\\nwarrow'}, {'text': '\u2197 \\\nearrow'}, {'text': '\u2198 \\\\searrow'}, {'text': '\u2199 \\\\swarrow'}, {'text': '\u219a \\\nleftarrow'}, {'text': '\u219b \\\nrightarrow'}, {'text': '\u219c \\\\leftsquigarrow'}, {'text': '\u219d \\\\rightsquigarrow'}, {'text': '\u219e \\\\twoheadleftarrow'}, {'text': '\u219f \\\\twoheaduparrow'}, {'text': '\u21a0 \\\\twoheadrightarrow'}, {'text': '\u21a1 \\\\twoheaddownarrow'}, {'text': '\u21a2 \\\\leftarrowtail'}, {'text': '\u21a3 \\\\rightarrowtail'}, {'text': '\u21a4 \\\\mapsfrom'}, {'text': '\u21a5 \\\\mapsup'}, {'text': '\u21a6 \\\\mapsto'}, {'text': '\u21a7 \\\\mapsdown'}, {'text': '\u21a8 \\\\updownarrowbar'}, {'text': '\u21a9 \\\\hookleftarrow'}, {'text': '\u21aa \\\\hookrightarrow'}, {'text': '\u21ab \\\\looparrowleft'}, {'text': '\u21ac \\\\looparrowright'}, {'text': '\u21ad \\\\leftrightsquigarrow'}, {'text': '\u21ae \\\nleftrightarrow'}, {'text': '\u21af \\\\downzigzagarrow'}, {'text': '\u21b0 \\\\Lsh'}, {'text': '\u21b1 \\\\Rsh'}, {'text': '\u21b2 \\\\Ldsh'}, {'text': '\u21b3 \\\\Rdsh'}, {'text': '\u21b6 \\\\curvearrowleft'}, {'text': '\u21b7 \\\\curvearrowright'}, {'text': '\u21ba \\\\circlearrowleft'}, {'text': '\u21bb \\\\cwopencirclearrow'}, {'text': '\u21bb \\\\circlearrowright'}, {'text': '\u21bc \\\\leftharpoonup'}, {'text': '\u21bd \\\\leftharpoondown'}, {'text': '\u21be \\\\upharpoonright'}, {'text': '\u21bf \\\\upharpoonleft'}, {'text': '\u21c0 \\\\rightharpoonup'}, {'text': '\u21c1 \\\\rightharpoondown'}, {'text': '\u21c2 \\\\downharpoonright'}, {'text': '\u21c3 \\\\downharpoonleft'}, {'text': '\u21c4 \\\\rightleftarrows'}, {'text': '\u21c5 \\\\updownarrows'}, {'text': '\u21c6 \\\\leftrightarrows'}, {'text': '\u21c7 \\\\leftleftarrows'}, {'text': '\u21c8 \\\\upuparrows'}, {'text': '\u21c9 \\\\rightrightarrows'}, {'text': '\u21ca \\\\downdownarrows'}, {'text': '\u21cb \\\\leftrightharpoons'}, {'text': '\u21cc \\\\rightleftharpoons'}, {'text': '\u21cd \\\nLeftarrow'}, {'text': '\u21ce \\\nLeftrightarrow'}, {'text': '\u21cf \\\nRightarrow'}, {'text': '\u21d0 \\\\Leftarrow'}, {'text': '\u21d1 \\\\Uparrow'}, {'text': '\u21d2 \\\\Rightarrow'}, {'text': '\u21d3 \\\\Downarrow'}, {'text': '\u21d4 \\\\Leftrightarrow'}, {'text': '\u21d5 \\\\Updownarrow'}, {'text': '\u21d6 \\\\Nwarrow'}, {'text': '\u21d7 \\\\Nearrow'}, {'text': '\u21d8 \\\\Searrow'}, {'text': '\u21d9 \\\\Swarrow'}, {'text': '\u21da \\\\Lleftarrow'}, {'text': '\u21db \\\\Rrightarrow'}, {'text': '\u21dd \\\\leadsto'}, {'text': '\u21dd \\\\rightzigzagarrow'}, {'text': '\u21e4 \\\\barleftarrow'}, {'text': '\u21e5 \\\\rightarrowbar'}, {'text': '\u228c \\\\cupleftarrow'}, {'text': '\u22b8 \\\\multimap'}, {'text': '\u27f5 \\\\longleftarrow'}, {'text': '\u27f6 \\\\longrightarrow'}, {'text': '\u27f7 \\\\longleftrightarrow'}, {'text': '\u27f8 \\\\Longleftarrow'}, {'text': '\u27f9 \\\\Longrightarrow'}, {'text': '\u27fa \\\\Longleftrightarrow'}, {'text': '\u27fc \\\\longmapsto'}, {'text': '\u290e \\\\dashleftarrow'}, {'text': '\u290f \\\\dashrightarrow'}, {'text': 'Dot symbols'}, {'text': '\u2026 \\\\ldots'}, {'text': '\u2234 \\\\therefore'}, {'text': '\u2235 \\\\because'}, {'text': '\u2237 \\\\Colon'}, {'text': '\u22ee \\\\vdots'}, {'text': '\u22ef \\\\cdots'}, {'text': '\u22f0 \\\\adots'}, {'text': '\u22f1 \\\\ddots'}, {'text': 'Black-board characters'}, {'text': '\u2102 \\\\BbbC'}, {'text': '\u2115 \\\\BbbN'}, {'text': '\u2119 \\\\BbbP'}, {'text': '\u211a \\\\BbbQ'}, {'text': '\u211d \\\\BbbR'}, {'text': '\u2124 \\\\BbbZ'}, {'text': 'Script characters'}, {'text': '\u210a \\\\scrg'}, {'text': '\u210b \\\\scrH'}, {'text': '\u2110 \\\\scrI'}, {'text': '\u2112 \\\\scrL'}, {'text': '\u211b \\\\scrR'}, {'text': '\u212c \\\\scrB'}, {'text': '\u212f \\\\scre'}, {'text': '\u2130 \\\\scrE'}, {'text': '\u2131 \\\\scrF'}, {'text': '\u2133 \\\\scrM'}, {'text': '\u2134 \\\\scro'}, {'text': 'Fraktur characters'}, {'text': '\u2128 \\\\frakZ'}, {'text': '\u212d \\\\frakC'}, {'text': 'Miscellaneous symbols'}, {'text': '$ \\\\$'}, {'text': '\u00a2 \\\\cent'}, {'text': '\u00a3 \\\\sterling'}, {'text': '\u00a5 \\\\yen'}, {'text': '\u00a7 \\\\S'}, {'text': '\u00a9 \\\\copyright'}, {'text': '\u00ac \\\neg'}, {'text': '\u00ae \\\\circledR'}, {'text': '\u00b0 \\\\degree'}, {'text': '\u00b6 \\\\P'}, {'text': '\u0127 \\\\hbar'}, {'text': '\u0131 \\\\imath'}, {'text': '\u0131 \\\\i'}, {'text': '\u0141 \\\\L'}, {'text': '\u0142 \\\\l'}, {'text': '\u019b \\\\lambdabar'}, {'text': '\u0237 \\\\jmath'}, {'text': '\u2020 \\\\dag'}, {'text': '\u2021 \\\\ddag'}, {'text': '\u2030 \\\\perthousand'}, {'text': '\u2032 \\\\prime'}, {'text': '\u2035 \\\\backprime'}, {'text': '\u210f \\\\hslash'}, {'text': '\u2111 \\\\Im'}, {'text': '\u2113 \\\\ell'}, {'text': '\u2118 \\\\wp'}, {'text': '\u211c \\\\Re'}, {'text': '\u2127 \\\\mho'}, {'text': '\u2132 \\\\Finv'}, {'text': '\u2141 \\\\Game'}, {'text': '\u2200 \\\\forall'}, {'text': '\u2201 \\\\complement'}, {'text': '\u2202 \\\\partial'}, {'text': '\u2203 \\\\exists'}, {'text': '\u2204 \\\nexists'}, {'text': '\u2205 \\\\emptyset'}, {'text': '\u2205 \\\\varnothing'}, {'text': '\u2206 \\\\increment'}, {'text': '\u2207 \\\nabla'}, {'text': '\u220e \\\\QED'}, {'text': '\u221e \\\\infty'}, {'text': '\u2220 \\\\angle'}, {'text': '\u2221 \\\\measuredangle'}, {'text': '\u2222 \\\\sphericalangle'}, {'text': '\u223e \\\\ac'}, {'text': '\u223f \\\\sinewave'}, {'text': '\u22b9 \\\\hermitmatrix'}, {'text': '\u24c8 \\\\circledS'}, {'text': '\u25a0 \\\\blacksquare'}, {'text': '\u25b3 \\\\triangle'}, {'text': '\u25b5 \\\\vartriangle'}, {'text': '\u25b4 \\\\blacktriangle'}, {'text': '\u25be \\\\blacktriangledown'}, {'text': '\u25bf \\\\triangledown'}, {'text': '\u2605 \\\\bigstar'}, {'text': '\u2621 \\\\danger'}, {'text': '\u2660 \\\\spadesuit'}, {'text': '\u2661 \\\\heartsuit'}, {'text': '\u2662 \\\\diamondsuit'}, {'text': '\u2663 \\\\clubsuit'}, {'text': '\u2667 \\\\clubsuitopen'}, {'text': '\u266d \\\\flat'}, {'text': '\u266e \\\natural'}, {'text': '\u266f \\\\sharp'}, {'text': '\u2713 \\\\checkmark'}, {'text': '\u2720 \\\\maltese'}, {'text': 'If a particular symbol does not have a name (as is true of many of the more\nobscure symbols in the STIX fonts), Unicode characters can also be used:'}, {'code': 'r'$\\\\u23ce$'\n'}, {'text': 'Download Python source code: mathtext.py'}, {'text': 'Download Jupyter notebook: mathtext.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 41
},
{
    "raw_page": "{'h1': 'Text rendering with XeLaTeX/LuaLaTeX via the pgf backend'}, {'text': 'Using the pgf backend, Matplotlib can export figures as pgf drawing\ncommands that can be processed with pdflatex, xelatex or lualatex. XeLaTeX and\nLuaLaTeX have full Unicode support and can use any font that is installed in\nthe operating system, making use of advanced typographic features of OpenType,\nAAT and Graphite. Pgf pictures created by plt.savefig('figure.pgf')\ncan be embedded as raw commands in LaTeX documents. Figures can also be\ndirectly compiled and saved to PDF with plt.savefig('figure.pdf') by\nswitching the backend'}, {'code': 'matplotlib.use('pgf')\n'}, {'text': 'or by explicitly requesting the use of the pgf backend'}, {'code': 'plt.savefig('figure.pdf', backend='pgf')\n'}, {'text': 'or by registering it for handling pdf output'}, {'code': 'from matplotlib.backends.backend_pgf import FigureCanvasPgf\nmatplotlib.backend_bases.register_backend('pdf', FigureCanvasPgf)\n'}, {'text': 'The last method allows you to keep using regular interactive backends and to\nsave xelatex, lualatex or pdflatex compiled PDF files from the graphical user\ninterface.'}, {'text': 'Matplotlib's pgf support requires a recent LaTeX installation that includes\nthe TikZ/PGF packages (such as TeXLive), preferably with XeLaTeX or LuaLaTeX\ninstalled. If either pdftocairo or ghostscript is present on your system,\nfigures can optionally be saved to PNG images as well. The executables\nfor all applications must be located on your PATH.'}, {'text': 'rcParams that control the behavior of the pgf backend:'}, {'text': 'Parameter'}, {'text': 'Documentation'}, {'text': 'pgf.preamble'}, {'text': 'Lines to be included in the LaTeX preamble'}, {'text': 'pgf.rcfonts'}, {'text': 'Setup fonts from rc params using the fontspec package'}, {'text': 'pgf.texsystem'}, {'text': 'Either 'xelatex' (default), 'lualatex' or 'pdflatex''}, {'text': 'Note'}, {'text': 'TeX defines a set of special characters, such as:'}, {'code': '# $ % & ~ _ ^ \\\\ { }\n'}, {'text': 'Generally, these characters must be escaped correctly. For convenience,\nsome characters (_, ^, %) are automatically escaped outside of math\nenvironments. Other characters are not escaped as they are commonly needed\nin actual TeX expressions. However, one can configure TeX to treat them as\n'normal' characters (known as 'catcode 12' to TeX) via a custom preamble,\nsuch as:'}, {'code': 'plt.rcParamspgf.preamble = (\n    r'\\\\AtBeginDocument{\\\\catcode`\\\\&=12\\\\catcode`\\\\#=12}')\n'}, {'h2': 'Multi-Page PDF Files'}, {'text': 'The pgf backend also supports multipage pdf files using\nPdfPages'}, {'code': 'from matplotlib.backends.backend_pgf import PdfPages\nimport matplotlib.pyplot as plt\n\nwith PdfPages('multipage.pdf', metadata={'author': 'Me'}) as pdf:\n\n    fig1, ax1 = plt.subplots()\n    ax1.plot([1, 5, 3])\n    pdf.savefig(fig1)\n\n    fig2, ax2 = plt.subplots()\n    ax2.plot([1, 5, 3])\n    pdf.savefig(fig2)\n'}, {'h2': 'Font specification'}, {'text': 'The fonts used for obtaining the size of text elements or when compiling\nfigures to PDF are usually defined in the rcParams. You can also use the\nLaTeX default Computer Modern fonts by clearing the lists for rcParamsfont.serif (default: ['DejaVu Serif', 'Bitstream Vera Serif', 'Computer Modern Roman', 'New Century Schoolbook', 'Century Schoolbook L', 'Utopia', 'ITC Bookman', 'Bookman', 'Nimbus Roman No9 L', 'Times New Roman', 'Times', 'Palatino', 'Charter', 'serif']),\nrcParamsfont.sans-serif (default: ['DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', 'sans-serif']) or rcParamsfont.monospace (default: ['DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Computer Modern Typewriter', 'Andale Mono', 'Nimbus Mono L', 'Courier New', 'Courier', 'Fixed', 'Terminal', 'monospace']). Please note that the glyph\ncoverage of these fonts is very limited. If you want to keep the Computer\nModern font face but require extended Unicode support, consider installing the\nComputer Modern Unicode fonts CMU Serif, CMU Sans Serif, etc.'}, {'text': 'When saving to .pgf, the font configuration Matplotlib used for the\nlayout of the figure is included in the header of the text file.'}, {'code': ''''\n=========\nPGF fonts\n=========\n'''\n\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    'font.family': 'serif',\n    # Use LaTeX default serif font.\n    'font.serif': [],\n    # Use specific cursive fonts.\n    'font.cursive': Comic Neue', 'Comic Sans MS,\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.text(0.5, 3., 'serif')\nax.text(0.5, 2., 'monospace', family='monospace')\nax.text(2.5, 2., 'sans-serif', family='DejaVu Sans')  # Use specific sans font.\nax.text(2.5, 1., 'comic', family='cursive')\nax.set_xlabel('\u00b5 is not $\\\\\\\\mu$')\n\nfig.tight_layout(pad=.5)\n\n'}, {'h2': 'Custom preamble'}, {'text': 'Full customization is possible by adding your own commands to the preamble.\nUse rcParamspgf.preamble (default: '') if you want to configure the math fonts,\nusing unicode-math for example, or for loading additional packages. Also,\nif you want to do the font configuration yourself instead of using the fonts\nspecified in the rc parameters, make sure to disable rcParamspgf.rcfonts (default: True).'}, {'code': ''''\n============\nPGF preamble\n============\n'''\n\nimport matplotlib as mpl\n\nmpl.use('pgf')\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    'font.family': 'serif',  # use serif/main font for text elements\n    'text.usetex': True,     # use inline math for ticks\n    'pgf.rcfonts': False,    # don't setup fonts from rc parameters\n    'pgf.preamble': '\\\n'.join([\n         r'\\\\usepackage{url}',            # load additional packages\n         r'\\\\usepackage{unicode-math}',   # unicode math setup\n         r'\\\\setmainfont{DejaVu Serif}',  # serif font via preamble\n    ])\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.set_xlabel('unicode text: \u044f, \u03c8, \u20ac, \u00fc')\nax.set_ylabel(r'\\\\url{https://matplotlib.org}')\nax.legend(unicode math: $\u03bb=\u2211_i^\u221e \u03bc_i^2$)\n\nfig.tight_layout(pad=.5)\n\n'}, {'h2': 'Choosing the TeX system'}, {'text': 'The TeX system to be used by Matplotlib is chosen by rcParamspgf.texsystem (default: 'xelatex').\nPossible values are 'xelatex' (default), 'lualatex' and 'pdflatex'.\nPlease note that when selecting pdflatex, the fonts and Unicode handling must\nbe configured in the preamble.'}, {'code': ''''\n=============\nPGF texsystem\n=============\n'''\n\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    'pgf.texsystem': 'pdflatex',\n    'pgf.preamble': '\\\n'.join([\n         r'\\\\usepackage[utf8x]{inputenc}',\n         r'\\\\usepackage[T1]{fontenc}',\n         r'\\\\usepackage{cmbright}',\n    ]),\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.text(0.5, 3., 'serif', family='serif')\nax.text(0.5, 2., 'monospace', family='monospace')\nax.text(2.5, 2., 'sans-serif', family='sans-serif')\nax.set_xlabel(r'\u00b5 is not $\\\\mu$')\n\nfig.tight_layout(pad=.5)\n\n'}, {'h2': 'Troubleshooting'}, {'text': 'Please note that the TeX packages found in some Linux distributions and\nMiKTeX installations are dramatically outdated. Make sure to update your\npackage catalog and upgrade or install a recent TeX distribution.'}, {'text': 'On Windows, the PATH environment variable may need to be modified\nto include the directories containing the latex, dvipng and ghostscript\nexecutables. See Environment variables and\nSetting environment variables in Windows for details.'}, {'text': 'Sometimes the font rendering in figures that are saved to png images is\nvery bad. This happens when the pdftocairo tool is not available and\nghostscript is used for the pdf to png conversion.'}, {'text': 'Make sure what you are trying to do is possible in a LaTeX document,\nthat your LaTeX syntax is valid and that you are using raw strings\nif necessary to avoid unintended escape sequences.'}, {'text': 'rcParamspgf.preamble (default: '') provides lots of flexibility, and lots of\nways to cause problems. When experiencing problems, try to minimalize or\ndisable the custom preamble.'}, {'text': 'Configuring an unicode-math environment can be a bit tricky. The\nTeXLive distribution for example provides a set of math fonts which are\nusually not installed system-wide. XeTeX, unlike LuaLatex, cannot find\nthese fonts by their name, which is why you might have to specify\n\\\\setmathfont{xits-math.otf} instead of \\\\setmathfont{XITS Math} or\nalternatively make the fonts available to your OS. See this\ntex.stackexchange.com question for more details.'}, {'text': 'If the font configuration used by Matplotlib differs from the font setting\nin yout LaTeX document, the alignment of text elements in imported figures\nmay be off. Check the header of your .pgf file if you are unsure about\nthe fonts Matplotlib used for the layout.'}, {'text': 'Vector images and hence .pgf files can become bloated if there are a lot\nof objects in the graph. This can be the case for image processing or very\nbig scatter graphs. In an extreme case this can cause TeX to run out of\nmemory: 'TeX capacity exceeded, sorry' You can configure latex to increase\nthe amount of memory available to generate the .pdf image as discussed on\ntex.stackexchange.com.\nAnother way would be to 'rasterize' parts of the graph causing problems\nusing either the rasterized=True keyword, or .set_rasterized(True) as\nper this example.'}, {'text': 'Various math fonts are compiled and rendered only if corresponding font\npackages are loaded. Specifically, when using \\\\mathbf{} on Greek letters,\nthe default computer modern font may not contain them, in which case the\nletter is not rendered. In such scenarios, the lmodern package should be\nloaded.'}, {'text': 'If you still need help, please see Get help'}, {'text': 'Download Python source code: pgf.py'}, {'text': 'Download Jupyter notebook: pgf.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 42
},
{
    "raw_page": "{'h1': 'Text rendering with LaTeX'}, {'text': 'Matplotlib can use LaTeX to render text. This is activated by setting\ntext.usetex : True in your rcParams, or by setting the usetex property\nto True on individual Text objects. Text handling through LaTeX is slower\nthan Matplotlib's very capable mathtext, but\nis more flexible, since different LaTeX packages (font packages, math packages,\netc.) can be used. The results can be striking, especially when you take care\nto use the same fonts in your figures as in the main document.'}, {'text': 'Matplotlib's LaTeX support requires a working LaTeX installation. For\nthe *Agg backends, dvipng is additionally required; for the PS backend,\nPSfrag, dvips and Ghostscript are additionally required. For the PDF\nand SVG backends, if LuaTeX is present, it will be used to speed up some\npost-processing steps, but note that it is not used to parse the TeX string\nitself (only LaTeX is supported). The executables for these external\ndependencies must all be located on your PATH.'}, {'text': 'Only a small number of font families (defined by the PSNFSS scheme) are\nsupported. They are listed here, with the corresponding LaTeX font selection\ncommands and LaTeX packages, which are automatically used.'}, {'text': 'generic family'}, {'text': 'fonts'}, {'text': 'serif (\\\\rmfamily)'}, {'text': 'Computer Modern Roman, Palatino (mathpazo),\nTimes (mathptmx), Bookman (bookman),\nNew Century Schoolbook (newcent),\nCharter (charter)'}, {'text': 'sans-serif (\\\\sffamily)'}, {'text': 'Computer Modern Serif, Helvetica (helvet),\nAvant Garde (avant)'}, {'text': 'cursive (\\\\rmfamily)'}, {'text': 'Zapf Chancery (chancery)'}, {'text': 'monospace (\\\\ttfamily)'}, {'text': 'Computer Modern Typewriter, Courier (courier)'}, {'text': 'The default font family (which does not require loading any LaTeX package) is\nComputer Modern. All other families are Adobe fonts. Times and Palatino each\nhave their own accompanying math fonts, while the other Adobe serif fonts make\nuse of the Computer Modern math fonts.'}, {'text': 'To enable LaTeX and select a font, use e.g.:'}, {'code': 'plt.rcParams.update({\n    'text.usetex': True,\n    'font.family': 'Helvetica'\n})\n'}, {'text': 'or equivalently, set your matplotlibrc to:'}, {'code': 'text.usetex : true\nfont.family : Helvetica\n'}, {'text': 'It is also possible to instead set font.family to one of the generic family\nnames and then configure the corresponding generic family; e.g.:'}, {'code': 'plt.rcParams.update({\n    'text.usetex': True,\n    'font.family': 'sans-serif',\n    'font.sans-serif': 'Helvetica',\n})\n'}, {'text': '(this was the required approach until Matplotlib 3.5).'}, {'text': 'Here is the standard example,\nRendering math equations using TeX:'}, {'text': 'Note that display math mode ($$ e=mc^2 $$) is not supported, but adding the\ncommand \\\\displaystyle, as in the above demo, will produce the same results.'}, {'text': 'Non-ASCII characters (e.g. the degree sign in the y-label above) are supported\nto the extent that they are supported by inputenc.'}, {'text': 'Note'}, {'text': 'For consistency with the non-usetex case, Matplotlib special-cases newlines,\nso that single-newlines yield linebreaks (rather than being interpreted as\nwhitespace in standard LaTeX).'}, {'text': 'Matplotlib uses the underscore package so that underscores (_) are\nprinted 'as-is' in text mode (rather than causing an error as in standard\nLaTeX). Underscores still introduce subscripts in math mode.'}, {'text': 'Note'}, {'text': 'Certain characters require special escaping in TeX, such as:'}, {'code': '# $ % & ~ ^ \\\\ { } \\\\( \\\\) \\\\[ \\\\]\n'}, {'text': 'Therefore, these characters will behave differently depending on\nrcParamstext.usetex (default: False). As noted above, underscores (_) do not require\nescaping outside of math mode.'}, {'h2': 'PostScript options'}, {'text': 'In order to produce encapsulated PostScript (EPS) files that can be embedded\nin a new LaTeX document, the default behavior of Matplotlib is to distill the\noutput, which removes some PostScript operators used by LaTeX that are illegal\nin an EPS file. This step produces results which may be unacceptable to some\nusers, because the text is coarsely rasterized and converted to bitmaps, which\nare not scalable like standard PostScript, and the text is not searchable. One\nworkaround is to set rcParamsps.distiller.res (default: 6000) to a higher value (perhaps 6000)\nin your rc settings, which will produce larger files but may look better and\nscale reasonably. A better workaround, which requires Poppler or Xpdf, can\nbe activated by changing rcParamsps.usedistiller (default: None) to xpdf. This alternative\nproduces PostScript without rasterizing text, so it scales properly, can be\nedited in Adobe Illustrator, and searched text in pdf documents.'}, {'h2': 'Possible hangups'}, {'text': 'On Windows, the PATH environment variable may need to be modified\nto include the directories containing the latex, dvipng and ghostscript\nexecutables. See Environment variables and\nSetting environment variables in Windows for details.'}, {'text': 'Using MiKTeX with Computer Modern fonts, if you get odd *Agg and PNG\nresults, go to MiKTeX/Options and update your format files'}, {'text': 'On Ubuntu and Gentoo, the base texlive install does not ship with\nthe type1cm package. You may need to install some of the extra\npackages to get all the goodies that come bundled with other LaTeX\ndistributions.'}, {'text': 'Some progress has been made so Matplotlib uses the dvi files\ndirectly for text layout. This allows LaTeX to be used for text\nlayout with the pdf and svg backends, as well as the *Agg and PS\nbackends. In the future, a LaTeX installation may be the only\nexternal dependency.'}, {'h2': 'Troubleshooting'}, {'text': 'Try deleting your .matplotlib/tex.cache directory. If you don't know\nwhere to find .matplotlib, see matplotlib configuration and cache directory locations.'}, {'text': 'Make sure LaTeX, dvipng and ghostscript are each working and on your\nPATH.'}, {'text': 'Make sure what you are trying to do is possible in a LaTeX document,\nthat your LaTeX syntax is valid and that you are using raw strings\nif necessary to avoid unintended escape sequences.'}, {'text': 'rcParamstext.latex.preamble (default: '') is not officially supported. This\noption provides lots of flexibility, and lots of ways to cause\nproblems. Please disable this option before reporting problems to\nthe mailing list.'}, {'text': 'If you still need help, please see Get help.'}, {'text': 'Download Python source code: usetex.py'}, {'text': 'Download Jupyter notebook: usetex.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 43
},
{
    "raw_page": "{'h1': 'Animations using Matplotlib'}, {'text': 'Based on its plotting functionality, Matplotlib also provides an interface to\ngenerate animations using the animation module. An\nanimation is a sequence of frames where each frame corresponds to a plot on a\nFigure. This tutorial covers a general guideline on\nhow to create such animations and the different options available.'}, {'text': 'Animations using Matplotlib'}, {'text': 'Faster rendering by using blitting'}",
    "id": 44
},
{
    "raw_page": "{'h1': 'Animations using Matplotlib'}, {'text': 'Based on its plotting functionality, Matplotlib also provides an interface to\ngenerate animations using the animation module. An\nanimation is a sequence of frames where each frame corresponds to a plot on a\nFigure. This tutorial covers a general guideline on\nhow to create such animations and the different options available.'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n'}, {'h2': 'Animation Classes'}, {'text': 'The animation process in Matplotlib can be thought of in 2 different ways:'}, {'text': 'FuncAnimation: Generate data for first\nframe and then modify this data for each frame to create an animated plot.'}, {'text': 'ArtistAnimation: Generate a list (iterable)\nof artists that will draw in each frame in the animation.'}, {'text': 'FuncAnimation is more efficient in terms of\nspeed and memory as it draws an artist once and then modifies it. On the\nother hand ArtistAnimation is flexible as it\nallows any iterable of artists to be animated in a sequence.'}, {'h3': 'FuncAnimation'}, {'text': 'The FuncAnimation class allows us to create an\nanimation by passing a function that iteratively modifies the data of a plot.\nThis is achieved by using the setter methods on various\nArtist (examples: Line2D,\nPathCollection, etc.). A usual\nFuncAnimation object takes a\nFigure that we want to animate and a function\nfunc that modifies the data plotted on the figure. It uses the frames\nparameter to determine the length of the animation. The interval parameter\nis used to determine time in milliseconds between drawing of two frames.\nAnimating using FuncAnimation would usually follow the following\nstructure:'}, {'text': 'Plot the initial figure, including all the required artists. Save all the\nartists in variables so that they can be updated later on during the\nanimation.'}, {'text': 'Create an animation function that updates the data in each artist to\ngenerate the new frame at each function call.'}, {'text': 'Create a FuncAnimation object with the Figure and the animation\nfunction, along with the keyword arguments that determine the animation\nproperties.'}, {'text': 'Use animation.Animation.save or pyplot.show to save or show the\nanimation.'}, {'text': 'The update function uses the set_* function for different artists to\nmodify the data. The following table shows a few plotting methods, the artist\ntypes they return and some methods that can be used to update them.'}, {'text': 'Plotting method'}, {'text': 'Artist'}, {'text': 'Set method'}, {'text': 'Axes.plot'}, {'text': 'lines.Line2D'}, {'text': 'set_data'}, {'text': 'Axes.scatter'}, {'text': 'collections.PathCollection'}, {'text': 'set_offsets'}, {'text': 'Axes.imshow'}, {'text': 'image.AxesImage'}, {'text': 'AxesImage.set_data'}, {'text': 'Axes.annotate'}, {'text': 'text.Annotation'}, {'text': 'update_positions'}, {'text': 'Axes.barh'}, {'text': 'patches.Rectangle'}, {'text': 'set_angle,\nset_bounds,\nset_height,\nset_width,\nset_x,\nset_y,\nset_xy'}, {'text': 'Axes.fill'}, {'text': 'patches.Polygon'}, {'text': 'set_xy'}, {'text': 'Axes.add_patch(patches.Ellipse)'}, {'text': 'patches.Ellipse'}, {'text': 'set_angle,\nset_center,\nset_height,\nset_width'}, {'text': 'Covering the set methods for all types of artists is beyond the scope of this\ntutorial but can be found in their respective documentations. An example of\nsuch update methods in use for Axes.scatter and Axes.plot is as follows.'}, {'code': 'fig, ax = plt.subplots()\nt = np.linspace(0, 3, 40)\ng = -9.81\nv0 = 12\nz = g * t**2 / 2 + v0 * t\n\nv02 = 5\nz2 = g * t**2 / 2 + v02 * t\n\nscat = ax.scatter(t[0], z[0], c='b', s=5, label=f'v0 = {v0} m/s')\nline2 = ax.plot(t[0], z2[0], label=f'v0 = {v02} m/s')[0]\nax.set(xlim=[0, 3], ylim=[-4, 10], xlabel='Time [s]', ylabel='Z [m]')\nax.legend()\n\n\ndef update(frame):\n    # for each frame, update the data stored on each artist.\n    x = t[:frame]\n    y = z[:frame]\n    # update the scatter plot:\n    data = np.stack([x, y]).T\n    scat.set_offsets(data)\n    # update the line plot:\n    line2.set_xdata(t[:frame])\n    line2.set_ydata(z2[:frame])\n    return (scat, line2)\n\n\nani = animation.FuncAnimation(fig=fig, func=update, frames=40, interval=30)\nplt.show()\n'}, {'h3': 'ArtistAnimation'}, {'text': 'ArtistAnimation can be used\nto generate animations if there is data stored on various different artists.\nThis list of artists is then converted frame by frame into an animation. For\nexample, when we use Axes.barh to plot a bar-chart, it creates a number of\nartists for each of the bar and error bars. To update the plot, one would\nneed to update each of the bars from the container individually and redraw\nthem. Instead, animation.ArtistAnimation can be used to plot each frame\nindividually and then stitched together to form an animation. A barchart race\nis a simple example for this.'}, {'code': 'fig, ax = plt.subplots()\nrng = np.random.default_rng(19680801)\ndata = np.array([20, 20, 20, 20])\nx = np.array([1, 2, 3, 4])\n\nartists = []\ncolors = ['tab:blue tab:red tab:green tab:purple']\nfor i in range(20):\n    data += rng.integers(low=0, high=10, size=data.shape)\n    container = ax.barh(x, data, color=colors)\n    artists.append(container)\n\n\nani = animation.ArtistAnimation(fig=fig, artists=artists, interval=400)\nplt.show()\n'}, {'h2': 'Animation Writers'}, {'text': 'Animation objects can be saved to disk using various multimedia writers\n(ex: Pillow, ffpmeg, imagemagick). Not all video formats are supported\nby all writers. There are 4 major types of writers:'}, {'text': 'PillowWriter - Uses the Pillow library to\ncreate the animation.'}, {'text': 'HTMLWriter - Used to create JavaScript-based\nanimations.'}, {'text': 'Pipe-based writers - FFMpegWriter and\nImageMagickWriter are pipe based writers.\nThese writers pipe each frame to the utility (ffmpeg / imagemagick)\nwhich then stitches all of them together to create the animation.'}, {'text': 'File-based writers - FFMpegFileWriter and\nImageMagickFileWriter are examples of\nfile-based writers. These writers are slower than their pipe-based\nalternatives but are more useful for debugging as they save each frame in\na file before stitching them together into an animation.'}, {'h3': 'Saving Animations'}, {'text': 'Writer'}, {'text': 'Supported Formats'}, {'text': 'PillowWriter'}, {'text': '.gif, .apng, .webp'}, {'text': 'HTMLWriter'}, {'text': '.htm, .html, .png'}, {'text': 'All formats supported by ffmpeg: ffmpeg -formats'}, {'text': 'All formats supported by imagemagick: magick -list format'}, {'text': 'To save animations using any of the writers, we can use the\nanimation.Animation.save method. It takes the filename that we want to\nsave the animation as and the writer, which is either a string or a writer\nobject. It also takes an fps argument. This argument is different than the\ninterval argument that FuncAnimation or\nArtistAnimation uses. fps determines the frame rate that the\nsaved animation uses, whereas interval determines the frame rate that\nthe displayed animation uses.'}, {'text': 'Below are a few examples that show how to save an animation with different\nwriters.'}, {'text': 'Pillow writers:'}, {'code': 'ani.save(filename='/tmp/pillow_example.gif', writer='pillow')\nani.save(filename='/tmp/pillow_example.apng', writer='pillow')\n'}, {'text': 'HTML writers:'}, {'code': 'ani.save(filename='/tmp/html_example.html', writer='html')\nani.save(filename='/tmp/html_example.htm', writer='html')\nani.save(filename='/tmp/html_example.png', writer='html')\n'}, {'text': 'FFMpegWriter:'}, {'code': 'ani.save(filename='/tmp/ffmpeg_example.mkv', writer='ffmpeg')\nani.save(filename='/tmp/ffmpeg_example.mp4', writer='ffmpeg')\nani.save(filename='/tmp/ffmpeg_example.mjpeg', writer='ffmpeg')\n'}, {'text': 'Imagemagick writers:'}, {'code': 'ani.save(filename='/tmp/imagemagick_example.gif', writer='imagemagick')\nani.save(filename='/tmp/imagemagick_example.webp', writer='imagemagick')\nani.save(filename='apng:/tmp/imagemagick_example.apng',\n         writer='imagemagick', extra_args=-quality', '100)\n'}, {'text': '(the extra_args for apng are needed to reduce filesize by ~10x)'}, {'text': 'Total running time of the script: (0 minutes 5.303 seconds)'}, {'text': 'Download Python source code: animations.py'}, {'text': 'Download Jupyter notebook: animations.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 45
},
{
    "raw_page": "{'h1': 'Faster rendering by using blitting'}, {'text': 'Blitting is a standard technique in raster graphics that,\nin the context of Matplotlib, can be used to (drastically) improve\nperformance of interactive figures. For example, the\nanimation and widgets modules use blitting\ninternally. Here, we demonstrate how to implement your own blitting, outside\nof these classes.'}, {'text': 'Blitting speeds up repetitive drawing by rendering all non-changing\ngraphic elements into a background image once. Then, for every draw, only the\nchanging elements need to be drawn onto this background. For example,\nif the limits of an Axes have not changed, we can render the empty Axes\nincluding all ticks and labels once, and only draw the changing data later.'}, {'text': 'The strategy is'}, {'text': 'Prepare the constant background:'}, {'text': 'Draw the figure, but exclude all artists that you want to animate by\nmarking them as animated (see Artist.set_animated).'}, {'text': 'Save a copy of the RBGA buffer.'}, {'text': 'Render the individual images:'}, {'text': 'Restore the copy of the RGBA buffer.'}, {'text': 'Redraw the animated artists using Axes.draw_artist /\nFigure.draw_artist.'}, {'text': 'Show the resulting image on the screen.'}, {'text': 'One consequence of this procedure is that your animated artists are always\ndrawn on top of the static artists.'}, {'text': 'Not all backends support blitting. You can check if a given canvas does via\nthe FigureCanvasBase.supports_blit property.'}, {'text': 'Warning'}, {'text': 'This code does not work with the OSX backend (but does work with other\nGUI backends on Mac).'}, {'h2': 'Minimal example'}, {'text': 'We can use the FigureCanvasAgg methods\ncopy_from_bbox and\nrestore_region in conjunction with setting\nanimated=True on our artist to implement a minimal example that\nuses blitting to accelerate rendering'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 100)\n\nfig, ax = plt.subplots()\n\n# animated=True tells matplotlib to only draw the artist when we\n# explicitly request it\n(ln,) = ax.plot(x, np.sin(x), animated=True)\n\n# make sure the window is raised, but the script keeps going\nplt.show(block=False)\n\n# stop to admire our empty window axes and ensure it is rendered at\n# least once.\n#\n# We need to fully draw the figure at its final size on the screen\n# before we continue on so that :\n#  a) we have the correctly sized and drawn background to grab\n#  b) we have a cached renderer so that ``ax.draw_artist`` works\n# so we spin the event loop to let the backend process any pending operations\nplt.pause(0.1)\n\n# get copy of entire figure (everything inside fig.bbox) sans animated artist\nbg = fig.canvas.copy_from_bbox(fig.bbox)\n# draw the animated artist, this uses a cached renderer\nax.draw_artist(ln)\n# show the result to the screen, this pushes the updated RGBA buffer from the\n# renderer to the GUI framework so you can see it\nfig.canvas.blit(fig.bbox)\n\nfor j in range(100):\n    # reset the background back in the canvas state, screen unchanged\n    fig.canvas.restore_region(bg)\n    # update the artist, neither the canvas state nor the screen have changed\n    ln.set_ydata(np.sin(x + (j / 100) * np.pi))\n    # re-render the artist, updating the canvas state, but not the screen\n    ax.draw_artist(ln)\n    # copy the image to the GUI state, but screen might not be changed yet\n    fig.canvas.blit(fig.bbox)\n    # flush any pending GUI events, re-painting the screen if needed\n    fig.canvas.flush_events()\n    # you can put a pause in if you want to slow things down\n    # plt.pause(.1)\n'}, {'text': 'This example works and shows a simple animation, however because we\nare only grabbing the background once, if the size of the figure in\npixels changes (due to either the size or dpi of the figure\nchanging) , the background will be invalid and result in incorrect\n(but sometimes cool looking!) images. There is also a global\nvariable and a fair amount of boilerplate which suggests we should\nwrap this in a class.'}, {'h2': 'Class-based example'}, {'text': 'We can use a class to encapsulate the boilerplate logic and state of\nrestoring the background, drawing the artists, and then blitting the\nresult to the screen. Additionally, we can use the 'draw_event'\ncallback to capture a new background whenever a full re-draw\nhappens to handle resizes correctly.'}, {'code': 'class BlitManager:\n    def __init__(self, canvas, animated_artists=()):\n        '''\n        Parameters\n        ----------\n        canvas : FigureCanvasAgg\n            The canvas to work with, this only works for subclasses of the Agg\n            canvas which have the `~FigureCanvasAgg.copy_from_bbox` and\n            `~FigureCanvasAgg.restore_region` methods.\n\n        animated_artists : Iterable[Artist]\n            List of the artists to manage\n        '''\n        self.canvas = canvas\n        self._bg = None\n        self._artists = []\n\n        for a in animated_artists:\n            self.add_artist(a)\n        # grab the background on every draw\n        self.cid = canvas.mpl_connect('draw_event', self.on_draw)\n\n    def on_draw(self, event):\n        '''Callback to register with 'draw_event'.'''\n        cv = self.canvas\n        if event is not None:\n            if event.canvas != cv:\n                raise RuntimeError\n        self._bg = cv.copy_from_bbox(cv.figure.bbox)\n        self._draw_animated()\n\n    def add_artist(self, art):\n        '''\n        Add an artist to be managed.\n\n        Parameters\n        ----------\n        art : Artist\n\n            The artist to be added.  Will be set to 'animated' (just\n            to be safe).  *art* must be in the figure associated with\n            the canvas this class is managing.\n\n        '''\n        if art.figure != self.canvas.figure:\n            raise RuntimeError\n        art.set_animated(True)\n        self._artists.append(art)\n\n    def _draw_animated(self):\n        '''Draw all of the animated artists.'''\n        fig = self.canvas.figure\n        for a in self._artists:\n            fig.draw_artist(a)\n\n    def update(self):\n        '''Update the screen with animated artists.'''\n        cv = self.canvas\n        fig = cv.figure\n        # paranoia in case we missed the draw event,\n        if self._bg is None:\n            self.on_draw(None)\n        else:\n            # restore the background\n            cv.restore_region(self._bg)\n            # draw all of the animated artists\n            self._draw_animated()\n            # update the GUI state\n            cv.blit(fig.bbox)\n        # let the GUI event loop process anything it has to do\n        cv.flush_events()\n'}, {'text': 'Here is how we would use our class. This is a slightly more complicated\nexample than the first case as we add a text frame counter as well.'}, {'code': '# make a new figure\nfig, ax = plt.subplots()\n# add a line\n(ln,) = ax.plot(x, np.sin(x), animated=True)\n# add a frame number\nfr_number = ax.annotate(\n    '0',\n    (0, 1),\n    xycoords='axes fraction',\n    xytext=(10, -10),\n    textcoords='offset points',\n    ha='left',\n    va='top',\n    animated=True,\n)\nbm = BlitManager(fig.canvas, [ln, fr_number])\n# make sure our window is on the screen and drawn\nplt.show(block=False)\nplt.pause(.1)\n\nfor j in range(100):\n    # update the artists\n    ln.set_ydata(np.sin(x + (j / 100) * np.pi))\n    fr_number.set_text(f'frame: {j}')\n    # tell the blitting manager to do its thing\n    bm.update()\n'}, {'text': 'This class does not depend on pyplot and is suitable to embed\ninto larger GUI application.'}, {'text': 'Download Python source code: blitting.py'}, {'text': 'Download Jupyter notebook: blitting.ipynb'}, {'text': 'Gallery generated by Sphinx-Gallery'}",
    "id": 46
},
{
    "raw_page": "{'h1': 'User Toolkits'}, {'text': 'Here you can find examples and explanations of how to use various toolkits available in Matplotlib.'}",
    "id": 47
},
{
    "raw_page": "{'h1': 'The axisartist toolkit'}, {'text': 'Warning'}, {'text': 'axisartist uses a custom Axes class\n(derived from the Matplotlib's original Axes class).\nAs a side effect, some commands (mostly tick-related) do not work.'}, {'text': 'The axisartist contains a custom Axes class that is meant to support\ncurvilinear grids (e.g., the world coordinate system in astronomy).\nUnlike Matplotlib's original Axes class which uses Axes.xaxis and Axes.yaxis\nto draw ticks, ticklines, etc., axisartist uses a special\nartist (AxisArtist) that can handle ticks, ticklines, etc. for\ncurved coordinate systems.'}, {'text': 'Since it uses special artists, some Matplotlib commands that work on\nAxes.xaxis and Axes.yaxis may not work.'}, {'h2': 'axisartist'}, {'text': 'The axisartist module provides a custom (and very experimental) Axes\nclass, where each axis (left, right, top, and bottom) have a separate\nassociated artist which is responsible for drawing the axis-line, ticks,\nticklabels, and labels. You can also create your own axis, which can pass\nthrough a fixed position in the axes coordinate, or a fixed position\nin the data coordinate (i.e., the axis floats around when viewlimit\nchanges).'}, {'text': 'The axes class, by default, has its xaxis and yaxis invisible, and\nhas 4 additional artists which are responsible for drawing the 4 axis spines in\n'left', 'right', 'bottom', and 'top'. They are accessed as\nax.axisleft, ax.axisright, and so on, i.e., ax.axis is a\ndictionary that contains artists (note that ax.axis is still a\ncallable method and it behaves as an original Axes.axis method in\nMatplotlib).'}, {'text': 'To create an Axes,'}, {'code': 'import mpl_toolkits.axisartist as AA\nfig = plt.figure()\nfig.add_axes([0.1, 0.1, 0.8, 0.8], axes_class=AA.Axes)\n'}, {'text': 'or to create a subplot'}, {'code': 'fig.add_subplot(111, axes_class=AA.Axes)\n# Given that 111 is the default, one can also do\nfig.add_subplot(axes_class=AA.Axes)\n'}, {'text': 'For example, you can hide the right and top spines using:'}, {'code': 'ax.axisright.set_visible(False)\nax.axistop.set_visible(False)\n'}, {'text': 'It is also possible to add a horizontal axis. For example, you may have an\nhorizontal axis at y=0 (in data coordinate).'}, {'code': 'ax.axisy=0 = ax.new_floating_axis(nth_coord=0, value=0)\n'}, {'text': 'Or a fixed axis with some offset'}, {'code': '# make new (right-side) yaxis, but with some offset\nax.axisright2 = ax.new_fixed_axis(loc='right', offset=(20, 0))\n'}, {'h3': 'axisartist with ParasiteAxes'}, {'text': 'Most commands in the axes_grid1 toolkit can take an axes_class keyword\nargument, and the commands create an Axes of the given class. For example,\nto create a host subplot with axisartist.Axes,'}, {'code': 'import mpl_toolkits.axisartist as AA\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111, axes_class=AA.Axes)\n'}, {'text': 'Here is an example that uses ParasiteAxes.'}, {'h3': 'Curvilinear Grid'}, {'text': 'The motivation behind the AxisArtist module is to support a curvilinear grid\nand ticks.'}, {'h3': 'Floating Axes'}, {'text': 'AxisArtist also supports a Floating Axes whose outer axes are defined as\nfloating axis.'}, {'h2': 'axisartist namespace'}, {'text': 'The axisartist namespace includes a derived Axes implementation. The\nbiggest difference is that the artists responsible to draw axis line,\nticks, ticklabel and axis labels are separated out from the Matplotlib's Axis\nclass, which are much more than artists in the original Matplotlib. This\nchange was strongly motivated to support curvilinear grid. Here are a\nfew things that mpl_toolkits.axisartist.Axes is different from original\nAxes from Matplotlib.'}, {'text': 'Axis elements (axis line(spine), ticks, ticklabel and axis labels)\nare drawn by a AxisArtist instance. Unlike Axis, left, right, top\nand bottom axis are drawn by separate artists. And each of them may\nhave different tick location and different tick labels.'}, {'text': 'gridlines are drawn by a Gridlines instance. The change was\nmotivated that in curvilinear coordinate, a gridline may not cross\naxis-lines (i.e., no associated ticks). In the original Axes class,\ngridlines are tied to ticks.'}, {'text': 'ticklines can be rotated if necessary (i.e, along the gridlines)'}, {'text': 'In summary, all these changes was to support'}, {'text': 'a curvilinear grid.'}, {'text': 'a floating axis'}, {'text': 'mpl_toolkits.axisartist.Axes class defines a axis attribute, which\nis a dictionary of AxisArtist instances. By default, the dictionary\nhas 4 AxisArtist instances, responsible for drawing of left, right,\nbottom and top axis.'}, {'text': 'xaxis and yaxis attributes are still available, however they are set\nto not visible. As separate artists are used for rendering axis, some\naxis-related method in Matplotlib may have no effect.\nIn addition to AxisArtist instances, the mpl_toolkits.axisartist.Axes will\nhave gridlines attribute (Gridlines), which obviously draws grid\nlines.'}, {'text': 'In both AxisArtist and Gridlines, the calculation of tick and grid\nlocation is delegated to an instance of GridHelper class.\nmpl_toolkits.axisartist.Axes class uses GridHelperRectlinear as a grid\nhelper. The GridHelperRectlinear class is a wrapper around the xaxis\nand yaxis of Matplotlib's original Axes, and it was meant to work as the\nway how Matplotlib's original axes works. For example, tick location changes\nusing set_ticks method and etc. should work as expected. But change in\nartist properties (e.g., color) will not work in general, although\nsome effort has been made so that some often-change attributes (color,\netc.) are respected.'}, {'h2': 'AxisArtist'}, {'text': 'AxisArtist can be considered as a container artist with following\nattributes which will draw ticks, labels, etc.'}, {'text': 'line'}, {'text': 'major_ticks, major_ticklabels'}, {'text': 'minor_ticks, minor_ticklabels'}, {'text': 'offsetText'}, {'text': 'label'}, {'h3': 'line'}, {'text': 'Derived from Line2D class. Responsible for drawing a spinal(?) line.'}, {'h3': 'major_ticks, minor_ticks'}, {'text': 'Derived from Line2D class. Note that ticks are markers.'}, {'h3': 'major_ticklabels, minor_ticklabels'}, {'text': 'Derived from Text. Note that it is not a list of Text artist, but a\nsingle artist (similar to a collection).'}, {'h3': 'axislabel'}, {'text': 'Derived from Text.'}, {'h2': 'Default AxisArtists'}, {'text': 'By default, following for axis artists are defined.:'}, {'code': 'ax.axisleft, ax.axisbottom, ax.axisright, ax.axistop\n'}, {'text': 'The ticklabels and axislabel of the top and the right axis are set to\nnot visible.'}, {'text': 'For example, if you want to change the color attributes of\nmajor_ticklabels of the bottom x-axis'}, {'code': 'ax.axisbottom.major_ticklabels.set_color('b')\n'}, {'text': 'Similarly, to make ticklabels invisible'}, {'code': 'ax.axisbottom.major_ticklabels.set_visible(False)\n'}, {'text': 'AxisArtist provides a helper method to control the visibility of ticks,\nticklabels, and label. To make ticklabel invisible,'}, {'code': 'ax.axisbottom.toggle(ticklabels=False)\n'}, {'text': 'To make all of ticks, ticklabels, and (axis) label invisible'}, {'code': 'ax.axisbottom.toggle(all=False)\n'}, {'text': 'To turn all off but ticks on'}, {'code': 'ax.axisbottom.toggle(all=False, ticks=True)\n'}, {'text': 'To turn all on but (axis) label off'}, {'code': 'ax.axisbottom.toggle(all=True, label=False)\n'}, {'text': 'ax.axis's __getitem__ method can take multiple axis names. For\nexample, to turn ticklabels of 'top' and 'right' axis on,'}, {'code': 'ax.axistop', 'right.toggle(ticklabels=True)\n'}, {'text': 'Note that ax.axistop', 'right returns a simple proxy object that\ntranslate above code to something like below.'}, {'code': 'for n in top', 'right:\n    ax.axis[n].toggle(ticklabels=True)\n'}, {'text': 'So, any return values in the for loop are ignored. And you should not\nuse it anything more than a simple method.'}, {'text': 'Like the list indexing ':' means all items, i.e.,'}, {'code': 'ax.axis[:].major_ticks.set_color('r')\n'}, {'text': 'changes tick color in all axis.'}, {'h2': 'HowTo'}, {'text': 'Changing tick locations and label.'}, {'text': 'Same as the original Matplotlib's axes:'}, {'code': 'ax.set_xticks([1, 2, 3])\n'}, {'text': 'Changing axis properties like color, etc.'}, {'text': 'Change the properties of appropriate artists. For example, to change\nthe color of the ticklabels:'}, {'code': 'ax.axisleft.major_ticklabels.set_color('r')\n'}, {'text': 'To change the attributes of multiple axis:'}, {'code': 'ax.axisleft', 'bottom.major_ticklabels.set_color('r')\n'}, {'text': 'or to change the attributes of all axis:'}, {'code': 'ax.axis[:].major_ticklabels.set_color('r')\n'}, {'text': 'To change the tick size (length), you need to use\naxis.major_ticks.set_ticksize method. To change the direction of\nthe ticks (ticks are in opposite direction of ticklabels by\ndefault), use axis.major_ticks.set_tick_out method.'}, {'text': 'To change the pad between ticks and ticklabels, use\naxis.major_ticklabels.set_pad method.'}, {'text': 'To change the pad between ticklabels and axis label,\naxis.label.set_pad method.'}, {'h2': 'Rotation and Alignment of TickLabels'}, {'text': 'This is also quite different from standard Matplotlib and can be\nconfusing. When you want to rotate the ticklabels, first consider\nusing 'set_axis_direction' method.'}, {'code': 'ax1.axisleft.major_ticklabels.set_axis_direction('top')\nax1.axisright.label.set_axis_direction('left')\n'}, {'text': 'The parameter for set_axis_direction is one of left', 'right',\n'bottom', 'top.'}, {'text': 'You must understand some underlying concept of directions.'}, {'text': 'There is a reference direction which is defined as the direction\nof the axis line with increasing coordinate. For example, the\nreference direction of the left x-axis is from bottom to top.'}, {'text': 'The direction, text angle, and alignments of the ticks, ticklabels and\naxis-label is determined with respect to the reference direction'}, {'text': 'label_direction and ticklabel_direction are either the right-hand side\n(+) of the reference direction or the left-hand side (-).'}, {'text': 'ticks are by default drawn toward the opposite direction of the ticklabels.'}, {'text': 'text rotation of ticklabels and label is determined in reference\nto the ticklabel_direction or label_direction,\nrespectively. The rotation of ticklabels and label is anchored.'}, {'text': 'On the other hand, there is a concept of 'axis_direction'. This is a\ndefault setting of above properties for each, 'bottom', 'left', 'top',\nand 'right' axis.'}, {'text': '?'}, {'text': '?'}, {'text': 'left'}, {'text': 'bottom'}, {'text': 'right'}, {'text': 'top'}, {'text': 'axislabel'}, {'text': 'direction'}, {'text': ''-''}, {'text': ''+''}, {'text': ''+''}, {'text': ''-''}, {'text': 'axislabel'}, {'text': 'rotation'}, {'text': '180'}, {'text': '0'}, {'text': '0'}, {'text': '180'}, {'text': 'axislabel'}, {'text': 'va'}, {'text': 'center'}, {'text': 'top'}, {'text': 'center'}, {'text': 'bottom'}, {'text': 'axislabel'}, {'text': 'ha'}, {'text': 'right'}, {'text': 'center'}, {'text': 'right'}, {'text': 'center'}, {'text': 'ticklabel'}, {'text': 'direction'}, {'text': ''-''}, {'text': ''+''}, {'text': ''+''}, {'text': ''-''}, {'text': 'ticklabels'}, {'text': 'rotation'}, {'text': '90'}, {'text': '0'}, {'text': '-90'}, {'text': '180'}, {'text': 'ticklabel'}, {'text': 'ha'}, {'text': 'right'}, {'text': 'center'}, {'text': 'right'}, {'text': 'center'}, {'text': 'ticklabel'}, {'text': 'va'}, {'text': 'center'}, {'text': 'baseline'}, {'text': 'center'}, {'text': 'baseline'}, {'text': 'And, 'set_axis_direction('top')' means to adjust the text rotation\netc, for settings suitable for 'top' axis. The concept of axis\ndirection can be more clear with curved axis.'}, {'text': 'The axis_direction can be adjusted in the AxisArtist level, or in the\nlevel of its child artists, i.e., ticks, ticklabels, and axis-label.'}, {'code': 'ax1.axisleft.set_axis_direction('top')\n'}, {'text': 'changes axis_direction of all the associated artist with the 'left'\naxis, while'}, {'code': 'ax1.axisleft.major_ticklabels.set_axis_direction('top')\n'}, {'text': 'changes the axis_direction of only the major_ticklabels. Note that\nset_axis_direction in the AxisArtist level changes the\nticklabel_direction and label_direction, while changing the\naxis_direction of ticks, ticklabels, and axis-label does not affect\nthem.'}, {'text': 'If you want to make ticks outward and ticklabels inside the axes,\nuse invert_ticklabel_direction method.'}, {'code': 'ax.axis[:].invert_ticklabel_direction()\n'}, {'text': 'A related method is 'set_tick_out'. It makes ticks outward (as a\nmatter of fact, it makes ticks toward the opposite direction of the\ndefault direction).'}, {'code': 'ax.axis[:].major_ticks.set_tick_out(True)\n'}, {'text': 'So, in summary,'}, {'text': 'AxisArtist's methods'}, {'text': 'set_axis_direction: 'left', 'right', 'bottom', or 'top''}, {'text': 'set_ticklabel_direction: '+' or '-''}, {'text': 'set_axislabel_direction: '+' or '-''}, {'text': 'invert_ticklabel_direction'}, {'text': 'Ticks' methods (major_ticks and minor_ticks)'}, {'text': 'set_tick_out: True or False'}, {'text': 'set_ticksize: size in points'}, {'text': 'TickLabels' methods (major_ticklabels and minor_ticklabels)'}, {'text': 'set_axis_direction: 'left', 'right', 'bottom', or 'top''}, {'text': 'set_rotation: angle with respect to the reference direction'}, {'text': 'set_ha and set_va: see below'}, {'text': 'AxisLabels' methods (label)'}, {'text': 'set_axis_direction: 'left', 'right', 'bottom', or 'top''}, {'text': 'set_rotation: angle with respect to the reference direction'}, {'text': 'set_ha and set_va'}, {'h3': 'Adjusting ticklabels alignment'}, {'text': 'Alignment of TickLabels are treated specially. See below'}, {'h3': 'Adjusting pad'}, {'text': 'To change the pad between ticks and ticklabels'}, {'code': 'ax.axisleft.major_ticklabels.set_pad(10)\n'}, {'text': 'Or ticklabels and axis-label'}, {'code': 'ax.axisleft.label.set_pad(10)\n'}, {'h2': 'GridHelper'}, {'text': 'To actually define a curvilinear coordinate, you have to use your own\ngrid helper. A generalised version of grid helper class is supplied\nand this class should suffice in most of cases. A user may provide\ntwo functions which defines a transformation (and its inverse pair)\nfrom the curved coordinate to (rectilinear) image coordinate. Note that\nwhile ticks and grids are drawn for curved coordinate, the data\ntransform of the axes itself (ax.transData) is still rectilinear\n(image) coordinate.'}, {'code': 'from mpl_toolkits.axisartist.grid_helper_curvelinear \\\\\n     import GridHelperCurveLinear\nfrom mpl_toolkits.axisartist import Axes\n\n# from curved coordinate to rectlinear coordinate.\ndef tr(x, y):\n    x, y = np.asarray(x), np.asarray(y)\n    return x, y-x\n\n# from rectlinear coordinate to curved coordinate.\ndef inv_tr(x, y):\n    x, y = np.asarray(x), np.asarray(y)\n    return x, y+x\n\ngrid_helper = GridHelperCurveLinear((tr, inv_tr))\n\nfig.add_subplot(axes_class=Axes, grid_helper=grid_helper)\n'}, {'text': 'You may use Matplotlib's Transform instance instead (but a\ninverse transformation must be defined). Often, coordinate range in a\ncurved coordinate system may have a limited range, or may have\ncycles. In those cases, a more customized version of grid helper is\nrequired.'}, {'code': 'import mpl_toolkits.axisartist.angle_helper as angle_helper\n\n# PolarAxes.PolarTransform takes radian. However, we want our coordinate\n# system in degree\ntr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform()\n\n# extreme finder: find a range of coordinate.\n# 20, 20: number of sampling points along x, y direction\n# The first coordinate (longitude, but theta in polar)\n#   has a cycle of 360 degree.\n# The second coordinate (latitude, but radius in polar)  has a minimum of 0\nextreme_finder = angle_helper.ExtremeFinderCycle(20, 20,\n                                                 lon_cycle=360,\n                                                 lat_cycle=None,\n                                                 lon_minmax=None,\n                                                 lat_minmax=(0, np.inf),\n                                                 )\n\n# Find a grid values appropriate for the coordinate (degree,\n# minute, second). The argument is a approximate number of grids.\ngrid_locator1 = angle_helper.LocatorDMS(12)\n\n# And also uses an appropriate formatter.  Note that the acceptable Locator\n# and Formatter classes are different than that of Matplotlib's, and you\n# cannot directly use Matplotlib's Locator and Formatter here (but may be\n# possible in the future).\ntick_formatter1 = angle_helper.FormatterDMS()\n\ngrid_helper = GridHelperCurveLinear(tr,\n                                    extreme_finder=extreme_finder,\n                                    grid_locator1=grid_locator1,\n                                    tick_formatter1=tick_formatter1\n                                    )\n'}, {'text': 'Again, the transData of the axes is still a rectilinear coordinate\n(image coordinate). You may manually do conversion between two\ncoordinates, or you may use Parasite Axes for convenience.:'}, {'code': 'ax1 = SubplotHost(fig, 1, 2, 2, grid_helper=grid_helper)\n\n# A parasite axes with given transform\nax2 = ax1.get_aux_axes(tr, 'equal')\n# note that ax2.transData == tr + ax1.transData\n# Anything you draw in ax2 will match the ticks and grids of ax1.\n'}, {'h2': 'FloatingAxis'}, {'text': 'A floating axis is an axis one of whose data coordinate is fixed, i.e,\nits location is not fixed in Axes coordinate but changes as axes data\nlimits changes. A floating axis can be created using\nnew_floating_axis method. However, it is your responsibility that\nthe resulting AxisArtist is properly added to the axes. A recommended\nway is to add it as an item of Axes's axis attribute.:'}, {'code': '# floating axis whose first (index starts from 0) coordinate\n# (theta) is fixed at 60\n\nax1.axislat = axis = ax1.new_floating_axis(0, 60)\naxis.label.set_text(r'$\\\\theta = 60^{\\\\circ}$')\naxis.label.set_visible(True)\n'}, {'text': 'See the first example of this page.'}, {'h2': 'Current Limitations and TODO's'}, {'text': 'The code need more refinement. Here is a incomplete list of issues and TODO's'}, {'text': 'No easy way to support a user customized tick location (for\ncurvilinear grid). A new Locator class needs to be created.'}, {'text': 'FloatingAxis may have coordinate limits, e.g., a floating axis of x = 0,\nbut y only spans from 0 to 1.'}, {'text': 'The location of axislabel of FloatingAxis needs to be optionally\ngiven as a coordinate value. ex, a floating axis of x=0 with label at y=1'}",
    "id": 48
},
{
    "raw_page": "{'h1': 'The axes_grid1 toolkit'}, {'text': 'axes_grid1 provides the following features:'}, {'text': 'Helper classes (ImageGrid, RGBAxes, AxesDivider) to ease the layout of\naxes displaying images with a fixed aspect ratio while satisfying additional\nconstraints (matching the heights of a colorbar and an image, or fixing the\npadding between images);'}, {'text': 'ParasiteAxes (twinx/twiny-like features so that you can plot different data\n(e.g., different y-scale) in a same Axes);'}, {'text': 'AnchoredArtists (custom artists which are placed at an anchored position,\nsimilarly to legends).'}, {'h2': 'axes_grid1'}, {'h3': 'ImageGrid'}, {'text': 'In Matplotlib, axes location and size are usually specified in normalized\nfigure coordinates (0 = bottom left, 1 = top right), which makes\nit difficult to achieve a fixed (absolute) padding between images.\nImageGrid can be used to achieve such a padding; see\nits docs for detailed API information.'}, {'text': 'The position of each axes is determined at the drawing time (see\nAxesDivider), so that the size of the entire grid fits in the\ngiven rectangle (like the aspect of axes). Note that in this example,\nthe paddings between axes are fixed even if you change the figure\nsize.'}, {'text': 'Axes in the same column share their x-axis, and axes in the same row share\ntheir y-axis (in the sense of sharex, sharey).\nAdditionally, Axes in the same column all have the same width, and axes in\nthe same row all have the same height. These widths and heights are scaled\nin proportion to the axes' view limits (xlim or ylim).'}, {'text': 'The examples below show what you can do with ImageGrid.'}, {'h3': 'AxesDivider Class'}, {'text': 'Behind the scenes, ImageGrid (and RGBAxes, described below) rely on\nAxesDivider, whose role is to calculate the\nlocation of the axes at drawing time.'}, {'text': 'Users typically do not need to directly instantiate dividers\nby calling AxesDivider; instead,\nmake_axes_locatable can be used to create a divider\nfor an Axes:'}, {'code': 'ax = subplot(1, 1, 1)\ndivider = make_axes_locatable(ax)\n'}, {'text': 'AxesDivider.append_axes can then be used to create a new axes on a given\nside ('left', 'right', 'top', 'bottom') of the original axes.'}, {'h3': 'colorbar whose height (or width) is in sync with the main axes'}, {'text': 'The Scatter plot with histograms example can be\nrewritten using make_axes_locatable:'}, {'code': 'axScatter = plt.subplot()\naxScatter.scatter(x, y)\naxScatter.set_aspect(1.)\n\n# create new axes on the right and on the top of the current axes.\ndivider = make_axes_locatable(axScatter)\naxHistx = divider.append_axes('top', size=1.2, pad=0.1, sharex=axScatter)\naxHisty = divider.append_axes('right', size=1.2, pad=0.1, sharey=axScatter)\n\n# the scatter plot:\n# histograms\nbins = np.arange(-lim, lim + binwidth, binwidth)\naxHistx.hist(x, bins=bins)\naxHisty.hist(y, bins=bins, orientation='horizontal')\n'}, {'text': 'See the full source code below.'}, {'text': 'The Scatter Histogram (Locatable Axes) using the\nAxesDivider has some advantages over the\noriginal Scatter plot with histograms in Matplotlib.\nFor example, you can set the aspect ratio of the scatter plot, even with the\nx-axis or y-axis is shared accordingly.'}, {'h3': 'ParasiteAxes'}, {'text': 'The ParasiteAxes is an Axes whose location is identical to its host\naxes. The location is adjusted in the drawing time, thus it works even\nif the host change its location (e.g., images).'}, {'text': 'In most cases, you first create a host axes, which provides a few\nmethods that can be used to create parasite axes. They are twinx,\ntwiny (which are similar to twinx and twiny in the matplotlib) and\ntwin. twin takes an arbitrary transformation that maps between the\ndata coordinates of the host axes and the parasite axes. The draw\nmethod of the parasite axes are never called. Instead, host axes\ncollects artists in parasite axes and draws them as if they belong to\nthe host axes, i.e., artists in parasite axes are merged to those of\nthe host axes and then drawn according to their zorder. The host and\nparasite axes modifies some of the axes behavior. For example, color\ncycle for plot lines are shared between host and parasites. Also, the\nlegend command in host, creates a legend that includes lines in the\nparasite axes. To create a host axes, you may use host_subplot or\nhost_axes command.'}, {'text': 'twin without a transform argument assumes that the parasite axes has the\nsame data transform as the host. This can be useful when you want the\ntop(or right)-axis to have different tick-locations, tick-labels, or\ntick-formatter for bottom(or left)-axis.'}, {'code': 'ax2 = ax.twin() # now, ax2 is responsible for 'top' axis and 'right' axis\nax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi],\n               labels=0', r'$\\\\frac{1}{2}\\\\pi$',\n                       r'$\\\\pi$', r'$\\\\frac{3}{2}\\\\pi$', r'$2\\\\pi$)\n'}, {'text': 'A more sophisticated example using twin. Note that if you change the\nx-limit in the host axes, the x-limit of the parasite axes will change\naccordingly.'}, {'h3': 'AnchoredArtists'}, {'text': 'axes_grid1.anchored_artists is a collection of artists whose location\nis anchored to the (axes) bbox, similarly to legends. These artists derive\nfrom offsetbox.OffsetBox, and the artist need to be drawn in canvas\ncoordinates. There is limited support for arbitrary transforms. For example,\nthe ellipse in the example below will have width and height in data coordinates.'}, {'h3': 'InsetLocator'}, {'text': 'See also'}, {'text': 'Axes.inset_axes and Axes.indicate_inset_zoom in the main library.'}, {'text': 'axes_grid1.inset_locator provides helper classes and functions to\nplace inset axes at an anchored position of the parent axes, similarly to\nAnchoredArtist.'}, {'text': 'inset_locator.inset_axes creates an inset axes whose size is either fixed,\nor a fixed proportion of the parent axes:'}, {'code': 'inset_axes = inset_axes(parent_axes,\n                        width='30%',  # width = 30% of parent_bbox\n                        height=1.,  # height = 1 inch\n                        loc='lower left')\n'}, {'text': 'creates an inset axes whose width is 30% of the parent axes and whose\nheight is fixed at 1 inch.'}, {'text': 'inset_locator.zoomed_inset_axes creates an inset axes whose data scale is\nthat of the parent axes multiplied by some factor, e.g.'}, {'code': 'inset_axes = zoomed_inset_axes(ax,\n                               0.5,  # zoom = 0.5\n                               loc='upper right')\n'}, {'text': 'creates an inset axes whose data scale is half of the parent axes. This can be\nuseful to mark the zoomed area on the parent axes:'}, {'text': 'inset_locator.mark_inset allows marking the location of the area represented\nby the inset axes:'}, {'h3': 'RGBAxes'}, {'text': 'RGBAxes is a helper class to conveniently show RGB composite\nimages. Like ImageGrid, the location of axes are adjusted so that the\narea occupied by them fits in a given rectangle. Also, the xaxis and\nyaxis of each axes are shared.'}, {'code': 'from mpl_toolkits.axes_grid1.axes_rgb import RGBAxes\n\nfig = plt.figure()\nax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8], pad=0.0)\nr, g, b = get_rgb()  # r, g, b are 2D images.\nax.imshow_rgb(r, g, b)\n'}, {'h2': 'AxesDivider'}, {'text': 'The mpl_toolkits.axes_grid1.axes_divider module provides helper classes\nto adjust the axes positions of a set of images at drawing time.'}, {'text': 'axes_size provides a class of\nunits that are used to determine the size of each axes. For example,\nyou can specify a fixed size.'}, {'text': 'Divider is the class that\ncalculates the axes position. It divides the given rectangular area into\nseveral areas. The divider is initialized by setting the lists of horizontal\nand vertical sizes on which the division will be based. Then use\nnew_locator(), which\nreturns a callable object that can be used to set the axes_locator of the\naxes.'}, {'text': 'Here, we demonstrate how to achieve the following layout: we want to position\naxes in a 3x4 grid (note that Divider makes row indices start from the\nbottom(!) of the grid):'}, {'code': '\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (2, 0) \u2502 (2, 1) \u2502 (2, 2) \u2502 (2, 3) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 (1, 0) \u2502 (1, 1) \u2502 (1, 2) \u2502 (1, 3) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 (0, 0) \u2502 (0, 1) \u2502 (0, 2) \u2502 (0, 3) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'}, {'text': 'such that the bottom row has a fixed height of 2 (inches) and the top two rows\nhave a height ratio of 2 (middle) to 3 (top). (For example, if the grid has\na size of 7 inches, the bottom row will be 2 inches, the middle row also 2\ninches, and the top row 3 inches.)'}, {'text': 'These constraints are specified using classes from the\naxes_size module, namely:'}, {'code': 'from mpl_toolkits.axes_grid1.axes_size import Fixed, Scaled\nvert = [Fixed(2), Scaled(2), Scaled(3)]\n'}, {'text': '(More generally, axes_size classes define a\nget_size(renderer) method that returns a pair of floats -- a relative size,\nand an absolute size. Fixed(2).get_size(renderer) returns (0, 2);\nScaled(2).get_size(renderer) returns (2, 0).)'}, {'text': 'We use these constraints to initialize a Divider object:'}, {'code': 'rect = [0.2, 0.2, 0.6, 0.6]  # Position of the grid in the figure.\nvert = [Fixed(2), Scaled(2), Scaled(3)]  # As above.\nhoriz = [...]  # Some other horizontal constraints.\ndivider = Divider(fig, rect, horiz, vert)\n'}, {'text': 'then use Divider.new_locator to create an axes locator callable for a\ngiven grid entry:'}, {'code': 'locator = divider.new_locator(nx=0, ny=1)  # Grid entry (1, 0).\n'}, {'text': 'and make it responsible for locating the axes:'}, {'code': 'ax.set_axes_locator(locator)\n'}, {'text': 'The axes locator callable returns the location and size of\nthe cell at the first column and the second row.'}, {'text': 'Locators that spans over multiple cells can be created with, e.g.:'}, {'code': '# Columns #0 and #1 ('0-2 range'), row #1.\nlocator = divider.new_locator(nx=0, nx1=2, ny=1)\n'}, {'text': 'See the example,'}, {'text': 'You can also adjust the size of each axes according to its x or y\ndata limits (AxesX and AxesY).'}",
    "id": 49
},
{
    "raw_page": "{'h1': 'The mplot3d toolkit'}, {'text': 'Generating 3D plots using the mplot3d toolkit.'}, {'text': 'This tutorial showcases various 3D plots. Click on the figures to see each full\ngallery example with the code that generates the figures.'}, {'text': 'Contents'}, {'text': 'The mplot3d toolkit'}, {'text': 'Line plots'}, {'text': 'Scatter plots'}, {'text': 'Wireframe plots'}, {'text': 'Surface plots'}, {'text': 'Tri-Surface plots'}, {'text': 'Contour plots'}, {'text': 'Filled contour plots'}, {'text': 'Polygon plots'}, {'text': 'Bar plots'}, {'text': 'Quiver'}, {'text': '2D plots in 3D'}, {'text': 'Text'}, {'text': '3D Axes (of class Axes3D) are created by passing the projection='3d'\nkeyword argument to Figure.add_subplot:'}, {'code': 'import matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n'}, {'text': 'Multiple 3D subplots can be added on the same figure, as for 2D subplots.'}, {'text': 'Changed in version 3.2.0: Prior to Matplotlib 3.2.0, it was necessary to explicitly import the\nmpl_toolkits.mplot3d module to make the '3d' projection to\nFigure.add_subplot.'}, {'text': 'See the mplot3d FAQ for more information about the mplot3d\ntoolkit.'}, {'h2': 'Line plots'}, {'text': 'See Axes3D.plot for API documentation.'}, {'h2': 'Scatter plots'}, {'text': 'See Axes3D.scatter for API documentation.'}, {'h2': 'Wireframe plots'}, {'text': 'See Axes3D.plot_wireframe for API documentation.'}, {'h2': 'Surface plots'}, {'text': 'See Axes3D.plot_surface for API documentation.'}, {'h2': 'Tri-Surface plots'}, {'text': 'See Axes3D.plot_trisurf for API documentation.'}, {'h2': 'Contour plots'}, {'text': 'See Axes3D.contour for API documentation.'}, {'h2': 'Filled contour plots'}, {'text': 'See Axes3D.contourf for API documentation.'}, {'text': 'New in version 1.1.0: The feature demoed in the second contourf3d example was enabled as a\nresult of a bugfix for version 1.1.0.'}, {'h2': 'Polygon plots'}, {'text': 'See Axes3D.add_collection3d for API documentation.'}, {'h2': 'Bar plots'}, {'text': 'See Axes3D.bar for API documentation.'}, {'h2': 'Quiver'}, {'text': 'See Axes3D.quiver for API documentation.'}, {'h2': '2D plots in 3D'}, {'h2': 'Text'}, {'text': 'See Axes3D.text for API documentation.'}",
    "id": 50
},
{
    "raw_page": "{'h1': 'User guide tutorials'}",
    "id": 51
},
{
    "raw_page": "{'h1': 'Getting started'}, {'h2': 'Installation quick-start'}, {'text': 'Install using pip:'}, {'code': 'pip install matplotlib\n'}, {'text': 'Install using conda:'}, {'code': 'conda install -c conda-forge matplotlib\n'}, {'text': 'Further details are available in the Installation Guide.'}, {'h2': 'Draw a first plot'}, {'text': 'Here is a minimal example plot:'}, {'code': 'import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 200)\ny = np.sin(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nplt.show()\n'}, {'text': '(Source code, 2x.png, png)'}, {'text': 'If a plot does not show up please check Troubleshooting.'}, {'h2': 'Where to go next'}, {'text': 'Check out Plot types to get an overview of the\ntypes of plots you can create with Matplotlib.'}, {'text': 'Learn Matplotlib from the ground up in the Quick-start guide.'}",
    "id": 52
},
{
    "raw_page": "{'h1': 'Installation'}, {'h2': 'Install an official release'}, {'text': 'Matplotlib releases are available as wheel packages for macOS, Windows and\nLinux on PyPI. Install it using\npip:'}, {'code': 'python -m pip install -U pip\npython -m pip install -U matplotlib\n'}, {'text': 'If this command results in Matplotlib being compiled from source and\nthere's trouble with the compilation, you can add --prefer-binary to\nselect the newest version of Matplotlib for which there is a\nprecompiled wheel for your OS and Python.'}, {'text': 'Note'}, {'text': 'The following backends work out of the box: Agg, ps, pdf, svg'}, {'text': 'Python is typically shipped with tk bindings which are used by\nTkAgg.'}, {'text': 'For support of other GUI frameworks, LaTeX rendering, saving\nanimations and a larger selection of file formats, you can\ninstall Optional dependencies.'}, {'h2': 'Third-party distributions'}, {'text': 'Various third-parties provide Matplotlib for their environments.'}, {'h3': 'Conda packages'}, {'text': 'Matplotlib is available both via the anaconda main channel'}, {'code': 'conda install matplotlib\n'}, {'text': 'as well as via the conda-forge community channel'}, {'code': 'conda install -c conda-forge matplotlib\n'}, {'h3': 'Python distributions'}, {'text': 'Matplotlib is part of major Python distributions:'}, {'text': 'Anaconda'}, {'text': 'ActiveState ActivePython'}, {'text': 'WinPython'}, {'h3': 'Linux package manager'}, {'text': 'If you are using the Python version that comes with your Linux distribution,\nyou can install Matplotlib via your package manager, e.g.:'}, {'text': 'Debian / Ubuntu: sudo apt-get install python3-matplotlib'}, {'text': 'Fedora: sudo dnf install python3-matplotlib'}, {'text': 'Red Hat: sudo yum install python3-matplotlib'}, {'text': 'Arch: sudo pacman -S python-matplotlib'}, {'h2': 'Install a nightly build'}, {'text': 'Matplotlib makes nightly development build wheels available on the\nscientific-python-nightly-wheels Anaconda Cloud organization.\nThese wheels can be installed with pip by specifying\nscientific-python-nightly-wheels as the package index to query:'}, {'code': 'python -m pip install \\\\\n  --upgrade \\\\\n  --pre \\\\\n  --index-url https://pypi.anaconda.org/scientific-python-nightly-wheels/simple \\\\\n  --extra-index-url https://pypi.org/simple \\\\\n  matplotlib\n'}, {'h2': 'Install from source'}, {'text': 'Installing for Development'}, {'text': 'If you would like to contribute to Matplotlib or otherwise need to\ninstall the latest development code, please follow the instructions in\nSetting up Matplotlib for development.'}, {'text': 'The following instructions are for installing from source for production use.\nThis is generally not recommended; please use prebuilt packages when possible.\nProceed with caution because these instructions may result in your\nbuild producing unexpected behavior and/or causing local testing to fail.'}, {'text': 'Before trying to install Matplotlib, please install the Dependencies.'}, {'text': 'To build from a tarball, download the latest tar.gz release\nfile from the PyPI files page.'}, {'text': 'We provide a mplsetup.cfg file which you can use to customize the build\nprocess. For example, which default backend to use, whether some of the\noptional libraries that Matplotlib ships with are installed, and so on. This\nfile will be particularly useful to those packaging Matplotlib.'}, {'text': 'If you are building your own Matplotlib wheels (or sdists) on Windows, note\nthat any DLLs that you copy into the source tree will be packaged too.'}, {'h2': 'Configure build and behavior defaults'}, {'text': 'Aspects of the build and install process and some behaviorial defaults of the\nlibrary can be configured via Environment variables. Default plotting\nappearance and behavior can be configured via the\nrcParams file'}, {'h1': 'Frequently asked questions'}, {'h2': 'Report a compilation problem'}, {'text': 'See Get help.'}, {'h2': 'Matplotlib compiled fine, but nothing shows up when I use it'}, {'text': 'The first thing to try is a clean install and see if\nthat helps. If not, the best way to test your install is by running a script,\nrather than working interactively from a python shell or an integrated\ndevelopment environment such as IDLE which add additional\ncomplexities. Open up a UNIX shell or a DOS command prompt and run, for\nexample:'}, {'code': 'python -c 'from pylab import *; set_loglevel('debug'); plot(); show()'\n'}, {'text': 'This will give you additional information about which backends Matplotlib is\nloading, version information, and more. At this point you might want to make\nsure you understand Matplotlib's configuration\nprocess, governed by the matplotlibrc configuration file which contains\ninstructions within and the concept of the Matplotlib backend.'}, {'text': 'If you are still having trouble, see Get help.'}, {'h2': 'How to completely remove Matplotlib'}, {'text': 'Occasionally, problems with Matplotlib can be solved with a clean\ninstallation of the package. In order to fully remove an installed Matplotlib:'}, {'text': 'Delete the caches from your Matplotlib configuration directory.'}, {'text': 'Delete any Matplotlib directories or eggs from your installation\ndirectory.'}, {'h2': 'OSX Notes'}, {'h3': 'Which python for OSX?'}, {'text': 'Apple ships OSX with its own Python, in /usr/bin/python, and its own copy\nof Matplotlib. Unfortunately, the way Apple currently installs its own copies\nof NumPy, Scipy and Matplotlib means that these packages are difficult to\nupgrade (see system python packages). For that reason we strongly suggest\nthat you install a fresh version of Python and use that as the basis for\ninstalling libraries such as NumPy and Matplotlib. One convenient way to\ninstall Matplotlib with other useful Python software is to use the Anaconda\nPython scientific software collection, which includes Python itself and a\nwide range of libraries; if you need a library that is not available from the\ncollection, you can install it yourself using standard methods such as pip.\nSee the Anaconda web page for installation support.'}, {'text': 'Other options for a fresh Python install are the standard installer from\npython.org, or installing\nPython using a general OSX package management system such as homebrew or macports. Power users on\nOSX will likely want one of homebrew or macports on their system to install\nopen source software packages, but it is perfectly possible to use these\nsystems with another source for your Python binary, such as Anaconda\nor Python.org Python.'}, {'h3': 'Installing OSX binary wheels'}, {'text': 'If you are using Python from https://www.python.org, Homebrew, or Macports,\nthen you can use the standard pip installer to install Matplotlib binaries in\nthe form of wheels.'}, {'text': 'pip is installed by default with python.org and Homebrew Python, but needs to\nbe manually installed on Macports with'}, {'code': 'sudo port install py38-pip\n'}, {'text': 'Once pip is installed, you can install Matplotlib and all its dependencies with\nfrom the Terminal.app command line:'}, {'code': 'python3 -m pip install matplotlib\n'}, {'text': 'You might also want to install IPython or the Jupyter notebook (python3 -m pip\ninstall ipython notebook).'}, {'h3': 'Checking your installation'}, {'text': 'The new version of Matplotlib should now be on your Python 'path'. Check this\nat the Terminal.app command line:'}, {'code': 'python3 -c 'import matplotlib; print(matplotlib.__version__, matplotlib.__file__)'\n'}, {'text': 'You should see something like'}, {'code': '3.6.0 /Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/matplotlib/__init__.py\n'}, {'text': 'where 3.6.0 is the Matplotlib version you just installed, and the path\nfollowing depends on whether you are using Python.org Python, Homebrew or\nMacports. If you see another version, or you get an error like'}, {'code': 'Traceback (most recent call last):\n  File '<string>', line 1, in <module>\nImportError: No module named matplotlib\n'}, {'text': 'then check that the Python binary is the one you expected by running'}, {'code': 'which python3\n'}, {'text': 'If you get a result like /usr/bin/python..., then you are getting the\nPython installed with OSX, which is probably not what you want. Try closing\nand restarting Terminal.app before running the check again. If that doesn't fix\nthe problem, depending on which Python you wanted to use, consider reinstalling\nPython.org Python, or check your homebrew or macports setup. Remember that\nthe disk image installer only works for Python.org Python, and will not get\npicked up by other Pythons. If all these fail, please let us know.'}, {'h2': 'Troubleshooting'}, {'h3': 'Obtaining Matplotlib version'}, {'text': 'To find out your Matplotlib version number, import it and print the\n__version__ attribute:'}, {'code': '>>> import matplotlib\n>>> matplotlib.__version__\n'0.98.0'\n'}, {'h3': 'matplotlib install location'}, {'text': 'You can find what directory Matplotlib is installed in by importing it\nand printing the __file__ attribute:'}, {'code': '>>> import matplotlib\n>>> matplotlib.__file__\n'/home/jdhunter/dev/lib64/python2.5/site-packages/matplotlib/__init__.pyc'\n'}, {'h3': 'matplotlib configuration and cache directory locations'}, {'text': 'Each user has a Matplotlib configuration directory which may contain a\nmatplotlibrc file. To\nlocate your matplotlib/ configuration directory, use\nmatplotlib.get_configdir():'}, {'code': '>>> import matplotlib as mpl\n>>> mpl.get_configdir()\n'/home/darren/.config/matplotlib'\n'}, {'text': 'On Unix-like systems, this directory is generally located in your\nHOME directory under the .config/ directory.'}, {'text': 'In addition, users have a cache directory. On Unix-like systems, this is\nseparate from the configuration directory by default. To locate your\n.cache/ directory, use matplotlib.get_cachedir():'}, {'code': '>>> import matplotlib as mpl\n>>> mpl.get_cachedir()\n'/home/darren/.cache/matplotlib'\n'}, {'text': 'On Windows, both the config directory and the cache directory are\nthe same and are in your Documents and Settings or Users\ndirectory by default:'}, {'code': '>>> import matplotlib as mpl\n>>> mpl.get_configdir()\n'C:\\\\\\\\Documents and Settings\\\\\\\\jdhunter\\\\\\\\.matplotlib'\n>>> mpl.get_cachedir()\n'C:\\\\\\\\Documents and Settings\\\\\\\\jdhunter\\\\\\\\.matplotlib'\n'}, {'text': 'If you would like to use a different configuration directory, you can\ndo so by specifying the location in your MPLCONFIGDIR\nenvironment variable -- see\nSetting environment variables in Linux and macOS. Note that\nMPLCONFIGDIR sets the location of both the configuration\ndirectory and the cache directory.'}",
    "id": 53
}
]
