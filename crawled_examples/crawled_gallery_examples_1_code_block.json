[
{
    "title": "Bar color demo",
    "text": "This is an example showing how to control bar color and legend entries\nusing the color and label parameters of bar.\nNote that labels with a preceding underscore won't show up in the legend.",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nfruits = ['apple blueberry cherry orange']\ncounts = [40, 100, 30, 55]\nbar_labels = ['red blue _red orange']\nbar_colors = ['tab:red tab:blue tab:red tab:orange']\n\nax.bar(fruits, counts, label=bar_labels, color=bar_colors)\n\nax.set_ylabel('fruit supply')\nax.set_title('Fruit supply by kind and color')\nax.legend(title='Fruit color')\n\nplt.show()\n",
    "id": 0
},
{
    "title": "Stacked bar chart",
    "text": "This is an example of creating a stacked bar plot\nusing bar.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nspecies = (\n    'Adelie\\\n $\\\\\\\\mu=$3700.66g',\n    'Chinstrap\\\n $\\\\\\\\mu=$3733.09g',\n    'Gentoo\\\n $\\\\\\\\mu=5076.02g$',\n)\nweight_counts = {\n    'Below': np.array([70, 31, 58]),\n    'Above': np.array([82, 37, 66]),\n}\nwidth = 0.5\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor boolean, weight_count in weight_counts.items():\n    p = ax.bar(species, weight_count, width, label=boolean, bottom=bottom)\n    bottom += weight_count\n\nax.set_title('Number of penguins with above average body mass')\nax.legend(loc='upper right')\n\nplt.show()\n",
    "id": 1
},
{
    "title": "Grouped bar chart with labels",
    "text": "This example shows a how to create a grouped bar chart and how to annotate\nbars with labels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label",
    "code": "# data from https://allisonhorst.github.io/palmerpenguins/\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = ('Adelie', 'Chinstrap', 'Gentoo')\npenguin_means = {\n    'Bill Depth': (18.35, 18.43, 14.98),\n    'Bill Length': (38.79, 48.83, 47.50),\n    'Flipper Length': (189.95, 195.82, 217.19),\n}\n\nx = np.arange(len(species))  # the label locations\nwidth = 0.25  # the width of the bars\nmultiplier = 0\n\nfig, ax = plt.subplots(layout='constrained')\n\nfor attribute, measurement in penguin_means.items():\n    offset = width * multiplier\n    rects = ax.bar(x + offset, measurement, width, label=attribute)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel('Length (mm)')\nax.set_title('Penguin attributes by species')\nax.set_xticks(x + width, species)\nax.legend(loc='upper left', ncols=3)\nax.set_ylim(0, 250)\n\nplt.show()\n",
    "id": 2
},
{
    "title": "Horizontal bar chart",
    "text": "This example showcases a simple horizontal bar chart.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\n# Example data\npeople = ('Tom Dick Harry Slim Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\nplt.show()\n",
    "id": 3
},
{
    "title": "Broken Barh",
    "text": "Make a \"broken\" horizontal bar plot, i.e., one with gaps",
    "code": "import matplotlib.pyplot as plt\n\n# Horizontal bar plot with gaps\nfig, ax = plt.subplots()\nax.broken_barh([(110, 30), (150, 10)], (10, 9), facecolors='tab:blue')\nax.broken_barh([(10, 50), (100, 20), (130, 10)], (20, 9),\n               facecolors=('tab:orange tab:green tab:red'))\nax.set_ylim(5, 35)\nax.set_xlim(0, 200)\nax.set_xlabel('seconds since start')\nax.set_yticks([15, 25], labels=['Bill Jim'])     # Modify y-axis tick labels\nax.grid(True)                                       # Make grid lines visible\nax.annotate('race interrupted', (61, 25),\n            xytext=(0.8, 0.9), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            fontsize=16,\n            horizontalalignment='right', verticalalignment='top')\n\nplt.show()\n",
    "id": 4
},
{
    "title": "CapStyle",
    "text": "The matplotlib._enums.CapStyle controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\nCapStyle docs.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib._enums import CapStyle\n\nCapStyle.demo()\nplt.show()\n",
    "id": 5
},
{
    "title": "Plotting the coherence of two signals",
    "text": "An example showing how to plot the coherence of two signals using cohere.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 30, dt)\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\n\n# Two signals with a coherent part at 10 Hz and a random part\ns1 = np.sin(2 * np.pi * 10 * t) + nse1\ns2 = np.sin(2 * np.pi * 10 * t) + nse2\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\naxs[0].plot(t, s1, t, s2)\naxs[0].set_xlim(0, 2)\naxs[0].set_xlabel('Time (s)')\naxs[0].set_ylabel('s1 and s2')\naxs[0].grid(True)\n\ncxy, f = axs[1].cohere(s1, s2, 256, 1. / dt)\naxs[1].set_ylabel('Coherence')\n\nplt.show()\n",
    "id": 6
},
{
    "title": "Cross spectral density (CSD)",
    "text": "Plot the cross spectral density (CSD) of two signals using csd.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax1, ax2) = plt.subplots(2, 1, layout='constrained')\n\ndt = 0.01\nt = np.arange(0, 30, dt)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\nr = np.exp(-t / 0.05)\n\ncnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1\ncnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2\n\n# two signals with a coherent part and a random part\ns1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1\ns2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2\n\nax1.plot(t, s1, t, s2)\nax1.set_xlim(0, 5)\nax1.set_xlabel('Time (s)')\nax1.set_ylabel('s1 and s2')\nax1.grid(True)\n\ncxy, f = ax2.csd(s1, s2, 256, 1. / dt)\nax2.set_ylabel('CSD (dB)')\n\nplt.show()\n",
    "id": 7
},
{
    "title": "Errorbar subsampling",
    "text": "The parameter errorevery of Axes.errorbar can be used to draw error bars\nonly on a subset of data points. This is particularly useful if there are many\ndata points with similar errors.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.1)\ny1 = np.exp(-1.0 * x)\ny2 = np.exp(-0.5 * x)\n\n# example variable error bar values\ny1err = 0.1 + 0.1 * np.sqrt(x)\ny2err = 0.1 + 0.1 * np.sqrt(x/2)\n\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3, sharex=True,\n                                    figsize=(12, 6))\n\nax0.set_title('all errorbars')\nax0.errorbar(x, y1, yerr=y1err)\nax0.errorbar(x, y2, yerr=y2err)\n\nax1.set_title('only every 6th errorbar')\nax1.errorbar(x, y1, yerr=y1err, errorevery=6)\nax1.errorbar(x, y2, yerr=y2err, errorevery=6)\n\nax2.set_title('second series shifted by 3')\nax2.errorbar(x, y1, yerr=y1err, errorevery=(0, 6))\nax2.errorbar(x, y2, yerr=y2err, errorevery=(3, 6))\n\nfig.suptitle('Errorbar subsampling')\nplt.show()\n",
    "id": 8
},
{
    "title": "EventCollection Demo",
    "text": "Plot two curves, then use EventCollections to mark the locations of the x\nand y data points on the respective axes for each curve.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EventCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# create random data\nxdata = np.random.random([2, 10])\n\n# split the data into two parts\nxdata1 = xdata[0, :]\nxdata2 = xdata[1, :]\n\n# sort the data so it makes clean curves\nxdata1.sort()\nxdata2.sort()\n\n# create some y data points\nydata1 = xdata1 ** 2\nydata2 = 1 - xdata2 ** 3\n\n# plot the data\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.plot(xdata1, ydata1, color='tab:blue')\nax.plot(xdata2, ydata2, color='tab:orange')\n\n# create the events marking the x data points\nxevents1 = EventCollection(xdata1, color='tab:blue', linelength=0.05)\nxevents2 = EventCollection(xdata2, color='tab:orange', linelength=0.05)\n\n# create the events marking the y data points\nyevents1 = EventCollection(ydata1, color='tab:blue', linelength=0.05,\n                           orientation='vertical')\nyevents2 = EventCollection(ydata2, color='tab:orange', linelength=0.05,\n                           orientation='vertical')\n\n# add the events to the axis\nax.add_collection(xevents1)\nax.add_collection(xevents2)\nax.add_collection(yevents1)\nax.add_collection(yevents2)\n\n# set the limits\nax.set_xlim([0, 1])\nax.set_ylim([0, 1])\n\nax.set_title('line plot with data points')\n\n# display the plot\nplt.show()\n",
    "id": 9
},
{
    "title": "Eventplot demo",
    "text": "An eventplot showing sequences of events with various line\nproperties. The plot is shown in both horizontal and vertical orientations.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\n\nmatplotlib.rcParams['font.size'] = 8.0\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# create random data\ndata1 = np.random.random([6, 50])\n\n# set different colors for each set of positions\ncolors1 = [f'C{i}' for i in range(6)]\n\n# set different line properties for each set of positions\n# note that some overlap\nlineoffsets1 = [-15, -3, 1, 1.5, 6, 10]\nlinelengths1 = [5, 2, 1, 1, 3, 1.5]\n\nfig, axs = plt.subplots(2, 2)\n\n# create a horizontal plot\naxs[0, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1)\n\n# create a vertical plot\naxs[1, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1, orientation='vertical')\n\n# create another set of random data.\n# the gamma distribution is only used for aesthetic purposes\ndata2 = np.random.gamma(4, size=[60, 50])\n\n# use individual values for the parameters this time\n# these values will be used for all data sets (except lineoffsets2, which\n# sets the increment between each data set in this usage)\ncolors2 = 'black'\nlineoffsets2 = 1\nlinelengths2 = 1\n\n# create a horizontal plot\naxs[0, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2)\n\n\n# create a vertical plot\naxs[1, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2, orientation='vertical')\n\nplt.show()\n",
    "id": 10
},
{
    "title": "Bar chart with gradients",
    "text": "Matplotlib does not natively support gradients. However, we can emulate a\ngradient-filled rectangle by an AxesImage of the right size and coloring. In particular, we use a colormap to generate the actual colors. It is then\nsufficient to define the underlying values on the corners of the image and\nlet bicubic interpolation fill out the area. We define the gradient direction\nby a unit vector v. The values at the corners are then obtained by the\nlengths of the projections of the corner vectors on v. A similar approach can be used to create a gradient background for an Axes.\nIn that case, it is helpful to use Axes coordinates (extent=(0, 1, 0, 1),\ntransform=ax.transAxes) to be independent of the data coordinates.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\ndef gradient_image(ax, direction=0.3, cmap_range=(0, 1), **kwargs):\n    '''\n    Draw a gradient image based on a colormap.\n\n    Parameters\n    ----------\n    ax : Axes\n        The axes to draw on.\n    direction : float\n        The direction of the gradient. This is a number in\n        range 0 (=vertical) to 1 (=horizontal).\n    cmap_range : float, float\n        The fraction (cmin, cmax) of the colormap that should be\n        used for the gradient, where the complete colormap is (0, 1).\n    **kwargs\n        Other parameters are passed on to `.Axes.imshow()`.\n        In particular, *cmap*, *extent*, and *transform* may be useful.\n    '''\n    phi = direction * np.pi / 2\n    v = np.array([np.cos(phi), np.sin(phi)])\n    X = np.array([[v @ [1, 0], v @ [1, 1]],\n                  [v @ [0, 0], v @ [0, 1]]])\n    a, b = cmap_range\n    X = a + (b - a) / X.max() * X\n    im = ax.imshow(X, interpolation='bicubic', clim=(0, 1),\n                   aspect='auto', **kwargs)\n    return im\n\n\ndef gradient_bar(ax, x, y, width=0.5, bottom=0):\n    for left, top in zip(x, y):\n        right = left + width\n        gradient_image(ax, extent=(left, right, bottom, top),\n                       cmap=plt.cm.Blues_r, cmap_range=(0, 0.8))\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 1))\n\n# background image\ngradient_image(ax, direction=1, extent=(0, 1, 0, 1), transform=ax.transAxes,\n               cmap=plt.cm.RdYlGn, cmap_range=(0.2, 0.8), alpha=0.5)\n\nN = 10\nx = np.arange(N) + 0.15\ny = np.random.rand(N)\ngradient_bar(ax, x, y, width=0.7)\nplt.show()\n",
    "id": 11
},
{
    "title": "Hat graph",
    "text": "This example shows how to create a hat graph and how to annotate it with\nlabels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hat_graph(ax, xlabels, values, group_labels):\n    '''\n    Create a hat graph.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        The Axes to plot into.\n    xlabels : list of str\n        The category names to be displayed on the x-axis.\n    values : (M, N) array-like\n        The data values.\n        Rows are the groups (len(group_labels) == M).\n        Columns are the categories (len(xlabels) == N).\n    group_labels : list of str\n        The group labels displayed in the legend.\n    '''\n\n    def label_bars(heights, rects):\n        '''Attach a text label on top of each bar.'''\n        for height, rect in zip(heights, rects):\n            ax.annotate(f'{height}',\n                        xy=(rect.get_x() + rect.get_width() / 2, height),\n                        xytext=(0, 4),  # 4 points vertical offset.\n                        textcoords='offset points',\n                        ha='center', va='bottom')\n\n    values = np.asarray(values)\n    x = np.arange(values.shape[1])\n    ax.set_xticks(x, labels=xlabels)\n    spacing = 0.3  # spacing between hat groups\n    width = (1 - spacing) / values.shape[0]\n    heights0 = values[0]\n    for i, (heights, group_label) in enumerate(zip(values, group_labels)):\n        style = {'fill': False} if i == 0 else {'edgecolor': 'black'}\n        rects = ax.bar(x - spacing/2 + i * width, heights - heights0,\n                       width, bottom=heights0, label=group_label, **style)\n        label_bars(heights, rects)\n\n\n# initialise labels and a numpy array make sure you have\n# N labels of N number of values in the array\nxlabels = ['I', 'II', 'III', 'IV', 'V']\nplayerA = np.array([5, 15, 22, 20, 25])\nplayerB = np.array([25, 32, 34, 30, 27])\n\nfig, ax = plt.subplots()\nhat_graph(ax, xlabels, [playerA, playerB], ['Player A', 'Player B'])\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel('Games')\nax.set_ylabel('Score')\nax.set_ylim(0, 60)\nax.set_title('Scores by number of game and players')\nax.legend()\n\nfig.tight_layout()\nplt.show()\n",
    "id": 12
},
{
    "title": "Discrete distribution as horizontal bar chart",
    "text": "Stacked bar charts can be used to visualize discrete distributions. This example visualizes the result of a survey in which people could rate\ntheir agreement to questions on a five-element scale. The horizontal stacking is achieved by calling barh() for each\ncategory and passing the starting point as the cumulative sum of the\nalready drawn bars via the parameter left. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.barh / matplotlib.pyplot.barh matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label matplotlib.axes.Axes.legend / matplotlib.pyplot.legend",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ncategory_names = ['Strongly disagree', 'Disagree',\n                  'Neither agree nor disagree', 'Agree', 'Strongly agree']\nresults = {\n    'Question 1': [10, 15, 17, 32, 26],\n    'Question 2': [26, 22, 29, 10, 13],\n    'Question 3': [35, 37, 7, 2, 19],\n    'Question 4': [32, 11, 9, 15, 33],\n    'Question 5': [21, 29, 5, 5, 40],\n    'Question 6': [8, 19, 5, 30, 38]\n}\n\n\ndef survey(results, category_names):\n    '''\n    Parameters\n    ----------\n    results : dict\n        A mapping from question labels to a list of answers per category.\n        It is assumed all lists contain the same number of entries and that\n        it matches the length of *category_names*.\n    category_names : list of str\n        The category labels.\n    '''\n    labels = list(results.keys())\n    data = np.array(list(results.values()))\n    data_cum = data.cumsum(axis=1)\n    category_colors = plt.colormaps['RdYlGn'](\n        np.linspace(0.15, 0.85, data.shape[1]))\n\n    fig, ax = plt.subplots(figsize=(9.2, 5))\n    ax.invert_yaxis()\n    ax.xaxis.set_visible(False)\n    ax.set_xlim(0, np.sum(data, axis=1).max())\n\n    for i, (colname, color) in enumerate(zip(category_names, category_colors)):\n        widths = data[:, i]\n        starts = data_cum[:, i] - widths\n        rects = ax.barh(labels, widths, left=starts, height=0.5,\n                        label=colname, color=color)\n\n        r, g, b, _ = color\n        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'\n        ax.bar_label(rects, label_type='center', color=text_color)\n    ax.legend(ncols=len(category_names), bbox_to_anchor=(0, 1),\n              loc='lower left', fontsize='small')\n\n    return fig, ax\n\n\nsurvey(results, category_names)\nplt.show()\n",
    "id": 13
},
{
    "title": "JoinStyle",
    "text": "The matplotlib._enums.JoinStyle controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\nJoinStyle docs.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib._enums import JoinStyle\n\nJoinStyle.demo()\nplt.show()\n",
    "id": 14
},
{
    "title": "Customizing dashed line styles",
    "text": "The dashing of a line is controlled via a dash sequence. It can be modified\nusing Line2D.set_dashes. The dash sequence is a series of on/off lengths in points, e.g.\n[3, 1] would be 3pt long lines separated by 1pt spaces. Some functions like Axes.plot support passing Line properties as keyword\narguments. In such a case, you can already set the dashing when creating the\nline. Note: The dash style can also be configured via a\nproperty_cycle\nby passing a list of dash sequences using the keyword dashes to the\ncycler. This is not shown within this example. Other attributes of the dash may also be set either with the relevant method\n(set_dash_capstyle, set_dash_joinstyle,\nset_gapcolor) or by passing the property through a plotting\nfunction.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 500)\ny = np.sin(x)\n\nplt.rc('lines', linewidth=2.5)\nfig, ax = plt.subplots()\n\n# Using set_dashes() and set_capstyle() to modify dashing of an existing line.\nline1, = ax.plot(x, y, label='Using set_dashes() and set_dash_capstyle()')\nline1.set_dashes([2, 2, 10, 2])  # 2pt line, 2pt break, 10pt line, 2pt break.\nline1.set_dash_capstyle('round')\n\n# Using plot(..., dashes=...) to set the dashing when creating a line.\nline2, = ax.plot(x, y - 0.2, dashes=[6, 2], label='Using the dashes parameter')\n\n# Using plot(..., dashes=..., gapcolor=...) to set the dashing and\n# alternating color when creating a line.\nline3, = ax.plot(x, y - 0.4, dashes=[4, 4], gapcolor='tab:pink',\n                 label='Using the dashes and gapcolor parameters')\n\nax.legend(handlelength=4)\nplt.show()\n",
    "id": 15
},
{
    "title": "Lines with a ticked patheffect",
    "text": "Ticks can be added along a line to mark one side as a barrier using\nTickedStroke. You can control the angle,\nspacing, and length of the ticks. The ticks will also appear appropriately in the legend.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\n# Plot a straight diagonal line with ticked style path\nfig, ax = plt.subplots(figsize=(6, 6))\nax.plot([0, 1], [0, 1], label='Line',\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\n# Plot a curved line with ticked style path\nnx = 101\nx = np.linspace(0.0, 1.0, nx)\ny = 0.3*np.sin(x*8) + 0.4\nax.plot(x, y, label='Curve', path_effects=[patheffects.withTickedStroke()])\n\nax.legend()\n\nplt.show()\n",
    "id": 16
},
{
    "title": "Linestyles",
    "text": "Simple linestyles can be defined using the strings \"solid\", \"dotted\", \"dashed\"\nor \"dashdot\". More refined control can be achieved by providing a dash tuple\n(offset, (on_off_seq)). For example, (0, (3, 10, 1, 15)) means\n(3pt line, 10pt space, 1pt line, 15pt space) with no offset, while\n(5, (10, 3)), means (10pt line, 3pt space), but skip the first 5pt line.\nSee also Line2D.set_linestyle. Note: The dash style can also be configured via Line2D.set_dashes\nas shown in Customizing dashed line styles\nand passing a list of dash sequences using the keyword dashes to the\ncycler in property_cycle.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nlinestyle_str = [\n     ('solid', 'solid'),      # Same as (0, ()) or '-'\n     ('dotted', 'dotted'),    # Same as (0, (1, 1)) or ':'\n     ('dashed', 'dashed'),    # Same as '--'\n     ('dashdot', 'dashdot')]  # Same as '-.'\n\nlinestyle_tuple = [\n     ('loosely dotted',        (0, (1, 10))),\n     ('dotted',                (0, (1, 1))),\n     ('densely dotted',        (0, (1, 1))),\n     ('long dash with offset', (5, (10, 3))),\n     ('loosely dashed',        (0, (5, 10))),\n     ('dashed',                (0, (5, 5))),\n     ('densely dashed',        (0, (5, 1))),\n\n     ('loosely dashdotted',    (0, (3, 10, 1, 10))),\n     ('dashdotted',            (0, (3, 5, 1, 5))),\n     ('densely dashdotted',    (0, (3, 1, 1, 1))),\n\n     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),\n     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),\n     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1)))]\n\n\ndef plot_linestyles(ax, linestyles, title):\n    X, Y = np.linspace(0, 100, 10), np.zeros(10)\n    yticklabels = []\n\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.plot(X, Y+i, linestyle=linestyle, linewidth=1.5, color='black')\n        yticklabels.append(name)\n\n    ax.set_title(title)\n    ax.set(ylim=(-0.5, len(linestyles)-0.5),\n           yticks=np.arange(len(linestyles)),\n           yticklabels=yticklabels)\n    ax.tick_params(left=False, bottom=False, labelbottom=False)\n    ax.spines[:].set_visible(False)\n\n    # For each line style, add a text annotation with a small offset from\n    # the reference point (0 in Axes coords, y tick value in Data coords).\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.annotate(repr(linestyle),\n                    xy=(0.0, i), xycoords=ax.get_yaxis_transform(),\n                    xytext=(-6, -12), textcoords='offset points',\n                    color='blue', fontsize=8, ha='right', family='monospace')\n\n\nfig, (ax0, ax1) = plt.subplots(2, 1, figsize=(10, 8), height_ratios=[1, 3])\n\nplot_linestyles(ax0, linestyle_str[::-1], title='Named linestyles')\nplot_linestyles(ax1, linestyle_tuple[::-1], title='Parametrized linestyles')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 17
},
{
    "title": "Plotting masked and NaN values",
    "text": "Sometimes you need to plot data with missing values. One possibility is to simply remove undesired data points. The line plotted\nthrough the remaining data will be continuous, and not indicate where the\nmissing data is located. If it is useful to have gaps in the line where the data is missing, then the\nundesired points can be indicated using a masked array or by setting their\nvalues to NaN. No marker will be drawn where either x or y are masked and, if\nplotting with a line, it will be broken there. The following example illustrates the three cases: Removing points. Masking points. Setting to NaN.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-np.pi/2, np.pi/2, 31)\ny = np.cos(x)**3\n\n# 1) remove points where y > 0.7\nx2 = x[y <= 0.7]\ny2 = y[y <= 0.7]\n\n# 2) mask points where y > 0.7\ny3 = np.ma.masked_where(y > 0.7, y)\n\n# 3) set to NaN where y > 0.7\ny4 = y.copy()\ny4[y3 > 0.7] = np.nan\n\nplt.plot(x*0.1, y, 'o-', color='lightgrey', label='No mask')\nplt.plot(x2*0.4, y2, 'o-', label='Points removed')\nplt.plot(x*0.7, y3, 'o-', label='Masked values')\nplt.plot(x*1.0, y4, 'o-', label='NaN values')\nplt.legend()\nplt.title('Masked and NaN data')\nplt.show()\n",
    "id": 18
},
{
    "title": "Multicolored lines",
    "text": "This example shows how to make a multicolored line. In this example, the line\nis colored based on its derivative.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\nfrom matplotlib.colors import BoundaryNorm, ListedColormap\n\nx = np.linspace(0, 3 * np.pi, 500)\ny = np.sin(x)\ndydx = np.cos(0.5 * (x[:-1] + x[1:]))  # first derivative\n\n# Create a set of line segments so that we can color them individually\n# This creates the points as an N x 1 x 2 array so that we can stack points\n# together easily to get the segments. The segments array for line collection\n# needs to be (numlines) x (points per line) x 2 (for x and y)\npoints = np.array([x, y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis=1)\n\nfig, axs = plt.subplots(2, 1, sharex=True, sharey=True)\n\n# Create a continuous norm to map from data points to colors\nnorm = plt.Normalize(dydx.min(), dydx.max())\nlc = LineCollection(segments, cmap='viridis', norm=norm)\n# Set the values used for colormapping\nlc.set_array(dydx)\nlc.set_linewidth(2)\nline = axs[0].add_collection(lc)\nfig.colorbar(line, ax=axs[0])\n\n# Use a boundary norm instead\ncmap = ListedColormap(['r g b'])\nnorm = BoundaryNorm([-1, -0.5, 0.5, 1], cmap.N)\nlc = LineCollection(segments, cmap=cmap, norm=norm)\nlc.set_array(dydx)\nlc.set_linewidth(2)\nline = axs[1].add_collection(lc)\nfig.colorbar(line, ax=axs[1])\n\naxs[0].set_xlim(x.min(), x.max())\naxs[0].set_ylim(-1.1, 1.1)\nplt.show()\n",
    "id": 19
},
{
    "title": "Mapping marker properties to multivariate data",
    "text": "This example shows how to use different properties of markers to plot\nmultivariate datasets. Here we represent a successful baseball throw as a\nsmiley face with marker size mapped to the skill of thrower, marker rotation to\nthe take-off angle, and thrust to the marker color.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\n\nSUCCESS_SYMBOLS = [\n    TextPath((0, 0), '\u2639'),\n    TextPath((0, 0), '\ud83d\ude12'),\n    TextPath((0, 0), '\u263a'),\n]\n\nN = 25\nnp.random.seed(42)\nskills = np.random.uniform(5, 80, size=N) * 0.1 + 5\ntakeoff_angles = np.random.normal(0, 90, N)\nthrusts = np.random.uniform(size=N)\nsuccessful = np.random.randint(0, 3, size=N)\npositions = np.random.normal(size=(N, 2)) * 5\ndata = zip(skills, takeoff_angles, thrusts, successful, positions)\n\ncmap = plt.colormaps['plasma']\nfig, ax = plt.subplots()\nfig.suptitle('Throwing success', size=14)\nfor skill, takeoff, thrust, mood, pos in data:\n    t = Affine2D().scale(skill).rotate_deg(takeoff)\n    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t)\n    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust))\nfig.colorbar(plt.cm.ScalarMappable(norm=Normalize(0, 1), cmap=cmap),\n             ax=ax, label='Normalized Thrust [a.u.]')\nax.set_xlabel('X position [m]')\nax.set_ylabel('Y position [m]')\n\nplt.show()\n",
    "id": 20
},
{
    "title": "Scatter Demo2",
    "text": "Demo of scatter plot with varying marker colors and sizes.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\nprice_data = cbook.get_sample_data('goog.npz')['price_data']\nprice_data = price_data[-250:]  # get the most recent 250 trading days\n\ndelta1 = np.diff(price_data['adj_close']) / price_data['adj_close'][:-1]\n\n# Marker size in units of points^2\nvolume = (15 * price_data['volume'][:-2] / price_data['volume'][0])**2\nclose = 0.003 * price_data['close'][:-2] / 0.003 * price_data['open'][:-2]\n\nfig, ax = plt.subplots()\nax.scatter(delta1[:-1], delta1[1:], c=close, s=volume, alpha=0.5)\n\nax.set_xlabel(r'$\\\\Delta_i$', fontsize=15)\nax.set_ylabel(r'$\\\\Delta_{i+1}$', fontsize=15)\nax.set_title('Volume and percent change')\n\nax.grid(True)\nfig.tight_layout()\n\nplt.show()\n",
    "id": 21
},
{
    "title": "Scatter Masked",
    "text": "Mask some data points and add a line demarking\nmasked regions.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 100\nr0 = 0.6\nx = 0.9 * np.random.rand(N)\ny = 0.9 * np.random.rand(N)\narea = (20 * np.random.rand(N))**2  # 0 to 10 point radii\nc = np.sqrt(area)\nr = np.sqrt(x ** 2 + y ** 2)\narea1 = np.ma.masked_where(r < r0, area)\narea2 = np.ma.masked_where(r >= r0, area)\nplt.scatter(x, y, s=area1, marker='^', c=c)\nplt.scatter(x, y, s=area2, marker='o', c=c)\n# Show the boundary between the regions:\ntheta = np.arange(0, np.pi / 2, 0.01)\nplt.plot(r0 * np.cos(theta), r0 * np.sin(theta))\n\nplt.show()\n",
    "id": 22
},
{
    "title": "Marker examples",
    "text": "Example with different ways to specify markers. See also the matplotlib.markers documentation for a list of all markers and\nMarker reference for more information\non configuring markers.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(10)\ny = np.random.rand(10)\nz = np.sqrt(x**2 + y**2)\n\nfig, axs = plt.subplots(2, 3, sharex=True, sharey=True, layout='constrained')\n\n# Matplotlib marker symbol\naxs[0, 0].scatter(x, y, s=80, c=z, marker='>')\naxs[0, 0].set_title('marker='>'')\n\n# marker from TeX: passing a TeX symbol name enclosed in $-signs\naxs[0, 1].scatter(x, y, s=80, c=z, marker=r'$\\\\clubsuit$')\naxs[0, 1].set_title(r'marker=r'\\\\$\\\\clubsuit\\\\$'')\n\n# marker from path: passing a custom path of N vertices as a (N, 2) array-like\nverts = [[-1, -1], [1, -1], [1, 1], [-1, -1]]\naxs[0, 2].scatter(x, y, s=80, c=z, marker=verts)\naxs[0, 2].set_title('marker=verts')\n\n# regular pentagon marker\naxs[1, 0].scatter(x, y, s=80, c=z, marker=(5, 0))\naxs[1, 0].set_title('marker=(5, 0)')\n\n# regular 5-pointed star marker\naxs[1, 1].scatter(x, y, s=80, c=z, marker=(5, 1))\naxs[1, 1].set_title('marker=(5, 1)')\n\n# regular 5-pointed asterisk marker\naxs[1, 2].scatter(x, y, s=80, c=z, marker=(5, 2))\naxs[1, 2].set_title('marker=(5, 2)')\n\nplt.show()\n",
    "id": 23
},
{
    "title": "Simple Plot",
    "text": "Create a simple plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.pyplot.subplots matplotlib.figure.Figure.savefig",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\n       title='About as simple as it gets, folks')\nax.grid()\n\nfig.savefig('test.png')\nplt.show()\n",
    "id": 24
},
{
    "title": "Shade regions defined by a logical mask using fill_between",
    "text": "References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.fill_between",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2, 0.01)\ns = np.sin(2*np.pi*t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s, color='black')\nax.axhline(0, color='black')\n\nax.fill_between(t, 1, where=s > 0, facecolor='green', alpha=.5)\nax.fill_between(t, -1, where=s < 0, facecolor='red', alpha=.5)\n\nplt.show()\n",
    "id": 25
},
{
    "title": "Spectrum representations",
    "text": "The plots show different spectrum representations of a sine signal with\nadditive noise. A (frequency) spectrum of a discrete-time signal is calculated\nby utilizing the fast Fourier transform (FFT). Total running time of the script: (0 minutes 1.201 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(0)\n\ndt = 0.01  # sampling interval\nFs = 1 / dt  # sampling frequency\nt = np.arange(0, 10, dt)\n\n# generate noise:\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\n\ns = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal\n\nfig = plt.figure(figsize=(7, 7), layout='constrained')\naxs = fig.subplot_mosaic([['signal', 'signal'],\n                          ['magnitude', 'log_magnitude'],\n                          ['phase', 'angle']])\n\n# plot time signal:\naxs['signal'].set_title('Signal')\naxs['signal'].plot(t, s, color='C0')\naxs['signal'].set_xlabel('Time (s)')\naxs['signal'].set_ylabel('Amplitude')\n\n# plot different spectrum types:\naxs['magnitude'].set_title('Magnitude Spectrum')\naxs['magnitude'].magnitude_spectrum(s, Fs=Fs, color='C1')\n\naxs['log_magnitude'].set_title('Log. Magnitude Spectrum')\naxs['log_magnitude'].magnitude_spectrum(s, Fs=Fs, scale='dB', color='C1')\n\naxs['phase'].set_title('Phase Spectrum ')\naxs['phase'].phase_spectrum(s, Fs=Fs, color='C2')\n\naxs['angle'].set_title('Angle Spectrum')\naxs['angle'].angle_spectrum(s, Fs=Fs, color='C2')\n\nplt.show()\n",
    "id": 26
},
{
    "title": "hlines and vlines",
    "text": "This example showcases the functions hlines and vlines.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nt = np.arange(0.0, 5.0, 0.1)\ns = np.exp(-t) + np.sin(2 * np.pi * t) + 1\nnse = np.random.normal(0.0, 0.3, t.shape) * s\n\nfig, (vax, hax) = plt.subplots(1, 2, figsize=(12, 6))\n\nvax.plot(t, s + nse, '^')\nvax.vlines(t, [0], s)\n# By using ``transform=vax.get_xaxis_transform()`` the y coordinates are scaled\n# such that 0 maps to the bottom of the axes and 1 to the top.\nvax.vlines([1, 2], 0, 1, transform=vax.get_xaxis_transform(), colors='r')\nvax.set_xlabel('time (s)')\nvax.set_title('Vertical lines demo')\n\nhax.plot(s + nse, t, '^')\nhax.hlines(t, [0], s, lw=2)\nhax.set_xlabel('time (s)')\nhax.set_title('Horizontal lines demo')\n\nplt.show()\n",
    "id": 27
},
{
    "title": "Cross- and auto-correlation",
    "text": "Example use of cross-correlation (xcorr) and auto-correlation\n(acorr) plots. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.acorr / matplotlib.pyplot.acorr matplotlib.axes.Axes.xcorr / matplotlib.pyplot.xcorr",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nx, y = np.random.randn(2, 100)\nfig, [ax1, ax2] = plt.subplots(2, 1, sharex=True)\nax1.xcorr(x, y, usevlines=True, maxlags=50, normed=True, lw=2)\nax1.grid(True)\nax1.set_title('Cross-correlation (xcorr)')\n\nax2.acorr(x, usevlines=True, normed=True, maxlags=50, lw=2)\nax2.grid(True)\nax2.set_title('Auto-correlation (acorr)')\n\nplt.show()\n",
    "id": 28
},
{
    "title": "Affine transform of an image",
    "text": "Prepending an affine transformation (Affine2D) to the data\ntransform of an image allows to manipulate the image's shape and\norientation. This is an example of the concept of transform chaining.\", 'The image of the output should have its boundary match the dashed yellow\nrectangle. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.transforms.Affine2D",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\n\ndef get_image():\n    delta = 0.25\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2)\n    return Z\n\n\ndef do_plot(ax, Z, transform):\n    im = ax.imshow(Z, interpolation='none',\n                   origin='lower',\n                   extent=[-2, 4, -3, 2], clip_on=True)\n\n    trans_data = transform + ax.transData\n    im.set_transform(trans_data)\n\n    # display intended extent of the image\n    x1, x2, y1, y2 = im.get_extent()\n    ax.plot([x1, x2, x2, x1, x1], [y1, y1, y2, y2, y1], 'y--',\n            transform=trans_data)\n    ax.set_xlim(-5, 5)\n    ax.set_ylim(-4, 4)\n\n\n# prepare image and figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nZ = get_image()\n\n# image rotation\ndo_plot(ax1, Z, mtransforms.Affine2D().rotate_deg(30))\n\n# image skew\ndo_plot(ax2, Z, mtransforms.Affine2D().skew_deg(30, 15))\n\n# scale and reflection\ndo_plot(ax3, Z, mtransforms.Affine2D().scale(-1, .5))\n\n# everything and a translation\ndo_plot(ax4, Z, mtransforms.Affine2D().\n        rotate_deg(30).skew_deg(30, 15).scale(-1, .5).translate(.5, -1))\n\nplt.show()\n",
    "id": 29
},
{
    "title": "Barcode",
    "text": "This demo shows how to produce a bar code. The figure size is calculated so that the width in pixels is a multiple of the\nnumber of data points to prevent interpolation artifacts. Additionally, the\nAxes is defined to span the whole figure and all Axis are turned off. The data itself is rendered with imshow using code.reshape(1, -1) to turn the data into a 2D array with one row.', \"imshow(..., aspect='auto') to allow for non-square pixels.\", \"imshow(..., interpolation='nearest') to prevent blurred edges. This\nshould not happen anyway because we fine-tuned the figure width in pixels,\nbut just to be safe.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.add_axes",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ncode = np.array([\n    1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,\n    0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,\n    1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,\n    1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1])\n\npixel_per_bar = 4\ndpi = 100\n\nfig = plt.figure(figsize=(len(code) * pixel_per_bar / dpi, 2), dpi=dpi)\nax = fig.add_axes([0, 0, 1, 1])  # span the whole figure\nax.set_axis_off()\nax.imshow(code.reshape(1, -1), cmap='binary', aspect='auto',\n          interpolation='nearest')\nplt.show()\n",
    "id": 30
},
{
    "title": "Interactive Adjustment of Colormap Range",
    "text": "Demonstration of how a colorbar can be used to interactively adjust the\nrange of colormapping on an image. To use the interactive feature, you must\nbe in either zoom mode (magnifying glass toolbar button) or\npan mode (4-way arrow toolbar button) and click inside the colorbar. When zooming, the bounding box of the zoom region defines the new vmin and\nvmax of the norm. Zooming using the right mouse button will expand the\nvmin and vmax proportionally to the selected region, in the same manner that\none can zoom out on an axis. When panning, the vmin and vmax of the norm are\nboth shifted according to the direction of movement. The\nHome/Back/Forward buttons can also be used to get back to a previous state.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 2 * np.pi, 1024)\ndata2d = np.sin(t)[:, np.newaxis] * np.cos(t)[np.newaxis, :]\n\nfig, ax = plt.subplots()\nim = ax.imshow(data2d)\nax.set_title('Pan on the colorbar to shift the color mapping\\\n'\n             'Zoom on the colorbar to scale the color mapping')\n\nfig.colorbar(im, ax=ax, label='Interactive colorbar')\n\nplt.show()\n",
    "id": 31
},
{
    "title": "Contour Corner Mask",
    "text": "Illustrate the difference between corner_mask=False and\ncorner_mask=True for masked contour plots. The default is controlled by\nrcParamscontour.corner_mask (default: True). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Data to plot.\nx, y = np.meshgrid(np.arange(7), np.arange(10))\nz = np.sin(0.5 * x) * np.cos(0.52 * y)\n\n# Mask various z values.\nmask = np.zeros_like(z, dtype=bool)\nmask[2, 3:5] = True\nmask[3:5, 4] = True\nmask[7, 2] = True\nmask[5, 0] = True\nmask[0, 6] = True\nz = np.ma.array(z, mask=mask)\n\ncorner_masks = [False, True]\nfig, axs = plt.subplots(ncols=2)\nfor ax, corner_mask in zip(axs, corner_masks):\n    cs = ax.contourf(x, y, z, corner_mask=corner_mask)\n    ax.contour(cs, colors='k')\n    ax.set_title(f'{corner_mask=}')\n\n    # Plot grid.\n    ax.grid(c='k', ls='-', alpha=0.3)\n\n    # Indicate masked points with red circles.\n    ax.plot(np.ma.array(x, mask=~mask), y, 'ro')\n\nplt.show()\n",
    "id": 32
},
{
    "title": "Contour Image",
    "text": "Test combinations of contouring, filled contouring, and image plotting.\nFor contour labelling, see also the contour demo example. The emphasis in this demo is on showing how to make contours register\ncorrectly on images, and on how to get both of them oriented as desired.\nIn particular, note the usage of the \"origin\" and \"extent\" keyword arguments to imshow and\ncontour. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.Normalize",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\n\n# Default delta is large because that makes it fast, and it illustrates\n# the correct registration between image and contours.\ndelta = 0.5\n\nextent = (-3, 4, -4, 3)\n\nx = np.arange(-3.0, 4.001, delta)\ny = np.arange(-4.0, 3.001, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Boost the upper limit to avoid truncation errors.\nlevels = np.arange(-2.0, 1.601, 0.4)\n\nnorm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max())\ncmap = cm.PRGn\n\nfig, _axs = plt.subplots(nrows=2, ncols=2)\nfig.subplots_adjust(hspace=0.3)\naxs = _axs.flatten()\n\ncset1 = axs[0].contourf(X, Y, Z, levels, norm=norm,\n                        cmap=cmap.resampled(len(levels) - 1))\n# It is not necessary, but for the colormap, we need only the\n# number of levels minus 1.  To avoid discretization error, use\n# either this number or a large number such as the default (256).\n\n# If we want lines as well as filled regions, we need to call\n# contour separately; don't try to change the edgecolor or edgewidth\n# of the polygons in the collections returned by contourf.\n# Use levels output from previous call to guarantee they are the same.\n\ncset2 = axs[0].contour(X, Y, Z, cset1.levels, colors='k')\n\n# We don't really need dashed contour lines to indicate negative\n# regions, so let's turn them off.\ncset2.set_linestyle('solid')\n\n# It is easier here to make a separate call to contour than\n# to set up an array of colors and linewidths.\n# We are making a thick green line as a zero contour.\n# Specify the zero level as a tuple with only 0 in it.\n\ncset3 = axs[0].contour(X, Y, Z, (0,), colors='g', linewidths=2)\naxs[0].set_title('Filled contours')\nfig.colorbar(cset1, ax=axs[0])\n\n\naxs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm)\naxs[1].contour(Z, levels, colors='k', origin='upper', extent=extent)\naxs[1].set_title('Image, origin 'upper'')\n\naxs[2].imshow(Z, origin='lower', extent=extent, cmap=cmap, norm=norm)\naxs[2].contour(Z, levels, colors='k', origin='lower', extent=extent)\naxs[2].set_title('Image, origin 'lower'')\n\n# We will use the interpolation 'nearest' here to show the actual\n# image pixels.\n# Note that the contour lines don't extend to the edge of the box.\n# This is intentional. The Z values are defined at the center of each\n# image pixel (each color block on the following subplot), so the\n# domain that is contoured does not extend beyond these pixel centers.\nim = axs[3].imshow(Z, interpolation='nearest', extent=extent,\n                   cmap=cmap, norm=norm)\naxs[3].contour(Z, levels, colors='k', origin='image', extent=extent)\nylim = axs[3].get_ylim()\naxs[3].set_ylim(ylim[::-1])\naxs[3].set_title('Origin from rc, reversed y-axis')\nfig.colorbar(im, ax=axs[3])\n\nfig.tight_layout()\nplt.show()\n",
    "id": 33
},
{
    "title": "Contourf and log color scale",
    "text": "Demonstrate use of a log color scale in contourf References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.ticker.LogLocator",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import ma\n\nfrom matplotlib import cm, ticker\n\nN = 100\nx = np.linspace(-3.0, 3.0, N)\ny = np.linspace(-2.0, 2.0, N)\n\nX, Y = np.meshgrid(x, y)\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\n# Put in some negative values (lower left corner) to cause trouble with logs:\nz[:5, :5] = -1\n\n# The following is not strictly essential, but it will eliminate\n# a warning.  Comment it out to see the warning.\nz = ma.masked_where(z <= 0, z)\n\n\n# Automatic selection of levels works; setting the\n# log locator tells contourf to use a log scale:\nfig, ax = plt.subplots()\ncs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cm.PuBu_r)\n\n# Alternatively, you can manually set the levels\n# and the norm:\n# lev_exp = np.arange(np.floor(np.log10(z.min())-1),\n#                    np.ceil(np.log10(z.max())+1))\n# levs = np.power(10, lev_exp)\n# cs = ax.contourf(X, Y, z, levs, norm=colors.LogNorm())\n\ncbar = fig.colorbar(cs)\n\nplt.show()\n",
    "id": 34
},
{
    "title": "Contouring the solution space of optimizations",
    "text": "Contour plotting is particularly handy when illustrating the solution\nspace of optimization problems. Not only can axes.Axes.contour be\nused to represent the topography of the objective function, it can be\nused to generate boundary curves of the constraint functions. The\nconstraint lines can be drawn with\nTickedStroke to distinguish the valid and\ninvalid sides of the constraint boundaries. axes.Axes.contour generates curves with larger values to the left\nof the contour. The angle parameter is measured zero ahead with\nincreasing values to the left. Consequently, when using\nTickedStroke to illustrate a constraint in\na typical optimization problem, the angle should be set between\nzero and 180 degrees.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nnx = 101\nny = 105\n\n# Set up survey vectors\nxvec = np.linspace(0.001, 4.0, nx)\nyvec = np.linspace(0.001, 4.0, ny)\n\n# Set up survey matrices.  Design disk loading and gear ratio.\nx1, x2 = np.meshgrid(xvec, yvec)\n\n# Evaluate some stuff to plot\nobj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2\ng1 = -(3*x1 + x2 - 5.5)\ng2 = -(x1 + 2*x2 - 4.5)\ng3 = 0.8 + x1**-3 - x2\n\ncntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],\n                  colors='black')\nax.clabel(cntr, fmt='%2.1f', use_clabeltext=True)\n\ncg1 = ax.contour(x1, x2, g1, [0], colors='sandybrown')\ncg1.set(path_effects=[patheffects.withTickedStroke(angle=135)])\n\ncg2 = ax.contour(x1, x2, g2, [0], colors='orangered')\ncg2.set(path_effects=[patheffects.withTickedStroke(angle=60, length=2)])\n\ncg3 = ax.contour(x1, x2, g3, [0], colors='mediumblue')\ncg3.set(path_effects=[patheffects.withTickedStroke(spacing=7)])\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nplt.show()\n",
    "id": 35
},
{
    "title": "BboxImage Demo",
    "text": "A BboxImage can be used to position an image according to\na bounding box. This demo shows how to show an image inside a text.Text's\nbounding box as well as how to manually create a bounding box for the image.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.image.BboxImage matplotlib.transforms.Bbox matplotlib.transforms.TransformedBbox matplotlib.text.Text",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.image import BboxImage\nfrom matplotlib.transforms import Bbox, TransformedBbox\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# ----------------------------\n# Create a BboxImage with Text\n# ----------------------------\ntxt = ax1.text(0.5, 0.5, 'test', size=30, ha='center', color='w')\nax1.add_artist(\n    BboxImage(txt.get_window_extent, data=np.arange(256).reshape((1, -1))))\n\n# ------------------------------------\n# Create a BboxImage for each colormap\n# ------------------------------------\n# List of all colormaps; skip reversed colormaps.\ncmap_names = sorted(m for m in plt.colormaps if not m.endswith('_r'))\n\nncol = 2\nnrow = len(cmap_names) // ncol + 1\n\nxpad_fraction = 0.3\ndx = 1 / (ncol + xpad_fraction * (ncol - 1))\n\nypad_fraction = 0.3\ndy = 1 / (nrow + ypad_fraction * (nrow - 1))\n\nfor i, cmap_name in enumerate(cmap_names):\n    ix, iy = divmod(i, nrow)\n    bbox0 = Bbox.from_bounds(ix*dx*(1+xpad_fraction),\n                             1 - iy*dy*(1+ypad_fraction) - dy,\n                             dx, dy)\n    bbox = TransformedBbox(bbox0, ax2.transAxes)\n    ax2.add_artist(\n        BboxImage(bbox, cmap=cmap_name, data=np.arange(256).reshape((1, -1))))\n\nplt.show()\n",
    "id": 36
},
{
    "title": "Figimage Demo",
    "text": "This illustrates placing images directly in the figure, with no Axes objects. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure matplotlib.figure.Figure.figimage / matplotlib.pyplot.figimage",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nZ = np.arange(10000).reshape((100, 100))\nZ[:, 50:] = 1\n\nim1 = fig.figimage(Z, xo=50, yo=0, origin='lower')\nim2 = fig.figimage(Z, xo=100, yo=100, alpha=.8, origin='lower')\n\nplt.show()\n",
    "id": 37
},
{
    "title": "Clipping images with patches",
    "text": "Demo of image that's been clipped by a circular patch.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.artist.Artist.set_clip_path",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.patches as patches\n\nwith cbook.get_sample_data('grace_hopper.jpg') as image_file:\n    image = plt.imread(image_file)\n\nfig, ax = plt.subplots()\nim = ax.imshow(image)\npatch = patches.Circle((260, 200), radius=200, transform=ax.transData)\nim.set_clip_path(patch)\n\nax.axis('off')\nplt.show()\n",
    "id": 38
},
{
    "title": "Image Masked",
    "text": "imshow with masked array input and out-of-range colors. The second subplot illustrates the use of BoundaryNorm to\nget a filled contour effect. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.BoundaryNorm matplotlib.colorbar.Colorbar.set_label",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n# compute some interesting data\nx0, x1 = -5, 5\ny0, y1 = -3, 3\nx = np.linspace(x0, x1, 500)\ny = np.linspace(y0, y1, 500)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Set up a colormap:\npalette = plt.cm.gray.with_extremes(over='r', under='g', bad='b')\n# Alternatively, we could use\n# palette.set_bad(alpha = 0.0)\n# to make the bad region transparent.  This is the default.\n# If you comment out all the palette.set* lines, you will see\n# all the defaults; under and over will be colored with the\n# first and last colors in the palette, respectively.\nZm = np.ma.masked_where(Z > 1.2, Z)\n\n# By setting vmin and vmax in the norm, we establish the\n# range to which the regular palette color scale is applied.\n# Anything above that range is colored based on palette.set_over, etc.\n\n# set up the Axes objects\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 5.4))\n\n# plot using 'continuous' colormap\nim = ax1.imshow(Zm, interpolation='bilinear',\n                cmap=palette,\n                norm=colors.Normalize(vmin=-1.0, vmax=1.0),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax1.set_title('Green=low, Red=high, Blue=masked')\ncbar = fig.colorbar(im, extend='both', shrink=0.9, ax=ax1)\ncbar.set_label('uniform')\nax1.tick_params(axis='x', labelbottom=False)\n\n# Plot using a small number of colors, with unevenly spaced boundaries.\nim = ax2.imshow(Zm, interpolation='nearest',\n                cmap=palette,\n                norm=colors.BoundaryNorm([-1, -0.5, -0.2, 0, 0.2, 0.5, 1],\n                                         ncolors=palette.N),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax2.set_title('With BoundaryNorm')\ncbar = fig.colorbar(im, extend='both', spacing='proportional',\n                    shrink=0.9, ax=ax2)\ncbar.set_label('proportional')\n\nfig.suptitle('imshow, with out-of-range and masked data')\nplt.show()\n",
    "id": 39
},
{
    "title": "Image nonuniform",
    "text": "This illustrates the NonUniformImage class. It is not\navailable via an Axes method, but it is easily added to an\nAxes instance as shown here. Total running time of the script: (0 minutes 1.293 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.image import NonUniformImage\n\ninterp = 'nearest'\n\n# Linear x array for cell centers:\nx = np.linspace(-4, 4, 9)\n\n# Highly nonlinear x array:\nx2 = x**3\n\ny = np.linspace(-4, 4, 9)\n\nz = np.sqrt(x[np.newaxis, :]**2 + y[:, np.newaxis]**2)\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\nfig.suptitle('NonUniformImage class', fontsize='large')\nax = axs[0, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[0, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\ninterp = 'bilinear'\n\nax = axs[1, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[1, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nplt.show()\n",
    "id": 40
},
{
    "title": "Modifying the coordinate formatter",
    "text": "Modify the coordinate formatter to report the image \"z\" value of the nearest\npixel given x and y. This functionality is built in by default; this example\njust showcases how to customize the format_coord function. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.format_coord matplotlib.axes.Axes.imshow",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nX = 10*np.random.rand(5, 3)\n\nfig, ax = plt.subplots()\nax.imshow(X)\n\n\ndef format_coord(x, y):\n    col = round(x)\n    row = round(y)\n    nrows, ncols = X.shape\n    if 0 <= col < ncols and 0 <= row < nrows:\n        z = X[row, col]\n        return f'x={x:1.4f}, y={y:1.4f}, z={z:1.4f}'\n    else:\n        return f'x={x:1.4f}, y={y:1.4f}'\n\n\nax.format_coord = format_coord\nplt.show()\n",
    "id": 41
},
{
    "title": "Interpolations for imshow",
    "text": "This example displays the difference between interpolation methods for\nimshow. If interpolation is None, it defaults to the rcParamsimage.interpolation (default: \\'antialiased\\').\nIf the interpolation is \\'none\\', then no interpolation is performed for the\nAgg, ps and pdf backends. Other backends will default to \\'antialiased\\'.', \"For the Agg, ps and pdf backends, interpolation='none' works well when a\nbig image is scaled down, while interpolation='nearest' works well when\na small image is scaled up.\", \"See Image antialiasing for a\ndiscussion on the default interpolation='antialiased' option.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow Total running time of the script: (0 minutes 1.438 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nmethods = [None, 'none nearest bilinear bicubic spline16',\n           'spline36 hanning hamming hermite kaiser quadric',\n           'catrom gaussian bessel mitchell sinc lanczos']\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ngrid = np.random.rand(4, 4)\n\nfig, axs = plt.subplots(nrows=3, ncols=6, figsize=(9, 6),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\nfor ax, interp_method in zip(axs.flat, methods):\n    ax.imshow(grid, interpolation=interp_method, cmap='viridis')\n    ax.set_title(str(interp_method))\n\nplt.tight_layout()\nplt.show()\n",
    "id": 42
},
{
    "title": "Contour plot of irregularly spaced data",
    "text": "Comparison of a contour plot of irregularly spaced data interpolated\non a regular grid versus a tricontour plot for an unstructured triangular grid. Since contour and contourf expect the data to live\non a regular grid, plotting a contour plot of irregularly spaced data requires\ndifferent methods. The two options are: Interpolate the data to a regular grid first. This can be done with on-board\nmeans, e.g. via LinearTriInterpolator or using external functionality\ne.g. via scipy.interpolate.griddata. Then plot the interpolated data with\nthe usual contour. Directly use tricontour or tricontourf which will\nperform a triangulation internally. This example shows both methods in action. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nnp.random.seed(19680801)\nnpts = 200\nngridx = 100\nngridy = 200\nx = np.random.uniform(-2, 2, npts)\ny = np.random.uniform(-2, 2, npts)\nz = x * np.exp(-x**2 - y**2)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2)\n\n# -----------------------\n# Interpolation on a grid\n# -----------------------\n# A contour plot of irregularly spaced data coordinates\n# via interpolation on a grid.\n\n# Create grid values first.\nxi = np.linspace(-2.1, 2.1, ngridx)\nyi = np.linspace(-2.1, 2.1, ngridy)\n\n# Linearly interpolate the data (x, y) on a grid defined by (xi, yi).\ntriang = tri.Triangulation(x, y)\ninterpolator = tri.LinearTriInterpolator(triang, z)\nXi, Yi = np.meshgrid(xi, yi)\nzi = interpolator(Xi, Yi)\n\n# Note that scipy.interpolate provides means to interpolate data on a grid\n# as well. The following would be an alternative to the four lines above:\n# from scipy.interpolate import griddata\n# zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method='linear')\n\nax1.contour(xi, yi, zi, levels=14, linewidths=0.5, colors='k')\ncntr1 = ax1.contourf(xi, yi, zi, levels=14, cmap='RdBu_r')\n\nfig.colorbar(cntr1, ax=ax1)\nax1.plot(x, y, 'ko', ms=3)\nax1.set(xlim=(-2, 2), ylim=(-2, 2))\nax1.set_title('grid and contour (%d points, %d grid points)' %\n              (npts, ngridx * ngridy))\n\n# ----------\n# Tricontour\n# ----------\n# Directly supply the unordered, irregularly spaced coordinates\n# to tricontour.\n\nax2.tricontour(x, y, z, levels=14, linewidths=0.5, colors='k')\ncntr2 = ax2.tricontourf(x, y, z, levels=14, cmap='RdBu_r')\n\nfig.colorbar(cntr2, ax=ax2)\nax2.plot(x, y, 'ko', ms=3)\nax2.set(xlim=(-2, 2), ylim=(-2, 2))\nax2.set_title('tricontour (%d points)' % npts)\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n",
    "id": 43
},
{
    "title": "Layer Images",
    "text": "Layer images above one another using alpha blending References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef func3(x, y):\n    return (1 - x / 2 + x**5 + y**3) * np.exp(-(x**2 + y**2))\n\n\n# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\nx = np.arange(-3.0, 3.0, dx)\ny = np.arange(-3.0, 3.0, dy)\nX, Y = np.meshgrid(x, y)\n\n# when layering multiple images, the images need to have the same\n# extent.  This does not mean they need to have the same shape, but\n# they both need to render to the same coordinate system determined by\n# xmin, xmax, ymin, ymax.  Note if you use different interpolations\n# for the images their apparent extent could be different due to\n# interpolation edge effects\n\nextent = np.min(x), np.max(x), np.min(y), np.max(y)\nfig = plt.figure(frameon=False)\n\nZ1 = np.add.outer(range(8), range(8)) % 2  # chessboard\nim1 = plt.imshow(Z1, cmap=plt.cm.gray, interpolation='nearest',\n                 extent=extent)\n\nZ2 = func3(X, Y)\n\nim2 = plt.imshow(Z2, cmap=plt.cm.viridis, alpha=.9, interpolation='bilinear',\n                 extent=extent)\n\nplt.show()\n",
    "id": 44
},
{
    "title": "Visualize matrices with matshow",
    "text": "matshow visualizes a 2D matrix or array as color-coded image. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# a 2D array with linearly increasing values on the diagonal\na = np.diag(range(15))\n\nplt.matshow(a)\n\nplt.show()\n",
    "id": 45
},
{
    "title": "Multiple images",
    "text": "Make a set of images with a single colormap, norm, and colorbar. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.Normalize matplotlib.cm.ScalarMappable.set_cmap matplotlib.cm.ScalarMappable.set_norm matplotlib.cm.ScalarMappable.set_clim matplotlib.cbook.CallbackRegistry.connect",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\n\nnp.random.seed(19680801)\nNr = 3\nNc = 2\n\nfig, axs = plt.subplots(Nr, Nc)\nfig.suptitle('Multiple images')\n\nimages = []\nfor i in range(Nr):\n    for j in range(Nc):\n        # Generate data with a range that varies from one plot to the next.\n        data = ((1 + i + j) / 10) * np.random.rand(10, 20)\n        images.append(axs[i, j].imshow(data))\n        axs[i, j].label_outer()\n\n# Find the min and max of all colors for use in setting the color scale.\nvmin = min(image.get_array().min() for image in images)\nvmax = max(image.get_array().max() for image in images)\nnorm = colors.Normalize(vmin=vmin, vmax=vmax)\nfor im in images:\n    im.set_norm(norm)\n\nfig.colorbar(images[0], ax=axs, orientation='horizontal', fraction=.1)\n\n\n# Make images respond to changes in the norm of other images (e.g. via the\n# 'edit axis, curves and images parameters' GUI on Qt), but be careful not to\n# recurse infinitely!\ndef update(changed_image):\n    for im in images:\n        if (changed_image.get_cmap() != im.get_cmap()\n                or changed_image.get_clim() != im.get_clim()):\n            im.set_cmap(changed_image.get_cmap())\n            im.set_clim(changed_image.get_clim())\n\n\nfor im in images:\n    im.callbacks.connect('changed', update)\n\nplt.show()\n",
    "id": 46
},
{
    "title": "Streamplot",
    "text": "A stream plot, or streamline plot, is used to display 2D vector fields. This\nexample shows a few features of the streamplot function: Varying the color along a streamline. Varying the density of streamlines. Varying the line width along a streamline. Controlling the starting points of streamlines. Streamlines skipping masked regions and NaN values. Unbroken streamlines even when exceeding the limit of lines within a single\ngrid cell. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.streamplot / matplotlib.pyplot.streamplot matplotlib.gridspec.GridSpec Total running time of the script: (0 minutes 3.501 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nw = 3\nY, X = np.mgrid[-w:w:100j, -w:w:100j]\nU = -1 - X**2 + Y\nV = 1 + X - Y**2\nspeed = np.sqrt(U**2 + V**2)\n\nfig, axs = plt.subplots(3, 2, figsize=(7, 9), height_ratios=[1, 1, 2])\naxs = axs.flat\n\n#  Varying density along a streamline\naxs[0].streamplot(X, Y, U, V, density=[0.5, 1])\naxs[0].set_title('Varying Density')\n\n# Varying color along a streamline\nstrm = axs[1].streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')\nfig.colorbar(strm.lines)\naxs[1].set_title('Varying Color')\n\n#  Varying line width along a streamline\nlw = 5*speed / speed.max()\naxs[2].streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)\naxs[2].set_title('Varying Line Width')\n\n# Controlling the starting points of the streamlines\nseed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])\n\nstrm = axs[3].streamplot(X, Y, U, V, color=U, linewidth=2,\n                         cmap='autumn', start_points=seed_points.T)\nfig.colorbar(strm.lines)\naxs[3].set_title('Controlling Starting Points')\n\n# Displaying the starting points with blue symbols.\naxs[3].plot(seed_points[0], seed_points[1], 'bo')\naxs[3].set(xlim=(-w, w), ylim=(-w, w))\n\n# Create a mask\nmask = np.zeros(U.shape, dtype=bool)\nmask[40:60, 40:60] = True\nU[:20, :20] = np.nan\nU = np.ma.array(U, mask=mask)\n\naxs[4].streamplot(X, Y, U, V, color='r')\naxs[4].set_title('Streamplot with Masking')\n\naxs[4].imshow(~mask, extent=(-w, w, -w, w), alpha=0.5, cmap='gray',\n              aspect='auto')\naxs[4].set_aspect('equal')\n\naxs[5].streamplot(X, Y, U, V, broken_streamlines=False)\naxs[5].set_title('Streamplot with unbroken streamlines')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 47
},
{
    "title": "QuadMesh Demo",
    "text": "pcolormesh uses a QuadMesh,\na faster generalization of pcolor, but with some restrictions. This demo illustrates a bug in quadmesh with masked data. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh",
    "code": "import numpy as np\n\nfrom matplotlib import pyplot as plt\n\nn = 12\nx = np.linspace(-1.5, 1.5, n)\ny = np.linspace(-1.5, 1.5, n * 2)\nX, Y = np.meshgrid(x, y)\nQx = np.cos(Y) - np.cos(X)\nQz = np.sin(Y) + np.sin(X)\nZ = np.sqrt(X**2 + Y**2) / 5\nZ = (Z - Z.min()) / (Z.max() - Z.min())\n\n# The color array can include masked values.\nZm = np.ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\nfig, axs = plt.subplots(nrows=1, ncols=3)\naxs[0].pcolormesh(Qx, Qz, Z, shading='gouraud')\naxs[0].set_title('Without masked values')\n\n# You can control the color of the masked region.\ncmap = plt.colormaps[plt.rcParams['image.cmap']].with_extremes(bad='y')\naxs[1].pcolormesh(Qx, Qz, Zm, shading='gouraud', cmap=cmap)\naxs[1].set_title('With masked values')\n\n# Or use the default, which is transparent.\naxs[2].pcolormesh(Qx, Qz, Zm, shading='gouraud')\naxs[2].set_title('With masked values')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 48
},
{
    "title": "Quiver Simple Demo",
    "text": "A simple example of a quiver plot with a quiverkey. For more advanced options refer to\nAdvanced quiver and quiverkey functions. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.quiver / matplotlib.pyplot.quiver matplotlib.axes.Axes.quiverkey / matplotlib.pyplot.quiverkey",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nX = np.arange(-10, 10, 1)\nY = np.arange(-10, 10, 1)\nU, V = np.meshgrid(X, Y)\n\nfig, ax = plt.subplots()\nq = ax.quiver(X, Y, U, V)\nax.quiverkey(q, X=0.3, Y=1.1, U=10,\n             label='Quiver key, length = 10', labelpos='E')\n\nplt.show()\n",
    "id": 49
},
{
    "title": "Shading example",
    "text": "Example showing how to make shaded relief plots like Mathematica or\nGeneric Mapping Tools. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors.LightSource matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow Total running time of the script: (0 minutes 1.190 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib.colors import LightSource\n\n\ndef main():\n    # Test data\n    x, y = np.mgrid[-5:5:0.05, -5:5:0.05]\n    z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2))\n\n    dem = cbook.get_sample_data('jacksboro_fault_dem.npz')\n    elev = dem['elevation']\n\n    fig = compare(z, plt.cm.copper)\n    fig.suptitle('HSV Blending Looks Best with Smooth Surfaces', y=0.95)\n\n    fig = compare(elev, plt.cm.gist_earth, ve=0.05)\n    fig.suptitle('Overlay Blending Looks Best with Rough Surfaces', y=0.95)\n\n    plt.show()\n\n\ndef compare(z, cmap, ve=1):\n    # Create subplots and hide ticks\n    fig, axs = plt.subplots(ncols=2, nrows=2)\n    for ax in axs.flat:\n        ax.set(xticks=[], yticks=[])\n\n    # Illuminate the scene from the northwest\n    ls = LightSource(azdeg=315, altdeg=45)\n\n    axs[0, 0].imshow(z, cmap=cmap)\n    axs[0, 0].set(xlabel='Colormapped Data')\n\n    axs[0, 1].imshow(ls.hillshade(z, vert_exag=ve), cmap='gray')\n    axs[0, 1].set(xlabel='Illumination Intensity')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='hsv')\n    axs[1, 0].imshow(rgb)\n    axs[1, 0].set(xlabel='Blend Mode: 'hsv' (default)')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='overlay')\n    axs[1, 1].imshow(rgb)\n    axs[1, 1].set(xlabel='Blend Mode: 'overlay'')\n\n    return fig\n\n\nif __name__ == '__main__':\n    main()\n",
    "id": 50
},
{
    "title": "Spectrogram",
    "text": "Plotting a spectrogram using specgram. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.specgram / matplotlib.pyplot.specgram",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.0005\nt = np.arange(0.0, 20.5, dt)\ns1 = np.sin(2 * np.pi * 100 * t)\ns2 = 2 * np.sin(2 * np.pi * 400 * t)\n\n# create a transient 'chirp'\ns2[t <= 10] = s2[12 <= t] = 0\n\n# add some noise into the mix\nnse = 0.01 * np.random.random(size=len(t))\n\nx = s1 + s2 + nse  # the signal\nNFFT = 1024  # the length of the windowing segments\nFs = 1/dt  # the sampling frequency\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)\nax1.plot(t, x)\nax1.set_ylabel('Signal')\n\nPxx, freqs, bins, im = ax2.specgram(x, NFFT=NFFT, Fs=Fs)\n# The `specgram` method returns 4 objects. They are:\n# - Pxx: the periodogram\n# - freqs: the frequency vector\n# - bins: the centers of the time bins\n# - im: the .image.AxesImage instance representing the data in the plot\nax2.set_xlabel('Time (s)')\nax2.set_ylabel('Frequency (Hz)')\nax2.set_xlim(0, 20)\n\nplt.show()\n",
    "id": 51
},
{
    "title": "Spy Demos",
    "text": "Plot the sparsity pattern of arrays. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.spy / matplotlib.pyplot.spy",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(2, 2)\nax1 = axs[0, 0]\nax2 = axs[0, 1]\nax3 = axs[1, 0]\nax4 = axs[1, 1]\n\nx = np.random.randn(20, 20)\nx[5, :] = 0.\nx[:, 12] = 0.\n\nax1.spy(x, markersize=5)\nax2.spy(x, precision=0.1, markersize=5)\n\nax3.spy(x)\nax4.spy(x, precision=0.1)\n\nplt.show()\n",
    "id": 52
},
{
    "title": "Tricontour Smooth Delaunay",
    "text": "Demonstrates high-resolution tricontouring of a random set of points;\na matplotlib.tri.TriAnalyzer is used to improve the plot quality. The initial data points and triangular grid for this demo are: a set of random points is instantiated, inside [-1, 1] x [-1, 1] square A Delaunay triangulation of these points is then computed, of which a\nrandom subset of triangles is masked out by the user (based on\ninit_mask_frac parameter). This simulates invalidated data. The proposed generic procedure to obtain a high resolution contouring of such\na data set is the following: Compute an extended mask with a matplotlib.tri.TriAnalyzer, which will\nexclude badly shaped (flat) triangles from the border of the\ntriangulation. Apply the mask to the triangulation (using set_mask). Refine and interpolate the data using a matplotlib.tri.UniformTriRefiner. Plot the refined data with tricontour. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.tri matplotlib.tri.Triangulation matplotlib.tri.TriAnalyzer matplotlib.tri.UniformTriRefiner",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import TriAnalyzer, Triangulation, UniformTriRefiner\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef experiment_res(x, y):\n    '''An analytic function representing experiment results.'''\n    x = 2 * x\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = (4 * (np.exp((r1/10)**2) - 1) * 30 * np.cos(3 * theta1) +\n         (np.exp((r2/10)**2) - 1) * 30 * np.cos(5 * theta2) +\n         2 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Generating the initial data test points and triangulation for the demo\n# ----------------------------------------------------------------------------\n# User parameters for data test points\n\n# Number of test data points, tested from 3 to 5000 for subdiv=3\nn_test = 200\n\n# Number of recursive subdivisions of the initial mesh for smooth plots.\n# Values >3 might result in a very high number of triangles for the refine\n# mesh: new triangles numbering = (4**subdiv)*ntri\nsubdiv = 3\n\n# Float > 0. adjusting the proportion of (invalid) initial triangles which will\n# be masked out. Enter 0 for no mask.\ninit_mask_frac = 0.0\n\n# Minimum circle ratio - border triangles with circle ratio below this will be\n# masked if they touch a border. Suggested value 0.01; use -1 to keep all\n# triangles.\nmin_circle_ratio = .01\n\n# Random points\nrandom_gen = np.random.RandomState(seed=19680801)\nx_test = random_gen.uniform(-1., 1., size=n_test)\ny_test = random_gen.uniform(-1., 1., size=n_test)\nz_test = experiment_res(x_test, y_test)\n\n# meshing with Delaunay triangulation\ntri = Triangulation(x_test, y_test)\nntri = tri.triangles.shape[0]\n\n# Some invalid data are masked out\nmask_init = np.zeros(ntri, dtype=bool)\nmasked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac))\nmask_init[masked_tri] = True\ntri.set_mask(mask_init)\n\n\n# ----------------------------------------------------------------------------\n# Improving the triangulation before high-res plots: removing flat triangles\n# ----------------------------------------------------------------------------\n# masking badly shaped triangles at the border of the triangular mesh.\nmask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio)\ntri.set_mask(mask)\n\n# refining the data\nrefiner = UniformTriRefiner(tri)\ntri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv)\n\n# analytical 'results' for comparison\nz_expected = experiment_res(tri_refi.x, tri_refi.y)\n\n# for the demo: loading the 'flat' triangles for plot\nflat_tri = Triangulation(x_test, y_test)\nflat_tri.set_mask(~mask)\n\n\n# ----------------------------------------------------------------------------\n# Now the plots\n# ----------------------------------------------------------------------------\n# User options for plots\nplot_tri = True          # plot of base triangulation\nplot_masked_tri = True   # plot of excessively flat excluded triangles\nplot_refi_tri = False    # plot of refined triangulation\nplot_expected = False    # plot of analytical function values for comparison\n\n\n# Graphical options for tricontouring\nlevels = np.arange(0., 1., 0.025)\n\nfig, ax = plt.subplots()\nax.set_aspect('equal')\nax.set_title('Filtering a Delaunay mesh\\\n'\n             '(application to high-resolution tricontouring)')\n\n# 1) plot of the refined (computed) data contours:\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='Blues',\n              linewidths=[2.0, 0.5, 1.0, 0.5])\n# 2) plot of the expected (analytical) data contours (dashed):\nif plot_expected:\n    ax.tricontour(tri_refi, z_expected, levels=levels, cmap='Blues',\n                  linestyles='--')\n# 3) plot of the fine mesh on which interpolation was done:\nif plot_refi_tri:\n    ax.triplot(tri_refi, color='0.97')\n# 4) plot of the initial 'coarse' mesh:\nif plot_tri:\n    ax.triplot(tri, color='0.7')\n# 4) plot of the unvalidated triangles from naive Delaunay Triangulation:\nif plot_masked_tri:\n    ax.triplot(flat_tri, color='red')\n\nplt.show()\n",
    "id": 53
},
{
    "title": "Tricontour Smooth User",
    "text": "Demonstrates high-resolution tricontouring on user-defined triangular grids\nwith matplotlib.tri.UniformTriRefiner. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.tri matplotlib.tri.Triangulation matplotlib.tri.UniformTriRefiner",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef function_z(x, y):\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +\n          (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +\n          0.7 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 20\nn_radii = 10\nmin_radius = 0.15\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = function_z(x, y)\n\n# Now create the Triangulation.\n# (Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.)\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data\n# ----------------------------------------------------------------------------\nrefiner = tri.UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(z, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation and the high-res iso-contours\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect('equal')\nax.triplot(triang, lw=0.5, color='white')\n\nlevels = np.arange(0., 1., 0.025)\nax.tricontourf(tri_refi, z_test_refi, levels=levels, cmap='terrain')\nax.tricontour(tri_refi, z_test_refi, levels=levels,\n              colors=['0.25', '0.5', '0.5', '0.5', '0.5'],\n              linewidths=[1.0, 0.5, 0.5, 0.5, 0.5])\n\nax.set_title('High-resolution tricontouring')\n\nplt.show()\n",
    "id": 54
},
{
    "title": "Trigradient Demo",
    "text": "Demonstrates computation of gradient with\nmatplotlib.tri.CubicTriInterpolator. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.tri matplotlib.tri.Triangulation matplotlib.tri.CubicTriInterpolator matplotlib.tri.CubicTriInterpolator.gradient matplotlib.tri.UniformTriRefiner matplotlib.axes.Axes.quiver / matplotlib.pyplot.quiver",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import (CubicTriInterpolator, Triangulation,\n                            UniformTriRefiner)\n\n\n# ----------------------------------------------------------------------------\n# Electrical potential of a dipole\n# ----------------------------------------------------------------------------\ndef dipole_potential(x, y):\n    '''The electric dipole potential V, at position *x*, *y*.'''\n    r_sq = x**2 + y**2\n    theta = np.arctan2(y, x)\n    z = np.cos(theta)/r_sq\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 30\nn_radii = 10\nmin_radius = 0.2\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nV = dipole_potential(x, y)\n\n# Create the Triangulation; no triangles specified so Delaunay triangulation\n# created.\ntriang = Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data - interpolates the electrical potential V\n# ----------------------------------------------------------------------------\nrefiner = UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Computes the electrical field (Ex, Ey) as gradient of electrical potential\n# ----------------------------------------------------------------------------\ntci = CubicTriInterpolator(triang, -V)\n# Gradient requested here at the mesh nodes but could be anywhere else:\n(Ex, Ey) = tci.gradient(triang.x, triang.y)\nE_norm = np.sqrt(Ex**2 + Ey**2)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation, the potential iso-contours and the vector field\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect('equal')\n# Enforce the margins, and enlarge them to give room for the vectors.\nax.use_sticky_edges = False\nax.margins(0.07)\n\nax.triplot(triang, color='0.8')\n\nlevels = np.arange(0., 1., 0.01)\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap='hot',\n              linewidths=[2.0, 1.0, 1.0, 1.0])\n# Plots direction of the electrical vector field\nax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,\n          units='xy', scale=10., zorder=3, color='blue',\n          width=0.007, headwidth=3., headlength=4.)\n\nax.set_title('Gradient plot: an electrical dipole')\nplt.show()\n",
    "id": 55
},
{
    "title": "Triinterp Demo",
    "text": "Interpolation from triangular grid to quad grid. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.tri matplotlib.tri.LinearTriInterpolator matplotlib.tri.CubicTriInterpolator matplotlib.tri.Triangulation",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\n# Create triangulation.\nx = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5])\ny = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0])\ntriangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7],\n             [5, 6, 8], [5, 8, 7], [7, 8, 9]]\ntriang = mtri.Triangulation(x, y, triangles)\n\n# Interpolate to regularly-spaced quad grid.\nz = np.cos(1.5 * x) * np.cos(1.5 * y)\nxi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20))\n\ninterp_lin = mtri.LinearTriInterpolator(triang, z)\nzi_lin = interp_lin(xi, yi)\n\ninterp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\nzi_cubic_geom = interp_cubic_geom(xi, yi)\n\ninterp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind='min_E')\nzi_cubic_min_E = interp_cubic_min_E(xi, yi)\n\n# Set up the figure\nfig, axs = plt.subplots(nrows=2, ncols=2)\naxs = axs.flatten()\n\n# Plot the triangulation.\naxs[0].tricontourf(triang, z)\naxs[0].triplot(triang, 'ko-')\naxs[0].set_title('Triangular grid')\n\n# Plot linear interpolation to quad grid.\naxs[1].contourf(xi, yi, zi_lin)\naxs[1].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[1].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[1].set_title('Linear interpolation')\n\n# Plot cubic interpolation to quad grid, kind=geom\naxs[2].contourf(xi, yi, zi_cubic_geom)\naxs[2].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[2].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[2].set_title('Cubic interpolation,\\\nkind='geom'')\n\n# Plot cubic interpolation to quad grid, kind=min_E\naxs[3].contourf(xi, yi, zi_cubic_min_E)\naxs[3].plot(xi, yi, 'k-', lw=0.5, alpha=0.5)\naxs[3].plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)\naxs[3].set_title('Cubic interpolation,\\\nkind='min_E'')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 56
},
{
    "title": "Watermark image",
    "text": "Overlay an image on a plot by moving it to the front (zorder=3) and making it\nsemi-transparent (alpha=0.7). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.image matplotlib.image.imread / matplotlib.pyplot.imread matplotlib.figure.Figure.figimage",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nimport matplotlib.image as image\n\nwith cbook.get_sample_data('logo2.png') as file:\n    im = image.imread(file)\n\nfig, ax = plt.subplots()\n\nnp.random.seed(19680801)\nx = np.arange(30)\ny = x + np.random.randn(30)\nax.bar(x, y, color='#6bbc6b')\nax.grid()\n\nfig.figimage(im, 25, 25, zorder=3, alpha=.7)\n\nplt.show()\n",
    "id": 57
},
{
    "title": "Aligning Labels",
    "text": "Aligning xlabel and ylabel using Figure.align_xlabels and\nFigure.align_ylabels Figure.align_labels wraps these two functions. Note that the xlabel \"XLabel1 1\" would normally be much closer to the\nx-axis, and \"YLabel1 0\" would be much closer to the y-axis of their\nrespective axes.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.gridspec as gridspec\n\nfig = plt.figure(tight_layout=True)\ngs = gridspec.GridSpec(2, 2)\n\nax = fig.add_subplot(gs[0, :])\nax.plot(np.arange(0, 1e6, 1000))\nax.set_ylabel('YLabel0')\nax.set_xlabel('XLabel0')\n\nfor i in range(2):\n    ax = fig.add_subplot(gs[1, i])\n    ax.plot(np.arange(1., 0., -0.1) * 2000., np.arange(1., 0., -0.1))\n    ax.set_ylabel('YLabel1 %d' % i)\n    ax.set_xlabel('XLabel1 %d' % i)\n    if i == 0:\n        ax.tick_params(axis='x', rotation=55)\nfig.align_labels()  # same as fig.align_xlabels(); fig.align_ylabels()\n\nplt.show()\n",
    "id": 58
},
{
    "title": "Programmatically controlling subplot adjustment",
    "text": "Note This example is primarily intended to show some advanced concepts in\nMatplotlib. If you are only looking for having enough space for your labels, it is\nalmost always simpler and good enough to either set the subplot parameters\nmanually using Figure.subplots_adjust, or use one of the automatic\nlayout mechanisms\n(Constrained Layout Guide or\nTight Layout guide). This example describes a user-defined way to read out Artist sizes and\nset the subplot parameters accordingly. Its main purpose is to illustrate\nsome advanced concepts like reading out text positions, working with\nbounding boxes and transforms and using\nevents. But it can also serve as a starting\npoint if you want to automate the layouting and need more flexibility than\ntight layout and constrained layout. Below, we collect the bounding boxes of all y-labels and move the left border\nof the subplot to the right so that it leaves enough room for the union of all\nthe bounding boxes.', \"There's one catch with calculating text bounding boxes:\nQuerying the text bounding boxes (Text.get_window_extent) needs a\nrenderer (RendererBase instance), to calculate the text size. This renderer\nis only available after the figure has been drawn (Figure.draw).\", 'A solution to this is putting the adjustment logic in a draw callback.\nThis function is executed after the figure has been drawn. It can now check\nif the subplot leaves enough room for the text. If not, the subplot parameters\nare updated and second draw is triggered. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.artist.Artist.get_window_extent matplotlib.transforms.Bbox matplotlib.transforms.BboxBase.transformed matplotlib.transforms.BboxBase.union matplotlib.transforms.Transform.inverted matplotlib.figure.Figure.subplots_adjust matplotlib.figure.SubplotParams matplotlib.backend_bases.FigureCanvasBase.mpl_connect",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_yticks([2, 5, 7], labels=['really, really, really long labels'])\n\n\ndef on_draw(event):\n    bboxes = []\n    for label in ax.get_yticklabels():\n        # Bounding box in pixels\n        bbox_px = label.get_window_extent()\n        # Transform to relative figure coordinates. This is the inverse of\n        # transFigure.\n        bbox_fig = bbox_px.transformed(fig.transFigure.inverted())\n        bboxes.append(bbox_fig)\n    # the bbox that bounds all the bboxes, again in relative figure coords\n    bbox = mtransforms.Bbox.union(bboxes)\n    if fig.subplotpars.left < bbox.width:\n        # Move the subplot left edge more to the right\n        fig.subplots_adjust(left=1.1*bbox.width)  # pad a little\n        fig.canvas.draw()\n\n\nfig.canvas.mpl_connect('draw_event', on_draw)\n\nplt.show()\n",
    "id": 59
},
{
    "title": "Axes Demo",
    "text": "Example use of fig.add_axes to create inset axes within the main plot axes. Please see also the Module - axes_grid1 section, and the following three\nexamples: Zoom region inset axes Inset locator demo Inset locator demo 2",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility.\n\n# create some data to use for the plot\ndt = 0.001\nt = np.arange(0.0, 10.0, dt)\nr = np.exp(-t[:1000] / 0.05)  # impulse response\nx = np.random.randn(len(t))\ns = np.convolve(x, r)[:len(x)] * dt  # colored noise\n\nfig, main_ax = plt.subplots()\nmain_ax.plot(t, s)\nmain_ax.set_xlim(0, 1)\nmain_ax.set_ylim(1.1 * np.min(s), 2 * np.max(s))\nmain_ax.set_xlabel('time (s)')\nmain_ax.set_ylabel('current (nA)')\nmain_ax.set_title('Gaussian colored noise')\n\n# this is an inset axes over the main axes\nright_inset_ax = fig.add_axes([.65, .6, .2, .2], facecolor='k')\nright_inset_ax.hist(s, 400, density=True)\nright_inset_ax.set(title='Probability', xticks=[], yticks=[])\n\n# this is another inset axes over the main axes\nleft_inset_ax = fig.add_axes([.2, .6, .2, .2], facecolor='k')\nleft_inset_ax.plot(t[:len(r)], r)\nleft_inset_ax.set(title='Impulse response', xlim=(0, .2), xticks=[], yticks=[])\n\nplt.show()\n",
    "id": 60
},
{
    "title": "Axes Props",
    "text": "You can control the axis tick and grid properties",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.grid(True, linestyle='-.')\nax.tick_params(labelcolor='r', labelsize='medium', width=3)\n\nplt.show()\n",
    "id": 61
},
{
    "title": "Axes Zoom Effect",
    "text": "Download Python source code: axes_zoom_effect.py Download Jupyter notebook: axes_zoom_effect.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import (Bbox, TransformedBbox,\n                                   blended_transform_factory)\nfrom mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\n                                                   BboxConnectorPatch,\n                                                   BboxPatch)\n\n\ndef connect_bbox(bbox1, bbox2,\n                 loc1a, loc2a, loc1b, loc2b,\n                 prop_lines, prop_patches=None):\n    if prop_patches is None:\n        prop_patches = {\n            **prop_lines,\n            'alpha': prop_lines.get('alpha', 1) * 0.2,\n            'clip_on': False,\n        }\n\n    c1 = BboxConnector(\n        bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\n    c2 = BboxConnector(\n        bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\n\n    bbox_patch1 = BboxPatch(bbox1, **prop_patches)\n    bbox_patch2 = BboxPatch(bbox2, **prop_patches)\n\n    p = BboxConnectorPatch(bbox1, bbox2,\n                           loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\n                           clip_on=False,\n                           **prop_patches)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect01(ax1, ax2, xmin, xmax, **kwargs):\n    '''\n    Connect *ax1* and *ax2*. The *xmin*-to-*xmax* range in both axes will\n    be marked.\n\n    Parameters\n    ----------\n    ax1\n        The main axes.\n    ax2\n        The zoomed axes.\n    xmin, xmax\n        The limits of the colored area in both plot axes.\n    **kwargs\n        Arguments passed to the patch constructor.\n    '''\n\n    bbox = Bbox.from_extents(xmin, 0, xmax, 1)\n\n    mybbox1 = TransformedBbox(bbox, ax1.get_xaxis_transform())\n    mybbox2 = TransformedBbox(bbox, ax2.get_xaxis_transform())\n\n    prop_patches = {**kwargs, 'ec': 'none', 'alpha': 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect02(ax1, ax2, **kwargs):\n    '''\n    ax1 : the main axes\n    ax1 : the zoomed axes\n\n    Similar to zoom_effect01.  The xmin & xmax will be taken from the\n    ax1.viewLim.\n    '''\n\n    tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\n    trans = blended_transform_factory(ax2.transData, tt)\n\n    mybbox1 = ax1.bbox\n    mybbox2 = TransformedBbox(ax1.viewLim, trans)\n\n    prop_patches = {**kwargs, 'ec': 'none', 'alpha': 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\naxs = plt.figure().subplot_mosaic([\n    ['zoom1', 'zoom2'],\n    ['main', 'main'],\n])\n\naxs['main'].set(xlim=(0, 5))\nzoom_effect01(axs['zoom1'], axs['main'], 0.2, 0.8)\naxs['zoom2'].set(xlim=(2, 3))\nzoom_effect02(axs['zoom2'], axs['main'])\n\nplt.show()\n",
    "id": 62
},
{
    "title": "axhspan Demo",
    "text": "Create lines or rectangles that span the axes in either the horizontal or\nvertical direction, and lines than span the axes with an arbitrary orientation.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(-1, 2, .01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s)\n# Thick red horizontal line at y=0 that spans the xrange.\nax.axhline(linewidth=8, color='#d62728')\n# Horizontal line at y=1 that spans the xrange.\nax.axhline(y=1)\n# Vertical line at x=1 that spans the yrange.\nax.axvline(x=1)\n# Thick blue vertical line at x=0 that spans the upper quadrant of the yrange.\nax.axvline(x=0, ymin=0.75, linewidth=8, color='#1f77b4')\n# Default hline at y=.5 that spans the middle half of the axes.\nax.axhline(y=.5, xmin=0.25, xmax=0.75)\n# Infinite black line going through (0, 0) to (1, 1).\nax.axline((0, 0), (1, 1), color='k')\n# 50%-gray rectangle spanning the axes' width from y=0.25 to y=0.75.\nax.axhspan(0.25, 0.75, facecolor='0.5')\n# Green rectangle spanning the axes' height from x=1.25 to x=1.55.\nax.axvspan(1.25, 1.55, facecolor='#2ca02c')\n\nplt.show()\n",
    "id": 63
},
{
    "title": "Equal axis aspect ratio",
    "text": "How to set and adjust plots with equal axis aspect ratios.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Plot circle of radius 3.\n\nan = np.linspace(0, 2 * np.pi, 100)\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 0].set_title('not equal, looks like ellipse', fontsize=10)\n\naxs[0, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 1].axis('equal')\naxs[0, 1].set_title('equal, looks like circle', fontsize=10)\n\naxs[1, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 0].axis('equal')\naxs[1, 0].set(xlim=(-3, 3), ylim=(-3, 3))\naxs[1, 0].set_title('still a circle, even after changing limits', fontsize=10)\n\naxs[1, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 1].set_aspect('equal box')\naxs[1, 1].set_title('still a circle, auto-adjusted data limits', fontsize=10)\n\nfig.tight_layout()\n\nplt.show()\n",
    "id": 64
},
{
    "title": "Axis Label Position",
    "text": "Choose axis label position when calling set_xlabel and\nset_ylabel as well as for colorbar.",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nsc = ax.scatter([1, 2], [1, 2], c=[1, 2])\nax.set_ylabel('YLabel', loc='top')\nax.set_xlabel('XLabel', loc='left')\ncbar = fig.colorbar(sc)\ncbar.set_label('ZLabel', loc='top')\n\nplt.show()\n",
    "id": 65
},
{
    "title": "Broken Axis",
    "text": "Broken axis example, where the y-axis will have a portion cut out.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\npts = np.random.rand(30)*.2\n# Now let's make two outlier points which are far away from everything.\npts[[3, 14]] += .8\n\n# If we were to simply plot pts, we'd lose most of the interesting\n# details due to the outliers. So let's 'break' or 'cut-out' the y-axis\n# into two portions - use the top (ax1) for the outliers, and the bottom\n# (ax2) for the details of the majority of our data\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nfig.subplots_adjust(hspace=0.05)  # adjust space between axes\n\n# plot the same data on both axes\nax1.plot(pts)\nax2.plot(pts)\n\n# zoom-in / limit the view to different portions of the data\nax1.set_ylim(.78, 1.)  # outliers only\nax2.set_ylim(0, .22)  # most of the data\n\n# hide the spines between ax and ax2\nax1.spines.bottom.set_visible(False)\nax2.spines.top.set_visible(False)\nax1.xaxis.tick_top()\nax1.tick_params(labeltop=False)  # don't put tick labels at the top\nax2.xaxis.tick_bottom()\n\n# Now, let's turn towards the cut-out slanted lines.\n# We create line objects in axes coordinates, in which (0,0), (0,1),\n# (1,0), and (1,1) are the four corners of the axes.\n# The slanted lines themselves are markers at those locations, such that the\n# lines keep their angle and position, independent of the axes size or scale\n# Finally, we need to disable clipping.\n\nd = .5  # proportion of vertical to horizontal extent of the slanted line\nkwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,\n              linestyle='none', color='k', mec='k', mew=1, clip_on=False)\nax1.plot([0, 1], [0, 0], transform=ax1.transAxes, **kwargs)\nax2.plot([0, 1], [1, 1], transform=ax2.transAxes, **kwargs)\n\n\nplt.show()\n",
    "id": 66
},
{
    "title": "Custom Figure subclasses",
    "text": "You can pass a Figure subclass to pyplot.figure if you want to change\nthe default behavior of the figure. This example defines a Figure subclass WatermarkFigure that accepts an\nadditional parameter watermark to display a custom watermark text. The\nfigure is created using the FigureClass parameter of pyplot.figure.\nThe additional watermark parameter is passed on to the subclass\nconstructor. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.figure.Figure matplotlib.figure.Figure.text",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.figure import Figure\n\n\nclass WatermarkFigure(Figure):\n    '''A figure with a text watermark.'''\n\n    def __init__(self, *args, watermark=None, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if watermark is not None:\n            bbox = dict(boxstyle='square', lw=3, ec='gray',\n                        fc=(0.9, 0.9, .9, .5), alpha=0.5)\n            self.text(0.5, 0.5, watermark,\n                      ha='center', va='center', rotation=30,\n                      fontsize=40, color='gray', alpha=0.5, bbox=bbox)\n\n\nx = np.linspace(-3, 3, 201)\ny = np.tanh(x) + 0.1 * np.cos(5 * x)\n\nplt.figure(FigureClass=WatermarkFigure, watermark='draft')\nplt.plot(x, y)\n",
    "id": 67
},
{
    "title": "Different scales on the same axes",
    "text": "Demo of how to display two scales on the left and right y-axis. This example uses the Fahrenheit and Celsius scales.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef fahrenheit2celsius(temp):\n    '''\n    Returns temperature in Celsius given Fahrenheit temperature.\n    '''\n    return (5. / 9.) * (temp - 32)\n\n\ndef make_plot():\n\n    # Define a closure function to register as a callback\n    def convert_ax_c_to_celsius(ax_f):\n        '''\n        Update second axis according to first axis.\n        '''\n        y1, y2 = ax_f.get_ylim()\n        ax_c.set_ylim(fahrenheit2celsius(y1), fahrenheit2celsius(y2))\n        ax_c.figure.canvas.draw()\n\n    fig, ax_f = plt.subplots()\n    ax_c = ax_f.twinx()\n\n    # automatically update ylim of ax2 when ylim of ax1 changes.\n    ax_f.callbacks.connect('ylim_changed', convert_ax_c_to_celsius)\n    ax_f.plot(np.linspace(-40, 120, 100))\n    ax_f.set_xlim(0, 100)\n\n    ax_f.set_title('Two scales: Fahrenheit and Celsius')\n    ax_f.set_ylabel('Fahrenheit')\n    ax_c.set_ylabel('Celsius')\n\n    plt.show()\n\nmake_plot()\n",
    "id": 68
},
{
    "title": "Creating adjacent subplots",
    "text": "To create plots that share a common axis (visually) you can set the hspace\nbetween the subplots to zero. Passing sharex=True when creating the subplots\nwill automatically turn off all x ticks and labels except those on the bottom\naxis. In this example the plots share a common x-axis, but you can follow the same\nlogic to supply a common y-axis.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\n\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = s1 * s2\n\nfig, axs = plt.subplots(3, 1, sharex=True)\n# Remove vertical space between axes\nfig.subplots_adjust(hspace=0)\n\n# Plot each graph, and manually set the y tick values\naxs[0].plot(t, s1)\naxs[0].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[0].set_ylim(-1, 1)\n\naxs[1].plot(t, s2)\naxs[1].set_yticks(np.arange(0.1, 1.0, 0.2))\naxs[1].set_ylim(0, 1)\n\naxs[2].plot(t, s3)\naxs[2].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[2].set_ylim(-1, 1)\n\nplt.show()\n",
    "id": 69
},
{
    "title": "Combining two subplots using subplots and GridSpec",
    "text": "Sometimes we want to combine two subplots in an axes layout created with\nsubplots. We can get the GridSpec from the axes\nand then remove the covered axes and fill the gap with a new bigger axes.\nHere we create a layout with the bottom two axes in the last column combined. To start with this layout (rather than removing the overlapping axes) use\nsubplot_mosaic. See also Arranging multiple Axes in a Figure.",
    "code": "import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(ncols=3, nrows=3)\ngs = axs[1, 2].get_gridspec()\n# remove the underlying axes\nfor ax in axs[1:, -1]:\n    ax.remove()\naxbig = fig.add_subplot(gs[1:, -1])\naxbig.annotate('Big Axes \\\nGridSpec[1:, -1]', (0.1, 0.5),\n               xycoords='axes fraction', va='center')\n\nfig.tight_layout()\n\nplt.show()\n",
    "id": 70
},
{
    "title": "Using Gridspec to make multi-column/row subplot layouts",
    "text": "GridSpec is a flexible way to layout\nsubplot grids. Here is an example with a 3x3 grid, and\naxes spanning all three columns, two columns, and two rows.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, 'ax%d' % (i+1), va='center', ha='center')\n        ax.tick_params(labelbottom=False, labelleft=False)\n\nfig = plt.figure(layout='constrained')\n\ngs = GridSpec(3, 3, figure=fig)\nax1 = fig.add_subplot(gs[0, :])\n# identical to ax1 = plt.subplot(gs.new_subplotspec((0, 0), colspan=3))\nax2 = fig.add_subplot(gs[1, :-1])\nax3 = fig.add_subplot(gs[1:, -1])\nax4 = fig.add_subplot(gs[-1, 0])\nax5 = fig.add_subplot(gs[-1, -2])\n\nfig.suptitle('GridSpec')\nformat_axes(fig)\n\nplt.show()\n",
    "id": 71
},
{
    "title": "Nested Gridspecs",
    "text": "GridSpecs can be nested, so that a subplot from a parent GridSpec can\nset the position for a nested grid of subplots. Note that the same functionality can be achieved more directly with\nsubfigures; see\nFigure subfigures.",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.gridspec as gridspec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, 'ax%d' % (i+1), va='center', ha='center')\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\n# gridspec inside gridspec\nfig = plt.figure()\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0])\n\nax1 = fig.add_subplot(gs00[:-1, :])\nax2 = fig.add_subplot(gs00[-1, :-1])\nax3 = fig.add_subplot(gs00[-1, -1])\n\n# the following syntax does the same as the GridSpecFromSubplotSpec call above:\ngs01 = gs0[1].subgridspec(3, 3)\n\nax4 = fig.add_subplot(gs01[:, :-1])\nax5 = fig.add_subplot(gs01[:-1, -1])\nax6 = fig.add_subplot(gs01[-1, -1])\n\nplt.suptitle('GridSpec Inside GridSpec')\nformat_axes(fig)\n\nplt.show()\n",
    "id": 72
},
{
    "title": "Invert Axes",
    "text": "You can use decreasing axes by flipping the normal order of the axis\nlimits",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns = np.exp(-t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s)\nax.set_xlim(5, 0)  # decreasing time\nax.set_xlabel('decreasing time (s)')\nax.set_ylabel('voltage (mV)')\nax.set_title('Should be growing...')\nax.grid(True)\n\nplt.show()\n",
    "id": 73
},
{
    "title": "Sharing axis limits and views",
    "text": "It's common to make two or more plots which share an axis, e.g., two subplots\nwith time as a common axis. When you pan and zoom around on one, you want the\nother to move around with you. To facilitate this, matplotlib Axes support a\nsharex and sharey attribute. When you create a subplot or\naxes, you can pass in a keyword indicating what axes you want to\nshare with.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0, 10, 0.01)\n\nax1 = plt.subplot(211)\nax1.plot(t, np.sin(2*np.pi*t))\n\nax2 = plt.subplot(212, sharex=ax1)\nax2.plot(t, np.sin(4*np.pi*t))\n\nplt.show()\n",
    "id": 74
},
{
    "title": "Subplots spacings and margins",
    "text": "Adjusting the spacing of margins and subplots using pyplot.subplots_adjust. Note There is also a tool window to adjust the margins and spacings of displayed\nfigures interactively. It can be opened via the toolbar or by calling\npyplot.subplot_tool.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.subplot(211)\nplt.imshow(np.random.random((100, 100)))\nplt.subplot(212)\nplt.imshow(np.random.random((100, 100)))\n\nplt.subplots_adjust(bottom=0.1, right=0.8, top=0.9)\ncax = plt.axes((0.85, 0.1, 0.075, 0.8))\nplt.colorbar(cax=cax)\n\nplt.show()\n",
    "id": 75
},
{
    "title": "Plots with different scales",
    "text": "Two plots on the same axes with different left and right scales. The trick is to use two different axes that share the same x axis.\nYou can use separate matplotlib.ticker formatters and locators as\ndesired since the two axes are independent. Such axes are generated by calling the Axes.twinx method. Likewise,\nAxes.twiny is available to generate axes that share a y axis but\nhave different top and bottom scales. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.twinx / matplotlib.pyplot.twinx matplotlib.axes.Axes.twiny / matplotlib.pyplot.twiny matplotlib.axes.Axes.tick_params / matplotlib.pyplot.tick_params",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some mock data\nt = np.arange(0.01, 10.0, 0.01)\ndata1 = np.exp(t)\ndata2 = np.sin(2 * np.pi * t)\n\nfig, ax1 = plt.subplots()\n\ncolor = 'tab:red'\nax1.set_xlabel('time (s)')\nax1.set_ylabel('exp', color=color)\nax1.plot(t, data1, color=color)\nax1.tick_params(axis='y', labelcolor=color)\n\nax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n\ncolor = 'tab:blue'\nax2.set_ylabel('sin', color=color)  # we already handled the x-label with ax1\nax2.plot(t, data2, color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfig.tight_layout()  # otherwise the right y-label is slightly clipped\nplt.show()\n",
    "id": 76
},
{
    "title": "Zoom region inset axes",
    "text": "Example of an inset axes and a rectangle showing where the zoom is located. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.inset_axes matplotlib.axes.Axes.indicate_inset_zoom matplotlib.axes.Axes.imshow",
    "code": "import numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib import pyplot as plt\n\nfig, ax = plt.subplots()\n\n# make data\nZ = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\nextent = (-3, 4, -4, 3)\n\nax.imshow(Z2, extent=extent, origin='lower')\n\n# inset axes....\nx1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9  # subregion of the original image\naxins = ax.inset_axes(\n    [0.5, 0.5, 0.47, 0.47],\n    xlim=(x1, x2), ylim=(y1, y2), xticklabels=[], yticklabels=[])\naxins.imshow(Z2, extent=extent, origin='lower')\n\nax.indicate_inset_zoom(axins, edgecolor='black')\n\nplt.show()\n",
    "id": 77
},
{
    "title": "Percentiles as horizontal bar chart",
    "text": "Bar charts are useful for visualizing counts, or summary statistics\nwith error bars. Also see the Grouped bar chart with labels\nor the Horizontal bar chart example for simpler versions\nof those features.', \"This example comes from an application in which grade school gym\nteachers wanted to be able to show parents how their child did across\na handful of fitness tests, and importantly, relative to how other\nchildren did. To extract the plotting code for demo purposes, we'll\njust make up some data for little Johnny Doe.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label matplotlib.axes.Axes.twinx / matplotlib.pyplot.twinx",
    "code": "from collections import namedtuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nStudent = namedtuple('Student', ['name', 'grade', 'gender'])\nScore = namedtuple('Score', ['value', 'unit', 'percentile'])\n\n\ndef to_ordinal(num):\n    '''Convert an integer to an ordinal string, e.g. 2 -> '2nd'.'''\n    suffixes = {str(i): v\n                for i, v in enumerate(['th', 'st', 'nd', 'rd', 'th',\n                                       'th', 'th', 'th', 'th', 'th'])}\n    v = str(num)\n    # special case early teens\n    if v in {'11', '12', '13'}:\n        return v + 'th'\n    return v + suffixes[v[-1]]\n\n\ndef format_score(score):\n    '''\n    Create score labels for the right y-axis as the test name followed by the\n    measurement unit (if any), split over two lines.\n    '''\n    return f'{score.value}\\\n{score.unit}' if score.unit else str(score.value)\n\n\ndef plot_student_results(student, scores_by_test, cohort_size):\n    fig, ax1 = plt.subplots(figsize=(9, 7), layout='constrained')\n    fig.canvas.manager.set_window_title('Eldorado K-8 Fitness Chart')\n\n    ax1.set_title(student.name)\n    ax1.set_xlabel(\n        'Percentile Ranking Across {grade} Grade {gender}s\\\n'\n        'Cohort Size: {cohort_size}'.format(\n            grade=to_ordinal(student.grade),\n            gender=student.gender.title(),\n            cohort_size=cohort_size))\n\n    test_names = list(scores_by_test.keys())\n    percentiles = [score.percentile for score in scores_by_test.values()]\n\n    rects = ax1.barh(test_names, percentiles, align='center', height=0.5)\n    # Partition the percentile values to be able to draw large numbers in\n    # white within the bar, and small numbers in black outside the bar.\n    large_percentiles = [to_ordinal(p) if p > 40 else '' for p in percentiles]\n    small_percentiles = [to_ordinal(p) if p <= 40 else '' for p in percentiles]\n    ax1.bar_label(rects, small_percentiles,\n                  padding=5, color='black', fontweight='bold')\n    ax1.bar_label(rects, large_percentiles,\n                  padding=-32, color='white', fontweight='bold')\n\n    ax1.set_xlim([0, 100])\n    ax1.set_xticks([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\n    ax1.xaxis.grid(True, linestyle='--', which='major',\n                   color='grey', alpha=.25)\n    ax1.axvline(50, color='grey', alpha=0.25)  # median position\n\n    # Set the right-hand Y-axis ticks and labels\n    ax2 = ax1.twinx()\n    # Set equal limits on both yaxis so that the ticks line up\n    ax2.set_ylim(ax1.get_ylim())\n    # Set the tick locations and labels\n    ax2.set_yticks(\n        np.arange(len(scores_by_test)),\n        labels=[format_score(score) for score in scores_by_test.values()])\n\n    ax2.set_ylabel('Test Scores')\n\n\nstudent = Student(name='Johnny Doe', grade=2, gender='Boy')\nscores_by_test = {\n    'Pacer Test': Score(7, 'laps', percentile=37),\n    'Flexed Arm\\\n Hang': Score(48, 'sec', percentile=95),\n    'Mile Run': Score('12:52', 'min:sec', percentile=73),\n    'Agility': Score(17, 'sec', percentile=60),\n    'Push Ups': Score(14, '', percentile=16),\n}\n\nplot_student_results(student, scores_by_test, cohort_size=62)\nplt.show()\n",
    "id": 78
},
{
    "title": "Box plots with custom fill colors",
    "text": "This plot illustrates how to create two types of box plots\n(rectangular and notched), and how to fill them with custom\ncolors by accessing the properties of the artists of the\nbox plots. Additionally, the labels parameter is used to\nprovide x-tick labels for each sample. A good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.boxplot / matplotlib.pyplot.boxplot",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Random test data\nnp.random.seed(19680801)\nall_data = [np.random.normal(0, std, size=100) for std in range(1, 4)]\nlabels = ['x1 x2 x3']\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# rectangular box plot\nbplot1 = ax1.boxplot(all_data,\n                     vert=True,  # vertical box alignment\n                     patch_artist=True,  # fill with color\n                     labels=labels)  # will be used to label x-ticks\nax1.set_title('Rectangular box plot')\n\n# notch shape box plot\nbplot2 = ax2.boxplot(all_data,\n                     notch=True,  # notch shape\n                     vert=True,  # vertical box alignment\n                     patch_artist=True,  # fill with color\n                     labels=labels)  # will be used to label x-ticks\nax2.set_title('Notched box plot')\n\n# fill with colors\ncolors = ['pink lightblue lightgreen']\nfor bplot in (bplot1, bplot2):\n    for patch, color in zip(bplot['boxes'], colors):\n        patch.set_facecolor(color)\n\n# adding horizontal grid lines\nfor ax in [ax1, ax2]:\n    ax.yaxis.grid(True)\n    ax.set_xlabel('Three separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n",
    "id": 79
},
{
    "title": "Box plot vs. violin plot comparison",
    "text": "Note that although violin plots are closely related to Tukey's (1977)\nbox plots, they add useful information such as the distribution of the\nsample data (density trace).\", 'By default, box plots show data points outside 1.5 * the inter-quartile\nrange as outliers above or below the whiskers whereas violin plots show\nthe whole range of the data. A good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf Violin plots require matplotlib >= 1.4. For more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.boxplot / matplotlib.pyplot.boxplot matplotlib.axes.Axes.violinplot / matplotlib.pyplot.violinplot",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# generate some random test data\nall_data = [np.random.normal(0, std, 100) for std in range(6, 10)]\n\n# plot violin plot\naxs[0].violinplot(all_data,\n                  showmeans=False,\n                  showmedians=True)\naxs[0].set_title('Violin plot')\n\n# plot box plot\naxs[1].boxplot(all_data)\naxs[1].set_title('Box plot')\n\n# adding horizontal grid lines\nfor ax in axs:\n    ax.yaxis.grid(True)\n    ax.set_xticks([y + 1 for y in range(len(all_data))],\n                  labels=['x1 x2 x3 x4'])\n    ax.set_xlabel('Four separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n",
    "id": 80
},
{
    "title": "Violin plot customization",
    "text": "This example demonstrates how to fully customize violin plots. The first plot\nshows the default style by providing only the data. The second plot first\nlimits what Matplotlib draws with additional keyword arguments. Then a\nsimplified representation of a box plot is drawn on top. Lastly, the styles of\nthe artists of the violins are modified. For more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.violinplot / matplotlib.pyplot.violinplot matplotlib.axes.Axes.vlines / matplotlib.pyplot.vlines",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjacent_values(vals, q1, q3):\n    upper_adjacent_value = q3 + (q3 - q1) * 1.5\n    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])\n\n    lower_adjacent_value = q1 - (q3 - q1) * 1.5\n    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)\n    return lower_adjacent_value, upper_adjacent_value\n\n\ndef set_axis_style(ax, labels):\n    ax.set_xticks(np.arange(1, len(labels) + 1), labels=labels)\n    ax.set_xlim(0.25, len(labels) + 0.75)\n    ax.set_xlabel('Sample name')\n\n\n# create test data\nnp.random.seed(19680801)\ndata = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)]\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True)\n\nax1.set_title('Default violin plot')\nax1.set_ylabel('Observed values')\nax1.violinplot(data)\n\nax2.set_title('Customized violin plot')\nparts = ax2.violinplot(\n        data, showmeans=False, showmedians=False,\n        showextrema=False)\n\nfor pc in parts['bodies']:\n    pc.set_facecolor('#D43F3A')\n    pc.set_edgecolor('black')\n    pc.set_alpha(1)\n\nquartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1)\nwhiskers = np.array([\n    adjacent_values(sorted_array, q1, q3)\n    for sorted_array, q1, q3 in zip(data, quartile1, quartile3)])\nwhiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]\n\ninds = np.arange(1, len(medians) + 1)\nax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3)\nax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5)\nax2.vlines(inds, whiskers_min, whiskers_max, color='k', linestyle='-', lw=1)\n\n# set style for the axes\nlabels = ['A B C D']\nfor ax in [ax1, ax2]:\n    set_axis_style(ax, labels)\n\nplt.subplots_adjust(bottom=0.15, wspace=0.05)\nplt.show()\n",
    "id": 81
},
{
    "title": "Errorbar function",
    "text": "This exhibits the most basic use of the error bar method.\nIn this case, constant values are provided for the error\nin both the x- and y-directions. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\nfig, ax = plt.subplots()\nax.errorbar(x, y, xerr=0.2, yerr=0.4)\nplt.show()\n",
    "id": 82
},
{
    "title": "Different ways of specifying error bars",
    "text": "Errors can be specified as a constant value (as shown in\nErrorbar function). However, this example demonstrates\nhow they vary by specifying arrays of error values. If the raw x and y data have length N, there are two options: Error varies for each point, but the error values are\nsymmetric (i.e. the lower and upper values are equal). Error varies for each point, and the lower and upper limits\n(in that order) are different (asymmetric case) In addition, this example demonstrates how to use log\nscale with error bars. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\n# example error bar values that vary with x-position\nerror = 0.1 + 0.2 * x\n\nfig, (ax0, ax1) = plt.subplots(nrows=2, sharex=True)\nax0.errorbar(x, y, yerr=error, fmt='-o')\nax0.set_title('variable, symmetric error')\n\n# error bar values w/ different -/+ errors that\n# also vary with the x-position\nlower_error = 0.4 * error\nupper_error = error\nasymmetric_error = [lower_error, upper_error]\n\nax1.errorbar(x, y, xerr=asymmetric_error, fmt='o')\nax1.set_title('variable, asymmetric error')\nax1.set_yscale('log')\nplt.show()\n",
    "id": 83
},
{
    "title": "Including upper and lower limits in error bars",
    "text": "In matplotlib, errors bars can have \"limits\". Applying limits to the\nerror bars essentially makes the error unidirectional. Because of that,\nupper and lower limits can be applied in both the y- and x-directions\nvia the uplims, lolims, xuplims, and xlolims parameters,\nrespectively. These parameters can be scalar or boolean arrays. For example, if xlolims is True, the x-error bars will only\nextend from the data towards increasing values. If uplims is an\narray filled with False except for the 4th and 7th values, all of the\ny-error bars will be bidirectional, except the 4th and 7th bars, which\nwill extend from the data towards decreasing y-values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])\ny = np.exp(-x)\nxerr = 0.1\nyerr = 0.2\n\n# lower & upper limits of the error\nlolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool)\nuplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool)\nls = 'dotted'\n\nfig, ax = plt.subplots(figsize=(7, 4))\n\n# standard error bars\nax.errorbar(x, y, xerr=xerr, yerr=yerr, linestyle=ls)\n\n# including upper limits\nax.errorbar(x, y + 0.5, xerr=xerr, yerr=yerr, uplims=uplims,\n            linestyle=ls)\n\n# including lower limits\nax.errorbar(x, y + 1.0, xerr=xerr, yerr=yerr, lolims=lolims,\n            linestyle=ls)\n\n# including upper and lower limits\nax.errorbar(x, y + 1.5, xerr=xerr, yerr=yerr,\n            lolims=lolims, uplims=uplims,\n            marker='o', markersize=8,\n            linestyle=ls)\n\n# Plot a series with lower and upper limits in both x & y\n# constant x-error with varying y-error\nxerr = 0.2\nyerr = np.full_like(x, 0.2)\nyerr[[3, 6]] = 0.3\n\n# mock up some limits by modifying previous data\nxlolims = lolims\nxuplims = uplims\nlolims = np.zeros_like(x)\nuplims = np.zeros_like(x)\nlolims[[6]] = True  # only limited at this index\nuplims[[3]] = True  # only limited at this index\n\n# do the plotting\nax.errorbar(x, y + 2.1, xerr=xerr, yerr=yerr,\n            xlolims=xlolims, xuplims=xuplims,\n            uplims=uplims, lolims=lolims,\n            marker='o', markersize=8,\n            linestyle='none')\n\n# tidy up the figure\nax.set_xlim((0, 5.5))\nax.set_title('Errorbar upper and lower limits')\nplt.show()\n",
    "id": 84
},
{
    "title": "Creating boxes from error bars using PatchCollection",
    "text": "In this example, we snazz up a pretty standard error bar plot by adding\na rectangle patch defined by the limits of the bars in both the x- and\ny- directions. To do this, we have to write our own custom function\ncalled make_error_boxes. Close inspection of this function will\nreveal the preferred pattern in writing functions for matplotlib: an Axes object is passed directly to the function the function operates on the Axes methods directly, not through\nthe pyplot interface plotting keyword arguments that could be abbreviated are spelled out for\nbetter code readability in the future (for example we use facecolor\ninstead of fc) the artists returned by the Axes plotting methods are then\nreturned by the function so that, if desired, their styles\ncan be modified later outside of the function (they are not\nmodified in this example). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar matplotlib.axes.Axes.add_collection matplotlib.collections.PatchCollection",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Rectangle\n\n# Number of data points\nn = 5\n\n# Dummy data\nnp.random.seed(19680801)\nx = np.arange(0, n, 1)\ny = np.random.rand(n) * 5.\n\n# Dummy errors (above and below)\nxerr = np.random.rand(2, n) + 0.1\nyerr = np.random.rand(2, n) + 0.2\n\n\ndef make_error_boxes(ax, xdata, ydata, xerror, yerror, facecolor='r',\n                     edgecolor='none', alpha=0.5):\n\n    # Loop over data points; create box from errors at each point\n    errorboxes = [Rectangle((x - xe[0], y - ye[0]), xe.sum(), ye.sum())\n                  for x, y, xe, ye in zip(xdata, ydata, xerror.T, yerror.T)]\n\n    # Create patch collection with specified colour/alpha\n    pc = PatchCollection(errorboxes, facecolor=facecolor, alpha=alpha,\n                         edgecolor=edgecolor)\n\n    # Add collection to axes\n    ax.add_collection(pc)\n\n    # Plot errorbars\n    artists = ax.errorbar(xdata, ydata, xerr=xerror, yerr=yerror,\n                          fmt='none', ecolor='k')\n\n    return artists\n\n\n# Create figure and axes\nfig, ax = plt.subplots(1)\n\n# Call function to create error boxes\n_ = make_error_boxes(ax, x, y, xerr, yerr)\n\nplt.show()\n",
    "id": 85
},
{
    "title": "Hexagonal binned plot",
    "text": "hexbin is a 2D histogram plot, in which the bins are hexagons and\nthe color represents the number of data points within each bin. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hexbin / matplotlib.pyplot.hexbin",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nn = 100_000\nx = np.random.standard_normal(n)\ny = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\nxlim = x.min(), x.max()\nylim = y.min(), y.max()\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, sharey=True, figsize=(9, 4))\n\nhb = ax0.hexbin(x, y, gridsize=50, cmap='inferno')\nax0.set(xlim=xlim, ylim=ylim)\nax0.set_title('Hexagon binning')\ncb = fig.colorbar(hb, ax=ax0, label='counts')\n\nhb = ax1.hexbin(x, y, gridsize=50, bins='log', cmap='inferno')\nax1.set(xlim=xlim, ylim=ylim)\nax1.set_title('With a log color scale')\ncb = fig.colorbar(hb, ax=ax1, label='log10(N)')\n\nplt.show()\n",
    "id": 86
},
{
    "title": "Plotting cumulative distributions",
    "text": "This example shows how to plot the empirical cumulative distribution function\n(ECDF) of a sample. We also show the theoretical CDF. In engineering, ECDFs are sometimes called \"non-exceedance\" curves: the y-value\nfor a given x-value gives probability that an observation from the sample is\nbelow that x-value. For example, the value of 220 on the x-axis corresponds to\nabout 0.80 on the y-axis, so there is an 80% chance that an observation in the\nsample does not exceed 220. Conversely, the empirical complementary\ncumulative distribution function (the ECCDF, or \"exceedance\" curve) shows the\nprobability y that an observation from the sample is above a value x. A direct method to plot ECDFs is Axes.ecdf. Passing complementary=True\nresults in an ECCDF instead. Alternatively, one can use ax.hist(data, density=True, cumulative=True) to\nfirst bin the data, as if plotting a histogram, and then compute and plot the\ncumulative sums of the frequencies of entries in each bin. Here, to plot the\nECCDF, pass cumulative=-1. Note that this approach results in an\napproximation of the E(C)CDF, whereas Axes.ecdf is exact. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist matplotlib.axes.Axes.ecdf / matplotlib.pyplot.ecdf",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu = 200\nsigma = 25\nn_bins = 25\ndata = np.random.normal(mu, sigma, size=100)\n\nfig = plt.figure(figsize=(9, 4), layout='constrained')\naxs = fig.subplots(1, 2, sharex=True, sharey=True)\n\n# Cumulative distributions.\naxs[0].ecdf(data, label='CDF')\nn, bins, patches = axs[0].hist(data, n_bins, density=True, histtype='step',\n                               cumulative=True, label='Cumulative histogram')\nx = np.linspace(data.min(), data.max())\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (x - mu))**2))\ny = y.cumsum()\ny /= y[-1]\naxs[0].plot(x, y, 'k--', linewidth=1.5, label='Theory')\n\n# Complementary cumulative distributions.\naxs[1].ecdf(data, complementary=True, label='CCDF')\naxs[1].hist(data, bins=bins, density=True, histtype='step', cumulative=-1,\n            label='Reversed cumulative histogram')\naxs[1].plot(x, 1 - y, 'k--', linewidth=1.5, label='Theory')\n\n# Label the figure.\nfig.suptitle('Cumulative distributions')\nfor ax in axs:\n    ax.grid(True)\n    ax.legend()\n    ax.set_xlabel('Annual rainfall (mm)')\n    ax.set_ylabel('Probability of occurrence')\n    ax.label_outer()\n\nplt.show()\n",
    "id": 87
},
{
    "title": "Some features of the histogram (hist) function",
    "text": "In addition to the basic histogram, this demo shows a few optional features: Setting the number of data bins. The density parameter, which normalizes bin heights so that the integral of\nthe histogram is 1. The resulting histogram is an approximation of the\nprobability density function. Selecting different bin counts and sizes can significantly affect the shape\nof a histogram. The Astropy docs have a great section on how to select these\nparameters. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_xlabel matplotlib.axes.Axes.set_ylabel",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nrng = np.random.default_rng(19680801)\n\n# example data\nmu = 106  # mean of distribution\nsigma = 17  # standard deviation of distribution\nx = rng.normal(loc=mu, scale=sigma, size=420)\n\nnum_bins = 42\n\nfig, ax = plt.subplots()\n\n# the histogram of the data\nn, bins, patches = ax.hist(x, num_bins, density=True)\n\n# add a 'best fit' line\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))\nax.plot(bins, y, '--')\nax.set_xlabel('Value')\nax.set_ylabel('Probability density')\nax.set_title('Histogram of normal distribution sample: '\n             fr'$\\\\mu={mu:.0f}$, $\\\\sigma={sigma:.0f}$')\n\n# Tweak spacing to prevent clipping of ylabel\nfig.tight_layout()\nplt.show()\n",
    "id": 88
},
{
    "title": "Demo of the histogram function's different histtype settings",
    "text": "Histogram with step curve that has a color fill. Histogram with step curve with no fill. Histogram with custom and unequal bin widths. Two histograms with stacked bars. Selecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu_x = 200\nsigma_x = 25\nx = np.random.normal(mu_x, sigma_x, size=100)\n\nmu_w = 200\nsigma_w = 10\nw = np.random.normal(mu_w, sigma_w, size=100)\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].hist(x, 20, density=True, histtype='stepfilled', facecolor='g',\n               alpha=0.75)\naxs[0, 0].set_title('stepfilled')\n\naxs[0, 1].hist(x, 20, density=True, histtype='step', facecolor='g',\n               alpha=0.75)\naxs[0, 1].set_title('step')\n\naxs[1, 0].hist(x, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].hist(w, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].set_title('barstacked')\n\n# Create a histogram by providing the bin edges (unequally spaced).\nbins = [100, 150, 180, 195, 205, 220, 250, 300]\naxs[1, 1].hist(x, bins, density=True, histtype='bar', rwidth=0.8)\naxs[1, 1].set_title('bar, unequal bins')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 89
},
{
    "title": "The histogram (hist) function with multiple data sets",
    "text": "Plot histogram with multiple sample sets and demonstrate: Use of legend with multiple sample sets Stacked bars Step curve with no fill Data sets of different sample sizes Selecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nn_bins = 10\nx = np.random.randn(1000, 3)\n\nfig, ((ax0, ax1), (ax2, ax3)) = plt.subplots(nrows=2, ncols=2)\n\ncolors = ['red tan lime']\nax0.hist(x, n_bins, density=True, histtype='bar', color=colors, label=colors)\nax0.legend(prop={'size': 10})\nax0.set_title('bars with legend')\n\nax1.hist(x, n_bins, density=True, histtype='bar', stacked=True)\nax1.set_title('stacked bar')\n\nax2.hist(x, n_bins, histtype='step', stacked=True, fill=False)\nax2.set_title('stack step (unfilled)')\n\n# Make a multiple-histogram of data-sets with different length.\nx_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]\nax3.hist(x_multi, n_bins, histtype='bar')\nax3.set_title('different sample sizes')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 90
},
{
    "title": "Producing multiple histograms side by side",
    "text": "This example plots horizontal histograms of different samples along\na categorical x-axis. Additionally, the histograms are plotted to\nbe symmetrical about their x-position, thus making them very similar\nto violin plots.', \"To make this highly specialized plot, we can't use the standard hist\nmethod. Instead, we use barh to draw the horizontal bars directly. The\nvertical positions and lengths of the bars are computed via the\nnp.histogram function. The histograms for all the samples are\ncomputed using the same range (min and max values) and number of bins,\nso that the bins for each sample are in the same vertical positions.\", 'Selecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.barh / matplotlib.pyplot.barh",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\nnumber_of_bins = 20\n\n# An example of three data sets to compare\nnumber_of_data_points = 387\nlabels = ['A', 'B', 'C']\ndata_sets = [np.random.normal(0, 1, number_of_data_points),\n             np.random.normal(6, 1, number_of_data_points),\n             np.random.normal(-3, 1, number_of_data_points)]\n\n# Computed quantities to aid plotting\nhist_range = (np.min(data_sets), np.max(data_sets))\nbinned_data_sets = [\n    np.histogram(d, range=hist_range, bins=number_of_bins)[0]\n    for d in data_sets\n]\nbinned_maximums = np.max(binned_data_sets, axis=1)\nx_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))\n\n# The bin_edges are the same for all of the histograms\nbin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1)\nheights = np.diff(bin_edges)\ncenters = bin_edges[:-1] + heights / 2\n\n# Cycle through and plot each histogram\nfig, ax = plt.subplots()\nfor x_loc, binned_data in zip(x_locations, binned_data_sets):\n    lefts = x_loc - 0.5 * binned_data\n    ax.barh(centers, binned_data, height=heights, left=lefts)\n\nax.set_xticks(x_locations, labels)\n\nax.set_ylabel('Data values')\nax.set_xlabel('Data sets')\n\nplt.show()\n",
    "id": 91
},
{
    "title": "Violin plot basics",
    "text": "Violin plots are similar to histograms and box plots in that they show\nan abstract representation of the probability distribution of the\nsample. Rather than showing counts of data points that fall into bins\nor order statistics, violin plots use kernel density estimation (KDE) to\ncompute an empirical distribution of the sample. That computation\nis controlled by several parameters. This example demonstrates how to\nmodify the number of points at which the KDE is evaluated (points)\nand how to modify the bandwidth of the KDE (bw_method). For more information on violin plots and KDE, the scikit-learn docs\nhave a great section: https://scikit-learn.org/stable/modules/density.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.violinplot / matplotlib.pyplot.violinplot",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# fake data\nfs = 10  # fontsize\npos = [1, 2, 4, 5, 7, 8]\ndata = [np.random.normal(0, std, size=100) for std in pos]\n\nfig, axs = plt.subplots(nrows=2, ncols=5, figsize=(10, 6))\n\naxs[0, 0].violinplot(data, pos, points=20, widths=0.3,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[0, 0].set_title('Custom violinplot 1', fontsize=fs)\n\naxs[0, 1].violinplot(data, pos, points=40, widths=0.5,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method='silverman')\naxs[0, 1].set_title('Custom violinplot 2', fontsize=fs)\n\naxs[0, 2].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5)\naxs[0, 2].set_title('Custom violinplot 3', fontsize=fs)\n\naxs[0, 3].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]])\naxs[0, 3].set_title('Custom violinplot 4', fontsize=fs)\n\naxs[0, 4].violinplot(data[-1:], pos[-1:], points=60, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[0, 4].set_title('Custom violinplot 5', fontsize=fs)\n\naxs[1, 0].violinplot(data, pos, points=80, vert=False, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[1, 0].set_title('Custom violinplot 6', fontsize=fs)\n\naxs[1, 1].violinplot(data, pos, points=100, vert=False, widths=0.9,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method='silverman')\naxs[1, 1].set_title('Custom violinplot 7', fontsize=fs)\n\naxs[1, 2].violinplot(data, pos, points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method=0.5)\naxs[1, 2].set_title('Custom violinplot 8', fontsize=fs)\n\naxs[1, 3].violinplot(data, pos, points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]],\n                     bw_method=0.5)\naxs[1, 3].set_title('Custom violinplot 9', fontsize=fs)\n\naxs[1, 4].violinplot(data[-1:], pos[-1:], points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[1, 4].set_title('Custom violinplot 10', fontsize=fs)\n\n\nfor ax in axs.flat:\n    ax.set_yticklabels([])\n\nfig.suptitle('Violin Plotting Examples')\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n",
    "id": 92
},
{
    "title": "Bar of pie",
    "text": "Make a \"bar of pie\" chart where the first slice of the pie is\n\"exploded\" into a bar chart with a further breakdown of said slice\\'s\ncharacteristics. The example demonstrates using a figure with multiple\nsets of axes and using the axes patches list to add two ConnectionPatches\nto link the subplot charts. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.pie / matplotlib.pyplot.pie matplotlib.patches.ConnectionPatch",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import ConnectionPatch\n\n# make figure and assign axis objects\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 5))\nfig.subplots_adjust(wspace=0)\n\n# pie chart parameters\noverall_ratios = [.27, .56, .17]\nlabels = ['Approve', 'Disapprove', 'Undecided']\nexplode = [0.1, 0, 0]\n# rotate so that first wedge is split by the x-axis\nangle = -180 * overall_ratios[0]\nwedges, *_ = ax1.pie(overall_ratios, autopct='%1.1f%%', startangle=angle,\n                     labels=labels, explode=explode)\n\n# bar chart parameters\nage_ratios = [.33, .54, .07, .06]\nage_labels = ['Under 35', '35-49', '50-65', 'Over 65']\nbottom = 1\nwidth = .2\n\n# Adding from the top matches the legend.\nfor j, (height, label) in enumerate(reversed([*zip(age_ratios, age_labels)])):\n    bottom -= height\n    bc = ax2.bar(0, height, width, bottom=bottom, color='C0', label=label,\n                 alpha=0.1 + 0.25 * j)\n    ax2.bar_label(bc, labels=[f'{height:.0%}'], label_type='center')\n\nax2.set_title('Age of approvers')\nax2.legend()\nax2.axis('off')\nax2.set_xlim(- 2.5 * width, 2.5 * width)\n\n# use ConnectionPatch to draw lines between the two plots\ntheta1, theta2 = wedges[0].theta1, wedges[0].theta2\ncenter, r = wedges[0].center, wedges[0].r\nbar_height = sum(age_ratios)\n\n# draw top connecting line\nx = r * np.cos(np.pi / 180 * theta2) + center[0]\ny = r * np.sin(np.pi / 180 * theta2) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, bar_height), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\ncon.set_linewidth(4)\nax2.add_artist(con)\n\n# draw bottom connecting line\nx = r * np.cos(np.pi / 180 * theta1) + center[0]\ny = r * np.sin(np.pi / 180 * theta1) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, 0), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\nax2.add_artist(con)\ncon.set_linewidth(4)\n\nplt.show()\n",
    "id": 93
},
{
    "title": "Bar chart on polar axis",
    "text": "Demo of bar plot on a polar axis. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.projections.polar",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute pie slices\nN = 20\ntheta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)\nradii = 10 * np.random.rand(N)\nwidth = np.pi / 4 * np.random.rand(N)\ncolors = plt.cm.viridis(radii / 10.)\n\nax = plt.subplot(projection='polar')\nax.bar(theta, radii, width=width, bottom=0.0, color=colors, alpha=0.5)\n\nplt.show()\n",
    "id": 94
},
{
    "title": "Polar plot",
    "text": "Demo of a line plot on a polar axis. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.projections.polar matplotlib.projections.polar.PolarAxes matplotlib.projections.polar.PolarAxes.set_rticks matplotlib.projections.polar.PolarAxes.set_rmax matplotlib.projections.polar.PolarAxes.set_rlabel_position",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rmax(2)\nax.set_rticks([0.5, 1, 1.5, 2])  # Less radial ticks\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\nax.grid(True)\n\nax.set_title('A line plot on a polar axis', va='bottom')\nplt.show()\n",
    "id": 95
},
{
    "title": "Polar legend",
    "text": "Using a legend on a polar-axis plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.projections.polar matplotlib.projections.polar.PolarAxes",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar', facecolor='lightgoldenrodyellow')\n\nr = np.linspace(0, 3, 301)\ntheta = 2 * np.pi * r\nax.plot(theta, r, color='tab:orange', lw=3, label='a line')\nax.plot(0.5 * theta, r, color='tab:blue', ls='--', lw=3, label='another line')\nax.tick_params(grid_color='palegoldenrod')\n# For polar axes, it may be useful to move the legend slightly away from the\n# axes center, to avoid overlap between the legend and the axes.  The following\n# snippet places the legend's lower left corner just outside the polar axes\n# at an angle of 67.5 degrees in polar coordinates.\nangle = np.deg2rad(67.5)\nax.legend(loc='lower left',\n          bbox_to_anchor=(.5 + np.cos(angle)/2, .5 + np.sin(angle)/2))\n\nplt.show()\n",
    "id": 96
},
{
    "title": "Angle annotations on bracket arrows",
    "text": "This example shows how to add angle annotations to bracket arrow styles\ncreated using FancyArrowPatch. angleA and angleB are measured from a\nvertical line as positive (to the left) or negative (to the right). Blue\nFancyArrowPatch arrows indicate the directions of angleA and angleB\nfrom the vertical and axes text annotate the angle sizes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.ArrowStyle",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\ndef get_point_of_rotated_vertical(origin, line_length, degrees):\n    '''Return xy coordinates of the vertical line end rotated by degrees.'''\n    rad = np.deg2rad(-degrees)\n    return [origin[0] + line_length * np.sin(rad),\n            origin[1] + line_length * np.cos(rad)]\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 6), ylim=(-1, 5))\nax.set_title('Orientation of the bracket arrows relative to angleA and angleB')\n\nstyle = ']-['\nfor i, angle in enumerate([-40, 0, 60]):\n    y = 2*i\n    arrow_centers = ((1, y), (5, y))\n    vlines = ((1, y + 0.5), (5, y + 0.5))\n    anglesAB = (angle, -angle)\n    bracketstyle = f'{style}, angleA={anglesAB[0]}, angleB={anglesAB[1]}'\n    bracket = FancyArrowPatch(*arrow_centers, arrowstyle=bracketstyle,\n                              mutation_scale=42)\n    ax.add_patch(bracket)\n    ax.text(3, y + 0.05, bracketstyle, ha='center', va='bottom', fontsize=14)\n    ax.vlines([line[0] for line in vlines], [y, y], [line[1] for line in vlines],\n              linestyles='--', color='C0')\n    # Get the top coordinates for the drawn patches at A and B\n    patch_tops = [get_point_of_rotated_vertical(center, 0.5, angle)\n                  for center, angle in zip(arrow_centers, anglesAB)]\n    # Define the connection directions for the annotation arrows\n    connection_dirs = (1, -1) if angle > 0 else (-1, 1)\n    # Add arrows and annotation text\n    arrowstyle = 'Simple, tail_width=0.5, head_width=4, head_length=8'\n    for vline, dir, patch_top, angle in zip(vlines, connection_dirs,\n                                            patch_tops, anglesAB):\n        kw = dict(connectionstyle=f'arc3,rad={dir * 0.5}',\n                  arrowstyle=arrowstyle, color='C0')\n        ax.add_patch(FancyArrowPatch(vline, patch_top, **kw))\n        ax.text(vline[0] - dir * 0.15, y + 0.7, f'{angle}\u00b0', ha='center',\n                va='center')\n\nplt.show()\n",
    "id": 97
},
{
    "title": "Annotate Transform",
    "text": "This example shows how to use different coordinate systems for annotations.\nFor a complete overview of the annotation capabilities, also see the\nannotation tutorial. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.transforms.Transform.transform matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nxdata, ydata = 5, 0\nxdisplay, ydisplay = ax.transData.transform((xdata, ydata))\n\nbbox = dict(boxstyle='round', fc='0.8')\narrowprops = dict(\n    arrowstyle='->',\n    connectionstyle='angle,angleA=0,angleB=90,rad=10')\n\noffset = 72\nax.annotate(\n    f'data = ({xdata:.1f}, {ydata:.1f})',\n    (xdata, ydata),\n    xytext=(-2*offset, offset), textcoords='offset points',\n    bbox=bbox, arrowprops=arrowprops)\nax.annotate(\n    f'display = ({xdisplay:.1f}, {ydisplay:.1f})',\n    xy=(xdisplay, ydisplay), xycoords='figure pixels',\n    xytext=(0.5*offset, -offset), textcoords='offset points',\n    bbox=bbox, arrowprops=arrowprops)\n\nplt.show()\n",
    "id": 98
},
{
    "title": "Annotating a plot",
    "text": "This example shows how to annotate a plot with an arrow pointing to provided\ncoordinates. We modify the defaults of the arrow, to \"shrink\" it. For a complete overview of the annotation capabilities, also see the\nannotation tutorial. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            )\nax.set_ylim(-2, 2)\nplt.show()\n",
    "id": 99
},
{
    "title": "Annotation Polar",
    "text": "This example shows how to create an annotation on a polar graph. For a complete overview of the annotation capabilities, also see the\nAnnotations. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.projections.polar matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nr = np.arange(0, 1, 0.001)\ntheta = 2 * 2*np.pi * r\nline, = ax.plot(theta, r, color='#ee8d18', lw=3)\n\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # theta, radius\n            xytext=(0.05, 0.05),    # fraction, fraction\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom',\n            )\nplt.show()\n",
    "id": 100
},
{
    "title": "Arrow Demo",
    "text": "Three ways of drawing arrows to encode arrow \"strength\" (e.g., transition\nprobabilities in a Markov model) using arrow length, width, or alpha (opacity).",
    "code": "import itertools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef make_arrow_graph(ax, data, size=4, display='length', shape='right',\n                     max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5,\n                     normalize_data=False, ec=None, labelcolor=None,\n                     **kwargs):\n    '''\n    Makes an arrow plot.\n\n    Parameters\n    ----------\n    ax\n        The axes where the graph is drawn.\n    data\n        Dict with probabilities for the bases and pair transitions.\n    size\n        Size of the plot, in inches.\n    display : {'length', 'width', 'alpha'}\n        The arrow property to change.\n    shape : {'full', 'left', 'right'}\n        For full or half arrows.\n    max_arrow_width : float\n        Maximum width of an arrow, in data coordinates.\n    arrow_sep : float\n        Separation between arrows in a pair, in data coordinates.\n    alpha : float\n        Maximum opacity of arrows.\n    **kwargs\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\n    '''\n\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[],\n           title=f'flux encoded as arrow {display}')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n\n    bases = 'ATGC'\n    coords = {\n        'A': np.array([0, 1]),\n        'T': np.array([1, 1]),\n        'G': np.array([0, 0]),\n        'C': np.array([1, 0]),\n    }\n    colors = {'A': 'r', 'T': 'k', 'G': 'g', 'C': 'b'}\n\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base]**(1/2),\n                           min_text_size, max_text_size)\n        ax.text(*coords[base], f'${base}_3$',\n                color=colors[base], size=fontsize,\n                horizontalalignment='center', verticalalignment='center',\n                weight='bold')\n\n    arrow_h_offset = 0.25  # data coordinates, empirically determined\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6  # max arrow size represents this in data coords\n\n    if normalize_data:\n        # find maximum value for rates, i.e. where keys are 2 chars long\n        max_val = max((v for k, v in data.items() if len(k) == 2), default=0)\n        # divide rates by max val, multiply by arrow scale factor\n        for k, v in data.items():\n            data[k] = v / max_val * sf\n\n    # iterate over strings 'AT', 'TA', 'AG', 'GA', etc.\n    for pair in map(''.join, itertools.permutations(bases, 2)):\n        # set the length of the arrow\n        if display == 'length':\n            length = (max_head_length\n                      + data[pair] / sf * (max_arrow_length - max_head_length))\n        else:\n            length = max_arrow_length\n        # set the transparency of the arrow\n        if display == 'alpha':\n            alpha = min(data[pair] / sf, alpha)\n        # set the width of the arrow\n        if display == 'width':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n\n        fc = colors[pair[0]]\n\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        # unit vector in arrow direction\n        delta = cos, sin = (cp1 - cp0) / np.hypot(*(cp1 - cp0))\n        x_pos, y_pos = (\n            (cp0 + cp1) / 2  # midpoint\n            - delta * length / 2  # half the arrow length\n            + np.array([-sin, cos]) * arrow_sep  # shift outwards by arrow_sep\n        )\n        ax.arrow(\n            x_pos, y_pos, cos * length, sin * length,\n            fc=fc, ec=ec or fc, alpha=alpha, width=width,\n            head_width=head_width, head_length=head_length, shape=shape,\n            length_includes_head=True,\n            **kwargs\n        )\n\n        # figure out coordinates for text:\n        # if drawing relative to base: x and y are same as for arrow\n        # dx and dy are one arrow width left and up\n        orig_positions = {\n            'base': [3 * max_arrow_width, 3 * max_arrow_width],\n            'center': [length / 2, 3 * max_arrow_width],\n            'tip': [length - 3 * max_arrow_width, 3 * max_arrow_width],\n        }\n        # for diagonal arrows, put the label at the arrow base\n        # for vertical or horizontal arrows, center the label\n        where = 'base' if (cp0 != cp1).all() else 'center'\n        # rotate based on direction of arrow (cos, sin)\n        M = [[cos, -sin], [sin, cos]]\n        x, y = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = r'$r_{_{\\\\mathrm{%s}}}$' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha='center', va='center',\n                color=labelcolor or fc)\n\n\nif __name__ == '__main__':\n    data = {  # test data\n        'A': 0.4, 'T': 0.3, 'G': 0.6, 'C': 0.2,\n        'AT': 0.4, 'AC': 0.3, 'AG': 0.2,\n        'TA': 0.2, 'TC': 0.3, 'TG': 0.4,\n        'CT': 0.2, 'CG': 0.3, 'CA': 0.2,\n        'GA': 0.1, 'GT': 0.4, 'GC': 0.1,\n    }\n\n    size = 4\n    fig = plt.figure(figsize=(3 * size, size), layout='constrained')\n    axs = fig.subplot_mosaic([['length', 'width', 'alpha']])\n\n    for display, ax in axs.items():\n        make_arrow_graph(\n            ax, data, display=display, linewidth=0.001, edgecolor=None,\n            normalize_data=True, size=size)\n\n    plt.show()\n",
    "id": 101
},
{
    "title": "Auto-wrapping text",
    "text": "Matplotlib can wrap text automatically, but if it's too long, the text will be\ndisplayed slightly outside of the boundaries of the axis anyways.\", \"Note: Auto-wrapping does not work together with\nsavefig(..., bbox_inches='tight'). The 'tight' setting rescales the canvas\nto accommodate all content and happens before wrapping. This affects\n%matplotlib inline in IPython and Jupyter notebooks where the inline\nsetting uses bbox_inches='tight' by default when saving the image to\nembed.",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\nplt.axis((0, 10, 0, 10))\nt = ('This is a really long string that I'd rather have wrapped so that it '\n     'doesn't go outside of the figure, but if it's long enough it will go '\n     'off the top or bottom!')\nplt.text(4, 1, t, ha='left', rotation=15, wrap=True)\nplt.text(6, 5, t, ha='left', rotation=15, wrap=True)\nplt.text(5, 5, t, ha='right', rotation=-15, wrap=True)\nplt.text(5, 10, t, fontsize=18, style='oblique', ha='center',\n         va='top', wrap=True)\nplt.text(3, 4, t, family='serif', style='italic', ha='right', wrap=True)\nplt.text(-1, 0, t, ha='left', rotation=-15, wrap=True)\n\nplt.show()\n",
    "id": 102
},
{
    "title": "Date tick labels",
    "text": "Matplotlib date plotting is done by converting date instances into\ndays since an epoch (by default 1970-01-01T00:00:00). The\nmatplotlib.dates module provides the converter functions date2num\nand num2date that convert datetime.datetime and numpy.datetime64\nobjects to and from Matplotlib's internal representation. These data\ntypes are registered with the unit conversion mechanism described in\nmatplotlib.units, so the conversion happens automatically for the user.\nThe registration process also sets the default tick locator and\nformatter for the axis to be AutoDateLocator and\nAutoDateFormatter.\", 'An alternative formatter is the ConciseDateFormatter,\nused in the second Axes below (see\nFormatting date ticks using ConciseDateFormatter), which often removes the need to\nrotate the tick labels. The last Axes formats the dates manually, using\nDateFormatter to format the dates using the format strings documented\nat datetime.date.strftime. Total running time of the script: (0 minutes 1.204 seconds)",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as mdates\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\ndata = cbook.get_sample_data('goog.npz')['price_data']\n\nfig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained')\n# common to all three:\nfor ax in axs:\n    ax.plot('date adj_close', data=data)\n    # Major ticks every half year, minor ticks every month,\n    ax.xaxis.set_major_locator(mdates.MonthLocator(bymonth=(1, 7)))\n    ax.xaxis.set_minor_locator(mdates.MonthLocator())\n    ax.grid(True)\n    ax.set_ylabel(r'Price [\\\\$]')\n\n# different formats:\nax = axs[0]\nax.set_title('DefaultFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\n\nax = axs[1]\nax.set_title('ConciseFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\nax.xaxis.set_major_formatter(\n    mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\nax = axs[2]\nax.set_title('Manual DateFormatter', loc='left', y=0.85, x=0.02,\n             fontsize='medium')\n# Text in the x-axis will be displayed in 'YYYY-mm' format.\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%b'))\n# Rotates and right-aligns the x labels so they don't crowd each other.\nfor label in ax.get_xticklabels(which='major'):\n    label.set(rotation=30, horizontalalignment='right')\n\nplt.show()\n",
    "id": 103
},
{
    "title": "AnnotationBbox demo",
    "text": "AnnotationBbox creates an annotation using an OffsetBox, and\nprovides more fine-grained control than Axes.annotate. This example\ndemonstrates the use of AnnotationBbox together with three different\nOffsetBoxes: TextArea, DrawingArea, and OffsetImage. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.Circle matplotlib.offsetbox.TextArea matplotlib.offsetbox.DrawingArea matplotlib.offsetbox.OffsetImage matplotlib.offsetbox.AnnotationBbox matplotlib.cbook.get_sample_data matplotlib.pyplot.subplots matplotlib.pyplot.imread",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.offsetbox import (AnnotationBbox, DrawingArea, OffsetImage,\n                                  TextArea)\nfrom matplotlib.patches import Circle\n\nfig, ax = plt.subplots()\n\n# Define a 1st position to annotate (display it with a marker)\nxy = (0.5, 0.7)\nax.plot(xy[0], xy[1], '.r')\n\n# Annotate the 1st position with a text box ('Test 1')\noffsetbox = TextArea('Test 1')\n\nab = AnnotationBbox(offsetbox, xy,\n                    xybox=(-20, 40),\n                    xycoords='data',\n                    boxcoords='offset points',\n                    arrowprops=dict(arrowstyle='->'),\n                    bboxprops=dict(boxstyle='sawtooth'))\nax.add_artist(ab)\n\n# Annotate the 1st position with another text box ('Test')\noffsetbox = TextArea('Test')\n\nab = AnnotationBbox(offsetbox, xy,\n                    xybox=(1.02, xy[1]),\n                    xycoords='data',\n                    boxcoords=('axes fraction', 'data'),\n                    box_alignment=(0., 0.5),\n                    arrowprops=dict(arrowstyle='->'))\nax.add_artist(ab)\n\n# Define a 2nd position to annotate (don't display with a marker this time)\nxy = [0.3, 0.55]\n\n# Annotate the 2nd position with a circle patch\nda = DrawingArea(20, 20, 0, 0)\np = Circle((10, 10), 10)\nda.add_artist(p)\n\nab = AnnotationBbox(da, xy,\n                    xybox=(1., xy[1]),\n                    xycoords='data',\n                    boxcoords=('axes fraction', 'data'),\n                    box_alignment=(0.2, 0.5),\n                    arrowprops=dict(arrowstyle='->'),\n                    bboxprops=dict(alpha=0.5))\n\nax.add_artist(ab)\n\n# Annotate the 2nd position with an image (a generated array of pixels)\narr = np.arange(100).reshape((10, 10))\nim = OffsetImage(arr, zoom=2)\nim.image.axes = ax\n\nab = AnnotationBbox(im, xy,\n                    xybox=(-50., 50.),\n                    xycoords='data',\n                    boxcoords='offset points',\n                    pad=0.3,\n                    arrowprops=dict(arrowstyle='->'))\n\nax.add_artist(ab)\n\n# Annotate the 2nd position with another image (a Grace Hopper portrait)\nwith get_sample_data('grace_hopper.jpg') as file:\n    arr_img = plt.imread(file)\n\nimagebox = OffsetImage(arr_img, zoom=0.2)\nimagebox.image.axes = ax\n\nab = AnnotationBbox(imagebox, xy,\n                    xybox=(120., -80.),\n                    xycoords='data',\n                    boxcoords='offset points',\n                    pad=0.5,\n                    arrowprops=dict(\n                        arrowstyle='->',\n                        connectionstyle='angle,angleA=0,angleB=90,rad=3')\n                    )\n\nax.add_artist(ab)\n\n# Fix the display limits to see everything\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\n\nplt.show()\n",
    "id": 104
},
{
    "title": "Using a text as a Path",
    "text": "TextPath creates a Path that is the outline of the\ncharacters of a text. The resulting path can be employed e.g. as a clip path\nfor an image. Total running time of the script: (0 minutes 1.930 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.image import BboxImage\nfrom matplotlib.offsetbox import (AnchoredOffsetbox, AnnotationBbox,\n                                  AuxTransformBox)\nfrom matplotlib.patches import PathPatch, Shadow\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import IdentityTransform\n\n\nclass PathClippedImagePatch(PathPatch):\n    '''\n    The given image is used to draw the face of the patch. Internally,\n    it uses BboxImage whose clippath set to the path of the patch.\n\n    FIXME : The result is currently dpi dependent.\n    '''\n\n    def __init__(self, path, bbox_image, **kwargs):\n        super().__init__(path, **kwargs)\n        self.bbox_image = BboxImage(\n            self.get_window_extent, norm=None, origin=None)\n        self.bbox_image.set_data(bbox_image)\n\n    def set_facecolor(self, color):\n        '''Simply ignore facecolor.'''\n        super().set_facecolor('none')\n\n    def draw(self, renderer=None):\n        # the clip path must be updated every draw. any solution? -JJ\n        self.bbox_image.set_clip_path(self._path, self.get_transform())\n        self.bbox_image.draw(renderer)\n        super().draw(renderer)\n\n\nif __name__ == '__main__':\n\n    fig, (ax1, ax2) = plt.subplots(2)\n\n    # EXAMPLE 1\n\n    arr = plt.imread(get_sample_data('grace_hopper.jpg'))\n\n    text_path = TextPath((0, 0), '!?', size=150)\n    p = PathClippedImagePatch(text_path, arr, ec='k')\n\n    # make offset box\n    offsetbox = AuxTransformBox(IdentityTransform())\n    offsetbox.add_artist(p)\n\n    # make anchored offset box\n    ao = AnchoredOffsetbox(loc='upper left', child=offsetbox, frameon=True,\n                           borderpad=0.2)\n    ax1.add_artist(ao)\n\n    # another text\n    for usetex, ypos, string in [\n            (False, 0.25, r'textpath supports mathtext'),\n            (True, 0.05, r'textpath supports \\\\TeX'),\n    ]:\n        text_path = TextPath((0, 0), string, size=20, usetex=usetex)\n\n        p1 = PathPatch(text_path, ec='w', lw=3, fc='w', alpha=0.9)\n        p2 = PathPatch(text_path, ec='none', fc='k')\n\n        offsetbox2 = AuxTransformBox(IdentityTransform())\n        offsetbox2.add_artist(p1)\n        offsetbox2.add_artist(p2)\n\n        ab = AnnotationBbox(offsetbox2, (0.95, ypos),\n                            xycoords='axes fraction',\n                            boxcoords='offset points',\n                            box_alignment=(1., 0.),\n                            frameon=False,\n                            )\n        ax1.add_artist(ab)\n\n    ax1.imshow([[0, 1, 2], [1, 2, 3]], cmap=plt.cm.gist_gray_r,\n               interpolation='bilinear', aspect='auto')\n\n    # EXAMPLE 2\n\n    arr = np.arange(256).reshape(1, 256)\n\n    for usetex, xpos, string in [\n            (False, 0.25,\n             r'$\\\\left[\\\\sum_{n=1}^\\\\infty\\\\frac{-e^{i\\\\pi}}{2^n}\\\\right]$!'),\n            (True, 0.75,\n             r'$\\\\displaystyle\\\\left[\\\\sum_{n=1}^\\\\infty'\n             r'\\\\frac{-e^{i\\\\pi}}{2^n}\\\\right]$!'),\n    ]:\n        text_path = TextPath((0, 0), string, size=40, usetex=usetex)\n        text_patch = PathClippedImagePatch(text_path, arr, ec='none')\n        shadow1 = Shadow(text_patch, 1, -1, fc='none', ec='0.6', lw=3)\n        shadow2 = Shadow(text_patch, 1, -1, fc='0.3', ec='none')\n\n        # make offset box\n        offsetbox = AuxTransformBox(IdentityTransform())\n        offsetbox.add_artist(shadow1)\n        offsetbox.add_artist(shadow2)\n        offsetbox.add_artist(text_patch)\n\n        # place the anchored offset box using AnnotationBbox\n        ab = AnnotationBbox(offsetbox, (xpos, 0.5), box_alignment=(0.5, 0.5))\n\n        ax2.add_artist(ab)\n\n    ax2.set_xlim(0, 1)\n    ax2.set_ylim(0, 1)\n\n    plt.show()\n",
    "id": 105
},
{
    "title": "Text Rotation Mode",
    "text": "This example illustrates the effect of rotation_mode on the positioning\nof rotated text.', \"Rotated Texts are created by passing the parameter rotation to\nthe constructor or the axes' method text.\", 'The actual positioning depends on the additional parameters\nhorizontalalignment, verticalalignment and rotation_mode.\nrotation_mode determines the order of rotation and alignment:', \"rotation_mode='default' (or None) first rotates the text and then aligns\nthe bounding box of the rotated text.\", \"rotation_mode='anchor' aligns the unrotated text and then rotates the\ntext around the point of alignment.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.text / matplotlib.pyplot.text",
    "code": "import matplotlib.pyplot as plt\n\n\ndef test_rotation_mode(fig, mode):\n    ha_list = ['left', 'center', 'right']\n    va_list = ['top', 'center', 'baseline', 'bottom']\n    axs = fig.subplots(len(va_list), len(ha_list), sharex=True, sharey=True,\n                       subplot_kw=dict(aspect=1),\n                       gridspec_kw=dict(hspace=0, wspace=0))\n\n    # labels and title\n    for ha, ax in zip(ha_list, axs[-1, :]):\n        ax.set_xlabel(ha)\n    for va, ax in zip(va_list, axs[:, 0]):\n        ax.set_ylabel(va)\n    axs[0, 1].set_title(f'rotation_mode='{mode}'', size='large')\n\n    kw = (\n        {} if mode == 'default' else\n        {'bbox': dict(boxstyle='square,pad=0.', ec='none', fc='C1', alpha=0.3)}\n    )\n\n    texts = {}\n\n    # use a different text alignment in each axes\n    for i, va in enumerate(va_list):\n        for j, ha in enumerate(ha_list):\n            ax = axs[i, j]\n            # prepare axes layout\n            ax.set(xticks=[], yticks=[])\n            ax.axvline(0.5, color='skyblue', zorder=0)\n            ax.axhline(0.5, color='skyblue', zorder=0)\n            ax.plot(0.5, 0.5, color='C0', marker='o', zorder=1)\n            # add text with rotation and alignment settings\n            tx = ax.text(0.5, 0.5, 'Tpg',\n                         size='x-large', rotation=40,\n                         horizontalalignment=ha, verticalalignment=va,\n                         rotation_mode=mode, **kw)\n            texts[ax] = tx\n\n    if mode == 'default':\n        # highlight bbox\n        fig.canvas.draw()\n        for ax, text in texts.items():\n            bb = text.get_window_extent().transformed(ax.transData.inverted())\n            rect = plt.Rectangle((bb.x0, bb.y0), bb.width, bb.height,\n                                 facecolor='C1', alpha=0.3, zorder=2)\n            ax.add_patch(rect)\n\n\nfig = plt.figure(figsize=(8, 5))\nsubfigs = fig.subfigures(1, 2)\ntest_rotation_mode(subfigs[0], 'default')\ntest_rotation_mode(subfigs[1], 'anchor')\nplt.show()\n",
    "id": 106
},
{
    "title": "The difference between \\dfrac and \\frac",
    "text": "In this example, the differences between the \\\\dfrac and \\\\frac TeX macros are\nillustrated; in particular, the difference between display style and text style\nfractions when using Mathtex. New in version 2.1. Note To use \\\\dfrac with the LaTeX engine (text.usetex : True), you need to\nimport the amsmath package with the text.latex.preamble rc, which is\nan unsupported feature; therefore, it is probably a better idea to just\nuse the \\\\displaystyle option before the \\\\frac macro to get this behavior\nwith the LaTeX engine.",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(5.25, 0.75))\nfig.text(0.5, 0.3, r'\\\\dfrac: $\\\\dfrac{a}{b}$',\n         horizontalalignment='center', verticalalignment='center')\nfig.text(0.5, 0.7, r'\\\\frac: $\\\\frac{a}{b}$',\n         horizontalalignment='center', verticalalignment='center')\nplt.show()\n",
    "id": 107
},
{
    "title": "Labeling ticks using engineering notation",
    "text": "Use of the engineering Formatter. Total running time of the script: (0 minutes 1.063 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import EngFormatter\n\n# Fixing random state for reproducibility\nprng = np.random.RandomState(19680801)\n\n# Create artificial data to plot.\n# The x data span over several decades to demonstrate several SI prefixes.\nxs = np.logspace(1, 9, 100)\nys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2\n\n# Figure width is doubled (2*6.4) to display nicely 2 subplots side by side.\nfig, (ax0, ax1) = plt.subplots(nrows=2, figsize=(7, 9.6))\nfor ax in (ax0, ax1):\n    ax.set_xscale('log')\n\n# Demo of the default settings, with a user-defined unit label.\nax0.set_title('Full unit ticklabels, w/ default precision & space separator')\nformatter0 = EngFormatter(unit='Hz')\nax0.xaxis.set_major_formatter(formatter0)\nax0.plot(xs, ys)\nax0.set_xlabel('Frequency')\n\n# Demo of the options `places` (number of digit after decimal point) and\n# `sep` (separator between the number and the prefix/unit).\nax1.set_title('SI-prefix only ticklabels, 1-digit precision & '\n              'thin space separator')\nformatter1 = EngFormatter(places=1, sep='\\\\N{THIN SPACE}')  # U+2009\nax1.xaxis.set_major_formatter(formatter1)\nax1.plot(xs, ys)\nax1.set_xlabel('Frequency [Hz]')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 108
},
{
    "title": "Annotation arrow style reference",
    "text": "Overview of the arrow styles available in annotate. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.ArrowStyle matplotlib.patches.ArrowStyle.get_styles matplotlib.axes.Axes.annotate",
    "code": "import inspect\nimport itertools\nimport re\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nstyles = mpatches.ArrowStyle.get_styles()\nncol = 2\nnrow = (len(styles) + 1) // ncol\naxs = (plt.figure(figsize=(4 * ncol, 1 + nrow))\n       .add_gridspec(1 + nrow, ncol,\n                     wspace=.7, left=.1, right=.9, bottom=0, top=1).subplots())\nfor ax in axs.flat:\n    ax.set_axis_off()\nfor ax in axs[0, :]:\n    ax.text(0, .5, 'arrowstyle',\n            transform=ax.transAxes, size='large', color='tab:blue',\n            horizontalalignment='center', verticalalignment='center')\n    ax.text(.35, .5, 'default parameters',\n            transform=ax.transAxes,\n            horizontalalignment='left', verticalalignment='center')\nfor ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):\n    l, = ax.plot(.25, .5, 'ok', transform=ax.transAxes)\n    ax.annotate(stylename, (.25, .5), (-0.1, .5),\n                xycoords='axes fraction', textcoords='axes fraction',\n                size='large', color='tab:blue',\n                horizontalalignment='center', verticalalignment='center',\n                arrowprops=dict(\n                    arrowstyle=stylename, connectionstyle='arc3,rad=-0.05',\n                    color='k', shrinkA=5, shrinkB=5, patchB=l,\n                ),\n                bbox=dict(boxstyle='square', fc='w'))\n    # wrap at every nth comma (n = 1 or 2, depending on text length)\n    s = str(inspect.signature(stylecls))[1:-1]\n    n = 2 if s.count(',') > 3 else 1\n    ax.text(.35, .5,\n            re.sub(', ', lambda m, c=itertools.count(1): m.group()\n                   if next(c) % n else '\\\n', s),\n            transform=ax.transAxes,\n            horizontalalignment='left', verticalalignment='center')\n\nplt.show()\n",
    "id": 109
},
{
    "title": "Styling text boxes",
    "text": "This example shows how to style text boxes using bbox parameters.",
    "code": "import matplotlib.pyplot as plt\n\nplt.text(0.6, 0.7, 'eggs', size=50, rotation=30.,\n         ha='center', va='center',\n         bbox=dict(boxstyle='round',\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\nplt.text(0.55, 0.6, 'spam', size=50, rotation=-25.,\n         ha='right', va='top',\n         bbox=dict(boxstyle='square',\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\nplt.show()\n",
    "id": 110
},
{
    "title": "Using a ttf font file in Matplotlib",
    "text": "Although it is usually not a good idea to explicitly point to a single ttf file\nfor a font instance, you can do so by passing a pathlib.Path instance as the\nfont parameter. Note that passing paths as strs is intentionally not\nsupported, but you can simply wrap strs in pathlib.Paths as needed. Here, we use the Computer Modern roman font (cmr10) shipped with\nMatplotlib. For a more flexible solution, see\nConfiguring the font family and\nFonts demo (object-oriented style). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.set_title",
    "code": "from pathlib import Path\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib as mpl\n\nfig, ax = plt.subplots()\n\nfpath = Path(mpl.get_data_path(), 'fonts/ttf/cmr10.ttf')\nax.set_title(f'This is a special font: {fpath.name}', font=fpath)\nax.set_xlabel('This is the default font')\n\nplt.show()\n",
    "id": 111
},
{
    "title": "Fonts demo (object-oriented style)",
    "text": "Set font properties using setters. See Fonts demo (keyword arguments) to achieve the same effect using keyword arguments.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.font_manager import FontProperties\n\nfig = plt.figure()\nalignment = {'horizontalalignment': 'center verticalalignment': 'baseline'}\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\nheading_font = FontProperties(size='large')\n\n# Show family options\nfig.text(0.1, 0.9, 'family', fontproperties=heading_font, **alignment)\nfamilies = ['serif sans-serif cursive fantasy monospace']\nfor k, family in enumerate(families):\n    font = FontProperties()\n    font.set_family(family)\n    fig.text(0.1, yp[k], family, fontproperties=font, **alignment)\n\n# Show style options\nstyles = ['normal italic oblique']\nfig.text(0.3, 0.9, 'style', fontproperties=heading_font, **alignment)\nfor k, style in enumerate(styles):\n    font = FontProperties()\n    font.set_family('sans-serif')\n    font.set_style(style)\n    fig.text(0.3, yp[k], style, fontproperties=font, **alignment)\n\n# Show variant options\nvariants = ['normal small-caps']\nfig.text(0.5, 0.9, 'variant', fontproperties=heading_font, **alignment)\nfor k, variant in enumerate(variants):\n    font = FontProperties()\n    font.set_family('serif')\n    font.set_variant(variant)\n    fig.text(0.5, yp[k], variant, fontproperties=font, **alignment)\n\n# Show weight options\nweights = ['light normal medium semibold bold heavy black']\nfig.text(0.7, 0.9, 'weight', fontproperties=heading_font, **alignment)\nfor k, weight in enumerate(weights):\n    font = FontProperties()\n    font.set_weight(weight)\n    fig.text(0.7, yp[k], weight, fontproperties=font, **alignment)\n\n# Show size options\nsizes = [\n    'xx-small x-small small medium large x-large xx-large']\nfig.text(0.9, 0.9, 'size', fontproperties=heading_font, **alignment)\nfor k, size in enumerate(sizes):\n    font = FontProperties()\n    font.set_size(size)\n    fig.text(0.9, yp[k], size, fontproperties=font, **alignment)\n\n# Show bold italic\nfont = FontProperties(style='italic', weight='bold', size='x-small')\nfig.text(0.3, 0.1, 'bold italic', fontproperties=font, **alignment)\nfont = FontProperties(style='italic', weight='bold', size='medium')\nfig.text(0.3, 0.2, 'bold italic', fontproperties=font, **alignment)\nfont = FontProperties(style='italic', weight='bold', size='x-large')\nfig.text(0.3, 0.3, 'bold italic', fontproperties=font, **alignment)\n\nplt.show()\n",
    "id": 112
},
{
    "title": "Fonts demo (keyword arguments)",
    "text": "Set font properties using keyword arguments. See Fonts demo (object-oriented style) to achieve the same effect using setters.",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\nalignment = {'horizontalalignment': 'center verticalalignment': 'baseline'}\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\n\n# Show family options\nfig.text(0.1, 0.9, 'family', size='large', **alignment)\nfamilies = ['serif sans-serif cursive fantasy monospace']\nfor k, family in enumerate(families):\n    fig.text(0.1, yp[k], family, family=family, **alignment)\n\n# Show style options\nfig.text(0.3, 0.9, 'style', **alignment)\nstyles = ['normal italic oblique']\nfor k, style in enumerate(styles):\n    fig.text(0.3, yp[k], style, family='sans-serif', style=style, **alignment)\n\n# Show variant options\nfig.text(0.5, 0.9, 'variant', **alignment)\nvariants = ['normal small-caps']\nfor k, variant in enumerate(variants):\n    fig.text(0.5, yp[k], variant, family='serif', variant=variant, **alignment)\n\n# Show weight options\nfig.text(0.7, 0.9, 'weight', **alignment)\nweights = ['light normal medium semibold bold heavy black']\nfor k, weight in enumerate(weights):\n    fig.text(0.7, yp[k], weight, weight=weight, **alignment)\n\n# Show size options\nfig.text(0.9, 0.9, 'size', **alignment)\nsizes = [\n    'xx-small x-small small medium large x-large xx-large']\nfor k, size in enumerate(sizes):\n    fig.text(0.9, yp[k], size, size=size, **alignment)\n\n# Show bold italic\nfig.text(0.3, 0.1, 'bold italic',\n         style='italic', weight='bold', size='x-small', **alignment)\nfig.text(0.3, 0.2, 'bold italic',\n         style='italic', weight='bold', size='medium', **alignment)\nfig.text(0.3, 0.3, 'bold italic',\n         style='italic', weight='bold', size='x-large', **alignment)\n\nplt.show()\n",
    "id": 113
},
{
    "title": "Legend using pre-defined labels",
    "text": "Defining legend labels with plots. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.axes.Axes.legend / matplotlib.pyplot.legend",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Make some fake data.\na = b = np.arange(0, 3, .02)\nc = np.exp(a)\nd = c[::-1]\n\n# Create plots with pre-defined labels.\nfig, ax = plt.subplots()\nax.plot(a, c, 'k--', label='Model length')\nax.plot(a, d, 'k:', label='Data length')\nax.plot(a, c + d, 'k', label='Total message length')\n\nlegend = ax.legend(loc='upper center', shadow=True, fontsize='x-large')\n\n# Put a nicer background color on the legend.\nlegend.get_frame().set_facecolor('C0')\n\nplt.show()\n",
    "id": 114
},
{
    "title": "Artist within an artist",
    "text": "Override basic methods so an artist can contain another\nartist. In this case, the line contains a Text instance to label it. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.lines matplotlib.lines.Line2D matplotlib.lines.Line2D.set_data matplotlib.artist matplotlib.artist.Artist matplotlib.artist.Artist.draw matplotlib.artist.Artist.set_transform matplotlib.text matplotlib.text.Text matplotlib.text.Text.set_color matplotlib.text.Text.set_fontsize matplotlib.text.Text.set_position matplotlib.axes.Axes.add_line matplotlib.transforms matplotlib.transforms.Affine2D",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.lines as lines\nimport matplotlib.text as mtext\nimport matplotlib.transforms as mtransforms\n\n\nclass MyLine(lines.Line2D):\n    def __init__(self, *args, **kwargs):\n        # we'll update the position when the line data is set\n        self.text = mtext.Text(0, 0, '')\n        super().__init__(*args, **kwargs)\n\n        # we can't access the label attr until *after* the line is\n        # initiated\n        self.text.set_text(self.get_label())\n\n    def set_figure(self, figure):\n        self.text.set_figure(figure)\n        super().set_figure(figure)\n\n    # Override the axes property setter to set Axes on our children as well.\n    @lines.Line2D.axes.setter\n    def axes(self, new_axes):\n        self.text.axes = new_axes\n        lines.Line2D.axes.fset(self, new_axes)  # Call the superclass property setter.\n\n    def set_transform(self, transform):\n        # 2 pixel offset\n        texttrans = transform + mtransforms.Affine2D().translate(2, 2)\n        self.text.set_transform(texttrans)\n        super().set_transform(transform)\n\n    def set_data(self, x, y):\n        if len(x):\n            self.text.set_position((x[-1], y[-1]))\n\n        super().set_data(x, y)\n\n    def draw(self, renderer):\n        # draw my label at the end of the line with 2 pixel offset\n        super().draw(renderer)\n        self.text.draw(renderer)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nx, y = np.random.rand(2, 20)\nline = MyLine(x, y, mfc='red', ms=12, label='line label')\nline.text.set_color('red')\nline.text.set_fontsize(16)\n\nax.add_line(line)\n\nplt.show()\n",
    "id": 115
},
{
    "title": "Convert texts to images",
    "text": "References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.figimage matplotlib.figure.Figure.text matplotlib.transforms.IdentityTransform matplotlib.image.imread",
    "code": "from io import BytesIO\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.transforms import IdentityTransform\n\n\ndef text_to_rgba(s, *, dpi, **kwargs):\n    # To convert a text string to an image, we can:\n    # - draw it on an empty and transparent figure;\n    # - save the figure to a temporary buffer using ``bbox_inches='tight',\n    #   pad_inches=0`` which will pick the correct area to save;\n    # - load the buffer using ``plt.imread``.\n    #\n    # (If desired, one can also directly save the image to the filesystem.)\n    fig = Figure(facecolor='none')\n    fig.text(0, 0, s, **kwargs)\n    with BytesIO() as buf:\n        fig.savefig(buf, dpi=dpi, format='png', bbox_inches='tight',\n                    pad_inches=0)\n        buf.seek(0)\n        rgba = plt.imread(buf)\n    return rgba\n\n\nfig = plt.figure()\nrgba1 = text_to_rgba(r'IQ: $\\\\sigma_i=15$', color='blue', fontsize=20, dpi=200)\nrgba2 = text_to_rgba(r'some other string', color='red', fontsize=20, dpi=200)\n# One can then draw such text images to a Figure using `.Figure.figimage`.\nfig.figimage(rgba1, 100, 50)\nfig.figimage(rgba2, 100, 150)\n\n# One can also directly draw texts to a figure with positioning\n# in pixel coordinates by using `.Figure.text` together with\n# `.transforms.IdentityTransform`.\nfig.text(100, 250, r'IQ: $\\\\sigma_i=15$', color='blue', fontsize=20,\n         transform=IdentityTransform())\nfig.text(100, 350, r'some other string', color='red', fontsize=20,\n         transform=IdentityTransform())\n\nplt.show()\n",
    "id": 116
},
{
    "title": "Mathtext",
    "text": "Use Matplotlib's internal LaTeX parser and layout engine. For true LaTeX\nrendering, see the text.usetex option.",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.plot([1, 2, 3], label=r'$\\\\sqrt{x^2}$')\nax.legend()\n\nax.set_xlabel(r'$\\\\Delta_i^j$', fontsize=20)\nax.set_ylabel(r'$\\\\Delta_{i+1}^j$', fontsize=20)\nax.set_title(r'$\\\\Delta_i^j \\\\hspace{0.4} \\\\mathrm{versus} \\\\hspace{0.4} '\n             r'\\\\Delta_{i+1}^j$', fontsize=20)\n\ntex = r'$\\\\mathcal{R}\\\\prod_{i=\\\\alpha_{i+1}}^\\\\infty a_i\\\\sin(2 \\\\pi f x_i)$'\nax.text(1, 1.6, tex, fontsize=20, va='bottom')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 117
},
{
    "title": "Math fontfamily",
    "text": "A simple example showcasing the new math_fontfamily parameter that can\nbe used to change the family of fonts for each individual text\nelement in a plot. If no parameter is set, the global value\nrcParamsmathtext.fontset (default: \\'dejavusans\\') will be used.",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# A simple plot for the background.\nax.plot(range(11), color='0.9')\n\n# A text mixing normal text and math text.\nmsg = (r'Normal Text. $Text\\\\ in\\\\ math\\\\ mode:\\\\ '\n       r'\\\\int_{0}^{\\\\infty } x^2 dx$')\n\n# Set the text in the plot.\nax.text(1, 7, msg, size=12, math_fontfamily='cm')\n\n# Set another font for the next text.\nax.text(1, 3, msg, size=12, math_fontfamily='dejavuserif')\n\n# *math_fontfamily* can be used in most places where there is text,\n# like in the title:\nax.set_title(r'$Title\\\\ in\\\\ math\\\\ mode:\\\\ \\\\int_{0}^{\\\\infty } x^2 dx$',\n             math_fontfamily='stixsans', size=14)\n\n# Note that the normal text is not changed by *math_fontfamily*.\nplt.show()\n",
    "id": 118
},
{
    "title": "Multiline",
    "text": "Download Python source code: multiline.py Download Jupyter notebook: multiline.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(7, 4))\n\nax0.set_aspect(1)\nax0.plot(np.arange(10))\nax0.set_xlabel('this is a xlabel\\\n(with newlines!)')\nax0.set_ylabel('this is vertical\\\ntest', multialignment='center')\nax0.text(2, 7, 'this is\\\nyet another test',\n         rotation=45,\n         horizontalalignment='center',\n         verticalalignment='top',\n         multialignment='center')\n\nax0.grid()\n\n\nax1.text(0.29, 0.4, 'Mat\\\nTTp\\\n123', size=18,\n         va='baseline', ha='right', multialignment='left',\n         bbox=dict(fc='none'))\n\nax1.text(0.34, 0.4, 'Mag\\\nTTT\\\n123', size=18,\n         va='baseline', ha='left', multialignment='left',\n         bbox=dict(fc='none'))\n\nax1.text(0.95, 0.4, 'Mag\\\nTTT$^{A^A}$\\\n123', size=18,\n         va='baseline', ha='right', multialignment='left',\n         bbox=dict(fc='none'))\n\nax1.set_xticks([0.2, 0.4, 0.6, 0.8, 1.],\n               labels=['Jan\\\n2009', 'Feb\\\n2009', 'Mar\\\n2009', 'Apr\\\n2009',\n                       'May\\\n2009'])\n\nax1.axhline(0.4)\nax1.set_title('test line spacing for multiline text')\n\nfig.subplots_adjust(bottom=0.25, top=0.75)\nplt.show()\n",
    "id": 119
},
{
    "title": "Placing text boxes",
    "text": "When decorating axes with text boxes, two useful tricks are to place the text\nin axes coordinates (see Transformations Tutorial),\nso the text doesn't move around with changes in x or y limits. You\ncan also use the bbox property of text to surround the text with a\nPatch instance -- the bbox keyword argument takes a\ndictionary with keys that are Patch properties.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nx = 30*np.random.randn(10000)\nmu = x.mean()\nmedian = np.median(x)\nsigma = x.std()\ntextstr = '\\\n'.join((\n    r'$\\\\mu=%.2f$' % (mu, ),\n    r'$\\\\mathrm{median}=%.2f$' % (median, ),\n    r'$\\\\sigma=%.2f$' % (sigma, )))\n\nax.hist(x, 50)\n# these are matplotlib.patch.Patch properties\nprops = dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n\n# place a text box in upper left in axes coords\nax.text(0.05, 0.95, textstr, transform=ax.transAxes, fontsize=14,\n        verticalalignment='top', bbox=props)\n\nplt.show()\n",
    "id": 120
},
{
    "title": "Concatenating text objects with different properties",
    "text": "The example strings together several Text objects with different properties\n(e.g., color or font), positioning each one after the other. The first Text\nis created directly using text; all subsequent ones are created with\nannotate, which allows positioning the Text's lower left corner at the\nlower right corner (xy=(1, 0)) of the previous one (xycoords=text).",
    "code": "import matplotlib.pyplot as plt\n\nplt.rcParams['font.size'] = 20\nax = plt.figure().add_subplot(xticks=[], yticks=[])\n\n# The first word, created with text().\ntext = ax.text(.1, .5, 'Matplotlib', color='red')\n# Subsequent words, positioned with annotate(), relative to the preceding one.\ntext = ax.annotate(\n    ' says,', xycoords=text, xy=(1, 0), verticalalignment='bottom',\n    color='gold', weight='bold')  # custom properties\ntext = ax.annotate(\n    ' hello', xycoords=text, xy=(1, 0), verticalalignment='bottom',\n    color='green', style='italic')  # custom properties\ntext = ax.annotate(\n    ' world!', xycoords=text, xy=(1, 0), verticalalignment='bottom',\n    color='blue', family='serif')  # custom properties\n\nplt.show()\n",
    "id": 121
},
{
    "title": "STIX Fonts",
    "text": "Demonstration of STIX Fonts used in LaTeX\nrendering.",
    "code": "import matplotlib.pyplot as plt\n\ncircle123 = '\\\\N{CIRCLED DIGIT ONE}\\\\N{CIRCLED DIGIT TWO}\\\\N{CIRCLED DIGIT THREE}'\n\ntests = [\n    r'$%s\\\\;\\\\mathrm{%s}\\\\;\\\\mathbf{%s}$' % ((circle123,) * 3),\n    r'$\\\\mathsf{Sans \\\\Omega}\\\\;\\\\mathrm{\\\\mathsf{Sans \\\\Omega}}\\\\;'\n    r'\\\\mathbf{\\\\mathsf{Sans \\\\Omega}}$',\n    r'$\\\\mathtt{Monospace}$',\n    r'$\\\\mathcal{CALLIGRAPHIC}$',\n    r'$\\\\mathbb{Blackboard\\\\;\\\\pi}$',\n    r'$\\\\mathrm{\\\\mathbb{Blackboard\\\\;\\\\pi}}$',\n    r'$\\\\mathbf{\\\\mathbb{Blackboard\\\\;\\\\pi}}$',\n    r'$\\\\mathfrak{Fraktur}\\\\;\\\\mathbf{\\\\mathfrak{Fraktur}}$',\n    r'$\\\\mathscr{Script}$',\n]\n\nfig = plt.figure(figsize=(8, len(tests) + 2))\nfor i, s in enumerate(tests[::-1]):\n    fig.text(0, (i + .5) / len(tests), s, fontsize=32)\n\nplt.show()\n",
    "id": 122
},
{
    "title": "Text alignment",
    "text": "Texts are aligned relative to their anchor point depending on the properties\nhorizontalalignment and verticalalignment. (Source code, 2x.png, png) The following plot uses this to align text relative to a plotted rectangle.",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\n# Build a rectangle in axes coords\nleft, width = .25, .5\nbottom, height = .25, .5\nright = left + width\ntop = bottom + height\np = plt.Rectangle((left, bottom), width, height, fill=False)\np.set_transform(ax.transAxes)\np.set_clip_on(False)\nax.add_patch(p)\n\nax.text(left, bottom, 'left top',\n        horizontalalignment='left',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, bottom, 'left bottom',\n        horizontalalignment='left',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right bottom',\n        horizontalalignment='right',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right top',\n        horizontalalignment='right',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(right, bottom, 'center top',\n        horizontalalignment='center',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'right center',\n        horizontalalignment='right',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'left center',\n        horizontalalignment='left',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(0.5 * (left + right), 0.5 * (bottom + top), 'middle',\n        horizontalalignment='center',\n        verticalalignment='center',\n        transform=ax.transAxes)\n\nax.text(right, 0.5 * (bottom + top), 'centered',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, top, 'rotated\\\nwith newlines',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation=45,\n        transform=ax.transAxes)\n\nax.set_axis_off()\n\nplt.show()\n",
    "id": 123
},
{
    "title": "Text Commands",
    "text": "Plotting text of many different kinds. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.suptitle matplotlib.figure.Figure.add_subplot matplotlib.figure.Figure.subplots_adjust matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_xlabel matplotlib.axes.Axes.set_ylabel matplotlib.axes.Axes.text matplotlib.axes.Axes.annotate",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\nfig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')\n\nax = fig.add_subplot()\nfig.subplots_adjust(top=0.85)\nax.set_title('axes title')\n\nax.set_xlabel('xlabel')\nax.set_ylabel('ylabel')\n\nax.text(3, 8, 'boxed italics text in data coords', style='italic',\n        bbox={'facecolor': 'red alpha': 0.5, 'pad': 10})\n\nax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)\n\nax.text(3, 2, 'Unicode: Institut f\\\\374r Festk\\\\366rperphysik')\n\nax.text(0.95, 0.01, 'colored text in axes coords',\n        verticalalignment='bottom', horizontalalignment='right',\n        transform=ax.transAxes,\n        color='green', fontsize=15)\n\n\nax.plot([2], [1], 'o')\nax.annotate('annotate', xy=(2, 1), xytext=(3, 4),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nax.set(xlim=(0, 10), ylim=(0, 10))\n\nplt.show()\n",
    "id": 124
},
{
    "title": "Controlling style of text and labels using a dictionary",
    "text": "This example shows how to share parameters across many text objects and labels\nby creating a dictionary of options passed across several functions.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfont = {'family': 'serif',\n        'color':  'darkred',\n        'weight': 'normal',\n        'size': 16,\n        }\n\nx = np.linspace(0.0, 5.0, 100)\ny = np.cos(2*np.pi*x) * np.exp(-x)\n\nplt.plot(x, y, 'k')\nplt.title('Damped exponential decay', fontdict=font)\nplt.text(2, 0.65, r'$\\\\cos(2 \\\\pi t) \\\\exp(-t)$', fontdict=font)\nplt.xlabel('time (s)', fontdict=font)\nplt.ylabel('voltage (mV)', fontdict=font)\n\n# Tweak spacing to prevent clipping of ylabel\nplt.subplots_adjust(left=0.15)\nplt.show()\n",
    "id": 125
},
{
    "title": "Text Rotation Relative To Line",
    "text": "Text objects in matplotlib are normally rotated with respect to the\nscreen coordinate system (i.e., 45 degrees rotation plots text along a\nline that is in between horizontal and vertical no matter how the axes\nare changed). However, at times one wants to rotate text with respect\nto something on the plot. In this case, the correct angle won't be\nthe angle of that object in the plot coordinate system, but the angle\nthat that object APPEARS in the screen coordinate system. This angle\ncan be determined automatically by setting the parameter\ntransform_rotates_text, as shown in the example below.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\n# Plot diagonal line (45 degrees)\nh = ax.plot(range(0, 10), range(0, 10))\n\n# set limits so that it no longer looks on screen to be 45 degrees\nax.set_xlim([-10, 20])\n\n# Locations to plot text\nl1 = np.array((1, 1))\nl2 = np.array((5, 5))\n\n# Rotate angle\nangle = 45\n\n# Plot text\nth1 = ax.text(*l1, 'text not rotated correctly', fontsize=16,\n              rotation=angle, rotation_mode='anchor')\nth2 = ax.text(*l2, 'text rotated correctly', fontsize=16,\n              rotation=angle, rotation_mode='anchor',\n              transform_rotates_text=True)\n\nplt.show()\n",
    "id": 126
},
{
    "title": "Unicode minus",
    "text": "By default, tick labels at negative values are rendered using a Unicode\nminus (U+2212) rather than an ASCII hyphen (U+002D). This can be controlled\nby setting rcParamsaxes.unicode_minus (default: True). The replacement is performed at draw time of the tick labels (usually during a\npyplot.show() or pyplot.savefig() call). Therefore, all tick labels of\nthe figure follow the same setting and we cannot demonstrate both glyphs on\nreal tick labels of the same figure simultaneously. Instead, this example simply showcases the difference between the two glyphs\nin a magnified font.",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(4, 2))\nfig.text(.15, .6, 'Unicode minus:', fontsize=20)\nfig.text(.85, .6, '\\\\N{MINUS SIGN}1', ha='right', fontsize=20)\nfig.text(.15, .3, 'ASCII hyphen:', fontsize=20)\nfig.text(.85, .3, '-1', ha='right', fontsize=20)\nplt.show()\n",
    "id": 127
},
{
    "title": "Usetex Baseline Test",
    "text": "Comparison of text baselines computed for mathtext and usetex.",
    "code": "import matplotlib.pyplot as plt\n\nplt.rcParams.update({'mathtext.fontset': 'cm', 'mathtext.rm': 'serif'})\naxs = plt.figure(figsize=(2 * 3, 6.5)).subplots(1, 2)\nfor ax, usetex in zip(axs, [False, True]):\n    ax.axvline(0, color='r')\n    test_strings = ['lg', r'$\\\\frac{1}{2}\\\\pi$', r'$p^{3^A}$', r'$p_{3_2}$']\n    for i, s in enumerate(test_strings):\n        ax.axhline(i, color='r')\n        ax.text(0., 3 - i, s,\n                usetex=usetex,\n                verticalalignment='baseline',\n                size=50,\n                bbox=dict(pad=0, ec='k', fc='none'))\n    ax.set(xlim=(-0.1, 1.1), ylim=(-.8, 3.9), xticks=[], yticks=[],\n           title=f'usetex={usetex}\\\n')\nplt.show()\n",
    "id": 128
},
{
    "title": "Usetex Fonteffects",
    "text": "This script demonstrates that font effects specified in your pdftex.map\nare now supported in usetex mode.",
    "code": "import matplotlib.pyplot as plt\n\n\ndef setfont(font):\n    return rf'\\\\font\\\\a {font} at 14pt\\\\a '\n\n\nfig = plt.figure()\nfor y, font, text in zip(\n    range(5),\n    ['ptmr8r ptmri8r ptmro8r ptmr8rn ptmrr8re'],\n    [f'Nimbus Roman No9 L {x}'\n     for x in [' Italics (real italics for comparison)',\n               '(slanted) (condensed) (extended)']],\n):\n    fig.text(.1, 1 - (y + 1) / 6, setfont(font) + text, usetex=True)\n\nfig.suptitle('Usetex font effects')\n# Would also work if saving to pdf.\nplt.show()\n",
    "id": 129
},
{
    "title": "Text watermark",
    "text": "A watermark effect can be achieved by drawing a semi-transparent text. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.text",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nax.plot(np.random.rand(20), '-o', ms=20, lw=2, alpha=0.7, mfc='orange')\nax.grid()\n\nax.text(0.5, 0.5, 'created with matplotlib', transform=ax.transAxes,\n        fontsize=40, color='gray', alpha=0.5,\n        ha='center', va='center', rotation=30)\n\nplt.show()\n",
    "id": 130
},
{
    "title": "Color Demo",
    "text": "Matplotlib recognizes the following formats to specify a color: an RGB or RGBA tuple of float values in [0, 1] (e.g. (0.1, 0.2, 0.5)\nor (0.1, 0.2, 0.5, 0.3)). RGBA is short for Red, Green, Blue, Alpha;', \"a hex RGB or RGBA string (e.g., '#0F0F0F' or '#0F0F0F0F');\", \"a shorthand hex RGB or RGBA string, equivalent to the hex RGB or RGBA\nstring obtained by duplicating each character, (e.g., '#abc', equivalent\nto '#aabbcc', or '#abcd', equivalent to '#aabbccdd');\", \"a string representation of a float value in [0, 1] inclusive for gray\nlevel (e.g., '0.5');\", \"a single letter string, i.e. one of\n{'b g r c m y k w'}, which are short-hand notations\nfor shades of blue, green, red, cyan, magenta, yellow, black, and white;\", 'a X11/CSS4 (\"html\") color name, e.g. \"blue\";', \"a name from the xkcd color survey,\nprefixed with 'xkcd:' (e.g., 'xkcd:sky blue');\", 'a \"Cn\" color spec, i.e. \\'C\\' followed by a number, which is an index into\nthe default property cycle (rcParamsaxes.prop_cycle (default: cycler(\\'color\\', [\\'#1f77b4\\', \\'#ff7f0e\\', \\'#2ca02c\\', \\'#d62728\\', \\'#9467bd\\', \\'#8c564b\\', \\'#e377c2\\', \\'#7f7f7f\\', \\'#bcbd22\\', \\'#17becf\\']))); the indexing is intended\nto occur at rendering time, and defaults to black if the cycle does not\ninclude color.', \"one of {'tab:blue tab:orange tab:green tab:red tab:purple',\n'tab:brown tab:pink tab:gray tab:olive tab:cyan'} which are\nthe Tableau Colors from the 'tab10' categorical palette (which is the\ndefault color cycle);\", 'For more information on colors in matplotlib see the Specifying colors tutorial; the matplotlib.colors API; the List of named colors example. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors matplotlib.axes.Axes.plot matplotlib.axes.Axes.set_facecolor matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_xlabel matplotlib.axes.Axes.set_ylabel matplotlib.axes.Axes.tick_params",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0.0, 2.0, 201)\ns = np.sin(2 * np.pi * t)\n\n# 1) RGB tuple:\nfig, ax = plt.subplots(facecolor=(.18, .31, .31))\n# 2) hex string:\nax.set_facecolor('#eafff5')\n# 3) gray level string:\nax.set_title('Voltage vs. time chart', color='0.7')\n# 4) single letter color string\nax.set_xlabel('Time [s]', color='c')\n# 5) a named color:\nax.set_ylabel('Voltage [mV]', color='peachpuff')\n# 6) a named xkcd color:\nax.plot(t, s, 'xkcd:crimson')\n# 7) Cn notation:\nax.plot(t, .7*s, color='C4', linestyle='--')\n# 8) tab notation:\nax.tick_params(labelcolor='tab:orange')\n\n\nplt.show()\n",
    "id": 131
},
{
    "title": "Color by y-value",
    "text": "Use masked arrays to plot a line with different colors by y-value. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nupper = 0.77\nlower = -0.77\n\nsupper = np.ma.masked_where(s < upper, s)\nslower = np.ma.masked_where(s > lower, s)\nsmiddle = np.ma.masked_where((s < lower) | (s > upper), s)\n\nfig, ax = plt.subplots()\nax.plot(t, smiddle, t, slower, t, supper)\nplt.show()\n",
    "id": 132
},
{
    "title": "Colors in the default property cycle",
    "text": "Display the colors from the default prop_cycle, which is obtained from the\nrc parameters. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.axhline / matplotlib.pyplot.axhline matplotlib.axes.Axes.axvline / matplotlib.pyplot.axvline matplotlib.axes.Axes.set_facecolor matplotlib.figure.Figure.suptitle",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nprop_cycle = plt.rcParams['axes.prop_cycle']\ncolors = prop_cycle.by_key()['color']\n\nlwbase = plt.rcParams['lines.linewidth']\nthin = lwbase / 2\nthick = lwbase * 3\n\nfig, axs = plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True)\nfor icol in range(2):\n    if icol == 0:\n        lwx, lwy = thin, lwbase\n    else:\n        lwx, lwy = lwbase, thick\n    for irow in range(2):\n        for i, color in enumerate(colors):\n            axs[irow, icol].axhline(i, color=color, lw=lwx)\n            axs[irow, icol].axvline(i, color=color, lw=lwy)\n\n    axs[1, icol].set_facecolor('k')\n    axs[1, icol].xaxis.set_ticks(np.arange(0, 10, 2))\n    axs[0, icol].set_title(f'line widths (pts): {lwx:g}, {lwy:g}',\n                           fontsize='medium')\n\nfor irow in range(2):\n    axs[irow, 0].yaxis.set_ticks(np.arange(0, 10, 2))\n\nfig.suptitle('Colors in the default prop_cycle', fontsize='large')\n\nplt.show()\n",
    "id": 133
},
{
    "title": "Colorbar",
    "text": "Use colorbar by specifying the mappable object (here\nthe AxesImage returned by imshow)\nand the axes to attach the colorbar to. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colorbar.Colorbar.minorticks_on matplotlib.colorbar.Colorbar.minorticks_off",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# setup some generic data\nN = 37\nx, y = np.mgrid[:N, :N]\nZ = (np.cos(x*0.2) + np.sin(y*0.3))\n\n# mask out the negative and positive values, respectively\nZpos = np.ma.masked_less(Z, 0)\nZneg = np.ma.masked_greater(Z, 0)\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(13, 3), ncols=3)\n\n# plot just the positive data and save the\n# color 'mappable' object returned by ax1.imshow\npos = ax1.imshow(Zpos, cmap='Blues', interpolation='none')\n\n# add the colorbar using the figure's method,\n# telling which mappable we're talking about and\n# which axes object it should be near\nfig.colorbar(pos, ax=ax1)\n\n# repeat everything above for the negative data\n# you can specify location, anchor and shrink the colorbar\nneg = ax2.imshow(Zneg, cmap='Reds_r', interpolation='none')\nfig.colorbar(neg, ax=ax2, location='right', anchor=(0, 0.3), shrink=0.7)\n\n# Plot both positive and negative values between +/- 1.2\npos_neg_clipped = ax3.imshow(Z, cmap='RdBu', vmin=-1.2, vmax=1.2,\n                             interpolation='none')\n# Add minorticks on the colorbar to make it easy to read the\n# values off the colorbar.\ncbar = fig.colorbar(pos_neg_clipped, ax=ax3, extend='both')\ncbar.minorticks_on()\nplt.show()\n",
    "id": 134
},
{
    "title": "Ways to set a color's alpha value",
    "text": "Compare setting alpha by the alpha keyword argument and by one of the Matplotlib color\nformats. Often, the alpha keyword is the only tool needed to add transparency to a\ncolor. In some cases, the (matplotlib_color, alpha) color format provides an easy way\nto fine-tune the appearance of a Figure. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar matplotlib.pyplot.subplots",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4))\n\nx_values = [n for n in range(20)]\ny_values = np.random.randn(20)\n\nfacecolors = ['green' if y > 0 else 'red' for y in y_values]\nedgecolors = facecolors\n\nax1.bar(x_values, y_values, color=facecolors, edgecolor=edgecolors, alpha=0.5)\nax1.set_title('Explicit 'alpha' keyword value\\\nshared by all bars and edges')\n\n\n# Normalize y values to get distinct face alpha values.\nabs_y = [abs(y) for y in y_values]\nface_alphas = [n / max(abs_y) for n in abs_y]\nedge_alphas = [1 - alpha for alpha in face_alphas]\n\ncolors_with_alphas = list(zip(facecolors, face_alphas))\nedgecolors_with_alphas = list(zip(edgecolors, edge_alphas))\n\nax2.bar(x_values, y_values, color=colors_with_alphas,\n        edgecolor=edgecolors_with_alphas)\nax2.set_title('Normalized alphas for\\\neach bar and each edge')\n\nplt.show()\n",
    "id": 135
},
{
    "title": "Reference for Matplotlib artists",
    "text": "This example displays several of Matplotlib's graphics primitives (artists).\nA full list of artists is documented at the artist API.\", 'See also Circles, Wedges and Polygons, which groups\nall artists into a single PatchCollection instead. Copyright (c) 2010, Bartosz Telenczuk\nBSD License References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.lines matplotlib.lines.Line2D matplotlib.patches matplotlib.patches.Circle matplotlib.patches.Ellipse matplotlib.patches.Wedge matplotlib.patches.Rectangle matplotlib.patches.Arrow matplotlib.patches.PathPatch matplotlib.patches.FancyBboxPatch matplotlib.patches.RegularPolygon matplotlib.axes.Axes.add_artist",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib as mpl\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n# Prepare the data for the PathPatch below.\nPath = mpath.Path\ncodes, verts = zip(*[\n    (Path.MOVETO, [0.018, -0.11]),\n    (Path.CURVE4, [-0.031, -0.051]),\n    (Path.CURVE4, [-0.115, 0.073]),\n    (Path.CURVE4, [-0.03, 0.073]),\n    (Path.LINETO, [-0.011, 0.039]),\n    (Path.CURVE4, [0.043, 0.121]),\n    (Path.CURVE4, [0.075, -0.005]),\n    (Path.CURVE4, [0.035, -0.027]),\n    (Path.CLOSEPOLY, [0.018, -0.11])])\n\nartists = [\n    mpatches.Circle((0, 0), 0.1, ec='none'),\n    mpatches.Rectangle((-0.025, -0.05), 0.05, 0.1, ec='none'),\n    mpatches.Wedge((0, 0), 0.1, 30, 270, ec='none'),\n    mpatches.RegularPolygon((0, 0), 5, radius=0.1),\n    mpatches.Ellipse((0, 0), 0.2, 0.1),\n    mpatches.Arrow(-0.05, -0.05, 0.1, 0.1, width=0.1),\n    mpatches.PathPatch(mpath.Path(verts, codes), ec='none'),\n    mpatches.FancyBboxPatch((-0.025, -0.05), 0.05, 0.1, ec='none',\n                            boxstyle=mpatches.BoxStyle('Round', pad=0.02)),\n    mlines.Line2D([-0.06, 0.0, 0.1], [0.05, -0.05, 0.05], lw=5),\n]\n\naxs = plt.figure(figsize=(6, 6), layout='constrained').subplots(3, 3)\nfor i, (ax, artist) in enumerate(zip(axs.flat, artists)):\n    artist.set(color=mpl.colormaps['hsv'](i / len(artists)))\n    ax.add_artist(artist)\n    ax.set(title=type(artist).__name__,\n           aspect=1, xlim=(-.2, .2), ylim=(-.2, .2))\n    ax.set_axis_off()\nplt.show()\n",
    "id": 136
},
{
    "title": "Line, Poly and RegularPoly Collection with autoscaling",
    "text": "For the first two subplots, we will use spirals. Their size will be set in\nplot units, not data units. Their positions will be set in data units by using\nthe offsets and offset_transform keyword arguments of the LineCollection\nand PolyCollection. The third subplot will make regular polygons, with the same\ntype of scaling and positioning as in the first two. The last subplot illustrates the use of offsets=(xo, yo),\nthat is, a single tuple instead of a list of tuples, to generate\nsuccessively offset curves, with the offset given in data\nunits. This behavior is available only for the LineCollection. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure matplotlib.collections matplotlib.collections.LineCollection matplotlib.collections.RegularPolyCollection matplotlib.axes.Axes.add_collection matplotlib.axes.Axes.autoscale_view matplotlib.transforms.Affine2D matplotlib.transforms.Affine2D.scale",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import collections, transforms\n\nnverts = 50\nnpts = 100\n\n# Make some spirals\nr = np.arange(nverts)\ntheta = np.linspace(0, 2*np.pi, nverts)\nxx = r * np.sin(theta)\nyy = r * np.cos(theta)\nspiral = np.column_stack([xx, yy])\n\n# Fixing random state for reproducibility\nrs = np.random.RandomState(19680801)\n\n# Make some offsets\nxyo = rs.randn(npts, 2)\n\n# Make a list of colors cycling through the default series.\ncolors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.subplots_adjust(top=0.92, left=0.07, right=0.97,\n                    hspace=0.3, wspace=0.3)\n\n\ncol = collections.LineCollection(\n    [spiral], offsets=xyo, offset_transform=ax1.transData)\ntrans = fig.dpi_scale_trans + transforms.Affine2D().scale(1.0/72.0)\ncol.set_transform(trans)  # the points to pixels transform\n# Note: the first argument to the collection initializer\n# must be a list of sequences of (x, y) tuples; we have only\n# one sequence, but we still have to put it in a list.\nax1.add_collection(col, autolim=True)\n# autolim=True enables autoscaling.  For collections with\n# offsets like this, it is neither efficient nor accurate,\n# but it is good enough to generate a plot that you can use\n# as a starting point.  If you know beforehand the range of\n# x and y that you want to show, it is better to set them\n# explicitly, leave out the *autolim* keyword argument (or set it to False),\n# and omit the 'ax1.autoscale_view()' call below.\n\n# Make a transform for the line segments such that their size is\n# given in points:\ncol.set_color(colors)\n\nax1.autoscale_view()  # See comment above, after ax1.add_collection.\nax1.set_title('LineCollection using offsets')\n\n\n# The same data as above, but fill the curves.\ncol = collections.PolyCollection(\n    [spiral], offsets=xyo, offset_transform=ax2.transData)\ntrans = transforms.Affine2D().scale(fig.dpi/72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax2.add_collection(col, autolim=True)\ncol.set_color(colors)\n\n\nax2.autoscale_view()\nax2.set_title('PolyCollection using offsets')\n\n# 7-sided regular polygons\n\ncol = collections.RegularPolyCollection(\n    7, sizes=np.abs(xx) * 10.0, offsets=xyo, offset_transform=ax3.transData)\ntrans = transforms.Affine2D().scale(fig.dpi / 72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax3.add_collection(col, autolim=True)\ncol.set_color(colors)\nax3.autoscale_view()\nax3.set_title('RegularPolyCollection using offsets')\n\n\n# Simulate a series of ocean current profiles, successively\n# offset by 0.1 m/s so that they form what is sometimes called\n# a 'waterfall' plot or a 'stagger' plot.\n\nnverts = 60\nncurves = 20\noffs = (0.1, 0.0)\n\nyy = np.linspace(0, 2*np.pi, nverts)\nym = np.max(yy)\nxx = (0.2 + (ym - yy) / ym) ** 2 * np.cos(yy - 0.4) * 0.5\nsegs = []\nfor i in range(ncurves):\n    xxx = xx + 0.02*rs.randn(nverts)\n    curve = np.column_stack([xxx, yy * 100])\n    segs.append(curve)\n\ncol = collections.LineCollection(segs, offsets=offs)\nax4.add_collection(col, autolim=True)\ncol.set_color(colors)\nax4.autoscale_view()\nax4.set_title('Successive data offsets')\nax4.set_xlabel('Zonal velocity component (m/s)')\nax4.set_ylabel('Depth (m)')\n# Reverse the y-axis so depth increases downward\nax4.set_ylim(ax4.get_ylim()[::-1])\n\n\nplt.show()\n",
    "id": 137
},
{
    "title": "Compound path",
    "text": "Make a compound path -- in this case two simple polygons, a rectangle\nand a triangle. Use CLOSEPOLY and MOVETO for the different parts of\nthe compound path References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.axes.Axes.add_patch matplotlib.axes.Axes.autoscale_view",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nvertices = []\ncodes = []\n\ncodes = [Path.MOVETO] + [Path.LINETO]*3 + [Path.CLOSEPOLY]\nvertices = [(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)]\n\ncodes += [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY]\nvertices += [(4, 4), (5, 5), (5, 4), (0, 0)]\n\npath = Path(vertices, codes)\n\npathpatch = PathPatch(path, facecolor='none', edgecolor='green')\n\nfig, ax = plt.subplots()\nax.add_patch(pathpatch)\nax.set_title('A compound path')\n\nax.autoscale_view()\n\nplt.show()\n",
    "id": 138
},
{
    "title": "Dolphins",
    "text": "This example shows how to draw, and manipulate shapes given vertices\nand nodes using the Path, PathPatch and\ntransforms classes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.patches.Circle matplotlib.axes.Axes.add_patch matplotlib.transforms matplotlib.transforms.Affine2D matplotlib.transforms.Affine2D.rotate_deg",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Affine2D\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nr = np.random.rand(50)\nt = np.random.rand(50) * np.pi * 2.0\nx = r * np.cos(t)\ny = r * np.sin(t)\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncircle = Circle((0, 0), 1, facecolor='none',\n                edgecolor=(0, 0.8, 0.8), linewidth=3, alpha=0.5)\nax.add_patch(circle)\n\nim = plt.imshow(np.random.random((100, 100)),\n                origin='lower', cmap=cm.winter,\n                interpolation='spline36',\n                extent=(-1, 1, -1, 1))\nim.set_clip_path(circle)\n\nplt.plot(x, y, 'o', color=(0.9, 0.9, 1.0), alpha=0.8)\n\n# Dolphin from OpenClipart library by Andy Fitzsimon\n#   <cc:License rdf:about='http://web.resource.org/cc/PublicDomain'>\n#     <cc:permits rdf:resource='http://web.resource.org/cc/Reproduction'/>\n#     <cc:permits rdf:resource='http://web.resource.org/cc/Distribution'/>\n#     <cc:permits rdf:resource='http://web.resource.org/cc/DerivativeWorks'/>\n#   </cc:License>\n\ndolphin = '''\nM -0.59739425,160.18173 C -0.62740401,160.18885 -0.57867129,160.11183\n-0.57867129,160.11183 C -0.57867129,160.11183 -0.5438361,159.89315\n-0.39514638,159.81496 C -0.24645668,159.73678 -0.18316813,159.71981\n-0.18316813,159.71981 C -0.18316813,159.71981 -0.10322971,159.58124\n-0.057804323,159.58725 C -0.029723983,159.58913 -0.061841603,159.60356\n-0.071265813,159.62815 C -0.080250183,159.65325 -0.082918513,159.70554\n-0.061841203,159.71248 C -0.040763903,159.7194 -0.0066711426,159.71091\n0.077336307,159.73612 C 0.16879567,159.76377 0.28380306,159.86448\n0.31516668,159.91533 C 0.3465303,159.96618 0.5011127,160.1771\n0.5011127,160.1771 C 0.63668998,160.19238 0.67763022,160.31259\n0.66556395,160.32668 C 0.65339985,160.34212 0.66350443,160.33642\n0.64907098,160.33088 C 0.63463742,160.32533 0.61309688,160.297\n0.5789627,160.29339 C 0.54348657,160.28968 0.52329693,160.27674\n0.50728856,160.27737 C 0.49060916,160.27795 0.48965803,160.31565\n0.46114204,160.33673 C 0.43329696,160.35786 0.4570711,160.39871\n0.43309565,160.40685 C 0.4105108,160.41442 0.39416631,160.33027\n0.3954995,160.2935 C 0.39683269,160.25672 0.43807996,160.21522\n0.44567915,160.19734 C 0.45327833,160.17946 0.27946869,159.9424\n-0.061852613,159.99845 C -0.083965233,160.0427 -0.26176109,160.06683\n-0.26176109,160.06683 C -0.30127962,160.07028 -0.21167141,160.09731\n-0.24649368,160.1011 C -0.32642366,160.11569 -0.34521187,160.06895\n-0.40622293,160.0819 C -0.467234,160.09485 -0.56738444,160.17461\n-0.59739425,160.18173\n'''\n\nvertices = []\ncodes = []\nparts = dolphin.split()\ni = 0\ncode_map = {\n    'M': Path.MOVETO,\n    'C': Path.CURVE4,\n    'L': Path.LINETO,\n}\n\nwhile i < len(parts):\n    path_code = code_map[parts[i]]\n    npoints = Path.NUM_VERTICES_FOR_CODE[path_code]\n    codes.extend([path_code] * npoints)\n    vertices.extend([[*map(float, y.split(','))]\n                     for y in parts[i + 1:][:npoints]])\n    i += npoints + 1\nvertices = np.array(vertices)\nvertices[:, 1] -= 160\n\ndolphin_path = Path(vertices, codes)\ndolphin_patch = PathPatch(dolphin_path, facecolor=(0.6, 0.6, 0.6),\n                          edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch)\n\nvertices = Affine2D().rotate_deg(60).transform(vertices)\ndolphin_path2 = Path(vertices, codes)\ndolphin_patch2 = PathPatch(dolphin_path2, facecolor=(0.5, 0.5, 0.5),\n                           edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch2)\n\nplt.show()\n",
    "id": 139
},
{
    "title": "Mmh Donuts!!!",
    "text": "Draw donuts (miam!) using Paths and PathPatches.\nThis example shows the effect of the path's orientations in a compound path.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.patches.Circle matplotlib.axes.Axes.add_patch matplotlib.axes.Axes.annotate matplotlib.axes.Axes.set_aspect matplotlib.axes.Axes.set_xlim matplotlib.axes.Axes.set_ylim matplotlib.axes.Axes.set_title",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n\ndef wise(v):\n    if v == 1:\n        return 'CCW'\n    else:\n        return 'CW'\n\n\ndef make_circle(r):\n    t = np.arange(0, np.pi * 2.0, 0.01)\n    t = t.reshape((len(t), 1))\n    x = r * np.cos(t)\n    y = r * np.sin(t)\n    return np.hstack((x, y))\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\n\ninside_vertices = make_circle(0.5)\noutside_vertices = make_circle(1.0)\ncodes = np.ones(\n    len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO\ncodes[0] = mpath.Path.MOVETO\n\nfor i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):\n    # Concatenate the inside and outside subpaths together, changing their\n    # order as needed\n    vertices = np.concatenate((outside_vertices[::outside],\n                               inside_vertices[::inside]))\n    # Shift the path\n    vertices[:, 0] += i * 2.5\n    # The codes will be all 'LINETO' commands, except for 'MOVETO's at the\n    # beginning of each subpath\n    all_codes = np.concatenate((codes, codes))\n    # Create the Path object\n    path = mpath.Path(vertices, all_codes)\n    # Add plot it\n    patch = mpatches.PathPatch(path, facecolor='#885500', edgecolor='black')\n    ax.add_patch(patch)\n\n    ax.annotate(f'Outside {wise(outside)},\\\nInside {wise(inside)}',\n                (i * 2.5, -1.5), va='top', ha='center')\n\nax.set_xlim(-2, 10)\nax.set_ylim(-3, 2)\nax.set_title('Mmm, donuts!')\nax.set_aspect(1.0)\nplt.show()\n",
    "id": 140
},
{
    "title": "Ellipse with orientation arrow demo",
    "text": "This demo shows how to draw an ellipse with\nan orientation arrow (clockwise or counterclockwise).\nCompare this to the Ellipse collection example. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Ellipse",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Ellipse\nfrom matplotlib.transforms import Affine2D\n\n# Create a figure and axis\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\n\nellipse = Ellipse(\n    xy=(2, 4),\n    width=30,\n    height=20,\n    angle=35,\n    facecolor='none',\n    edgecolor='b'\n)\nax.add_patch(ellipse)\n\n# Plot an arrow marker at the end point of minor axis\nvertices = ellipse.get_co_vertices()\nt = Affine2D().rotate_deg(ellipse.angle)\nax.plot(\n    vertices[0][0],\n    vertices[0][1],\n    color='b',\n    marker=MarkerStyle('>', 'full', t),\n    markersize=10\n)\n# Note: To reverse the orientation arrow, switch the marker type from > to <.\n\nplt.show()\n",
    "id": 141
},
{
    "title": "Ellipse Collection",
    "text": "Drawing a collection of ellipses. While this would equally be possible using\na EllipseCollection or PathCollection, the use\nof an EllipseCollection allows for much shorter code. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.collections matplotlib.collections.EllipseCollection matplotlib.axes.Axes.add_collection matplotlib.axes.Axes.autoscale_view matplotlib.cm.ScalarMappable.set_array",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EllipseCollection\n\nx = np.arange(10)\ny = np.arange(15)\nX, Y = np.meshgrid(x, y)\n\nXY = np.column_stack((X.ravel(), Y.ravel()))\n\nww = X / 10.0\nhh = Y / 15.0\naa = X * 9\n\n\nfig, ax = plt.subplots()\n\nec = EllipseCollection(ww, hh, aa, units='x', offsets=XY,\n                       offset_transform=ax.transData)\nec.set_array((X + Y).ravel())\nax.add_collection(ec)\nax.autoscale_view()\nax.set_xlabel('X')\nax.set_ylabel('y')\ncbar = plt.colorbar(ec)\ncbar.set_label('X+Y')\nplt.show()\n",
    "id": 142
},
{
    "title": "Ellipse Demo",
    "text": "Draw many ellipses. Here individual ellipses are drawn. Compare this\nto the Ellipse collection examp",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nNUM = 250\n\nells = [Ellipse(xy=np.random.rand(2) * 10,\n                width=np.random.rand(), height=np.random.rand(),\n                angle=np.random.rand() * 360)\n        for i in range(NUM)]\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 10), aspect='equal')\n\nfor e in ells:\n    ax.add_artist(e)\n    e.set_clip_box(ax.bbox)\n    e.set_alpha(np.random.rand())\n    e.set_facecolor(np.random.rand(3))\n\nplt.show()\n",
    "id": 143
},
{
    "title": "Hatch demo",
    "text": "Hatches can be added to most polygons in Matplotlib, including bar,\nfill_between, contourf, and children of Polygon.\nThey are currently supported in the PS, PDF, SVG, OSX, and Agg backends. The WX\nand Cairo backends do not currently support hatching. See also Contourf Hatching for\nan example using contourf, and\nHatch style reference for swatches\nof the existing hatches. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Ellipse matplotlib.patches.Polygon matplotlib.axes.Axes.add_patch matplotlib.patches.Patch.set_hatch matplotlib.axes.Axes.bar / matplotlib.pyplot.bar",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse, Polygon\n\nx = np.arange(1, 5)\ny1 = np.arange(1, 5)\ny2 = np.ones(y1.shape) * 4\n\nfig = plt.figure()\naxs = fig.subplot_mosaic([['bar1', 'patches'], ['bar2', 'patches']])\n\naxs['bar1'].bar(x, y1, edgecolor='black', hatch='/')\naxs['bar1'].bar(x, y2, bottom=y1, edgecolor='black', hatch='//')\n\naxs['bar2'].bar(x, y1, edgecolor='black', hatch=['--', '+', 'x', '\\\\\\\\'])\naxs['bar2'].bar(x, y2, bottom=y1, edgecolor='black',\n                hatch=['*', 'o', 'O', '.'])\n\nx = np.arange(0, 40, 0.2)\naxs['patches'].fill_between(x, np.sin(x) * 4 + 30, y2=0,\n                            hatch='///', zorder=2, fc='c')\naxs['patches'].add_patch(Ellipse((4, 50), 10, 10, fill=True,\n                                 hatch='*', facecolor='y'))\naxs['patches'].add_patch(Polygon([(10, 20), (30, 50), (50, 10)],\n                                 hatch='\\\\\\\\/...', facecolor='g'))\naxs['patches'].set_xlim([0, 40])\naxs['patches'].set_ylim([10, 60])\naxs['patches'].set_aspect(1)\nplt.show()\n",
    "id": 144
},
{
    "title": "Circles, Wedges and Polygons",
    "text": "This example demonstrates how to use collections.PatchCollection. See also Reference for Matplotlib artists, which instead\nadds each artist separately to its own axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Circle matplotlib.patches.Wedge matplotlib.patches.Polygon matplotlib.collections.PatchCollection matplotlib.collections.Collection.set_array matplotlib.axes.Axes.add_collection matplotlib.figure.Figure.colorbar",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Circle, Polygon, Wedge\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\n\nresolution = 50  # the number of vertices\nN = 3\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\npatches = []\nfor x1, y1, r in zip(x, y, radii):\n    circle = Circle((x1, y1), r)\n    patches.append(circle)\n\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\ntheta1 = 360.0*np.random.rand(N)\ntheta2 = 360.0*np.random.rand(N)\nfor x1, y1, r, t1, t2 in zip(x, y, radii, theta1, theta2):\n    wedge = Wedge((x1, y1), r, t1, t2)\n    patches.append(wedge)\n\n# Some limiting conditions on Wedge\npatches += [\n    Wedge((.3, .7), .1, 0, 360),             # Full circle\n    Wedge((.7, .8), .2, 0, 360, width=0.05),  # Full ring\n    Wedge((.8, .3), .2, 0, 45),              # Full sector\n    Wedge((.8, .3), .2, 45, 90, width=0.10),  # Ring sector\n]\n\nfor i in range(N):\n    polygon = Polygon(np.random.rand(N, 2), closed=True)\n    patches.append(polygon)\n\ncolors = 100 * np.random.rand(len(patches))\np = PatchCollection(patches, alpha=0.4)\np.set_array(colors)\nax.add_collection(p)\nfig.colorbar(p, ax=ax)\n\nplt.show()\n",
    "id": 145
},
{
    "title": "PathPatch object",
    "text": "This example shows how to create Path and PathPatch\nobjects through Matplotlib's API.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.axes.Axes.add_patch",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nfig, ax = plt.subplots()\n\nPath = mpath.Path\npath_data = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n    ]\ncodes, verts = zip(*path_data)\npath = mpath.Path(verts, codes)\npatch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)\nax.add_patch(patch)\n\n# plot control points and connecting lines\nx, y = zip(*path.vertices)\nline, = ax.plot(x, y, 'go-')\n\nax.grid()\nax.axis('equal')\nplt.show()\n",
    "id": 146
},
{
    "title": "Bezier Curve",
    "text": "This example showcases the PathPatch object to create a Bezier\npolycurve path patch. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.axes.Axes.add_patch",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\npp1 = mpatches.PathPatch(\n    Path([(0, 0), (1, 0), (1, 1), (0, 0)],\n         [Path.MOVETO, Path.CURVE3, Path.CURVE3, Path.CLOSEPOLY]),\n    fc='none', transform=ax.transData)\n\nax.add_patch(pp1)\nax.plot([0.75], [0.25], 'ro')\nax.set_title('The red point should be on the path')\n\nplt.show()\n",
    "id": 147
},
{
    "title": "Scatter plot",
    "text": "This example showcases a simple scatter plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.scatter / matplotlib.pyplot.scatter",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\n\nplt.scatter(x, y, s=area, c=colors, alpha=0.5)\nplt.show()\n",
    "id": 148
},
{
    "title": "Bayesian Methods for Hackers style sheet",
    "text": "This example demonstrates the style used in the Bayesian Methods for Hackers\n[1] online book. http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.style.use('bmh')\n\n\ndef plot_beta_hist(ax, a, b):\n    ax.hist(np.random.beta(a, b, size=10000),\n            histtype='stepfilled', bins=25, alpha=0.8, density=True)\n\n\nfig, ax = plt.subplots()\nplot_beta_hist(ax, 10, 10)\nplot_beta_hist(ax, 4, 12)\nplot_beta_hist(ax, 50, 12)\nplot_beta_hist(ax, 6, 55)\nax.set_title(''bmh' style sheet')\n\nplt.show()\n",
    "id": 149
},
{
    "title": "Dark background style sheet",
    "text": "This example demonstrates the \"dark_background\" style, which uses white for\nelements that are typically black (text, borders, etc). Note that not all plot\nelements default to colors defined by an rc parameter.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('dark_background')\n\nfig, ax = plt.subplots()\n\nL = 6\nx = np.linspace(0, L)\nncolors = len(plt.rcParams['axes.prop_cycle'])\nshift = np.linspace(0, L, ncolors, endpoint=False)\nfor s in shift:\n    ax.plot(x, np.sin(x + s), 'o-')\nax.set_xlabel('x-axis')\nax.set_ylabel('y-axis')\nax.set_title(''dark_background' style sheet')\n\nplt.show()\n",
    "id": 150
},
{
    "title": "FiveThirtyEight style sheet",
    "text": "This shows an example of the \"fivethirtyeight\" styling, which\ntries to replicate the styles from FiveThirtyEight.com.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('fivethirtyeight')\n\nx = np.linspace(0, 10)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nax.plot(x, np.sin(x) + x + np.random.randn(50))\nax.plot(x, np.sin(x) + 0.5 * x + np.random.randn(50))\nax.plot(x, np.sin(x) + 2 * x + np.random.randn(50))\nax.plot(x, np.sin(x) - 0.5 * x + np.random.randn(50))\nax.plot(x, np.sin(x) - 2 * x + np.random.randn(50))\nax.plot(x, np.sin(x) + np.random.randn(50))\nax.set_title(''fivethirtyeight' style sheet')\n\nplt.show()\n",
    "id": 151
},
{
    "title": "ggplot style sheet",
    "text": "This example demonstrates the \"ggplot\" style, which adjusts the style to\nemulate ggplot (a popular plotting package for R). These settings were shamelessly stolen from [1] (with permission). https://everyhue.me/posts/sane-color-scheme-for-matplotlib/",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('ggplot')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(ncols=2, nrows=2)\nax1, ax2, ax3, ax4 = axs.flat\n\n# scatter plot (Note: `plt.scatter` doesn't use default colors)\nx, y = np.random.normal(size=(2, 200))\nax1.plot(x, y, 'o')\n\n# sinusoidal lines with colors from default color cycle\nL = 2*np.pi\nx = np.linspace(0, L)\nncolors = len(plt.rcParams['axes.prop_cycle'])\nshift = np.linspace(0, L, ncolors, endpoint=False)\nfor s in shift:\n    ax2.plot(x, np.sin(x + s), '-')\nax2.margins(0)\n\n# bar graphs\nx = np.arange(5)\ny1, y2 = np.random.randint(1, 25, size=(2, 5))\nwidth = 0.25\nax3.bar(x, y1, width)\nax3.bar(x + width, y2, width,\n        color=list(plt.rcParams['axes.prop_cycle'])[2]['color'])\nax3.set_xticks(x + width, labels=['a b c d e'])\n\n# circles with colors from default color cycle\nfor i, color in enumerate(plt.rcParams['axes.prop_cycle']):\n    xy = np.random.normal(size=2)\n    ax4.add_patch(plt.Circle(xy, radius=0.3, color=color['color']))\nax4.axis('equal')\nax4.margins(0)\n\nplt.show()\n",
    "id": 152
},
{
    "title": "Grayscale style sheet",
    "text": "This example demonstrates the \"grayscale\" style sheet, which changes all colors\nthat are defined as rcParams to grayscale. Note, however, that not all\nplot elements respect rcParams.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef color_cycle_example(ax):\n    L = 6\n    x = np.linspace(0, L)\n    ncolors = len(plt.rcParams['axes.prop_cycle'])\n    shift = np.linspace(0, L, ncolors, endpoint=False)\n    for s in shift:\n        ax.plot(x, np.sin(x + s), 'o-')\n\n\ndef image_and_patch_example(ax):\n    ax.imshow(np.random.random(size=(20, 20)), interpolation='none')\n    c = plt.Circle((5, 5), radius=5, label='patch')\n    ax.add_patch(c)\n\n\nplt.style.use('grayscale')\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\nfig.suptitle(''grayscale' style sheet')\n\ncolor_cycle_example(ax1)\nimage_and_patch_example(ax2)\n\nplt.show()\n",
    "id": 153
},
{
    "title": "Solarized Light stylesheet",
    "text": "This shows an example of \"Solarized_Light\" styling, which\ntries to replicate the styles of: https://ethanschoonover.com/solarized/ jrnold/ggthemes http://www.pygal.org/en/stable/documentation/builtin_styles.html#light-solarized and work of: tonysyu/mpltools using all 8 accents of the color palette - starting with blue Still TODO: Create alpha values for bar and stacked charts. .33 or .5 Apply Layout Rules",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.linspace(0, 10)\nwith plt.style.context('Solarize_Light2'):\n    plt.plot(x, np.sin(x) + x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 2 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 3 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 4 + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 5 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 6 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 7 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 8 * x + np.random.randn(50))\n    # Number of accent colors in the color scheme\n    plt.title('8 Random Lines - Line')\n    plt.xlabel('x label', fontsize=14)\n    plt.ylabel('y label', fontsize=14)\n\nplt.show()\n",
    "id": 154
},
{
    "title": "Simple plot",
    "text": "A simple plot where a list of numbers are plotted against their index,\nresulting in a straight line. Use a format string (here, 'o-r') to set the\nmarkers (circles), linestyle (solid line) and color (red).\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.plot matplotlib.pyplot.ylabel matplotlib.pyplot.show",
    "code": "import matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4], 'o-r')\nplt.ylabel('some numbers')\nplt.show()\n",
    "id": 155
},
{
    "title": "Text and mathtext using pyplot",
    "text": "Set the special text objects title, xlabel, and\nylabel through the dedicated pyplot functions. Additional text\nobjects can be placed in the axes using text. You can use TeX-like mathematical typesetting in all texts; see also\nWriting mathematical expressions. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.hist matplotlib.pyplot.xlabel matplotlib.pyplot.ylabel matplotlib.pyplot.text matplotlib.pyplot.grid matplotlib.pyplot.show",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2*np.pi*t)\n\nplt.plot(t, s)\nplt.text(0, -1, r'Hello, world!', fontsize=15)\nplt.title(r'$\\\\mathcal{A}\\\\sin(\\\\omega t)$', fontsize=20)\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n",
    "id": 156
},
{
    "title": "Multiple lines using pyplot",
    "text": "Plot three datasets with a single call to plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# evenly sampled time at 200ms intervals\nt = np.arange(0., 5., 0.2)\n\n# red dashes, blue squares and green triangles\nplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')\nplt.show()\n",
    "id": 157
},
{
    "title": "Two subplots using pyplot",
    "text": "Create a figure with two subplots using pyplot.subplot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.pyplot.subplot",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\n\nplt.figure()\nplt.subplot(211)\nplt.plot(t1, f(t1), color='tab:blue', marker='o')\nplt.plot(t2, f(t2), color='black')\n\nplt.subplot(212)\nplt.plot(t2, np.cos(2*np.pi*t2), color='tab:orange', linestyle='--')\nplt.show()\n",
    "id": 158
},
{
    "title": "Anchored Direction Arrow",
    "text": "Download Python source code: demo_anchored_direction_arrows.py Download Jupyter notebook: demo_anchored_direction_arrows.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.font_manager as fm\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredDirectionArrows\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.imshow(np.random.random((10, 10)))\n\n# Simple example\nsimple_arrow = AnchoredDirectionArrows(ax.transAxes, 'X Y')\nax.add_artist(simple_arrow)\n\n# High contrast arrow\nhigh_contrast_part_1 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'w fc': 'none alpha': 1,\n                                         'lw': 2}\n                            )\nax.add_artist(high_contrast_part_1)\n\nhigh_contrast_part_2 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'none fc': 'k'},\n                            text_props={'ec': 'w fc': 'k lw': 0.4}\n                            )\nax.add_artist(high_contrast_part_2)\n\n# Rotated arrow\nfontprops = fm.FontProperties(family='serif')\n\nrotated_arrow = AnchoredDirectionArrows(\n                    ax.transAxes,\n                    '30 120',\n                    loc='center',\n                    color='w',\n                    angle=30,\n                    fontproperties=fontprops\n                    )\nax.add_artist(rotated_arrow)\n\n# Altering arrow directions\na1 = AnchoredDirectionArrows(\n        ax.transAxes, 'A B', loc='lower center',\n        length=-0.15,\n        sep_x=0.03, sep_y=0.03,\n        color='r'\n    )\nax.add_artist(a1)\n\na2 = AnchoredDirectionArrows(\n        ax.transAxes, 'A  B', loc='lower left',\n        aspect_ratio=-1,\n        sep_x=0.01, sep_y=-0.02,\n        color='orange'\n        )\nax.add_artist(a2)\n\n\na3 = AnchoredDirectionArrows(\n        ax.transAxes, ' A B', loc='lower right',\n        length=-0.15,\n        aspect_ratio=-1,\n        sep_y=-0.1, sep_x=0.04,\n        color='cyan'\n        )\nax.add_artist(a3)\n\nplt.show()\n",
    "id": 159
},
{
    "title": "Axes divider",
    "text": "Axes divider to calculate location of axes and\ncreate a divider for them using existing axes instances.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\n\n\ndef get_demo_image():\n    z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array\n    return z, (-3, 4, -4, 3)\n\n\ndef demo_simple_image(ax):\n    Z, extent = get_demo_image()\n\n    im = ax.imshow(Z, extent=extent)\n    cb = plt.colorbar(im)\n    cb.ax.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_locatable_axes_hard(fig):\n    from mpl_toolkits.axes_grid1 import Size, SubplotDivider\n\n    divider = SubplotDivider(fig, 2, 2, 2, aspect=True)\n\n    # axes for image\n    ax = fig.add_subplot(axes_locator=divider.new_locator(nx=0, ny=0))\n    # axes for colorbar\n    ax_cb = fig.add_subplot(axes_locator=divider.new_locator(nx=2, ny=0))\n\n    divider.set_horizontal([\n        Size.AxesX(ax),  # main axes\n        Size.Fixed(0.05),  # padding, 0.1 inch\n        Size.Fixed(0.2),  # colorbar, 0.3 inch\n    ])\n    divider.set_vertical([Size.AxesY(ax)])\n\n    Z, extent = get_demo_image()\n\n    im = ax.imshow(Z, extent=extent)\n    plt.colorbar(im, cax=ax_cb)\n    ax_cb.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_locatable_axes_easy(ax):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n    divider = make_axes_locatable(ax)\n\n    ax_cb = divider.append_axes('right', size='5%', pad=0.05)\n    fig = ax.get_figure()\n    fig.add_axes(ax_cb)\n\n    Z, extent = get_demo_image()\n    im = ax.imshow(Z, extent=extent)\n\n    plt.colorbar(im, cax=ax_cb)\n    ax_cb.yaxis.tick_right()\n    ax_cb.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_images_side_by_side(ax):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n    divider = make_axes_locatable(ax)\n\n    Z, extent = get_demo_image()\n    ax2 = divider.append_axes('right', size='100%', pad=0.05)\n    fig1 = ax.get_figure()\n    fig1.add_axes(ax2)\n\n    ax.imshow(Z, extent=extent)\n    ax2.imshow(Z, extent=extent)\n    ax2.yaxis.set_tick_params(labelleft=False)\n\n\ndef demo():\n    fig = plt.figure(figsize=(6, 6))\n\n    # PLOT 1\n    # simple image & colorbar\n    ax = fig.add_subplot(2, 2, 1)\n    demo_simple_image(ax)\n\n    # PLOT 2\n    # image and colorbar with draw-time positioning -- a hard way\n    demo_locatable_axes_hard(fig)\n\n    # PLOT 3\n    # image and colorbar with draw-time positioning -- an easy way\n    ax = fig.add_subplot(2, 2, 3)\n    demo_locatable_axes_easy(ax)\n\n    # PLOT 4\n    # two images side by side with fixed padding.\n    ax = fig.add_subplot(2, 2, 4)\n    demo_images_side_by_side(ax)\n\n    plt.show()\n\n\ndemo()\n",
    "id": 160
},
{
    "title": "Demo Axes Grid",
    "text": "Grid of 2x2 images with a single colorbar or with one colorbar per axes.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(10.5, 2.5))\nZ = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array\nextent = (-3, 4, -4, 3)\n\n\n# A grid of 2x2 images with 0.05 inch pad between images and only the\n# lower-left axes is labeled.\ngrid = ImageGrid(\n    fig, 141,  # similar to fig.add_subplot(141).\n     nrows_ncols=(2, 2), axes_pad=0.05, label_mode='1')\nfor ax in grid:\n    ax.imshow(Z, extent=extent)\n# This only affects axes in first column and second row as share_all=False.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images with a single colorbar.\ngrid = ImageGrid(\n    fig, 142,  # similar to fig.add_subplot(142).\n    nrows_ncols=(2, 2), axes_pad=0.0, label_mode='L', share_all=True,\n    cbar_location='top', cbar_mode='single')\nfor ax in grid:\n    im = ax.imshow(Z, extent=extent)\ngrid.cbar_axes[0].colorbar(im)\nfor cax in grid.cbar_axes:\n    cax.tick_params(labeltop=False)\n# This affects all axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images. Each image has its own colorbar.\ngrid = ImageGrid(\n    fig, 143,  # similar to fig.add_subplot(143).\n    nrows_ncols=(2, 2), axes_pad=0.1, label_mode='1', share_all=True,\n    cbar_location='top', cbar_mode='each', cbar_size='7%', cbar_pad='2%')\nfor ax, cax in zip(grid, grid.cbar_axes):\n    im = ax.imshow(Z, extent=extent)\n    cax.colorbar(im)\n    cax.tick_params(labeltop=False)\n# This affects all axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images. Each image has its own colorbar.\ngrid = ImageGrid(\n    fig, 144,  # similar to fig.add_subplot(144).\n    nrows_ncols=(2, 2), axes_pad=(0.45, 0.15), label_mode='1', share_all=True,\n    cbar_location='right', cbar_mode='each', cbar_size='7%', cbar_pad='2%')\n# Use a different colorbar range every time\nlimits = ((0, 1), (-2, 2), (-1.7, 1.4), (-1.5, 1))\nfor ax, cax, vlim in zip(grid, grid.cbar_axes, limits):\n    im = ax.imshow(Z, extent=extent, vmin=vlim[0], vmax=vlim[1])\n    cb = cax.colorbar(im)\n    cb.set_ticks((vlim[0], vlim[1]))\n# This affects all axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\nplt.show()\n",
    "id": 161
},
{
    "title": "Axes Grid2",
    "text": "Grid of images with shared xaxis and yaxis.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\n\ndef add_inner_title(ax, title, loc, **kwargs):\n    from matplotlib.offsetbox import AnchoredText\n    from matplotlib.patheffects import withStroke\n    prop = dict(path_effects=[withStroke(foreground='w', linewidth=3)],\n                size=plt.rcParams['legend.fontsize'])\n    at = AnchoredText(title, loc=loc, prop=prop,\n                      pad=0., borderpad=0.5,\n                      frameon=False, **kwargs)\n    ax.add_artist(at)\n    return at\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# Prepare images\nZ = cbook.get_sample_data('axes_grid/bivariate_normal.npy')\nextent = (-3, 4, -4, 3)\nZS = [Z[i::3, :] for i in range(3)]\nextent = extent[0], extent[1]/3., extent[2], extent[3]\n\n# *** Demo 1: colorbar at each axes ***\ngrid = ImageGrid(\n    # 211 = at the position of fig.add_subplot(211)\n    fig, 211, nrows_ncols=(1, 3), axes_pad=0.05, label_mode='1', share_all=True,\n    cbar_location='top', cbar_mode='each', cbar_size='7%', cbar_pad='1%')\ngrid[0].set(xticks=[-2, 0], yticks=[-2, 0, 2])\n\nfor i, (ax, z) in enumerate(zip(grid, ZS)):\n    im = ax.imshow(z, origin='lower', extent=extent)\n    cb = ax.cax.colorbar(im)\n    # Changing the colorbar ticks\n    if i in [1, 2]:\n        cb.set_ticks([-1, 0, 1])\n\nfor ax, im_title in zip(grid, ['Image 1', 'Image 2', 'Image 3']):\n    add_inner_title(ax, im_title, loc='lower left')\n\n# *** Demo 2: shared colorbar ***\ngrid2 = ImageGrid(\n    fig, 212, nrows_ncols=(1, 3), axes_pad=0.05, label_mode='1', share_all=True,\n    cbar_location='right', cbar_mode='single', cbar_size='10%', cbar_pad=0.05)\ngrid2[0].set(xlabel='X', ylabel='Y', xticks=[-2, 0], yticks=[-2, 0, 2])\n\nclim = (np.min(ZS), np.max(ZS))\nfor ax, z in zip(grid2, ZS):\n    im = ax.imshow(z, clim=clim, origin='lower', extent=extent)\n\n# With cbar_mode='single', cax attribute of all axes are identical.\nax.cax.colorbar(im)\n\nfor ax, im_title in zip(grid2, ['(a)', '(b)', '(c)']):\n    add_inner_title(ax, im_title, loc='upper left')\n\nplt.show()\n",
    "id": 162
},
{
    "title": "Showing RGB channels using RGBAxes",
    "text": "RGBAxes creates a layout of 4 Axes for displaying RGB\nchannels: one large Axes for the RGB image and 3 smaller Axes for the R, G, B\nchannels.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.axes_rgb import RGBAxes, make_rgb_axes\n\n\ndef get_rgb():\n    Z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')\n    Z[Z < 0] = 0.\n    Z = Z / Z.max()\n\n    R = Z[:13, :13]\n    G = Z[2:, 2:]\n    B = Z[:13, 2:]\n\n    return R, G, B\n\n\ndef make_cube(r, g, b):\n    ny, nx = r.shape\n    R = np.zeros((ny, nx, 3))\n    R[:, :, 0] = r\n    G = np.zeros_like(R)\n    G[:, :, 1] = g\n    B = np.zeros_like(R)\n    B[:, :, 2] = b\n\n    RGB = R + G + B\n\n    return R, G, B, RGB\n\n\ndef demo_rgb1():\n    fig = plt.figure()\n    ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8], pad=0.0)\n    r, g, b = get_rgb()\n    ax.imshow_rgb(r, g, b)\n\n\ndef demo_rgb2():\n    fig, ax = plt.subplots()\n    ax_r, ax_g, ax_b = make_rgb_axes(ax, pad=0.02)\n\n    r, g, b = get_rgb()\n    im_r, im_g, im_b, im_rgb = make_cube(r, g, b)\n    ax.imshow(im_rgb)\n    ax_r.imshow(im_r)\n    ax_g.imshow(im_g)\n    ax_b.imshow(im_b)\n\n    for ax in fig.axes:\n        ax.tick_params(direction='in', color='w')\n        ax.spines[:].set_color('w')\n\n\ndemo_rgb1()\ndemo_rgb2()\n\nplt.show()\n",
    "id": 163
},
{
    "title": "Adding a colorbar to inset axes",
    "text": "Download Python source code: demo_colorbar_of_inset_axes.py Download Jupyter notebook: demo_colorbar_of_inset_axes.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes, zoomed_inset_axes\n\nfig, ax = plt.subplots(figsize=[5, 4])\nax.set(aspect=1, xlim=(-15, 15), ylim=(-20, 5))\n\nZ = cbook.get_sample_data('axes_grid/bivariate_normal.npy')\nextent = (-3, 4, -4, 3)\n\naxins = zoomed_inset_axes(ax, zoom=2, loc='upper left')\naxins.set(xticks=[], yticks=[])\nim = axins.imshow(Z, extent=extent, origin='lower')\n\n# colorbar\ncax = inset_axes(axins,\n                 width='5%',  # width = 10% of parent_bbox width\n                 height='100%',  # height : 50%\n                 loc='lower left',\n                 bbox_to_anchor=(1.05, 0., 1, 1),\n                 bbox_transform=axins.transAxes,\n                 borderpad=0,\n                 )\nfig.colorbar(im, cax=cax)\n\nplt.show()\n",
    "id": 164
},
{
    "title": "Colorbar with AxesDivider",
    "text": "The axes_divider.make_axes_locatable function takes an existing axes, adds\nit to a new AxesDivider and returns the AxesDivider. The append_axes\nmethod of the AxesDivider can then be used to create a new axes on a given\nside (\"top\", \"right\", \"bottom\", or \"left\") of the original axes. This example\nuses append_axes to add colorbars next to axes.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.subplots_adjust(wspace=0.5)\n\nim1 = ax1.imshow([[1, 2], [3, 4]])\nax1_divider = make_axes_locatable(ax1)\n# Add an Axes to the right of the main Axes.\ncax1 = ax1_divider.append_axes('right', size='7%', pad='2%')\ncb1 = fig.colorbar(im1, cax=cax1)\n\nim2 = ax2.imshow([[1, 2], [3, 4]])\nax2_divider = make_axes_locatable(ax2)\n# Add an Axes above the main Axes.\ncax2 = ax2_divider.append_axes('top', size='7%', pad='2%')\ncb2 = fig.colorbar(im2, cax=cax2, orientation='horizontal')\n# Change tick position to top (with the default tick position 'bottom', ticks\n# overlap the image).\ncax2.xaxis.set_ticks_position('top')\n\nplt.show()\n",
    "id": 165
},
{
    "title": "Controlling the position and size of colorbars with Inset Axes",
    "text": "This example shows how to control the position, height, and width of\ncolorbars using inset_axes. Inset axes placement is controlled as for legends: either by providing a loc\noption (\"upper right\", \"best\", ...), or by providing a locator with respect to\nthe parent bbox. Parameters such as bbox_to_anchor and borderpad likewise\nwork in the same way, and are also demonstrated here.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=[6, 3])\n\nim1 = ax1.imshow([[1, 2], [2, 3]])\naxins1 = inset_axes(\n    ax1,\n    width='50%',  # width: 50% of parent_bbox width\n    height='5%',  # height: 5%\n    loc='upper right',\n)\naxins1.xaxis.set_ticks_position('bottom')\nfig.colorbar(im1, cax=axins1, orientation='horizontal', ticks=[1, 2, 3])\n\nim = ax2.imshow([[1, 2], [2, 3]])\naxins = inset_axes(\n    ax2,\n    width='5%',  # width: 5% of parent_bbox width\n    height='50%',  # height: 50%\n    loc='lower left',\n    bbox_to_anchor=(1.05, 0., 1, 1),\n    bbox_transform=ax2.transAxes,\n    borderpad=0,\n)\nfig.colorbar(im, cax=axins, ticks=[1, 2, 3])\n\nplt.show()\n",
    "id": 166
},
{
    "title": "Per-row or per-column colorbars",
    "text": "This example shows how to use one common colorbar for each row or column\nof an image grid.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import AxesGrid\n\n\ndef get_demo_image():\n    z = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array\n    return z, (-3, 4, -4, 3)\n\n\ndef demo_bottom_cbar(fig):\n    '''\n    A grid of 2x2 images with a colorbar for each column.\n    '''\n    grid = AxesGrid(fig, 121,  # similar to subplot(121)\n                    nrows_ncols=(2, 2),\n                    axes_pad=0.10,\n                    share_all=True,\n                    label_mode='1',\n                    cbar_location='bottom',\n                    cbar_mode='edge',\n                    cbar_pad=0.25,\n                    cbar_size='15%',\n                    direction='column'\n                    )\n\n    Z, extent = get_demo_image()\n    cmaps = ['autumn', 'summer']\n    for i in range(4):\n        im = grid[i].imshow(Z, extent=extent, cmap=cmaps[i//2])\n        if i % 2:\n            grid.cbar_axes[i//2].colorbar(im)\n\n    for cax in grid.cbar_axes:\n        cax.axis[cax.orientation].set_label('Bar')\n\n    # This affects all axes as share_all = True.\n    grid.axes_llc.set_xticks([-2, 0, 2])\n    grid.axes_llc.set_yticks([-2, 0, 2])\n\n\ndef demo_right_cbar(fig):\n    '''\n    A grid of 2x2 images. Each row has its own colorbar.\n    '''\n    grid = AxesGrid(fig, 122,  # similar to subplot(122)\n                    nrows_ncols=(2, 2),\n                    axes_pad=0.10,\n                    label_mode='1',\n                    share_all=True,\n                    cbar_location='right',\n                    cbar_mode='edge',\n                    cbar_size='7%',\n                    cbar_pad='2%',\n                    )\n    Z, extent = get_demo_image()\n    cmaps = ['spring', 'winter']\n    for i in range(4):\n        im = grid[i].imshow(Z, extent=extent, cmap=cmaps[i//2])\n        if i % 2:\n            grid.cbar_axes[i//2].colorbar(im)\n\n    for cax in grid.cbar_axes:\n        cax.axis[cax.orientation].set_label('Foo')\n\n    # This affects all axes because we set share_all = True.\n    grid.axes_llc.set_xticks([-2, 0, 2])\n    grid.axes_llc.set_yticks([-2, 0, 2])\n\n\nfig = plt.figure()\n\ndemo_bottom_cbar(fig)\ndemo_right_cbar(fig)\n\nplt.show()\n",
    "id": 167
},
{
    "title": "Setting a fixed aspect on ImageGrid cells",
    "text": "Download Python source code: demo_imagegrid_aspect.py Download Jupyter notebook: demo_imagegrid_aspect.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure()\n\ngrid1 = ImageGrid(fig, 121, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [0, 1]:\n    grid1[i].set_aspect(2)\n\ngrid2 = ImageGrid(fig, 122, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [1, 3]:\n    grid2[i].set_aspect(2)\n\nplt.show()\n",
    "id": 168
},
{
    "title": "Inset locator demo 2",
    "text": "This demo shows how to create a zoomed inset via zoomed_inset_axes.\nIn the first subplot an AnchoredSizeBar shows the zoom effect.\nIn the second subplot a connection to the region of interest is\ncreated via mark_inset. A version of the second subplot, not using the toolkit, is available in\nZoom region inset axes.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nfrom mpl_toolkits.axes_grid1.inset_locator import mark_inset, zoomed_inset_axes\n\nfig, (ax, ax2) = plt.subplots(ncols=2, figsize=[6, 3])\n\n\n# First subplot, showing an inset with a size bar.\nax.set_aspect(1)\n\naxins = zoomed_inset_axes(ax, zoom=0.5, loc='upper right')\n# fix the number of ticks on the inset axes\naxins.yaxis.get_major_locator().set_params(nbins=7)\naxins.xaxis.get_major_locator().set_params(nbins=7)\naxins.tick_params(labelleft=False, labelbottom=False)\n\n\ndef add_sizebar(ax, size):\n    asb = AnchoredSizeBar(ax.transData,\n                          size,\n                          str(size),\n                          loc=8,\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\nadd_sizebar(ax, 0.5)\nadd_sizebar(axins, 0.5)\n\n\n# Second subplot, showing an image with an inset zoom and a marked inset\nZ = cbook.get_sample_data('axes_grid/bivariate_normal.npy')  # 15x15 array\nextent = (-3, 4, -4, 3)\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\n\nax2.imshow(Z2, extent=extent, origin='lower')\n\naxins2 = zoomed_inset_axes(ax2, zoom=6, loc=1)\naxins2.imshow(Z2, extent=extent, origin='lower')\n\n# subregion of the original image\nx1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9\naxins2.set_xlim(x1, x2)\naxins2.set_ylim(y1, y2)\n# fix the number of ticks on the inset axes\naxins2.yaxis.get_major_locator().set_params(nbins=7)\naxins2.xaxis.get_major_locator().set_params(nbins=7)\naxins2.tick_params(labelleft=False, labelbottom=False)\n\n# draw a bbox of the region of the inset axes in the parent axes and\n# connecting lines between the bbox and the inset axes area\nmark_inset(ax2, axins2, loc1=2, loc2=4, fc='none', ec='0.5')\n\nplt.show()\n",
    "id": 169
},
{
    "title": "Parasite Simple",
    "text": "Download Python source code: parasite_simple.py Download Jupyter notebook: parasite_simple.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111)\npar = host.twinx()\n\nhost.set_xlabel('Distance')\nhost.set_ylabel('Density')\npar.set_ylabel('Temperature')\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label='Density')\np2, = par.plot([0, 1, 2], [0, 3, 2], label='Temperature')\n\nhost.legend(labelcolor='linecolor')\n\nhost.yaxis.get_label().set_color(p1.get_color())\npar.yaxis.get_label().set_color(p2.get_color())\n\nplt.show()\n",
    "id": 170
},
{
    "title": "Parasite Simple2",
    "text": "Download Python source code: parasite_simple2.py Download Jupyter notebook: parasite_simple2.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\nfrom mpl_toolkits.axes_grid1.parasite_axes import HostAxes\n\nobs = [['01_S1', 3.88, 0.14, 1970, 63],\n       ['01_S4', 5.6, 0.82, 1622, 150],\n       ['02_S1', 2.4, 0.54, 1570, 40],\n       ['03_S1', 4.1, 0.62, 2380, 170]]\n\n\nfig = plt.figure()\n\nax_kms = fig.add_subplot(axes_class=HostAxes, aspect=1)\n\n# angular proper motion('/yr) to linear velocity(km/s) at distance=2.3kpc\npm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5\n\naux_trans = mtransforms.Affine2D().scale(pm_to_kms, 1.)\nax_pm = ax_kms.twin(aux_trans)\n\nfor n, ds, dse, w, we in obs:\n    time = ((2007 + (10. + 4/30.)/12) - 1988.5)\n    v = ds / time * pm_to_kms\n    ve = dse / time * pm_to_kms\n    ax_kms.errorbar([v], [w], xerr=[ve], yerr=[we], color='k')\n\n\nax_kms.axis['bottom'].set_label('Linear velocity at 2.3 kpc [km/s]')\nax_kms.axis['left'].set_label('FWHM [km/s]')\nax_pm.axis['top'].set_label(r'Proper Motion [$''$/yr]')\nax_pm.axis['top'].label.set_visible(True)\nax_pm.axis['right'].major_ticklabels.set_visible(False)\n\nax_kms.set_xlim(950, 3700)\nax_kms.set_ylim(950, 3100)\n# xlim and ylim of ax_pms will be automatically adjusted.\n\nplt.show()\n",
    "id": 171
},
{
    "title": "Scatter Histogram (Locatable Axes)",
    "text": "Show the marginal distributions of a scatter plot as histograms at the sides of\nthe plot. For a nice alignment of the main axes with the marginals, the axes positions\nare defined by a Divider, produced via make_axes_locatable. Note that\nthe Divider API allows setting axes sizes and pads in inches, which is its\nmain feature. If one wants to set axes sizes and pads relative to the main Figure, see the\nScatter plot with histograms example. References The use of the following functions, methods, classes and modules is shown\nin this example: mpl_toolkits.axes_grid1.axes_divider.make_axes_locatable matplotlib.axes.Axes.set_aspect matplotlib.axes.Axes.scatter matplotlib.axes.Axes.hist",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# the random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\nfig, ax = plt.subplots(figsize=(5.5, 5.5))\n\n# the scatter plot:\nax.scatter(x, y)\n\n# Set aspect of the main axes.\nax.set_aspect(1.)\n\n# create new axes on the right and on the top of the current axes\ndivider = make_axes_locatable(ax)\n# below height and pad are in inches\nax_histx = divider.append_axes('top', 1.2, pad=0.1, sharex=ax)\nax_histy = divider.append_axes('right', 1.2, pad=0.1, sharey=ax)\n\n# make some labels invisible\nax_histx.xaxis.set_tick_params(labelbottom=False)\nax_histy.yaxis.set_tick_params(labelleft=False)\n\n# now determine nice limits by hand:\nbinwidth = 0.25\nxymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\nlim = (int(xymax/binwidth) + 1)*binwidth\n\nbins = np.arange(-lim, lim + binwidth, binwidth)\nax_histx.hist(x, bins=bins)\nax_histy.hist(y, bins=bins, orientation='horizontal')\n\n# the xaxis of ax_histx and yaxis of ax_histy are shared with ax,\n# thus there is no need to manually adjust the xlim and ylim of these\n# axis.\n\nax_histx.set_yticks([0, 50, 100])\nax_histy.set_xticks([0, 50, 100])\n\nplt.show()\n",
    "id": 172
},
{
    "title": "Simple Anchored Artists",
    "text": "This example illustrates the use of the anchored helper classes found in\nmatplotlib.offsetbox and in mpl_toolkits.axes_grid1.\nAn implementation of a similar figure, but without use of the toolkit,\ncan be found in Anchored Artists.",
    "code": "import matplotlib.pyplot as plt\n\n\ndef draw_text(ax):\n    '''\n    Draw two text-boxes, anchored by different corners to the upper-left\n    corner of the figure.\n    '''\n    from matplotlib.offsetbox import AnchoredText\n    at = AnchoredText('Figure 1a',\n                      loc='upper left', prop=dict(size=8), frameon=True,\n                      )\n    at.patch.set_boxstyle('round,pad=0.,rounding_size=0.2')\n    ax.add_artist(at)\n\n    at2 = AnchoredText('Figure 1(b)',\n                       loc='lower left', prop=dict(size=8), frameon=True,\n                       bbox_to_anchor=(0., 1.),\n                       bbox_transform=ax.transAxes\n                       )\n    at2.patch.set_boxstyle('round,pad=0.,rounding_size=0.2')\n    ax.add_artist(at2)\n\n\ndef draw_circle(ax):\n    '''\n    Draw a circle in axis coordinates\n    '''\n    from matplotlib.patches import Circle\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea\n    ada = AnchoredDrawingArea(20, 20, 0, 0,\n                              loc='upper right', pad=0., frameon=False)\n    p = Circle((10, 10), 10)\n    ada.da.add_artist(p)\n    ax.add_artist(ada)\n\n\ndef draw_sizebar(ax):\n    '''\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label underneath.\n    '''\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\n    asb = AnchoredSizeBar(ax.transData,\n                          0.1,\n                          r'1$^{\\\\prime}$',\n                          loc='lower center',\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1.)\n\ndraw_text(ax)\ndraw_circle(ax)\ndraw_sizebar(ax)\n\nplt.show()\n",
    "id": 173
},
{
    "title": "Simple axes divider 3",
    "text": "See also The axes_grid1 toolkit.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\nfig = plt.figure(figsize=(5.5, 4))\n\n# the rect parameter will be ignored as we will set axes_locator\nrect = (0.1, 0.1, 0.8, 0.8)\nax = [fig.add_axes(rect, label='%d' % i) for i in range(4)]\n\n\nhoriz = [Size.AxesX(ax[0]), Size.Fixed(.5), Size.AxesX(ax[1])]\nvert = [Size.AxesY(ax[0]), Size.Fixed(.5), Size.AxesY(ax[2])]\n\n# divide the axes rectangle into grid whose size is specified by horiz * vert\ndivider = Divider(fig, rect, horiz, vert, aspect=False)\n\n\nax[0].set_axes_locator(divider.new_locator(nx=0, ny=0))\nax[1].set_axes_locator(divider.new_locator(nx=2, ny=0))\nax[2].set_axes_locator(divider.new_locator(nx=0, ny=2))\nax[3].set_axes_locator(divider.new_locator(nx=2, ny=2))\n\nax[0].set_xlim(0, 2)\nax[1].set_xlim(0, 1)\n\nax[0].set_ylim(0, 1)\nax[2].set_ylim(0, 2)\n\ndivider.set_aspect(1.)\n\nfor ax1 in ax:\n    ax1.tick_params(labelbottom=False, labelleft=False)\n\nplt.show()\n",
    "id": 174
},
{
    "title": "Simple ImageGrid",
    "text": "Align multiple images using ImageGrid.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nim1 = np.arange(100).reshape((10, 10))\nim2 = im1.T\nim3 = np.flipud(im1)\nim4 = np.fliplr(im2)\n\nfig = plt.figure(figsize=(4., 4.))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(2, 2),  # creates 2x2 grid of axes\n                 axes_pad=0.1,  # pad between axes in inch.\n                 )\n\nfor ax, im in zip(grid, [im1, im2, im3, im4]):\n    # Iterating over the grid returns the Axes.\n    ax.imshow(im)\n\nplt.show()\n",
    "id": 175
},
{
    "title": "Simple ImageGrid 2",
    "text": "Align multiple images of different sizes using\nImageGrid.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(5.5, 3.5))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(1, 3),\n                 axes_pad=0.1,\n                 label_mode='L',\n                 )\n\n# demo image\nZ = cbook.get_sample_data('axes_grid/bivariate_normal.npy')\nim1 = Z\nim2 = Z[:, :10]\nim3 = Z[:, 10:]\nvmin, vmax = Z.min(), Z.max()\nfor ax, im in zip(grid, [im1, im2, im3]):\n    ax.imshow(im, origin='lower', vmin=vmin, vmax=vmax)\n\nplt.show()\n",
    "id": 176
},
{
    "title": "Simple Axisline4",
    "text": "Download Python source code: simple_axisline4.py Download Jupyter notebook: simple_axisline4.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nax = host_subplot(111)\nxx = np.arange(0, 2*np.pi, 0.01)\nax.plot(xx, np.sin(xx))\n\nax2 = ax.twin()  # ax2 is responsible for 'top' axis and 'right' axis\nax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi],\n               labels=['$0$', r'$\\\\frac{1}{2}\\\\pi$',\n                       r'$\\\\pi$', r'$\\\\frac{3}{2}\\\\pi$', r'$2\\\\pi$'])\n\nax2.axis['right'].major_ticklabels.set_visible(False)\nax2.axis['top'].major_ticklabels.set_visible(True)\n\nplt.show()\n",
    "id": 177
},
{
    "title": "Simple Colorbar",
    "text": "Download Python source code: simple_colorbar.py Download Jupyter notebook: simple_colorbar.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nax = plt.subplot()\nim = ax.imshow(np.arange(100).reshape((10, 10)))\n\n# create an Axes on the right side of ax. The width of cax will be 5%\n# of ax and the padding between cax and ax will be fixed at 0.05 inch.\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes('right', size='5%', pad=0.05)\n\nplt.colorbar(im, cax=cax)\n\nplt.show()\n",
    "id": 178
},
{
    "title": "Axis Direction",
    "text": "Download Python source code: axis_direction.py Download Jupyter notebook: axis_direction.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n\n    ax.set_ylim(-0.1, 1.5)\n    ax.set_yticks([0, 1])\n\n    ax.axis[:].set_visible(False)\n\n    ax.axis['x'] = ax.new_floating_axis(1, 0.5)\n    ax.axis['x'].set_axisline_style('->', size=1.5)\n\n    return ax\n\n\nplt.rcParams.update({\n    'axes.titlesize': 'medium',\n    'axes.titley': 1.1,\n})\n\nfig = plt.figure(figsize=(10, 4))\nfig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)\n\nax1 = setup_axes(fig, 251)\nax1.axis['x'].set_axis_direction('left')\n\nax2 = setup_axes(fig, 252)\nax2.axis['x'].label.set_text('Label')\nax2.axis['x'].toggle(ticklabels=False)\nax2.axis['x'].set_axislabel_direction('+')\nax2.set_title('label direction=$+$')\n\nax3 = setup_axes(fig, 253)\nax3.axis['x'].label.set_text('Label')\nax3.axis['x'].toggle(ticklabels=False)\nax3.axis['x'].set_axislabel_direction('-')\nax3.set_title('label direction=$-$')\n\nax4 = setup_axes(fig, 254)\nax4.axis['x'].set_ticklabel_direction('+')\nax4.set_title('ticklabel direction=$+$')\n\nax5 = setup_axes(fig, 255)\nax5.axis['x'].set_ticklabel_direction('-')\nax5.set_title('ticklabel direction=$-$')\n\nax7 = setup_axes(fig, 257)\nax7.axis['x'].label.set_text('rotation=10')\nax7.axis['x'].label.set_rotation(10)\nax7.axis['x'].toggle(ticklabels=False)\n\nax8 = setup_axes(fig, 258)\nax8.axis['x'].set_axislabel_direction('-')\nax8.axis['x'].label.set_text('rotation=10')\nax8.axis['x'].label.set_rotation(10)\nax8.axis['x'].toggle(ticklabels=False)\n\nplt.show()\n",
    "id": 179
},
{
    "title": "axis_direction demo",
    "text": "Download Python source code: demo_axis_direction.py Download Jupyter notebook: demo_axis_direction.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    '''Polar projection, but in a rectangular box.'''\n    # see demo_curvelinear_grid.py for details\n    grid_helper = GridHelperCurveLinear(\n        Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform(),\n        extreme_finder=angle_helper.ExtremeFinderCycle(\n            20, 20,\n            lon_cycle=360, lat_cycle=None,\n            lon_minmax=None, lat_minmax=(0, np.inf),\n        ),\n        grid_locator1=angle_helper.LocatorDMS(12),\n        grid_locator2=grid_finder.MaxNLocator(5),\n        tick_formatter1=angle_helper.FormatterDMS(),\n    )\n    ax = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper,\n        aspect=1, xlim=(-5, 12), ylim=(-5, 10))\n    ax.axis[:].toggle(ticklabels=False)\n    ax.grid(color='.9')\n    return ax\n\n\ndef add_floating_axis1(ax):\n    ax.axis['lat'] = axis = ax.new_floating_axis(0, 30)\n    axis.label.set_text(r'$\\\\theta = 30^{\\\\circ}$')\n    axis.label.set_visible(True)\n    return axis\n\n\ndef add_floating_axis2(ax):\n    ax.axis['lon'] = axis = ax.new_floating_axis(1, 6)\n    axis.label.set_text(r'$r = 6$')\n    axis.label.set_visible(True)\n    return axis\n\n\nfig = plt.figure(figsize=(8, 4), layout='constrained')\n\nfor i, d in enumerate(['bottom', 'left', 'top', 'right']):\n    ax = setup_axes(fig, rect=241+i)\n    axis = add_floating_axis1(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nfor i, d in enumerate(['bottom', 'left', 'top', 'right']):\n    ax = setup_axes(fig, rect=245+i)\n    axis = add_floating_axis2(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nplt.show()\n",
    "id": 180
},
{
    "title": "Axis line styles",
    "text": "This example shows some configurations for axis style. Note: The mpl_toolkits.axisartist axes classes may be confusing for new\nusers. If the only aim is to obtain arrow heads at the ends of the axes,\nrather check out the Centered spines with arrows\nexample.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nax = fig.add_subplot(axes_class=AxesZero)\n\nfor direction in ['xzero', 'yzero']:\n    # adds arrows at the ends of each axis\n    ax.axis[direction].set_axisline_style('-|>')\n\n    # adds X and Y-axis from the origin\n    ax.axis[direction].set_visible(True)\n\nfor direction in ['left', 'right', 'bottom', 'top']:\n    # hides borders\n    ax.axis[direction].set_visible(False)\n\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()\n",
    "id": 181
},
{
    "title": "Curvilinear grid demo",
    "text": "Custom grid and ticklines. This example demonstrates how to use\nGridHelperCurveLinear to define custom grids and\nticklines by applying a transformation on the grid. This can be used, as\nshown on the second plot, to create polar projections in a rectangular box.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import Axes, HostAxes, angle_helper\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef curvelinear_test1(fig):\n    '''\n    Grid for custom transform.\n    '''\n\n    def tr(x, y): return x, y - x\n    def inv_tr(x, y): return x, y + x\n\n    grid_helper = GridHelperCurveLinear((tr, inv_tr))\n\n    ax1 = fig.add_subplot(1, 2, 1, axes_class=Axes, grid_helper=grid_helper)\n    # ax1 will have ticks and gridlines defined by the given transform (+\n    # transData of the Axes).  Note that the transform of the Axes itself\n    # (i.e., transData) is not affected by the given transform.\n    xx, yy = tr(np.array([3, 6]), np.array([5, 10]))\n    ax1.plot(xx, yy)\n\n    ax1.set_aspect(1)\n    ax1.set_xlim(0, 10)\n    ax1.set_ylim(0, 10)\n\n    ax1.axis['t'] = ax1.new_floating_axis(0, 3)\n    ax1.axis['t2'] = ax1.new_floating_axis(1, 7)\n    ax1.grid(True, zorder=0)\n\n\ndef curvelinear_test2(fig):\n    '''\n    Polar projection, but in a rectangular box.\n    '''\n\n    # PolarAxes.PolarTransform takes radian. However, we want our coordinate\n    # system in degree\n    tr = Affine2D().scale(np.pi/180, 1) + PolarAxes.PolarTransform()\n    # Polar projection, which involves cycle, and also has limits in\n    # its coordinates, needs a special method to find the extremes\n    # (min, max of the coordinate within the view).\n    extreme_finder = angle_helper.ExtremeFinderCycle(\n        nx=20, ny=20,  # Number of sampling points in each direction.\n        lon_cycle=360, lat_cycle=None,\n        lon_minmax=None, lat_minmax=(0, np.inf),\n    )\n    # Find grid values appropriate for the coordinate (degree, minute, second).\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    # Use an appropriate formatter.  Note that the acceptable Locator and\n    # Formatter classes are a bit different than that of Matplotlib, which\n    # cannot directly be used here (this may be possible in the future).\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(\n        tr, extreme_finder=extreme_finder,\n        grid_locator1=grid_locator1, tick_formatter1=tick_formatter1)\n    ax1 = fig.add_subplot(\n        1, 2, 2, axes_class=HostAxes, grid_helper=grid_helper)\n\n    # make ticklabels of right and top axis visible.\n    ax1.axis['right'].major_ticklabels.set_visible(True)\n    ax1.axis['top'].major_ticklabels.set_visible(True)\n    # let right axis shows ticklabels for 1st coordinate (angle)\n    ax1.axis['right'].get_helper().nth_coord_ticks = 0\n    # let bottom axis shows ticklabels for 2nd coordinate (radius)\n    ax1.axis['bottom'].get_helper().nth_coord_ticks = 1\n\n    ax1.set_aspect(1)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True, zorder=0)\n\n    # A parasite axes with given transform\n    ax2 = ax1.get_aux_axes(tr)\n    # note that ax2.transData == tr + ax1.transData\n    # Anything you draw in ax2 will match the ticks and grids of ax1.\n    ax2.plot(np.linspace(0, 30, 51), np.linspace(10, 10, 51), linewidth=2)\n\n    ax2.pcolor(np.linspace(0, 90, 4), np.linspace(0, 10, 4),\n               np.arange(9).reshape((3, 3)))\n    ax2.contour(np.linspace(0, 90, 4), np.linspace(0, 10, 4),\n                np.arange(16).reshape((4, 4)), colors='k')\n\n\nif __name__ == '__main__':\n    fig = plt.figure(figsize=(7, 4))\n\n    curvelinear_test1(fig)\n    curvelinear_test2(fig)\n\n    plt.show()\n",
    "id": 182
},
{
    "title": "Demo CurveLinear Grid2",
    "text": "Custom grid and ticklines. This example demonstrates how to use GridHelperCurveLinear to define\ncustom grids and ticklines by applying a transformation on the grid.\nAs showcase on the plot, a 5x5 matrix is displayed on the axes.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import Axes\nfrom mpl_toolkits.axisartist.grid_finder import (ExtremeFinderSimple,\n                                                 MaxNLocator)\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef curvelinear_test1(fig):\n    '''Grid for custom transform.'''\n\n    def tr(x, y):\n        return np.sign(x)*abs(x)**.5, y\n\n    def inv_tr(x, y):\n        return np.sign(x)*x**2, y\n\n    grid_helper = GridHelperCurveLinear(\n        (tr, inv_tr),\n        extreme_finder=ExtremeFinderSimple(20, 20),\n        # better tick density\n        grid_locator1=MaxNLocator(nbins=6), grid_locator2=MaxNLocator(nbins=6))\n\n    ax1 = fig.add_subplot(axes_class=Axes, grid_helper=grid_helper)\n    # ax1 will have a ticks and gridlines defined by the given\n    # transform (+ transData of the Axes). Note that the transform of the Axes\n    # itself (i.e., transData) is not affected by the given transform.\n\n    ax1.imshow(np.arange(25).reshape(5, 5),\n               vmax=50, cmap=plt.cm.gray_r, origin='lower')\n\n\nif __name__ == '__main__':\n    fig = plt.figure(figsize=(7, 4))\n    curvelinear_test1(fig)\n    plt.show()\n",
    "id": 183
},
{
    "title": "floating_axis demo",
    "text": "Axis within rectangular frame. The following code demonstrates how to put a floating polar curve within a\nrectangular box. In order to get a better sense of polar curves, please look at\nCurvilinear grid demo.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import GridHelperCurveLinear, HostAxes\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\n\n\ndef curvelinear_test2(fig):\n    '''Polar projection, but in a rectangular box.'''\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform()\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20,\n                                                     20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(axes_class=HostAxes, grid_helper=grid_helper)\n\n    # Now creates floating axis\n\n    # floating axis whose first coordinate (theta) is fixed at 60\n    ax1.axis['lat'] = axis = ax1.new_floating_axis(0, 60)\n    axis.label.set_text(r'$\\\\theta = 60^{\\\\circ}$')\n    axis.label.set_visible(True)\n\n    # floating axis whose second coordinate (r) is fixed at 6\n    ax1.axis['lon'] = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r'$r = 6$')\n\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True)\n\n\nfig = plt.figure(figsize=(5, 5))\ncurvelinear_test2(fig)\nplt.show()\n",
    "id": 184
},
{
    "title": "Parasite Axes demo",
    "text": "Create a parasite axes. Such axes would share the x scale with a host axes,\nbut show a different scale in y direction. This approach uses mpl_toolkits.axes_grid1.parasite_axes.HostAxes and\nmpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes. The standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the Multiple y-axis with Spines\nexample. An alternative approach using mpl_toolkits.axes_grid1 and\nmpl_toolkits.axisartist is shown in the\nParasite axis demo example.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.parasite_axes import HostAxes\n\nfig = plt.figure()\n\nhost = fig.add_axes([0.15, 0.1, 0.65, 0.8], axes_class=HostAxes)\npar1 = host.get_aux_axes(viewlim_mode=None, sharex=host)\npar2 = host.get_aux_axes(viewlim_mode=None, sharex=host)\n\nhost.axis['right'].set_visible(False)\n\npar1.axis['right'].set_visible(True)\npar1.axis['right'].major_ticklabels.set_visible(True)\npar1.axis['right'].label.set_visible(True)\n\npar2.axis['right2'] = par2.new_fixed_axis(loc='right', offset=(60, 0))\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label='Density')\np2, = par1.plot([0, 1, 2], [0, 3, 2], label='Temperature')\np3, = par2.plot([0, 1, 2], [50, 30, 15], label='Velocity')\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density')\npar1.set(ylim=(0, 4), ylabel='Temperature')\npar2.set(ylim=(1, 65), ylabel='Velocity')\n\nhost.legend()\n\nhost.axis['left'].label.set_color(p1.get_color())\npar1.axis['right'].label.set_color(p2.get_color())\npar2.axis['right2'].label.set_color(p3.get_color())\n\nplt.show()\n",
    "id": 185
},
{
    "title": "Parasite axis demo",
    "text": "This example demonstrates the use of parasite axis to plot multiple datasets\nonto one single plot.', \"Notice how in this example, par1 and par2 are both obtained by calling\ntwinx(), which ties their x-limits with the host's x-axis. From there, each\nof those two axis behave separately from each other: different datasets can be\nplotted, and the y-limits are adjusted separately.\", 'This approach uses mpl_toolkits.axes_grid1.parasite_axes.host_subplot and\nmpl_toolkits.axisartist.axislines.Axes. The standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the Multiple y-axis with Spines\nexample. An alternative approach using mpl_toolkits.axes_grid1.parasite_axes.HostAxes\nand mpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes is shown in the\nParasite Axes demo example.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits import axisartist\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111, axes_class=axisartist.Axes)\nplt.subplots_adjust(right=0.75)\n\npar1 = host.twinx()\npar2 = host.twinx()\n\npar2.axis['right'] = par2.new_fixed_axis(loc='right', offset=(60, 0))\n\npar1.axis['right'].toggle(all=True)\npar2.axis['right'].toggle(all=True)\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label='Density')\np2, = par1.plot([0, 1, 2], [0, 3, 2], label='Temperature')\np3, = par2.plot([0, 1, 2], [50, 30, 15], label='Velocity')\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density')\npar1.set(ylim=(0, 4), ylabel='Temperature')\npar2.set(ylim=(1, 65), ylabel='Velocity')\n\nhost.legend()\n\nhost.axis['left'].label.set_color(p1.get_color())\npar1.axis['right'].label.set_color(p2.get_color())\npar2.axis['right'].label.set_color(p3.get_color())\n\nplt.show()\n",
    "id": 186
},
{
    "title": "Ticklabel alignment",
    "text": "Download Python source code: demo_ticklabel_alignment.py Download Jupyter notebook: demo_ticklabel_alignment.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8], labels=['short', 'loooong'])\n    ax.set_xticks([0.2, 0.8], labels=[r'$\\\\frac{1}{2}\\\\pi$', r'$\\\\pi$'])\n    return ax\n\n\nfig = plt.figure(figsize=(3, 5))\nfig.subplots_adjust(left=0.5, hspace=0.7)\n\nax = setup_axes(fig, 311)\nax.set_ylabel('ha=right')\nax.set_xlabel('va=baseline')\n\nax = setup_axes(fig, 312)\nax.axis['left'].major_ticklabels.set_ha('center')\nax.axis['bottom'].major_ticklabels.set_va('top')\nax.set_ylabel('ha=center')\nax.set_xlabel('va=top')\n\nax = setup_axes(fig, 313)\nax.axis['left'].major_ticklabels.set_ha('left')\nax.axis['bottom'].major_ticklabels.set_va('bottom')\nax.set_ylabel('ha=left')\nax.set_xlabel('va=bottom')\n\nplt.show()\n",
    "id": 187
},
{
    "title": "Ticklabel direction",
    "text": "Download Python source code: demo_ticklabel_direction.py Download Jupyter notebook: demo_ticklabel_direction.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist.axislines as axislines\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axislines.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(6, 3))\nfig.subplots_adjust(bottom=0.2)\n\nax = setup_axes(fig, 131)\nfor axis in ax.axis.values():\n    axis.major_ticks.set_tick_out(True)\n# or you can simply do 'ax.axis[:].major_ticks.set_tick_out(True)'\n\nax = setup_axes(fig, 132)\nax.axis['left'].set_axis_direction('right')\nax.axis['bottom'].set_axis_direction('top')\nax.axis['right'].set_axis_direction('left')\nax.axis['top'].set_axis_direction('bottom')\n\nax = setup_axes(fig, 133)\nax.axis['left'].set_axis_direction('right')\nax.axis[:].major_ticks.set_tick_out(True)\n\nax.axis['left'].label.set_text('Long Label Left')\nax.axis['bottom'].label.set_text('Label Bottom')\nax.axis['right'].label.set_text('Long Label Right')\nax.axis['right'].label.set_visible(True)\nax.axis['left'].label.set_pad(0)\nax.axis['bottom'].label.set_pad(10)\n\nplt.show()\n",
    "id": 188
},
{
    "title": "Simple axis direction",
    "text": "Download Python source code: simple_axis_direction01.py Download Jupyter notebook: simple_axis_direction01.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\nfig = plt.figure(figsize=(4, 2.5))\nax1 = fig.add_subplot(axes_class=axisartist.Axes)\nfig.subplots_adjust(right=0.8)\n\nax1.axis['left'].major_ticklabels.set_axis_direction('top')\nax1.axis['left'].label.set_text('Left label')\n\nax1.axis['right'].label.set_visible(True)\nax1.axis['right'].label.set_text('Right label')\nax1.axis['right'].label.set_axis_direction('left')\n\nplt.show()\n",
    "id": 189
},
{
    "title": "Simple axis tick label and tick directions",
    "text": "First subplot moves the tick labels to inside the spines.\nSecond subplot moves the ticks to inside the spines.\nThese effects can be obtained for a standard Axes by tick_params.",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(5, 2))\nfig.subplots_adjust(wspace=0.4, bottom=0.3)\n\nax1 = setup_axes(fig, 121)\nax1.set_xlabel('ax1 X-label')\nax1.set_ylabel('ax1 Y-label')\n\nax1.axis[:].invert_ticklabel_direction()\n\nax2 = setup_axes(fig, 122)\nax2.set_xlabel('ax2 X-label')\nax2.set_ylabel('ax2 Y-label')\n\nax2.axis[:].major_ticks.set_tick_out(False)\n\nplt.show()\n",
    "id": 190
},
{
    "title": "Simple Axis Pad",
    "text": "Download Python source code: simple_axis_pad.py Download Jupyter notebook: simple_axis_pad.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    '''Polar projection, but in a rectangular box.'''\n\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform()\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    grid_locator2 = grid_finder.MaxNLocator(5)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        grid_locator2=grid_locator2,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper)\n    ax1.axis[:].set_visible(False)\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    return ax1\n\n\ndef add_floating_axis1(ax1):\n    ax1.axis['lat'] = axis = ax1.new_floating_axis(0, 30)\n    axis.label.set_text(r'$\\\\theta = 30^{\\\\circ}$')\n    axis.label.set_visible(True)\n\n    return axis\n\n\ndef add_floating_axis2(ax1):\n    ax1.axis['lon'] = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r'$r = 6$')\n    axis.label.set_visible(True)\n\n    return axis\n\n\nfig = plt.figure(figsize=(9, 3.))\nfig.subplots_adjust(left=0.01, right=0.99, bottom=0.01, top=0.99,\n                    wspace=0.01, hspace=0.01)\n\n\ndef ann(ax1, d):\n    if plt.rcParams['text.usetex']:\n        d = d.replace('_', r'\\\\_')\n\n    ax1.annotate(d, (0.5, 1), (5, -5),\n                 xycoords='axes fraction', textcoords='offset points',\n                 va='top', ha='center')\n\n\nax1 = setup_axes(fig, rect=141)\naxis = add_floating_axis1(ax1)\nann(ax1, r'default')\n\nax1 = setup_axes(fig, rect=142)\naxis = add_floating_axis1(ax1)\naxis.major_ticklabels.set_pad(10)\nann(ax1, r'ticklabels.set_pad(10)')\n\nax1 = setup_axes(fig, rect=143)\naxis = add_floating_axis1(ax1)\naxis.label.set_pad(20)\nann(ax1, r'label.set_pad(20)')\n\nax1 = setup_axes(fig, rect=144)\naxis = add_floating_axis1(ax1)\naxis.major_ticks.set_tick_out(True)\nann(ax1, 'ticks.set_tick_out(True)')\n\nplt.show()\n",
    "id": 191
},
{
    "title": "Custom spines with axisartist",
    "text": "This example showcases the use of axisartist to draw spines at custom\npositions (here, at y = 0). Note, however, that it is simpler to achieve this effect using standard\nSpine methods, as demonstrated in\nCentered spines with arrows.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits import axisartist\n\nfig = plt.figure(figsize=(6, 3), layout='constrained')\n# To construct axes of two different classes, we need to use gridspec (or\n# MATLAB-style add_subplot calls).\ngs = fig.add_gridspec(1, 2)\n\n\nax0 = fig.add_subplot(gs[0, 0], axes_class=axisartist.Axes)\n# Make a new axis along the first (x) axis which passes through y=0.\nax0.axis['y=0'] = ax0.new_floating_axis(nth_coord=0, value=0,\n                                        axis_direction='bottom')\nax0.axis['y=0'].toggle(all=True)\nax0.axis['y=0'].label.set_text('y = 0')\n# Make other axis invisible.\nax0.axis['bottom', 'top', 'right'].set_visible(False)\n\n\n# Alternatively, one can use AxesZero, which automatically sets up two\n# additional axis, named 'xzero' (the y=0 axis) and 'yzero' (the x=0 axis).\nax1 = fig.add_subplot(gs[0, 1], axes_class=axisartist.axislines.AxesZero)\n# 'xzero' and 'yzero' default to invisible; make xzero axis visible.\nax1.axis['xzero'].set_visible(True)\nax1.axis['xzero'].label.set_text('Axis Zero')\n# Make other axis invisible.\nax1.axis['bottom', 'top', 'right'].set_visible(False)\n\n\n# Draw some sample data.\nx = np.arange(0, 2*np.pi, 0.01)\nax0.plot(x, np.sin(x))\nax1.plot(x, np.sin(x))\n\nplt.show()\n",
    "id": 192
},
{
    "title": "Simple Axisline",
    "text": "Download Python source code: simple_axisline.py Download Jupyter notebook: simple_axisline.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nfig.subplots_adjust(right=0.85)\nax = fig.add_subplot(axes_class=AxesZero)\n\n# make right and top axis invisible\nax.axis['right'].set_visible(False)\nax.axis['top'].set_visible(False)\n\n# make xzero axis (horizontal axis line through y=0) visible.\nax.axis['xzero'].set_visible(True)\nax.axis['xzero'].label.set_text('Axis Zero')\n\nax.set_ylim(-2, 4)\nax.set_xlabel('Label X')\nax.set_ylabel('Label Y')\n# Or:\n# ax.axis['bottom'].label.set_text('Label X')\n# ax.axis['left'].label.set_text('Label Y')\n\n# make new (right-side) yaxis, but with some offset\nax.axis['right2'] = ax.new_fixed_axis(loc='right', offset=(20, 0))\nax.axis['right2'].label.set_text('Label Y2')\n\nax.plot([-2, 3, 2])\nplt.show()\n",
    "id": 193
},
{
    "title": "Simple Axisline3",
    "text": "Download Python source code: simple_axisline3.py Download Jupyter notebook: simple_axisline3.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import Axes\n\nfig = plt.figure(figsize=(3, 3))\n\nax = fig.add_subplot(axes_class=Axes)\n\nax.axis['right'].set_visible(False)\nax.axis['top'].set_visible(False)\n\nplt.show()\n",
    "id": 194
},
{
    "title": "Anatomy of a figure",
    "text": "This figure shows the name of several matplotlib elements composing a figure References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.axes.Axes.text matplotlib.axis.Axis.set_minor_formatter matplotlib.axis.Axis.set_major_locator matplotlib.axis.Axis.set_minor_locator matplotlib.patches.Circle matplotlib.patheffects.withStroke matplotlib.ticker.FuncFormatter",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle\nfrom matplotlib.patheffects import withStroke\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nroyal_blue = [0, 20/256, 82/256]\n\n\n# make the figure\n\nnp.random.seed(19680801)\n\nX = np.linspace(0.5, 3.5, 100)\nY1 = 3+np.cos(X)\nY2 = 1+np.cos(1+X/0.75)/2\nY3 = np.random.uniform(Y1, Y2, len(X))\n\nfig = plt.figure(figsize=(7.5, 7.5))\nax = fig.add_axes([0.2, 0.17, 0.68, 0.7], aspect=1)\n\nax.xaxis.set_major_locator(MultipleLocator(1.000))\nax.xaxis.set_minor_locator(AutoMinorLocator(4))\nax.yaxis.set_major_locator(MultipleLocator(1.000))\nax.yaxis.set_minor_locator(AutoMinorLocator(4))\nax.xaxis.set_minor_formatter('{x:.2f}')\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nax.tick_params(which='major', width=1.0, length=10, labelsize=14)\nax.tick_params(which='minor', width=1.0, length=5, labelsize=10,\n               labelcolor='0.25')\n\nax.grid(linestyle='--', linewidth=0.5, color='.25', zorder=-10)\n\nax.plot(X, Y1, c='C0', lw=2.5, label='Blue signal', zorder=10)\nax.plot(X, Y2, c='C1', lw=2.5, label='Orange signal')\nax.plot(X[::3], Y3[::3], linewidth=0, markersize=9,\n        marker='s', markerfacecolor='none', markeredgecolor='C4',\n        markeredgewidth=2.5)\n\nax.set_title('Anatomy of a figure', fontsize=20, verticalalignment='bottom')\nax.set_xlabel('x Axis label', fontsize=14)\nax.set_ylabel('y Axis label', fontsize=14)\nax.legend(loc='upper right', fontsize=14)\n\n\n# Annotate the figure\n\ndef annotate(x, y, text, code):\n    # Circle marker\n    c = Circle((x, y), radius=0.15, clip_on=False, zorder=10, linewidth=2.5,\n               edgecolor=royal_blue + [0.6], facecolor='none',\n               path_effects=[withStroke(linewidth=7, foreground='white')])\n    ax.add_artist(c)\n\n    # use path_effects as a background for the texts\n    # draw the path_effects and the colored text separately so that the\n    # path_effects cannot clip other texts\n    for path_effects in [[withStroke(linewidth=7, foreground='white')], []]:\n        color = 'white' if path_effects else royal_blue\n        ax.text(x, y-0.2, text, zorder=100,\n                ha='center', va='top', weight='bold', color=color,\n                style='italic', fontfamily='monospace',\n                path_effects=path_effects)\n\n        color = 'white' if path_effects else 'black'\n        ax.text(x, y-0.33, code, zorder=100,\n                ha='center', va='top', weight='normal', color=color,\n                fontfamily='monospace', fontsize='medium',\n                path_effects=path_effects)\n\n\nannotate(3.5, -0.13, 'Minor tick label', 'ax.xaxis.set_minor_formatter')\nannotate(-0.03, 1.0, 'Major tick', 'ax.yaxis.set_major_locator')\nannotate(0.00, 3.75, 'Minor tick', 'ax.yaxis.set_minor_locator')\nannotate(-0.15, 3.00, 'Major tick label', 'ax.yaxis.set_major_formatter')\nannotate(1.68, -0.39, 'xlabel', 'ax.set_xlabel')\nannotate(-0.38, 1.67, 'ylabel', 'ax.set_ylabel')\nannotate(1.52, 4.15, 'Title', 'ax.set_title')\nannotate(1.75, 2.80, 'Line', 'ax.plot')\nannotate(2.25, 1.54, 'Markers', 'ax.scatter')\nannotate(3.00, 3.00, 'Grid', 'ax.grid')\nannotate(3.60, 3.58, 'Legend', 'ax.legend')\nannotate(2.5, 0.55, 'Axes', 'fig.subplots')\nannotate(4, 4.5, 'Figure', 'plt.figure')\nannotate(0.65, 0.01, 'x Axis', 'ax.xaxis')\nannotate(0, 0.36, 'y Axis', 'ax.yaxis')\nannotate(4.0, 0.7, 'Spine', 'ax.spines')\n\n# frame around figure\nfig.patch.set(linewidth=4, edgecolor='0.5')\nplt.show()\n",
    "id": 195
},
{
    "title": "Firefox",
    "text": "This example shows how to create the Firefox logo with path and patches.",
    "code": "import re\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\n\n# From: https://dmitrybaranovskiy.github.io/raphael/icons/#firefox\nfirefox = 'M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68,1.86c-2.274-0.528-3.433-0.261-3.423-0.248c0.013,0.015,3.384,0.589,3.981,1.411c0,0-1.431,0-2.856,0.41c-0.065,0.019,5.242,0.663,6.327,5.966c0,0-0.582-1.213-1.301-1.42c0.473,1.439,0.351,4.17-0.1,5.528c-0.058,0.174-0.118-0.755-1.004-1.155c0.284,2.037-0.018,5.268-1.432,6.158c-0.109,0.07,0.887-3.189,0.201-1.93c-4.093,6.276-8.959,2.539-10.934,1.208c1.585,0.388,3.267,0.108,4.242-0.559c0.982-0.672,1.564-1.162,2.087-1.047c0.522,0.117,0.87-0.407,0.464-0.872c-0.405-0.466-1.392-1.105-2.725-0.757c-0.94,0.247-2.107,1.287-3.886,0.233c-1.518-0.899-1.507-1.63-1.507-2.095c0-0.366,0.257-0.88,0.734-1.028c0.58,0.062,1.044,0.214,1.537,0.466c0.005-0.135,0.006-0.315-0.001-0.519c0.039-0.077,0.015-0.311-0.047-0.596c-0.036-0.287-0.097-0.582-0.19-0.851c0.01-0.002,0.017-0.007,0.021-0.021c0.076-0.344,2.147-1.544,2.299-1.659c0.153-0.114,0.55-0.378,0.506-1.183c-0.015-0.265-0.058-0.294-2.232-0.286c-0.917,0.003-1.425-0.894-1.589-1.245c0.222-1.231,0.863-2.11,1.919-2.704c0.02-0.011,0.015-0.021-0.008-0.027c0.219-0.127-2.524-0.006-3.76,1.604C9.674,8.045,9.219,7.95,8.71,7.95c-0.638,0-1.139,0.07-1.603,0.187c-0.05,0.013-0.122,0.011-0.208-0.001C6.769,8.04,6.575,7.88,6.365,7.672c0.161-0.18,0.324-0.356,0.495-0.526C9.201,4.804,12.43,3.357,16.002,3.356z'  # noqa\n\n\ndef svg_parse(path):\n    commands = {'M': (Path.MOVETO,),\n                'L': (Path.LINETO,),\n                'Q': (Path.CURVE3,)*2,\n                'C': (Path.CURVE4,)*3,\n                'Z': (Path.CLOSEPOLY,)}\n    vertices = []\n    codes = []\n    cmd_values = re.split('([A-Za-z])', path)[1:]  # Split over commands.\n    for cmd, values in zip(cmd_values[::2], cmd_values[1::2]):\n        # Numbers are separated either by commas, or by +/- signs (but not at\n        # the beginning of the string).\n        points = ([*map(float, re.split(',|(?<!^)(?=[+-])', values))] if values\n                  else [(0., 0.)])  # Only for 'z/Z' (CLOSEPOLY).\n        points = np.reshape(points, (-1, 2))\n        if cmd.islower():\n            points += vertices[-1][-1]\n        codes.extend(commands[cmd.upper()])\n        vertices.append(points)\n    return np.array(codes), np.concatenate(vertices)\n\n\n# SVG to Matplotlib\ncodes, verts = svg_parse(firefox)\npath = Path(verts, codes)\n\nxmin, ymin = verts.min(axis=0) - 1\nxmax, ymax = verts.max(axis=0) + 1\n\nfig = plt.figure(figsize=(5, 5), facecolor='0.75')  # gray background\nax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1,\n                  xlim=(xmin, xmax),  # centering\n                  ylim=(ymax, ymin),  # centering, upside down\n                  xticks=[], yticks=[])  # no ticks\n\n# White outline (width = 6)\nax.add_patch(patches.PathPatch(path, facecolor='none', edgecolor='w', lw=6))\n# Actual shape with black outline\nax.add_patch(patches.PathPatch(path, facecolor='orange', edgecolor='k', lw=2))\n\nplt.show()  # Display\n",
    "id": 196
},
{
    "title": "Integral as the area under a curve",
    "text": "Although this is a simple example, it demonstrates some important tweaks: A simple line plot with custom color and line width. A shaded region created using a Polygon patch. A text label with mathtext rendering. figtext calls to label the x- and y-axes. Use of axis spines to hide the top and right spines. Custom tick placement and labels.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef func(x):\n    return (x - 3) * (x - 5) * (x - 7) + 85\n\n\na, b = 2, 9  # integral limits\nx = np.linspace(0, 10)\ny = func(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y, 'r', linewidth=2)\nax.set_ylim(bottom=0)\n\n# Make the shaded region\nix = np.linspace(a, b)\niy = func(ix)\nverts = [(a, 0), *zip(ix, iy), (b, 0)]\npoly = Polygon(verts, facecolor='0.9', edgecolor='0.5')\nax.add_patch(poly)\n\nax.text(0.5 * (a + b), 30, r'$\\\\int_a^b f(x)\\\\mathrm{d}x$',\n        horizontalalignment='center', fontsize=20)\n\nfig.text(0.9, 0.05, '$x$')\nfig.text(0.1, 0.9, '$y$')\n\nax.spines[['top', 'right']].set_visible(False)\nax.set_xticks([a, b], labels=['$a$', '$b$'])\nax.set_yticks([])\n\nplt.show()\n",
    "id": 197
},
{
    "title": "Shaded & power normalized rendering",
    "text": "The Mandelbrot set rendering can be improved by using a normalized recount\nassociated with a power normalized colormap (gamma=0.3). Rendering can be\nfurther enhanced thanks to shading. The maxiter gives the precision of the computation. maxiter=200 should\ntake a few seconds on most modern laptops. Total running time of the script: (0 minutes 3.134 seconds)",
    "code": "import numpy as np\n\n\ndef mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n    X = np.linspace(xmin, xmax, xn).astype(np.float32)\n    Y = np.linspace(ymin, ymax, yn).astype(np.float32)\n    C = X + Y[:, None] * 1j\n    N = np.zeros_like(C, dtype=int)\n    Z = np.zeros_like(C)\n    for n in range(maxiter):\n        I = abs(Z) < horizon\n        N[I] = n\n        Z[I] = Z[I]**2 + C[I]\n    N[N == maxiter-1] = 0\n    return Z, N\n\n\nif __name__ == '__main__':\n    import time\n\n    import matplotlib.pyplot as plt\n\n    import matplotlib\n    from matplotlib import colors\n\n    xmin, xmax, xn = -2.25, +0.75, 3000 // 2\n    ymin, ymax, yn = -1.25, +1.25, 2500 // 2\n    maxiter = 200\n    horizon = 2.0 ** 40\n    log_horizon = np.log2(np.log(horizon))\n    Z, N = mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon)\n\n    # Normalized recount as explained in:\n    # https://linas.org/art-gallery/escape/smooth.html\n    # https://web.archive.org/web/20160331171238/https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en\n\n    # This line will generate warnings for null values, but it is faster to\n    # process them afterwards using the nan_to_num\n    with np.errstate(invalid='ignore'):\n        M = np.nan_to_num(N + 1 - np.log2(np.log(abs(Z))) + log_horizon)\n\n    dpi = 72\n    width = 10\n    height = 10*yn/xn\n    fig = plt.figure(figsize=(width, height), dpi=dpi)\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1)\n\n    # Shaded rendering\n    light = colors.LightSource(azdeg=315, altdeg=10)\n    M = light.shade(M, cmap=plt.cm.hot, vert_exag=1.5,\n                    norm=colors.PowerNorm(0.3), blend_mode='hsv')\n    ax.imshow(M, extent=[xmin, xmax, ymin, ymax], interpolation='bicubic')\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Some advertisement for matplotlib\n    year = time.strftime('%Y')\n    text = ('The Mandelbrot fractal set\\\n'\n            'Rendered with matplotlib %s, %s - https://matplotlib.org'\n            % (matplotlib.__version__, year))\n    ax.text(xmin+.025, ymin+.025, text, color='white', fontsize=12, alpha=0.5)\n\n    plt.show()\n",
    "id": 198
},
{
    "title": "Stock prices over 32 years",
    "text": "A graph of multiple time series that demonstrates custom styling of plot frame,\ntick lines, tick labels, and line graph properties. It also uses custom\nplacement of text labels along the right edge as an alternative to a\nconventional legend. Note: The third-party mpl style dufte produces similar-looking plots with less\ncode. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axes.Axes.text matplotlib.axis.XAxis.tick_bottom matplotlib.axis.YAxis.tick_left matplotlib.artist.Artist.set_visible Total running time of the script: (0 minutes 1.298 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nimport matplotlib.transforms as mtransforms\n\nwith get_sample_data('Stocks.csv') as file:\n    stock_data = np.genfromtxt(\n        file, delimiter=',', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 8), layout='constrained')\n\n# These are the colors that will be used in the plot\nax.set_prop_cycle(color=[\n    '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a',\n    '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94',\n    '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d',\n    '#17becf', '#9edae5'])\n\nstocks_name = ['IBM', 'Apple', 'Microsoft', 'Xerox', 'Amazon', 'Dell',\n               'Alphabet', 'Adobe', 'S&P 500', 'NASDAQ']\nstocks_ticker = ['IBM', 'AAPL', 'MSFT', 'XRX', 'AMZN', 'DELL', 'GOOGL',\n                 'ADBE', 'GSPC', 'IXIC']\n\n# Manually adjust the label positions vertically (units are points = 1/72 inch)\ny_offsets = {k: 0 for k in stocks_ticker}\ny_offsets['IBM'] = 5\ny_offsets['AAPL'] = -5\ny_offsets['AMZN'] = -6\n\nfor nn, column in enumerate(stocks_ticker):\n    # Plot each line separately with its own color.\n    # don't include any data with NaN.\n    good = np.nonzero(np.isfinite(stock_data[column]))\n    line, = ax.plot(stock_data['Date'][good], stock_data[column][good], lw=2.5)\n\n    # Add a text label to the right end of every line. Most of the code below\n    # is adding specific offsets y position because some labels overlapped.\n    y_pos = stock_data[column][-1]\n\n    # Use an offset transform, in points, for any text that needs to be nudged\n    # up or down.\n    offset = y_offsets[column] / 72\n    trans = mtransforms.ScaledTranslation(0, offset, fig.dpi_scale_trans)\n    trans = ax.transData + trans\n\n    # Again, make sure that all labels are large enough to be easily read\n    # by the viewer.\n    ax.text(np.datetime64('2022-10-01'), y_pos, stocks_name[nn],\n            color=line.get_color(), transform=trans)\n\nax.set_xlim(np.datetime64('1989-06-01'), np.datetime64('2023-01-01'))\n\nfig.suptitle('Technology company stocks prices dollars (1990-2022)',\n             ha='center')\n\n# Remove the plot frame lines. They are unnecessary here.\nax.spines[:].set_visible(False)\n\n# Ensure that the axis ticks only show up on the bottom and left of the plot.\n# Ticks on the right and top of the plot are generally unnecessary.\nax.xaxis.tick_bottom()\nax.yaxis.tick_left()\nax.set_yscale('log')\n\n# Provide tick lines across the plot to help your viewers trace along\n# the axis ticks. Make sure that the lines are light and small so they\n# don't obscure the primary data lines.\nax.grid(True, 'major', 'both', ls='--', lw=.5, c='k', alpha=.3)\n\n# Remove the tick marks; they are unnecessary with the tick lines we just\n# plotted. Make sure your axis ticks are large enough to be easily read.\n# You don't want your viewers squinting to read your plot.\nax.tick_params(axis='both', which='both', labelsize='large',\n               bottom=False, top=False, labelbottom=True,\n               left=False, right=False, labelleft=True)\n\n# Finally, save the figure as a PNG.\n# You can also save it as a PDF, JPEG, etc.\n# Just change the file extension in this call.\n# fig.savefig('stock-prices.png', bbox_inches='tight')\nplt.show()\n",
    "id": 199
},
{
    "title": "Decay",
    "text": "This example showcases: using a generator to drive an animation, changing axes limits during an animation. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 8.094 seconds)",
    "code": "import itertools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n\ndef data_gen():\n    for cnt in itertools.count():\n        t = cnt / 10\n        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)\n\n\ndef init():\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_xlim(0, 1)\n    del xdata[:]\n    del ydata[:]\n    line.set_data(xdata, ydata)\n    return line,\n\nfig, ax = plt.subplots()\nline, = ax.plot([], [], lw=2)\nax.grid()\nxdata, ydata = [], []\n\n\ndef run(data):\n    # update the data\n    t, y = data\n    xdata.append(t)\n    ydata.append(y)\n    xmin, xmax = ax.get_xlim()\n\n    if t >= xmax:\n        ax.set_xlim(xmin, 2*xmax)\n        ax.figure.canvas.draw()\n    line.set_data(xdata, ydata)\n\n    return line,\n\n# Only save last 100 frames, but run forever\nani = animation.FuncAnimation(fig, run, data_gen, interval=100, init_func=init,\n                              save_count=100)\nplt.show()\n",
    "id": 200
},
{
    "title": "pyplot animation",
    "text": "Generating an animation by calling pause between plotting commands. The method shown here is only suitable for simple, low-performance use. For\nmore demanding applications, look at the animation module and the\nexamples that use it. Note that calling time.sleep instead of pause would not work. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 7.753 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\ndata = np.random.random((50, 50, 50))\n\nfig, ax = plt.subplots()\n\nfor i, img in enumerate(data):\n    ax.clear()\n    ax.imshow(img)\n    ax.set_title(f'frame {i}')\n    # Note that using time.sleep does *not* work here!\n    plt.pause(0.1)\n",
    "id": 201
},
{
    "title": "The Bayes update",
    "text": "This animation displays the posterior estimate updates as it is refitted when\nnew data arrives.\nThe vertical line represents the theoretical value to which the plotted\ndistribution should converge. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.905 seconds)",
    "code": "import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.animation import FuncAnimation\n\n\ndef beta_pdf(x, a, b):\n    return (x**(a-1) * (1-x)**(b-1) * math.gamma(a + b)\n            / (math.gamma(a) * math.gamma(b)))\n\n\nclass UpdateDist:\n    def __init__(self, ax, prob=0.5):\n        self.success = 0\n        self.prob = prob\n        self.line, = ax.plot([], [], 'k-')\n        self.x = np.linspace(0, 1, 200)\n        self.ax = ax\n\n        # Set up plot parameters\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 10)\n        self.ax.grid(True)\n\n        # This vertical line represents the theoretical value, to\n        # which the plotted distribution should converge.\n        self.ax.axvline(prob, linestyle='--', color='black')\n\n    def __call__(self, i):\n        # This way the plot can continuously run and we just keep\n        # watching new realizations of the process\n        if i == 0:\n            self.success = 0\n            self.line.set_data([], [])\n            return self.line,\n\n        # Choose success based on exceed a threshold with a uniform pick\n        if np.random.rand() < self.prob:\n            self.success += 1\n        y = beta_pdf(self.x, self.success + 1, (i - self.success) + 1)\n        self.line.set_data(self.x, y)\n        return self.line,\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nud = UpdateDist(ax, prob=0.7)\nanim = FuncAnimation(fig, ud, frames=100, interval=100, blit=True)\nplt.show()\n",
    "id": 202
},
{
    "title": "The double pendulum problem",
    "text": "This animation illustrates the double pendulum problem. Double pendulum formula translated from the C code at\nhttp://www.physics.usyd.edu.au/~wheat/dpend_html/solve_dpend.c Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 17.031 seconds)",
    "code": "from collections import deque\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import cos, sin\n\nimport matplotlib.animation as animation\n\nG = 9.8  # acceleration due to gravity, in m/s^2\nL1 = 1.0  # length of pendulum 1 in m\nL2 = 1.0  # length of pendulum 2 in m\nL = L1 + L2  # maximal length of the combined pendulum\nM1 = 1.0  # mass of pendulum 1 in kg\nM2 = 1.0  # mass of pendulum 2 in kg\nt_stop = 2.5  # how many seconds to simulate\nhistory_len = 500  # how many trajectory points to display\n\n\ndef derivs(t, state):\n    dydx = np.zeros_like(state)\n\n    dydx[0] = state[1]\n\n    delta = state[2] - state[0]\n    den1 = (M1+M2) * L1 - M2 * L1 * cos(delta) * cos(delta)\n    dydx[1] = ((M2 * L1 * state[1] * state[1] * sin(delta) * cos(delta)\n                + M2 * G * sin(state[2]) * cos(delta)\n                + M2 * L2 * state[3] * state[3] * sin(delta)\n                - (M1+M2) * G * sin(state[0]))\n               / den1)\n\n    dydx[2] = state[3]\n\n    den2 = (L2/L1) * den1\n    dydx[3] = ((- M2 * L2 * state[3] * state[3] * sin(delta) * cos(delta)\n                + (M1+M2) * G * sin(state[0]) * cos(delta)\n                - (M1+M2) * L1 * state[1] * state[1] * sin(delta)\n                - (M1+M2) * G * sin(state[2]))\n               / den2)\n\n    return dydx\n\n# create a time array from 0..t_stop sampled at 0.02 second steps\ndt = 0.01\nt = np.arange(0, t_stop, dt)\n\n# th1 and th2 are the initial angles (degrees)\n# w10 and w20 are the initial angular velocities (degrees per second)\nth1 = 120.0\nw1 = 0.0\nth2 = -10.0\nw2 = 0.0\n\n# initial state\nstate = np.radians([th1, w1, th2, w2])\n\n# integrate the ODE using Euler's method\ny = np.empty((len(t), 4))\ny[0] = state\nfor i in range(1, len(t)):\n    y[i] = y[i - 1] + derivs(t[i - 1], y[i - 1]) * dt\n\n# A more accurate estimate could be obtained e.g. using scipy:\n#\n#   y = scipy.integrate.solve_ivp(derivs, t[[0, -1]], state, t_eval=t).y.T\n\nx1 = L1*sin(y[:, 0])\ny1 = -L1*cos(y[:, 0])\n\nx2 = L2*sin(y[:, 2]) + x1\ny2 = -L2*cos(y[:, 2]) + y1\n\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(autoscale_on=False, xlim=(-L, L), ylim=(-L, 1.))\nax.set_aspect('equal')\nax.grid()\n\nline, = ax.plot([], [], 'o-', lw=2)\ntrace, = ax.plot([], [], '.-', lw=1, ms=2)\ntime_template = 'time = %.1fs'\ntime_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)\nhistory_x, history_y = deque(maxlen=history_len), deque(maxlen=history_len)\n\n\ndef animate(i):\n    thisx = [0, x1[i], x2[i]]\n    thisy = [0, y1[i], y2[i]]\n\n    if i == 0:\n        history_x.clear()\n        history_y.clear()\n\n    history_x.appendleft(thisx[2])\n    history_y.appendleft(thisy[2])\n\n    line.set_data(thisx, thisy)\n    trace.set_data(history_x, history_y)\n    time_text.set_text(time_template % (i*dt))\n    return line, trace, time_text\n\n\nani = animation.FuncAnimation(\n    fig, animate, len(y), interval=dt*1000, blit=True)\nplt.show()\n",
    "id": 203
},
{
    "title": "Animated image using a precomputed list of images",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.011 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\n\ndef f(x, y):\n    return np.sin(x) + np.cos(y)\n\nx = np.linspace(0, 2 * np.pi, 120)\ny = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)\n\n# ims is a list of lists, each row is a list of artists to draw in the\n# current frame; here we are just animating one artist, the image, in\n# each frame\nims = []\nfor i in range(60):\n    x += np.pi / 15\n    y += np.pi / 30\n    im = ax.imshow(f(x, y), animated=True)\n    if i == 0:\n        ax.imshow(f(x, y))  # show an initial one first\n    ims.append([im])\n\nani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,\n                                repeat_delay=1000)\n\n# To save the animation, use e.g.\n#\n# ani.save('movie.mp4')\n#\n# or\n#\n# writer = animation.FFMpegWriter(\n#     fps=15, metadata=dict(artist='Me'), bitrate=1800)\n# ani.save('movie.mp4', writer=writer)\n\nplt.show()\n",
    "id": 204
},
{
    "title": "Frame grabbing",
    "text": "Use a MovieWriter directly to grab individual frames and write them to a\nfile. This avoids any event loop integration, and thus works even with the Agg\nbackend. This is not recommended for use in an interactive setting. Output generated via matplotlib.animation.Animation.to_jshtml.",
    "code": "import numpy as np\n\nimport matplotlib\n\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.animation import FFMpegWriter\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nmetadata = dict(title='Movie Test', artist='Matplotlib',\n                comment='Movie support!')\nwriter = FFMpegWriter(fps=15, metadata=metadata)\n\nfig = plt.figure()\nl, = plt.plot([], [], 'k-o')\n\nplt.xlim(-5, 5)\nplt.ylim(-5, 5)\n\nx0, y0 = 0, 0\n\nwith writer.saving(fig, 'writer_test.mp4', 100):\n    for i in range(100):\n        x0 += 0.1 * np.random.randn()\n        y0 += 0.1 * np.random.randn()\n        l.set_data(x0, y0)\n        writer.grab_frame()\n",
    "id": 205
},
{
    "title": "Multiple axes animation",
    "text": "This example showcases: how animation across multiple subplots works, using a figure artist in the animation. Output generated via matplotlib.animation.Animation.to_jshtml. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.ConnectionPatch matplotlib.animation.FuncAnimation Total running time of the script: (0 minutes 2.845 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\nfrom matplotlib.patches import ConnectionPatch\n\nfig, (axl, axr) = plt.subplots(\n    ncols=2,\n    sharey=True,\n    figsize=(6, 2),\n    gridspec_kw=dict(width_ratios=[1, 3], wspace=0),\n)\naxl.set_aspect(1)\naxr.set_box_aspect(1 / 3)\naxr.yaxis.set_visible(False)\naxr.xaxis.set_ticks([0, np.pi, 2 * np.pi], ['0', r'$\\\\pi$', r'$2\\\\pi$'])\n\n# draw circle with initial point in left Axes\nx = np.linspace(0, 2 * np.pi, 50)\naxl.plot(np.cos(x), np.sin(x), 'k', lw=0.3)\npoint, = axl.plot(0, 0, 'o')\n\n# draw full curve to set view limits in right Axes\nsine, = axr.plot(x, np.sin(x))\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (1, 0),\n    (0, 0),\n    'data',\n    'data',\n    axesA=axl,\n    axesB=axr,\n    color='C0',\n    ls='dotted',\n)\nfig.add_artist(con)\n\n\ndef animate(i):\n    x = np.linspace(0, i, int(i * 25 / np.pi))\n    sine.set_data(x, np.sin(x))\n    x, y = np.cos(i), np.sin(i)\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = i, y\n    return point, sine, con\n\n\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=50,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=x,\n    repeat_delay=100,\n)\n\nplt.show()\n",
    "id": 206
},
{
    "title": "Pausing and Resuming an Animation",
    "text": "This example showcases: using the Animation.pause() method to pause an animation. using the Animation.resume() method to resume an animation. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Output generated via matplotlib.animation.Animation.to_jshtml.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n\nclass PauseAnimation:\n    def __init__(self):\n        fig, ax = plt.subplots()\n        ax.set_title('Click to pause/resume the animation')\n        x = np.linspace(-0.1, 0.1, 1000)\n\n        # Start with a normal distribution\n        self.n0 = (1.0 / ((4 * np.pi * 2e-4 * 0.1) ** 0.5)\n                   * np.exp(-x ** 2 / (4 * 2e-4 * 0.1)))\n        self.p, = ax.plot(x, self.n0)\n\n        self.animation = animation.FuncAnimation(\n            fig, self.update, frames=200, interval=50, blit=True)\n        self.paused = False\n\n        fig.canvas.mpl_connect('button_press_event', self.toggle_pause)\n\n    def toggle_pause(self, *args, **kwargs):\n        if self.paused:\n            self.animation.resume()\n        else:\n            self.animation.pause()\n        self.paused = not self.paused\n\n    def update(self, i):\n        self.n0 += i / 100 % 5\n        self.p.set_ydata(self.n0 % 20)\n        return (self.p,)\n\n\npa = PauseAnimation()\nplt.show()\n",
    "id": 207
},
{
    "title": "Rain simulation",
    "text": "Simulates rain drops on a surface by animating the scale and opacity\nof 50 scatter points. Author: Nicolas P. Rougier Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 3.503 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.animation import FuncAnimation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# Create new Figure and an Axes which fills it.\nfig = plt.figure(figsize=(7, 7))\nax = fig.add_axes([0, 0, 1, 1], frameon=False)\nax.set_xlim(0, 1), ax.set_xticks([])\nax.set_ylim(0, 1), ax.set_yticks([])\n\n# Create rain data\nn_drops = 50\nrain_drops = np.zeros(n_drops, dtype=[('position', float, (2,)),\n                                      ('size',     float),\n                                      ('growth',   float),\n                                      ('color',    float, (4,))])\n\n# Initialize the raindrops in random positions and with\n# random growth rates.\nrain_drops['position'] = np.random.uniform(0, 1, (n_drops, 2))\nrain_drops['growth'] = np.random.uniform(50, 200, n_drops)\n\n# Construct the scatter which we will update during animation\n# as the raindrops develop.\nscat = ax.scatter(rain_drops['position'][:, 0], rain_drops['position'][:, 1],\n                  s=rain_drops['size'], lw=0.5, edgecolors=rain_drops['color'],\n                  facecolors='none')\n\n\ndef update(frame_number):\n    # Get an index which we can use to re-spawn the oldest raindrop.\n    current_index = frame_number % n_drops\n\n    # Make all colors more transparent as time progresses.\n    rain_drops['color'][:, 3] -= 1.0/len(rain_drops)\n    rain_drops['color'][:, 3] = np.clip(rain_drops['color'][:, 3], 0, 1)\n\n    # Make all circles bigger.\n    rain_drops['size'] += rain_drops['growth']\n\n    # Pick a new position for oldest rain drop, resetting its size,\n    # color and growth factor.\n    rain_drops['position'][current_index] = np.random.uniform(0, 1, 2)\n    rain_drops['size'][current_index] = 5\n    rain_drops['color'][current_index] = (0, 0, 0, 1)\n    rain_drops['growth'][current_index] = np.random.uniform(50, 200)\n\n    # Update the scatter collection, with the new colors, sizes and positions.\n    scat.set_edgecolors(rain_drops['color'])\n    scat.set_sizes(rain_drops['size'])\n    scat.set_offsets(rain_drops['position'])\n\n\n# Construct the animation, using the update function as the animation director.\nanimation = FuncAnimation(fig, update, interval=10, save_count=100)\nplt.show()\n",
    "id": 208
},
{
    "title": "Animated 3D random walk",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 3.220 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef random_walk(num_steps, max_step=0.05):\n    '''Return a 3D random walk as (num_steps, 3) array.'''\n    start_pos = np.random.random(3)\n    steps = np.random.uniform(-max_step, max_step, size=(num_steps, 3))\n    walk = start_pos + np.cumsum(steps, axis=0)\n    return walk\n\n\ndef update_lines(num, walks, lines):\n    for line, walk in zip(lines, walks):\n        # NOTE: there is no .set_data() for 3 dim data...\n        line.set_data(walk[:num, :2].T)\n        line.set_3d_properties(walk[:num, 2])\n    return lines\n\n\n# Data: 40 random walks as (num_steps, 3) arrays\nnum_steps = 30\nwalks = [random_walk(num_steps) for index in range(40)]\n\n# Attaching 3D axis to the figure\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create lines initially without data\nlines = [ax.plot([], [], [])[0] for _ in walks]\n\n# Setting the axes properties\nax.set(xlim3d=(0, 1), xlabel='X')\nax.set(ylim3d=(0, 1), ylabel='Y')\nax.set(zlim3d=(0, 1), zlabel='Z')\n\n# Creating the Animation object\nani = animation.FuncAnimation(\n    fig, update_lines, num_steps, fargs=(walks, lines), interval=100)\n\nplt.show()\n",
    "id": 209
},
{
    "title": "Animated line plot",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 3.379 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nx = np.arange(0, 2*np.pi, 0.01)\nline, = ax.plot(x, np.sin(x))\n\n\ndef animate(i):\n    line.set_ydata(np.sin(x + i / 50))  # update the data.\n    return line,\n\n\nani = animation.FuncAnimation(\n    fig, animate, interval=20, blit=True, save_count=50)\n\n# To save the animation, use e.g.\n#\n# ani.save('movie.mp4')\n#\n# or\n#\n# writer = animation.FFMpegWriter(\n#     fps=15, metadata=dict(artist='Me'), bitrate=1800)\n# ani.save('movie.mp4', writer=writer)\n\nplt.show()\n",
    "id": 210
},
{
    "title": "Animated scatter saved as GIF",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 2.912 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\nax.set_xlim([0, 10])\n\nscat = ax.scatter(1, 0)\nx = np.linspace(0, 10)\n\n\ndef animate(i):\n    scat.set_offsets((x[i], 0))\n    return scat,\n\nani = animation.FuncAnimation(fig, animate, repeat=True,\n                                    frames=len(x) - 1, interval=50)\n\n# To save the animation using Pillow as a gif\n# writer = animation.PillowWriter(fps=15,\n#                                 metadata=dict(artist='Me'),\n#                                 bitrate=1800)\n# ani.save('scatter.gif', writer=writer)\n\nplt.show()\n",
    "id": 211
},
{
    "title": "Oscilloscope",
    "text": "Emulates an oscilloscope. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 6.324 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\nfrom matplotlib.lines import Line2D\n\n\nclass Scope:\n    def __init__(self, ax, maxt=2, dt=0.02):\n        self.ax = ax\n        self.dt = dt\n        self.maxt = maxt\n        self.tdata = [0]\n        self.ydata = [0]\n        self.line = Line2D(self.tdata, self.ydata)\n        self.ax.add_line(self.line)\n        self.ax.set_ylim(-.1, 1.1)\n        self.ax.set_xlim(0, self.maxt)\n\n    def update(self, y):\n        lastt = self.tdata[-1]\n        if lastt >= self.tdata[0] + self.maxt:  # reset the arrays\n            self.tdata = [self.tdata[-1]]\n            self.ydata = [self.ydata[-1]]\n            self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)\n            self.ax.figure.canvas.draw()\n\n        # This slightly more complex calculation avoids floating-point issues\n        # from just repeatedly adding `self.dt` to the previous value.\n        t = self.tdata[0] + len(self.tdata) * self.dt\n\n        self.tdata.append(t)\n        self.ydata.append(y)\n        self.line.set_data(self.tdata, self.ydata)\n        return self.line,\n\n\ndef emitter(p=0.1):\n    '''Return a random value in [0, 1) with probability p, else 0.'''\n    while True:\n        v = np.random.rand()\n        if v > p:\n            yield 0.\n        else:\n            yield np.random.rand()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801 // 10)\n\n\nfig, ax = plt.subplots()\nscope = Scope(ax)\n\n# pass a generator in 'emitter' to produce data for the update func\nani = animation.FuncAnimation(fig, scope.update, emitter, interval=50,\n                              blit=True, save_count=100)\n\nplt.show()\n",
    "id": 212
},
{
    "title": "MATPLOTLIB UNCHAINED",
    "text": "Comparative path demonstration of frequency from a fake signal of a pulsar\n(mostly known because of the cover for Joy Division's Unknown Pleasures).\", 'Author: Nicolas P. Rougier Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.886 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# Create new Figure with black background\nfig = plt.figure(figsize=(8, 8), facecolor='black')\n\n# Add a subplot with no frame\nax = plt.subplot(frameon=False)\n\n# Generate random data\ndata = np.random.uniform(0, 1, (64, 75))\nX = np.linspace(-1, 1, data.shape[-1])\nG = 1.5 * np.exp(-4 * X ** 2)\n\n# Generate line plots\nlines = []\nfor i in range(len(data)):\n    # Small reduction of the X extents to get a cheap perspective effect\n    xscale = 1 - i / 200.\n    # Same for linewidth (thicker strokes on bottom)\n    lw = 1.5 - i / 100.0\n    line, = ax.plot(xscale * X, i + G * data[i], color='w', lw=lw)\n    lines.append(line)\n\n# Set y limit (or first line is cropped because of thickness)\nax.set_ylim(-1, 70)\n\n# No ticks\nax.set_xticks([])\nax.set_yticks([])\n\n# 2 part titles to get different font weights\nax.text(0.5, 1.0, 'MATPLOTLIB ', transform=ax.transAxes,\n        ha='right', va='bottom', color='w',\n        family='sans-serif', fontweight='light', fontsize=16)\nax.text(0.5, 1.0, 'UNCHAINED', transform=ax.transAxes,\n        ha='left', va='bottom', color='w',\n        family='sans-serif', fontweight='bold', fontsize=16)\n\n\ndef update(*args):\n    # Shift all data to the right\n    data[:, 1:] = data[:, :-1]\n\n    # Fill-in new values\n    data[:, 0] = np.random.uniform(0, 1, len(data))\n\n    # Update data\n    for i in range(len(data)):\n        lines[i].set_ydata(i + G * data[i])\n\n    # Return modified artists\n    return lines\n\n# Construct the animation, using the update function as the animation director.\nanim = animation.FuncAnimation(fig, update, interval=10, save_count=100)\nplt.show()\n",
    "id": 213
},
{
    "title": "Close Event",
    "text": "Example to show connecting events that occur when the figure closes. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\n\n\ndef on_close(event):\n    print('Closed Figure!')\n\nfig = plt.figure()\nfig.canvas.mpl_connect('close_event', on_close)\n\nplt.text(0.35, 0.5, 'Close Me!', dict(size=30))\nplt.show()\n",
    "id": 214
},
{
    "title": "Mouse move and click events",
    "text": "An example of how to interact with the plotting canvas by connecting to move\nand click events. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\n\nt = np.arange(0.0, 1.0, 0.01)\ns = np.sin(2 * np.pi * t)\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n\ndef on_move(event):\n    if event.inaxes:\n        print(f'data coords {event.xdata} {event.ydata},',\n              f'pixel coords {event.x} {event.y}')\n\n\ndef on_click(event):\n    if event.button is MouseButton.LEFT:\n        print('disconnecting callback')\n        plt.disconnect(binding_id)\n\n\nbinding_id = plt.connect('motion_notify_event', on_move)\nplt.connect('button_press_event', on_click)\n\nplt.show()\n",
    "id": 215
},
{
    "title": "Data browser",
    "text": "Connecting data between multiple canvases. This example covers how to interact data with multiple canvases. This\nlets you select and highlight a point on one axis, and generating the\ndata of that point on the other axis. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import numpy as np\n\n\nclass PointBrowser:\n    '''\n    Click on a point to select and highlight it -- the data that\n    generated the point will be shown in the lower axes.  Use the 'n'\n    and 'p' keys to browse through the next and previous points\n    '''\n\n    def __init__(self):\n        self.lastind = 0\n\n        self.text = ax.text(0.05, 0.95, 'selected: none',\n                            transform=ax.transAxes, va='top')\n        self.selected, = ax.plot([xs[0]], [ys[0]], 'o', ms=12, alpha=0.4,\n                                 color='yellow', visible=False)\n\n    def on_press(self, event):\n        if self.lastind is None:\n            return\n        if event.key not in ('n', 'p'):\n            return\n        if event.key == 'n':\n            inc = 1\n        else:\n            inc = -1\n\n        self.lastind += inc\n        self.lastind = np.clip(self.lastind, 0, len(xs) - 1)\n        self.update()\n\n    def on_pick(self, event):\n\n        if event.artist != line:\n            return True\n\n        N = len(event.ind)\n        if not N:\n            return True\n\n        # the click locations\n        x = event.mouseevent.xdata\n        y = event.mouseevent.ydata\n\n        distances = np.hypot(x - xs[event.ind], y - ys[event.ind])\n        indmin = distances.argmin()\n        dataind = event.ind[indmin]\n\n        self.lastind = dataind\n        self.update()\n\n    def update(self):\n        if self.lastind is None:\n            return\n\n        dataind = self.lastind\n\n        ax2.clear()\n        ax2.plot(X[dataind])\n\n        ax2.text(0.05, 0.9, f'mu={xs[dataind]:1.3f}\\\nsigma={ys[dataind]:1.3f}',\n                 transform=ax2.transAxes, va='top')\n        ax2.set_ylim(-0.5, 1.5)\n        self.selected.set_visible(True)\n        self.selected.set_data(xs[dataind], ys[dataind])\n\n        self.text.set_text('selected: %d' % dataind)\n        fig.canvas.draw()\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    X = np.random.rand(100, 200)\n    xs = np.mean(X, axis=1)\n    ys = np.std(X, axis=1)\n\n    fig, (ax, ax2) = plt.subplots(2, 1)\n    ax.set_title('click on point to plot time series')\n    line, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)\n\n    browser = PointBrowser()\n\n    fig.canvas.mpl_connect('pick_event', browser.on_pick)\n    fig.canvas.mpl_connect('key_press_event', browser.on_press)\n\n    plt.show()\n",
    "id": 216
},
{
    "title": "Figure/Axes enter and leave events",
    "text": "Illustrate the figure and Axes enter and leave events by changing the\nframe colors on enter and leave. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\n\n\ndef on_enter_axes(event):\n    print('enter_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('yellow')\n    event.canvas.draw()\n\n\ndef on_leave_axes(event):\n    print('leave_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('white')\n    event.canvas.draw()\n\n\ndef on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n\n\ndef on_leave_figure(event):\n    print('leave_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('grey')\n    event.canvas.draw()\n\n\nfig, axs = plt.subplots(2, 1)\nfig.suptitle('mouse hover over figure or axes to trigger events')\n\nfig.canvas.mpl_connect('figure_enter_event', on_enter_figure)\nfig.canvas.mpl_connect('figure_leave_event', on_leave_figure)\nfig.canvas.mpl_connect('axes_enter_event', on_enter_axes)\nfig.canvas.mpl_connect('axes_leave_event', on_leave_axes)\n\nplt.show()\n",
    "id": 217
},
{
    "title": "Scroll event",
    "text": "In this example a scroll wheel event is used to scroll through 2D slices of\n3D data. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass IndexTracker:\n    def __init__(self, ax, X):\n        self.index = 0\n        self.X = X\n        self.ax = ax\n        self.im = ax.imshow(self.X[:, :, self.index])\n        self.update()\n\n    def on_scroll(self, event):\n        print(event.button, event.step)\n        increment = 1 if event.button == 'up' else -1\n        max_index = self.X.shape[-1] - 1\n        self.index = np.clip(self.index + increment, 0, max_index)\n        self.update()\n\n    def update(self):\n        self.im.set_data(self.X[:, :, self.index])\n        self.ax.set_title(\n            f'Use scroll wheel to navigate\\\nindex {self.index}')\n        self.im.axes.figure.canvas.draw()\n\n\nx, y, z = np.ogrid[-10:10:100j, -10:10:100j, 1:10:20j]\nX = np.sin(x * y * z) / (x * y * z)\n\nfig, ax = plt.subplots()\n# create an IndexTracker and make sure it lives during the whole\n# lifetime of the figure by assigning it to a variable\ntracker = IndexTracker(ax, X)\n\nfig.canvas.mpl_connect('scroll_event', tracker.on_scroll)\nplt.show()\n",
    "id": 218
},
{
    "title": "Keypress event",
    "text": "Show how to connect to keypress events. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import sys\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef on_press(event):\n    print('press', event.key)\n    sys.stdout.flush()\n    if event.key == 'x':\n        visible = xl.get_visible()\n        xl.set_visible(not visible)\n        fig.canvas.draw()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nfig.canvas.mpl_connect('key_press_event', on_press)\n\nax.plot(np.random.rand(12), np.random.rand(12), 'go')\nxl = ax.set_xlabel('easy come, easy go')\nax.set_title('Press a key')\nplt.show()\n",
    "id": 219
},
{
    "title": "Lasso Demo",
    "text": "Use a lasso to select a set of points and get the indices of the selected points.\nA callback is used to change the color of the selected points. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors as mcolors\nfrom matplotlib import path\nfrom matplotlib.collections import RegularPolyCollection\nfrom matplotlib.widgets import Lasso\n\n\nclass LassoManager:\n    def __init__(self, ax, data):\n        # The information of whether a point has been selected or not is stored in the\n        # collection's array (0 = out, 1 = in), which then gets colormapped to blue\n        # (out) and red (in).\n        self.collection = RegularPolyCollection(\n            6, sizes=(100,), offset_transform=ax.transData,\n            offsets=data, array=np.zeros(len(data)),\n            clim=(0, 1), cmap=mcolors.ListedColormap(['tab:blue', 'tab:red']))\n        ax.add_collection(self.collection)\n        canvas = ax.figure.canvas\n        canvas.mpl_connect('button_press_event', self.on_press)\n        canvas.mpl_connect('button_release_event', self.on_release)\n\n    def callback(self, verts):\n        data = self.collection.get_offsets()\n        self.collection.set_array(path.Path(verts).contains_points(data))\n        canvas = self.collection.figure.canvas\n        canvas.draw_idle()\n        del self.lasso\n\n    def on_press(self, event):\n        canvas = self.collection.figure.canvas\n        if event.inaxes is not self.collection.axes or canvas.widgetlock.locked():\n            return\n        self.lasso = Lasso(event.inaxes, (event.xdata, event.ydata), self.callback)\n        canvas.widgetlock(self.lasso)  # acquire a lock on the widget drawing\n\n    def on_release(self, event):\n        canvas = self.collection.figure.canvas\n        if hasattr(self, 'lasso') and canvas.widgetlock.isowner(self.lasso):\n            canvas.widgetlock.release(self.lasso)\n\n\nif __name__ == '__main__':\n    np.random.seed(19680801)\n    ax = plt.figure().add_subplot(\n        xlim=(0, 1), ylim=(0, 1), title='Lasso points using left mouse button')\n    manager = LassoManager(ax, np.random.rand(100, 2))\n    plt.show()\n",
    "id": 220
},
{
    "title": "Legend picking",
    "text": "Enable picking on the legend to toggle the original line on and off Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 1)\ny1 = 2 * np.sin(2*np.pi*t)\ny2 = 4 * np.sin(2*np.pi*2*t)\n\nfig, ax = plt.subplots()\nax.set_title('Click on legend line to toggle line on/off')\nline1, = ax.plot(t, y1, lw=2, label='1 Hz')\nline2, = ax.plot(t, y2, lw=2, label='2 Hz')\nleg = ax.legend(fancybox=True, shadow=True)\n\nlines = [line1, line2]\nlined = {}  # Will map legend lines to original lines.\nfor legline, origline in zip(leg.get_lines(), lines):\n    legline.set_picker(True)  # Enable picking on the legend line.\n    lined[legline] = origline\n\n\ndef on_pick(event):\n    # On the pick event, find the original line corresponding to the legend\n    # proxy line, and toggle its visibility.\n    legline = event.artist\n    origline = lined[legline]\n    visible = not origline.get_visible()\n    origline.set_visible(visible)\n    # Change the alpha on the line in the legend, so we can see what lines\n    # have been toggled.\n    legline.set_alpha(1.0 if visible else 0.2)\n    fig.canvas.draw()\n\nfig.canvas.mpl_connect('pick_event', on_pick)\nplt.show()\n",
    "id": 221
},
{
    "title": "Looking Glass",
    "text": "Example using mouse events to simulate a looking glass for inspecting data. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx, y = np.random.rand(2, 200)\n\nfig, ax = plt.subplots()\ncirc = patches.Circle((0.5, 0.5), 0.25, alpha=0.8, fc='yellow')\nax.add_patch(circ)\n\n\nax.plot(x, y, alpha=0.2)\nline, = ax.plot(x, y, alpha=1.0, clip_path=circ)\nax.set_title('Left click and drag to move looking glass')\n\n\nclass EventHandler:\n    def __init__(self):\n        fig.canvas.mpl_connect('button_press_event', self.on_press)\n        fig.canvas.mpl_connect('button_release_event', self.on_release)\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n\n    def on_press(self, event):\n        if event.inaxes != ax:\n            return\n\n        if not circ.contains(event)[0]:\n            return\n\n        self.pressevent = event\n\n    def on_release(self, event):\n        self.pressevent = None\n        self.x0, self.y0 = circ.center\n\n    def on_move(self, event):\n        if self.pressevent is None or event.inaxes != self.pressevent.inaxes:\n            return\n\n        dx = event.xdata - self.pressevent.xdata\n        dy = event.ydata - self.pressevent.ydata\n        circ.center = self.x0 + dx, self.y0 + dy\n        line.set_clip_path(circ)\n        fig.canvas.draw()\n\nhandler = EventHandler()\nplt.show()\n",
    "id": 222
},
{
    "title": "Path editor",
    "text": "Sharing events across GUIs. This example demonstrates a cross-GUI application using Matplotlib event\nhandling to interact with and modify objects on the canvas. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nfig, ax = plt.subplots()\n\npathdata = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n]\n\ncodes, verts = zip(*pathdata)\npath = Path(verts, codes)\npatch = PathPatch(\n    path, facecolor='green', edgecolor='yellow', alpha=0.5)\nax.add_patch(patch)\n\n\nclass PathInteractor:\n    '''\n    A path editor.\n\n    Press 't' to toggle vertex markers on and off.  When vertex markers are on,\n    they can be dragged with the mouse.\n    '''\n\n    showverts = True\n    epsilon = 5  # max pixel distance to count as a vertex hit\n\n    def __init__(self, pathpatch):\n\n        self.ax = pathpatch.axes\n        canvas = self.ax.figure.canvas\n        self.pathpatch = pathpatch\n        self.pathpatch.set_animated(True)\n\n        x, y = zip(*self.pathpatch.get_path().vertices)\n\n        self.line, = ax.plot(\n            x, y, marker='o', markerfacecolor='r', animated=True)\n\n        self._ind = None  # the active vertex\n\n        canvas.mpl_connect('draw_event', self.on_draw)\n        canvas.mpl_connect('button_press_event', self.on_button_press)\n        canvas.mpl_connect('key_press_event', self.on_key_press)\n        canvas.mpl_connect('button_release_event', self.on_button_release)\n        canvas.mpl_connect('motion_notify_event', self.on_mouse_move)\n        self.canvas = canvas\n\n    def get_ind_under_point(self, event):\n        '''\n        Return the index of the point closest to the event position or *None*\n        if no point is within ``self.epsilon`` to the event position.\n        '''\n        xy = self.pathpatch.get_path().vertices\n        xyt = self.pathpatch.get_transform().transform(xy)  # to display coords\n        xt, yt = xyt[:, 0], xyt[:, 1]\n        d = np.sqrt((xt - event.x)**2 + (yt - event.y)**2)\n        ind = d.argmin()\n        return ind if d[ind] < self.epsilon else None\n\n    def on_draw(self, event):\n        '''Callback for draws.'''\n        self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n        self.ax.draw_artist(self.pathpatch)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n    def on_button_press(self, event):\n        '''Callback for mouse button presses.'''\n        if (event.inaxes is None\n                or event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n        self._ind = self.get_ind_under_point(event)\n\n    def on_button_release(self, event):\n        '''Callback for mouse button releases.'''\n        if (event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n        self._ind = None\n\n    def on_key_press(self, event):\n        '''Callback for key presses.'''\n        if not event.inaxes:\n            return\n        if event.key == 't':\n            self.showverts = not self.showverts\n            self.line.set_visible(self.showverts)\n            if not self.showverts:\n                self._ind = None\n        self.canvas.draw()\n\n    def on_mouse_move(self, event):\n        '''Callback for mouse movements.'''\n        if (self._ind is None\n                or event.inaxes is None\n                or event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n\n        vertices = self.pathpatch.get_path().vertices\n\n        vertices[self._ind] = event.xdata, event.ydata\n        self.line.set_data(zip(*vertices))\n\n        self.canvas.restore_region(self.background)\n        self.ax.draw_artist(self.pathpatch)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n\ninteractor = PathInteractor(patch)\nax.set_title('drag vertices to update path')\nax.set_xlim(-3, 4)\nax.set_ylim(-3, 4)\n\nplt.show()\n",
    "id": 223
},
{
    "title": "Pick event demo 2",
    "text": "Compute the mean (mu) and standard deviation (sigma) of 100 data sets and plot\nmu vs. sigma. When you click on one of the (mu, sigma) points, plot the raw\ndata from the dataset that generated this point. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nX = np.random.rand(100, 1000)\nxs = np.mean(X, axis=1)\nys = np.std(X, axis=1)\n\nfig, ax = plt.subplots()\nax.set_title('click on point to plot time series')\nline, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)\n\n\ndef onpick(event):\n\n    if event.artist != line:\n        return\n\n    N = len(event.ind)\n    if not N:\n        return\n\n    figi, axs = plt.subplots(N, squeeze=False)\n    for ax, dataind in zip(axs.flat, event.ind):\n        ax.plot(X[dataind])\n        ax.text(.05, .9, f'mu={xs[dataind]:1.3f}\\\nsigma={ys[dataind]:1.3f}',\n                transform=ax.transAxes, va='top')\n        ax.set_ylim(-0.5, 1.5)\n    figi.show()\n\n\nfig.canvas.mpl_connect('pick_event', onpick)\n\nplt.show()\n",
    "id": 224
},
{
    "title": "Poly Editor",
    "text": "This is an example to show how to build cross-GUI applications using\nMatplotlib event handling to interact with objects on the canvas. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import numpy as np\n\nfrom matplotlib.artist import Artist\nfrom matplotlib.lines import Line2D\n\n\ndef dist_point_to_segment(p, s0, s1):\n    '''\n    Get the distance from the point *p* to the segment (*s0*, *s1*), where\n    *p*, *s0*, *s1* are ``[x, y]`` arrays.\n    '''\n    s01 = s1 - s0\n    s0p = p - s0\n    if (s01 == 0).all():\n        return np.hypot(*s0p)\n    # Project onto segment, without going past segment ends.\n    p1 = s0 + np.clip((s0p @ s01) / (s01 @ s01), 0, 1) * s01\n    return np.hypot(*(p - p1))\n\n\nclass PolygonInteractor:\n    '''\n    A polygon editor.\n\n    Key-bindings\n\n      't' toggle vertex markers on and off.  When vertex markers are on,\n          you can move them, delete them\n\n      'd' delete the vertex under point\n\n      'i' insert a vertex at point.  You must be within epsilon of the\n          line connecting two existing vertices\n\n    '''\n\n    showverts = True\n    epsilon = 5  # max pixel distance to count as a vertex hit\n\n    def __init__(self, ax, poly):\n        if poly.figure is None:\n            raise RuntimeError('You must first add the polygon to a figure '\n                               'or canvas before defining the interactor')\n        self.ax = ax\n        canvas = poly.figure.canvas\n        self.poly = poly\n\n        x, y = zip(*self.poly.xy)\n        self.line = Line2D(x, y,\n                           marker='o', markerfacecolor='r',\n                           animated=True)\n        self.ax.add_line(self.line)\n\n        self.cid = self.poly.add_callback(self.poly_changed)\n        self._ind = None  # the active vert\n\n        canvas.mpl_connect('draw_event', self.on_draw)\n        canvas.mpl_connect('button_press_event', self.on_button_press)\n        canvas.mpl_connect('key_press_event', self.on_key_press)\n        canvas.mpl_connect('button_release_event', self.on_button_release)\n        canvas.mpl_connect('motion_notify_event', self.on_mouse_move)\n        self.canvas = canvas\n\n    def on_draw(self, event):\n        self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n        self.ax.draw_artist(self.poly)\n        self.ax.draw_artist(self.line)\n        # do not need to blit here, this will fire before the screen is\n        # updated\n\n    def poly_changed(self, poly):\n        '''This method is called whenever the pathpatch object is called.'''\n        # only copy the artist props to the line (except visibility)\n        vis = self.line.get_visible()\n        Artist.update_from(self.line, poly)\n        self.line.set_visible(vis)  # don't use the poly visibility state\n\n    def get_ind_under_point(self, event):\n        '''\n        Return the index of the point closest to the event position or *None*\n        if no point is within ``self.epsilon`` to the event position.\n        '''\n        # display coords\n        xy = np.asarray(self.poly.xy)\n        xyt = self.poly.get_transform().transform(xy)\n        xt, yt = xyt[:, 0], xyt[:, 1]\n        d = np.hypot(xt - event.x, yt - event.y)\n        indseq, = np.nonzero(d == d.min())\n        ind = indseq[0]\n\n        if d[ind] >= self.epsilon:\n            ind = None\n\n        return ind\n\n    def on_button_press(self, event):\n        '''Callback for mouse button presses.'''\n        if not self.showverts:\n            return\n        if event.inaxes is None:\n            return\n        if event.button != 1:\n            return\n        self._ind = self.get_ind_under_point(event)\n\n    def on_button_release(self, event):\n        '''Callback for mouse button releases.'''\n        if not self.showverts:\n            return\n        if event.button != 1:\n            return\n        self._ind = None\n\n    def on_key_press(self, event):\n        '''Callback for key presses.'''\n        if not event.inaxes:\n            return\n        if event.key == 't':\n            self.showverts = not self.showverts\n            self.line.set_visible(self.showverts)\n            if not self.showverts:\n                self._ind = None\n        elif event.key == 'd':\n            ind = self.get_ind_under_point(event)\n            if ind is not None:\n                self.poly.xy = np.delete(self.poly.xy,\n                                         ind, axis=0)\n                self.line.set_data(zip(*self.poly.xy))\n        elif event.key == 'i':\n            xys = self.poly.get_transform().transform(self.poly.xy)\n            p = event.x, event.y  # display coords\n            for i in range(len(xys) - 1):\n                s0 = xys[i]\n                s1 = xys[i + 1]\n                d = dist_point_to_segment(p, s0, s1)\n                if d <= self.epsilon:\n                    self.poly.xy = np.insert(\n                        self.poly.xy, i+1,\n                        [event.xdata, event.ydata],\n                        axis=0)\n                    self.line.set_data(zip(*self.poly.xy))\n                    break\n        if self.line.stale:\n            self.canvas.draw_idle()\n\n    def on_mouse_move(self, event):\n        '''Callback for mouse movements.'''\n        if not self.showverts:\n            return\n        if self._ind is None:\n            return\n        if event.inaxes is None:\n            return\n        if event.button != 1:\n            return\n        x, y = event.xdata, event.ydata\n\n        self.poly.xy[self._ind] = x, y\n        if self._ind == 0:\n            self.poly.xy[-1] = x, y\n        elif self._ind == len(self.poly.xy) - 1:\n            self.poly.xy[0] = x, y\n        self.line.set_data(zip(*self.poly.xy))\n\n        self.canvas.restore_region(self.background)\n        self.ax.draw_artist(self.poly)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    from matplotlib.patches import Polygon\n\n    theta = np.arange(0, 2*np.pi, 0.1)\n    r = 1.5\n\n    xs = r * np.cos(theta)\n    ys = r * np.sin(theta)\n\n    poly = Polygon(np.column_stack([xs, ys]), animated=True)\n\n    fig, ax = plt.subplots()\n    ax.add_patch(poly)\n    p = PolygonInteractor(ax, poly)\n\n    ax.set_title('Click and drag a point to move it')\n    ax.set_xlim((-2, 2))\n    ax.set_ylim((-2, 2))\n    plt.show()\n",
    "id": 225
},
{
    "title": "Pong",
    "text": "A Matplotlib based game of Pong illustrating one way to write interactive\nanimations that are easily ported to multiple backends. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import randint, randn\n\nfrom matplotlib.font_manager import FontProperties\n\ninstructions = '''\nPlayer A:       Player B:\n  'e'      up     'i'\n  'd'     down    'k'\n\npress 't' -- close these instructions\n            (animation will be much faster)\npress 'a' -- add a puck\npress 'A' -- remove a puck\npress '1' -- slow down all pucks\npress '2' -- speed up all pucks\npress '3' -- slow down distractors\npress '4' -- speed up distractors\npress ' ' -- reset the first puck\npress 'n' -- toggle distractors on/off\npress 'g' -- toggle the game on/off\n\n  '''\n\n\nclass Pad:\n    def __init__(self, disp, x, y, type='l'):\n        self.disp = disp\n        self.x = x\n        self.y = y\n        self.w = .3\n        self.score = 0\n        self.xoffset = 0.3\n        self.yoffset = 0.1\n        if type == 'r':\n            self.xoffset *= -1.0\n\n        if type == 'l' or type == 'r':\n            self.signx = -1.0\n            self.signy = 1.0\n        else:\n            self.signx = 1.0\n            self.signy = -1.0\n\n    def contains(self, loc):\n        return self.disp.get_bbox().contains(loc.x, loc.y)\n\n\nclass Puck:\n    def __init__(self, disp, pad, field):\n        self.vmax = .2\n        self.disp = disp\n        self.field = field\n        self._reset(pad)\n\n    def _reset(self, pad):\n        self.x = pad.x + pad.xoffset\n        if pad.y < 0:\n            self.y = pad.y + pad.yoffset\n        else:\n            self.y = pad.y - pad.yoffset\n        self.vx = pad.x - self.x\n        self.vy = pad.y + pad.w/2 - self.y\n        self._speedlimit()\n        self._slower()\n        self._slower()\n\n    def update(self, pads):\n        self.x += self.vx\n        self.y += self.vy\n        for pad in pads:\n            if pad.contains(self):\n                self.vx *= 1.2 * pad.signx\n                self.vy *= 1.2 * pad.signy\n        fudge = .001\n        # probably cleaner with something like...\n        if self.x < fudge:\n            pads[1].score += 1\n            self._reset(pads[0])\n            return True\n        if self.x > 7 - fudge:\n            pads[0].score += 1\n            self._reset(pads[1])\n            return True\n        if self.y < -1 + fudge or self.y > 1 - fudge:\n            self.vy *= -1.0\n            # add some randomness, just to make it interesting\n            self.vy -= (randn()/300.0 + 1/300.0) * np.sign(self.vy)\n        self._speedlimit()\n        return False\n\n    def _slower(self):\n        self.vx /= 5.0\n        self.vy /= 5.0\n\n    def _faster(self):\n        self.vx *= 5.0\n        self.vy *= 5.0\n\n    def _speedlimit(self):\n        if self.vx > self.vmax:\n            self.vx = self.vmax\n        if self.vx < -self.vmax:\n            self.vx = -self.vmax\n\n        if self.vy > self.vmax:\n            self.vy = self.vmax\n        if self.vy < -self.vmax:\n            self.vy = -self.vmax\n\n\nclass Game:\n    def __init__(self, ax):\n        # create the initial line\n        self.ax = ax\n        ax.xaxis.set_visible(False)\n        ax.set_xlim([0, 7])\n        ax.yaxis.set_visible(False)\n        ax.set_ylim([-1, 1])\n        pad_a_x = 0\n        pad_b_x = .50\n        pad_a_y = pad_b_y = .30\n        pad_b_x += 6.3\n\n        # pads\n        pA, = self.ax.barh(pad_a_y, .2,\n                           height=.3, color='k', alpha=.5, edgecolor='b',\n                           lw=2, label='Player B',\n                           animated=True)\n        pB, = self.ax.barh(pad_b_y, .2,\n                           height=.3, left=pad_b_x, color='k', alpha=.5,\n                           edgecolor='r', lw=2, label='Player A',\n                           animated=True)\n\n        # distractors\n        self.x = np.arange(0, 2.22*np.pi, 0.01)\n        self.line, = self.ax.plot(self.x, np.sin(self.x), 'r',\n                                  animated=True, lw=4)\n        self.line2, = self.ax.plot(self.x, np.cos(self.x), 'g',\n                                   animated=True, lw=4)\n        self.line3, = self.ax.plot(self.x, np.cos(self.x), 'g',\n                                   animated=True, lw=4)\n        self.line4, = self.ax.plot(self.x, np.cos(self.x), 'r',\n                                   animated=True, lw=4)\n\n        # center line\n        self.centerline, = self.ax.plot([3.5, 3.5], [1, -1], 'k',\n                                        alpha=.5, animated=True, lw=8)\n\n        # puck (s)\n        self.puckdisp = self.ax.scatter([1], [1], label='_nolegend_',\n                                        s=200, c='g',\n                                        alpha=.9, animated=True)\n\n        self.canvas = self.ax.figure.canvas\n        self.background = None\n        self.cnt = 0\n        self.distract = True\n        self.res = 100.0\n        self.on = False\n        self.inst = True    # show instructions from the beginning\n        self.pads = [Pad(pA, pad_a_x, pad_a_y),\n                     Pad(pB, pad_b_x, pad_b_y, 'r')]\n        self.pucks = []\n        self.i = self.ax.annotate(instructions, (.5, 0.5),\n                                  name='monospace',\n                                  verticalalignment='center',\n                                  horizontalalignment='center',\n                                  multialignment='left',\n                                  xycoords='axes fraction',\n                                  animated=False)\n        self.canvas.mpl_connect('key_press_event', self.on_key_press)\n\n    def draw(self):\n        draw_artist = self.ax.draw_artist\n        if self.background is None:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n\n        # restore the clean slate background\n        self.canvas.restore_region(self.background)\n\n        # show the distractors\n        if self.distract:\n            self.line.set_ydata(np.sin(self.x + self.cnt/self.res))\n            self.line2.set_ydata(np.cos(self.x - self.cnt/self.res))\n            self.line3.set_ydata(np.tan(self.x + self.cnt/self.res))\n            self.line4.set_ydata(np.tan(self.x - self.cnt/self.res))\n            draw_artist(self.line)\n            draw_artist(self.line2)\n            draw_artist(self.line3)\n            draw_artist(self.line4)\n\n        # pucks and pads\n        if self.on:\n            self.ax.draw_artist(self.centerline)\n            for pad in self.pads:\n                pad.disp.set_y(pad.y)\n                pad.disp.set_x(pad.x)\n                self.ax.draw_artist(pad.disp)\n\n            for puck in self.pucks:\n                if puck.update(self.pads):\n                    # we only get here if someone scored\n                    self.pads[0].disp.set_label(f'   {self.pads[0].score}')\n                    self.pads[1].disp.set_label(f'   {self.pads[1].score}')\n                    self.ax.legend(loc='center', framealpha=.2,\n                                   facecolor='0.5',\n                                   prop=FontProperties(size='xx-large',\n                                                       weight='bold'))\n\n                    self.background = None\n                    self.ax.figure.canvas.draw_idle()\n                    return\n                puck.disp.set_offsets([[puck.x, puck.y]])\n                self.ax.draw_artist(puck.disp)\n\n        # just redraw the axes rectangle\n        self.canvas.blit(self.ax.bbox)\n        self.canvas.flush_events()\n        if self.cnt == 50000:\n            # just so we don't get carried away\n            print('...and you've been playing for too long!!!')\n            plt.close()\n\n        self.cnt += 1\n\n    def on_key_press(self, event):\n        if event.key == '3':\n            self.res *= 5.0\n        if event.key == '4':\n            self.res /= 5.0\n\n        if event.key == 'e':\n            self.pads[0].y += .1\n            if self.pads[0].y > 1 - .3:\n                self.pads[0].y = 1 - .3\n        if event.key == 'd':\n            self.pads[0].y -= .1\n            if self.pads[0].y < -1:\n                self.pads[0].y = -1\n\n        if event.key == 'i':\n            self.pads[1].y += .1\n            if self.pads[1].y > 1 - .3:\n                self.pads[1].y = 1 - .3\n        if event.key == 'k':\n            self.pads[1].y -= .1\n            if self.pads[1].y < -1:\n                self.pads[1].y = -1\n\n        if event.key == 'a':\n            self.pucks.append(Puck(self.puckdisp,\n                                   self.pads[randint(2)],\n                                   self.ax.bbox))\n        if event.key == 'A' and len(self.pucks):\n            self.pucks.pop()\n        if event.key == ' ' and len(self.pucks):\n            self.pucks[0]._reset(self.pads[randint(2)])\n        if event.key == '1':\n            for p in self.pucks:\n                p._slower()\n        if event.key == '2':\n            for p in self.pucks:\n                p._faster()\n\n        if event.key == 'n':\n            self.distract = not self.distract\n\n        if event.key == 'g':\n            self.on = not self.on\n        if event.key == 't':\n            self.inst = not self.inst\n            self.i.set_visible(not self.i.get_visible())\n            self.background = None\n            self.canvas.draw_idle()\n        if event.key == 'q':\n            plt.close()\n\n\nfig, ax = plt.subplots()\ncanvas = ax.figure.canvas\nanimation = Game(ax)\n\n# disable the default key bindings\nif fig.canvas.manager.key_press_handler_id is not None:\n    canvas.mpl_disconnect(fig.canvas.manager.key_press_handler_id)\n\n\n# reset the blitting background on redraw\ndef on_redraw(event):\n    animation.background = None\n\n\n# bootstrap after the first draw\ndef start_anim(event):\n    canvas.mpl_disconnect(start_anim.cid)\n\n    start_anim.timer.add_callback(animation.draw)\n    start_anim.timer.start()\n    canvas.mpl_connect('draw_event', on_redraw)\n\n\nstart_anim.cid = canvas.mpl_connect('draw_event', start_anim)\nstart_anim.timer = animation.canvas.new_timer(interval=1)\n\ntstart = time.time()\n\nplt.show()\nprint('FPS: %f' % (animation.cnt/(time.time() - tstart)))\n",
    "id": 226
},
{
    "title": "Resampling Data",
    "text": "Downsampling lowers the sample rate or sample size of a signal. In\nthis tutorial, the signal is downsampled when the plot is adjusted\nthrough dragging and zooming. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\n# A class that will downsample the data and recompute when zoomed.\nclass DataDisplayDownsampler:\n    def __init__(self, xdata, ydata):\n        self.origYData = ydata\n        self.origXData = xdata\n        self.max_points = 50\n        self.delta = xdata[-1] - xdata[0]\n\n    def downsample(self, xstart, xend):\n        # get the points in the view range\n        mask = (self.origXData > xstart) & (self.origXData < xend)\n        # dilate the mask by one to catch the points just outside\n        # of the view range to not truncate the line\n        mask = np.convolve([1, 1, 1], mask, mode='same').astype(bool)\n        # sort out how many points to drop\n        ratio = max(np.sum(mask) // self.max_points, 1)\n\n        # mask data\n        xdata = self.origXData[mask]\n        ydata = self.origYData[mask]\n\n        # downsample data\n        xdata = xdata[::ratio]\n        ydata = ydata[::ratio]\n\n        print(f'using {len(ydata)} of {np.sum(mask)} visible points')\n\n        return xdata, ydata\n\n    def update(self, ax):\n        # Update the line\n        lims = ax.viewLim\n        if abs(lims.width - self.delta) > 1e-8:\n            self.delta = lims.width\n            xstart, xend = lims.intervalx\n            self.line.set_data(*self.downsample(xstart, xend))\n            ax.figure.canvas.draw_idle()\n\n\n# Create a signal\nxdata = np.linspace(16, 365, (365-16)*4)\nydata = np.sin(2*np.pi*xdata/153) + np.cos(2*np.pi*xdata/127)\n\nd = DataDisplayDownsampler(xdata, ydata)\n\nfig, ax = plt.subplots()\n\n# Hook up the line\nd.line, = ax.plot(xdata, ydata, 'o-')\nax.set_autoscale_on(False)  # Otherwise, infinite loop\n\n# Connect for changing the view limits\nax.callbacks.connect('xlim_changed', d.update)\nax.set_xlim(16, 365)\nplt.show()\n",
    "id": 227
},
{
    "title": "Timers",
    "text": "Simple example of using general timer objects. This is used to update\nthe time placed in the title of the figure. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "from datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef update_title(axes):\n    axes.set_title(datetime.now())\n    axes.figure.canvas.draw()\n\nfig, ax = plt.subplots()\n\nx = np.linspace(-3, 3)\nax.plot(x, x ** 2)\n\n# Create a new timer object. Set the interval to 100 milliseconds\n# (1000 is default) and tell the timer what function should be called.\ntimer = fig.canvas.new_timer(interval=100)\ntimer.add_callback(update_title, ax)\ntimer.start()\n\n# Or could start the timer on first figure draw:\n# def start_timer(event):\n#     timer.start()\n#     fig.canvas.mpl_disconnect(drawid)\n# drawid = fig.canvas.mpl_connect('draw_event', start_timer)\n\nplt.show()\n",
    "id": 228
},
{
    "title": "Trifinder Event Demo",
    "text": "Example showing the use of a TriFinder object. As the mouse is moved over the\ntriangulation, the triangle under the cursor is highlighted and the index of\nthe triangle is displayed in the plot title. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\nfrom matplotlib.tri import Triangulation\n\n\ndef update_polygon(tri):\n    if tri == -1:\n        points = [0, 0, 0]\n    else:\n        points = triang.triangles[tri]\n    xs = triang.x[points]\n    ys = triang.y[points]\n    polygon.set_xy(np.column_stack([xs, ys]))\n\n\ndef on_mouse_move(event):\n    if event.inaxes is None:\n        tri = -1\n    else:\n        tri = trifinder(event.xdata, event.ydata)\n    update_polygon(tri)\n    ax.set_title(f'In triangle {tri}')\n    event.canvas.draw()\n\n\n# Create a Triangulation.\nn_angles = 16\nn_radii = 5\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\ntriang = Triangulation(x, y)\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# Use the triangulation's default TriFinder object.\ntrifinder = triang.get_trifinder()\n\n# Setup plot and callbacks.\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\nax.triplot(triang, 'bo-')\npolygon = Polygon([[0, 0], [0, 0]], facecolor='y')  # dummy data for (xs, ys)\nupdate_polygon(-1)\nax.add_patch(polygon)\nfig.canvas.mpl_connect('motion_notify_event', on_mouse_move)\nplt.show()\n",
    "id": 229
},
{
    "title": "Viewlims",
    "text": "Creates two identical panels. Zooming in on the right panel will show\na rectangle in the first panel, denoting the zoomed region. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Rectangle\n\n\n# We just subclass Rectangle so that it can be called with an Axes\n# instance, causing the rectangle to update its shape to match the\n# bounds of the Axes\nclass UpdatingRect(Rectangle):\n    def __call__(self, ax):\n        self.set_bounds(*ax.viewLim.bounds)\n        ax.figure.canvas.draw_idle()\n\n\n# A class that will regenerate a fractal set as we zoom in, so that you\n# can actually see the increasing detail.  A box in the left panel will show\n# the area to which we are zoomed.\nclass MandelbrotDisplay:\n    def __init__(self, h=500, w=500, niter=50, radius=2., power=2):\n        self.height = h\n        self.width = w\n        self.niter = niter\n        self.radius = radius\n        self.power = power\n\n    def compute_image(self, xstart, xend, ystart, yend):\n        self.x = np.linspace(xstart, xend, self.width)\n        self.y = np.linspace(ystart, yend, self.height).reshape(-1, 1)\n        c = self.x + 1.0j * self.y\n        threshold_time = np.zeros((self.height, self.width))\n        z = np.zeros(threshold_time.shape, dtype=complex)\n        mask = np.ones(threshold_time.shape, dtype=bool)\n        for i in range(self.niter):\n            z[mask] = z[mask]**self.power + c[mask]\n            mask = (np.abs(z) < self.radius)\n            threshold_time += mask\n        return threshold_time\n\n    def ax_update(self, ax):\n        ax.set_autoscale_on(False)  # Otherwise, infinite loop\n        # Get the number of points from the number of pixels in the window\n        self.width, self.height = \\\\\n            np.round(ax.patch.get_window_extent().size).astype(int)\n        # Get the range for the new area\n        vl = ax.viewLim\n        extent = vl.x0, vl.x1, vl.y0, vl.y1\n        # Update the image object with our new data and extent\n        im = ax.images[-1]\n        im.set_data(self.compute_image(*extent))\n        im.set_extent(extent)\n        ax.figure.canvas.draw_idle()\n\n\nmd = MandelbrotDisplay()\nZ = md.compute_image(-2., 0.5, -1.25, 1.25)\n\nfig1, (ax1, ax2) = plt.subplots(1, 2)\nax1.imshow(Z, origin='lower',\n           extent=(md.x.min(), md.x.max(), md.y.min(), md.y.max()))\nax2.imshow(Z, origin='lower',\n           extent=(md.x.min(), md.x.max(), md.y.min(), md.y.max()))\n\nrect = UpdatingRect(\n    [0, 0], 0, 0, facecolor='none', edgecolor='black', linewidth=1.0)\nrect.set_bounds(*ax2.viewLim.bounds)\nax1.add_patch(rect)\n\n# Connect for changing the view limits\nax2.callbacks.connect('xlim_changed', rect)\nax2.callbacks.connect('ylim_changed', rect)\n\nax2.callbacks.connect('xlim_changed', md.ax_update)\nax2.callbacks.connect('ylim_changed', md.ax_update)\nax2.set_title('Zoom here')\n\nplt.show()\n",
    "id": 230
},
{
    "title": "Zoom Window",
    "text": "This example shows how to connect events in one window, for example, a mouse\npress, to another figure window. If you click on a point in the first window, the z and y limits of the second\nwill be adjusted so that the center of the zoom in the second window will be\nthe (x, y) coordinates of the clicked point. Note the diameter of the circles in the scatter are defined in points**2, so\ntheir size is independent of the zoom. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfigsrc, axsrc = plt.subplots(figsize=(3.7, 3.7))\nfigzoom, axzoom = plt.subplots(figsize=(3.7, 3.7))\naxsrc.set(xlim=(0, 1), ylim=(0, 1), autoscale_on=False,\n          title='Click to zoom')\naxzoom.set(xlim=(0.45, 0.55), ylim=(0.4, 0.6), autoscale_on=False,\n           title='Zoom window')\n\nx, y, s, c = np.random.rand(4, 200)\ns *= 200\n\naxsrc.scatter(x, y, s, c)\naxzoom.scatter(x, y, s, c)\n\n\ndef on_press(event):\n    if event.button != 1:\n        return\n    x, y = event.xdata, event.ydata\n    axzoom.set_xlim(x - 0.1, x + 0.1)\n    axzoom.set_ylim(y - 0.1, y + 0.1)\n    figzoom.canvas.draw()\n\nfigsrc.canvas.mpl_connect('button_press_event', on_press)\nplt.show()\n",
    "id": 231
},
{
    "title": "Anchored Artists",
    "text": "This example illustrates the use of the anchored objects without the\nhelper classes found in mpl_toolkits.axes_grid1. This version\nof the figure is similar to the one found in\nSimple Anchored Artists, but it is\nimplemented using only the matplotlib namespace, without the help\nof additional toolkits.",
    "code": "from matplotlib import pyplot as plt\nfrom matplotlib.lines import Line2D\nfrom matplotlib.offsetbox import (AnchoredOffsetbox, AuxTransformBox,\n                                  DrawingArea, TextArea, VPacker)\nfrom matplotlib.patches import Circle, Ellipse\n\n\ndef draw_text(ax):\n    '''Draw a text-box anchored to the upper-left corner of the figure.'''\n    box = AnchoredOffsetbox(child=TextArea('Figure 1a'),\n                            loc='upper left', frameon=True)\n    box.patch.set_boxstyle('round,pad=0.,rounding_size=0.2')\n    ax.add_artist(box)\n\n\ndef draw_circles(ax):\n    '''Draw circles in axes coordinates.'''\n    area = DrawingArea(width=40, height=20)\n    area.add_artist(Circle((10, 10), 10, fc='tab:blue'))\n    area.add_artist(Circle((30, 10), 5, fc='tab:red'))\n    box = AnchoredOffsetbox(\n        child=area, loc='upper right', pad=0, frameon=False)\n    ax.add_artist(box)\n\n\ndef draw_ellipse(ax):\n    '''Draw an ellipse of width=0.1, height=0.15 in data coordinates.'''\n    aux_tr_box = AuxTransformBox(ax.transData)\n    aux_tr_box.add_artist(Ellipse((0, 0), width=0.1, height=0.15))\n    box = AnchoredOffsetbox(child=aux_tr_box, loc='lower left', frameon=True)\n    ax.add_artist(box)\n\n\ndef draw_sizebar(ax):\n    '''\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label center-aligned underneath.\n    '''\n    size = 0.1\n    text = r'1$^{\\\\prime}$'\n    sizebar = AuxTransformBox(ax.transData)\n    sizebar.add_artist(Line2D([0, size], [0, 0], color='black'))\n    text = TextArea(text)\n    packer = VPacker(\n        children=[sizebar, text], align='center', sep=5)  # separation in points.\n    ax.add_artist(AnchoredOffsetbox(\n        child=packer, loc='lower center', frameon=False,\n        pad=0.1, borderpad=0.5))  # paddings relative to the legend fontsize.\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1)\n\ndraw_text(ax)\ndraw_circles(ax)\ndraw_ellipse(ax)\ndraw_sizebar(ax)\n\nplt.show()\n",
    "id": 232
},
{
    "title": "Changing colors of lines intersecting a box",
    "text": "The lines intersecting the rectangle are colored in red, while the others\nare left as blue lines. This example showcases the intersects_bbox function.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Bbox\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nleft, bottom, width, height = (-1, -1, 2, 2)\nrect = plt.Rectangle((left, bottom), width, height,\n                     facecolor='black', alpha=0.1)\n\nfig, ax = plt.subplots()\nax.add_patch(rect)\n\nbbox = Bbox.from_bounds(left, bottom, width, height)\n\nfor i in range(12):\n    vertices = (np.random.random((2, 2)) - 0.5) * 6.0\n    path = Path(vertices)\n    if path.intersects_bbox(bbox):\n        color = 'r'\n    else:\n        color = 'b'\n    ax.plot(vertices[:, 0], vertices[:, 1], color=color)\n\nplt.show()\n",
    "id": 233
},
{
    "title": "Coords Report",
    "text": "Override the default reporting of coords as the mouse moves over the axes\nin an interactive backend.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef millions(x):\n    return '$%1.1fM' % (x * 1e-6)\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(20)\ny = 1e7 * np.random.rand(20)\n\nfig, ax = plt.subplots()\nax.fmt_ydata = millions\nplt.plot(x, y, 'o')\n\nplt.show()\n",
    "id": 234
},
{
    "title": "Custom projection",
    "text": "Showcase Hammer projection by alleviating many features of Matplotlib.",
    "code": "import numpy as np\n\nimport matplotlib\nfrom matplotlib.axes import Axes\nimport matplotlib.axis as maxis\nfrom matplotlib.patches import Circle\nfrom matplotlib.path import Path\nfrom matplotlib.projections import register_projection\nimport matplotlib.spines as mspines\nfrom matplotlib.ticker import FixedLocator, Formatter, NullLocator\nfrom matplotlib.transforms import Affine2D, BboxTransformTo, Transform\n\nrcParams = matplotlib.rcParams\n\n# This example projection class is rather long, but it is designed to\n# illustrate many features, not all of which will be used every time.\n# It is also common to factor out a lot of these methods into common\n# code used by a number of projections with similar characteristics\n# (see geo.py).\n\n\nclass GeoAxes(Axes):\n    '''\n    An abstract base class for geographic projections\n    '''\n    class ThetaFormatter(Formatter):\n        '''\n        Used to format the theta tick labels.  Converts the native\n        unit of radians into degrees and adds a degree symbol.\n        '''\n        def __init__(self, round_to=1.0):\n            self._round_to = round_to\n\n        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f'{degrees:0.0f}\\\\N{DEGREE SIGN}'\n\n    RESOLUTION = 75\n\n    def _init_axis(self):\n        self.xaxis = maxis.XAxis(self)\n        self.yaxis = maxis.YAxis(self)\n        # Do not register xaxis or yaxis with spines -- as done in\n        # Axes._init_axis() -- until GeoAxes.xaxis.clear() works.\n        # self.spines['geo'].register_axis(self.yaxis)\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position('none')\n        self.yaxis.set_ticks_position('none')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(rcParams['axes.grid'])\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)\n\n    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n\n        # There are three important coordinate spaces going on here:\n        #\n        # 1. Data space: The space of the data itself\n        #\n        # 2. Axes space: The unit rectangle (0, 0) to (1, 1)\n        #    covering the entire plot area.\n        #\n        # 3. Display space: The coordinates of the resulting image,\n        #    often in pixels or dpi/inch.\n\n        # This function makes heavy use of the Transform classes in\n        # ``lib/matplotlib/transforms.py.`` For more information, see\n        # the inline documentation there.\n\n        # The goal of the first two transformations is to get from the\n        # data space (in this case longitude and latitude) to axes\n        # space.  It is separated into a non-affine and affine part so\n        # that the non-affine part does not have to be recomputed when\n        # a simple affine change to the figure has been made (such as\n        # resizing the window or changing the dpi).\n\n        # 1) The core transformation from data space into\n        # rectilinear space defined in the HammerTransform class.\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        # 2) The above has an output range that is not in the unit\n        # rectangle, so scale and translate it so it fits correctly\n        # within the axes.  The peculiar calculations of xscale and\n        # yscale are specific to an Aitoff-Hammer projection, so don't\n        # worry about them too much.\n        self.transAffine = self._get_affine_transform()\n\n        # 3) This is the transformation from axes space to display\n        # space.\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # Now put these 3 transforms together -- from data all the way\n        # to display coordinates.  Using the '+' operator, these\n        # transforms will be applied 'in order'.  The transforms are\n        # automatically simplified, if possible, by the underlying\n        # transformation framework.\n        self.transData = \\\\\n            self.transProjection + \\\\\n            self.transAffine + \\\\\n            self.transAxes\n\n        # The main data transformation is set up.  Now deal with\n        # gridlines and tick labels.\n\n        # Longitude gridlines and ticklabels.  The input to these\n        # transforms are in display space in x and axes space in y.\n        # Therefore, the input values will be in range (-xmin, 0),\n        # (xmax, 1).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the equator.\n        self._xaxis_pretransform = \\\\\n            Affine2D() \\\\\n            .scale(1.0, self._longitude_cap * 2.0) \\\\\n            .translate(0.0, -self._longitude_cap)\n        self._xaxis_transform = \\\\\n            self._xaxis_pretransform + \\\\\n            self.transData\n        self._xaxis_text1_transform = \\\\\n            Affine2D().scale(1.0, 0.0) + \\\\\n            self.transData + \\\\\n            Affine2D().translate(0.0, 4.0)\n        self._xaxis_text2_transform = \\\\\n            Affine2D().scale(1.0, 0.0) + \\\\\n            self.transData + \\\\\n            Affine2D().translate(0.0, -4.0)\n\n        # Now set up the transforms for the latitude ticks.  The input to\n        # these transforms are in axes space in x and display space in\n        # y.  Therefore, the input values will be in range (0, -ymin),\n        # (1, ymax).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the edge of the axes ellipse.\n        yaxis_stretch = Affine2D().scale(np.pi*2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1.0, 1.1)\n        self._yaxis_transform = \\\\\n            yaxis_stretch + \\\\\n            self.transData\n        yaxis_text_base = \\\\\n            yaxis_stretch + \\\\\n            self.transProjection + \\\\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\\\n            yaxis_text_base + \\\\\n            Affine2D().translate(-8.0, 0.0)\n        self._yaxis_text2_transform = \\\\\n            yaxis_text_base + \\\\\n            Affine2D().translate(8.0, 0.0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which='grid'):\n        '''\n        Override this method to provide a transformation for the\n        x-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        '''\n        if which not in ['tick1', 'tick2', 'grid']:\n            raise ValueError(\n                ''which' must be one of 'tick1', 'tick2', or 'grid'')\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, 'bottom', 'center'\n\n    def get_xaxis_text2_transform(self, pad):\n        '''\n        Override this method to provide a transformation for the\n        secondary x-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        '''\n        return self._xaxis_text2_transform, 'top', 'center'\n\n    def get_yaxis_transform(self, which='grid'):\n        '''\n        Override this method to provide a transformation for the\n        y-axis grid and ticks.\n        '''\n        if which not in ['tick1', 'tick2', 'grid']:\n            raise ValueError(\n                ''which' must be one of 'tick1', 'tick2', or 'grid'')\n        return self._yaxis_transform\n\n    def get_yaxis_text1_transform(self, pad):\n        '''\n        Override this method to provide a transformation for the\n        y-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        '''\n        return self._yaxis_text1_transform, 'center', 'right'\n\n    def get_yaxis_text2_transform(self, pad):\n        '''\n        Override this method to provide a transformation for the\n        secondary y-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        '''\n        return self._yaxis_text2_transform, 'center', 'left'\n\n    def _gen_axes_patch(self):\n        '''\n        Override this method to define the shape that is used for the\n        background of the plot.  It should be a subclass of Patch.\n\n        In this case, it is a Circle (that may be warped by the axes\n        transform into an ellipse).  Any data and gridlines will be\n        clipped to this shape.\n        '''\n        return Circle((0.5, 0.5), 0.5)\n\n    def _gen_axes_spines(self):\n        return {'geo': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}\n\n    def set_yscale(self, *args, **kwargs):\n        if args[0] != 'linear':\n            raise NotImplementedError\n\n    # Prevent the user from applying scales to one or both of the\n    # axes.  In this particular case, scaling the axes wouldn't make\n    # sense, so we don't allow it.\n    set_xscale = set_yscale\n\n    # Prevent the user from changing the axes limits.  In our case, we\n    # want to display the whole sphere all the time, so we override\n    # set_xlim and set_ylim to ignore any input.  This also applies to\n    # interactive panning and zooming in the GUI interfaces.\n    def set_xlim(self, *args, **kwargs):\n        raise TypeError('Changing axes limits of a geographic projection is '\n                        'not supported.  Please consider using Cartopy.')\n\n    set_ylim = set_xlim\n\n    def format_coord(self, lon, lat):\n        '''\n        Override this method to change how the values are displayed in\n        the status bar.\n\n        In this case, we want them to be displayed in degrees N/S/E/W.\n        '''\n        lon, lat = np.rad2deg([lon, lat])\n        ns = 'N' if lat >= 0.0 else 'S'\n        ew = 'E' if lon >= 0.0 else 'W'\n        return ('%f\\\\N{DEGREE SIGN}%s, %f\\\\N{DEGREE SIGN}%s'\n                % (abs(lat), ns, abs(lon), ew))\n\n    def set_longitude_grid(self, degrees):\n        '''\n        Set the number of degrees between each longitude grid.\n\n        This is an example method that is specific to this projection\n        class -- it provides a more convenient interface to set the\n        ticking than set_xticks would.\n        '''\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_latitude_grid(self, degrees):\n        '''\n        Set the number of degrees between each longitude grid.\n\n        This is an example method that is specific to this projection\n        class -- it provides a more convenient interface than\n        set_yticks would.\n        '''\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_longitude_grid_ends(self, degrees):\n        '''\n        Set the latitude(s) at which to stop drawing the longitude grids.\n\n        Often, in geographic projections, you wouldn't want to draw\n        longitude gridlines near the poles.  This allows the user to\n        specify the degree at which to stop drawing longitude grids.\n\n        This is an example method that is specific to this projection\n        class -- it provides an interface to something that has no\n        analogy in the base Axes class.\n        '''\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\\\n            .clear() \\\\\n            .scale(1.0, self._longitude_cap * 2.0) \\\\\n            .translate(0.0, -self._longitude_cap)\n\n    def get_data_ratio(self):\n        '''\n        Return the aspect ratio of the data itself.\n\n        This method should be overridden by any Axes that have a\n        fixed data ratio.\n        '''\n        return 1.0\n\n    # Interactive panning and zooming is not supported with this projection,\n    # so we override all of the following methods to disable it.\n    def can_zoom(self):\n        '''\n        Return whether this Axes supports the zoom box button functionality.\n\n        This Axes object does not support interactive zoom box.\n        '''\n        return False\n\n    def can_pan(self):\n        '''\n        Return whether this Axes supports the pan/zoom button functionality.\n\n        This Axes object does not support interactive pan/zoom.\n        '''\n        return False\n\n    def start_pan(self, x, y, button):\n        pass\n\n    def end_pan(self):\n        pass\n\n    def drag_pan(self, button, key, x, y):\n        pass\n\n\nclass HammerAxes(GeoAxes):\n    '''\n    A custom class for the Aitoff-Hammer projection, an equal-area map\n    projection.\n\n    https://en.wikipedia.org/wiki/Hammer_projection\n    '''\n\n    # The projection must specify a name. This will be used by the\n    # user to select the projection,\n    # i.e. ``subplot(projection='custom_hammer')``.\n    name = 'custom_hammer'\n\n    class HammerTransform(Transform):\n        '''The base Hammer transform.'''\n        input_dims = output_dims = 2\n\n        def __init__(self, resolution):\n            '''\n            Create a new Hammer transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Hammer space.\n            '''\n            Transform.__init__(self)\n            self._resolution = resolution\n\n        def transform_non_affine(self, ll):\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2)\n\n            alpha = np.sqrt(1 + cos_latitude * np.cos(half_long))\n            x = (2 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])\n\n        def transform_path_non_affine(self, path):\n            # vertices = path.vertices\n            ipath = path.interpolated(self._resolution)\n            return Path(self.transform(ipath.vertices), ipath.codes)\n\n        def inverted(self):\n            return HammerAxes.InvertedHammerTransform(self._resolution)\n\n    class InvertedHammerTransform(Transform):\n        input_dims = output_dims = 2\n\n        def __init__(self, resolution):\n            Transform.__init__(self)\n            self._resolution = resolution\n\n        def transform_non_affine(self, xy):\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            return HammerAxes.HammerTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.clear()\n\n    def _get_core_transform(self, resolution):\n        return self.HammerTransform(resolution)\n\n\n# Now register the projection with Matplotlib so the user can select it.\nregister_projection(HammerAxes)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    # Now make a simple example using the custom projection.\n    fig, ax = plt.subplots(subplot_kw={'projection': 'custom_hammer'})\n    ax.plot([-1, 1, 1], [-1, -1, 1], 'o-')\n    ax.grid()\n\n    plt.show()\n",
    "id": 235
},
{
    "title": "AGG filter",
    "text": "Most pixel-based backends in Matplotlib use Anti-Grain Geometry (AGG) for\nrendering. You can modify the rendering of Artists by applying a filter via\nArtist.set_agg_filter.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.artist import Artist\nimport matplotlib.cm as cm\nfrom matplotlib.colors import LightSource\nimport matplotlib.transforms as mtransforms\n\n\ndef smooth1d(x, window_len):\n    # copied from https://scipy-cookbook.readthedocs.io/items/SignalSmooth.html\n    s = np.r_[2*x[0] - x[window_len:1:-1], x, 2*x[-1] - x[-1:-window_len:-1]]\n    w = np.hanning(window_len)\n    y = np.convolve(w/w.sum(), s, mode='same')\n    return y[window_len-1:-window_len+1]\n\n\ndef smooth2d(A, sigma=3):\n    window_len = max(int(sigma), 3) * 2 + 1\n    A = np.apply_along_axis(smooth1d, 0, A, window_len)\n    A = np.apply_along_axis(smooth1d, 1, A, window_len)\n    return A\n\n\nclass BaseFilter:\n\n    def get_pad(self, dpi):\n        return 0\n\n    def process_image(self, padded_src, dpi):\n        raise NotImplementedError('Should be overridden by subclasses')\n\n    def __call__(self, im, dpi):\n        pad = self.get_pad(dpi)\n        padded_src = np.pad(im, [(pad, pad), (pad, pad), (0, 0)], 'constant')\n        tgt_image = self.process_image(padded_src, dpi)\n        return tgt_image, -pad, -pad\n\n\nclass OffsetFilter(BaseFilter):\n\n    def __init__(self, offsets=(0, 0)):\n        self.offsets = offsets\n\n    def get_pad(self, dpi):\n        return int(max(self.offsets) / 72 * dpi)\n\n    def process_image(self, padded_src, dpi):\n        ox, oy = self.offsets\n        a1 = np.roll(padded_src, int(ox / 72 * dpi), axis=1)\n        a2 = np.roll(a1, -int(oy / 72 * dpi), axis=0)\n        return a2\n\n\nclass GaussianFilter(BaseFilter):\n    '''Simple Gaussian filter.'''\n\n    def __init__(self, sigma, alpha=0.5, color=(0, 0, 0)):\n        self.sigma = sigma\n        self.alpha = alpha\n        self.color = color\n\n    def get_pad(self, dpi):\n        return int(self.sigma*3 / 72 * dpi)\n\n    def process_image(self, padded_src, dpi):\n        tgt_image = np.empty_like(padded_src)\n        tgt_image[:, :, :3] = self.color\n        tgt_image[:, :, 3] = smooth2d(padded_src[:, :, 3] * self.alpha,\n                                      self.sigma / 72 * dpi)\n        return tgt_image\n\n\nclass DropShadowFilter(BaseFilter):\n\n    def __init__(self, sigma, alpha=0.3, color=(0, 0, 0), offsets=(0, 0)):\n        self.gauss_filter = GaussianFilter(sigma, alpha, color)\n        self.offset_filter = OffsetFilter(offsets)\n\n    def get_pad(self, dpi):\n        return max(self.gauss_filter.get_pad(dpi),\n                   self.offset_filter.get_pad(dpi))\n\n    def process_image(self, padded_src, dpi):\n        t1 = self.gauss_filter.process_image(padded_src, dpi)\n        t2 = self.offset_filter.process_image(t1, dpi)\n        return t2\n\n\nclass LightFilter(BaseFilter):\n    '''Apply LightSource filter'''\n\n    def __init__(self, sigma, fraction=1):\n        '''\n        Parameters\n        ----------\n        sigma : float\n            sigma for gaussian filter\n        fraction: number, default: 1\n            Increases or decreases the contrast of the hillshade.\n            See `matplotlib.colors.LightSource`\n\n        '''\n        self.gauss_filter = GaussianFilter(sigma, alpha=1)\n        self.light_source = LightSource()\n        self.fraction = fraction\n\n    def get_pad(self, dpi):\n        return self.gauss_filter.get_pad(dpi)\n\n    def process_image(self, padded_src, dpi):\n        t1 = self.gauss_filter.process_image(padded_src, dpi)\n        elevation = t1[:, :, 3]\n        rgb = padded_src[:, :, :3]\n        alpha = padded_src[:, :, 3:]\n        rgb2 = self.light_source.shade_rgb(rgb, elevation,\n                                           fraction=self.fraction,\n                                           blend_mode='overlay')\n        return np.concatenate([rgb2, alpha], -1)\n\n\nclass GrowFilter(BaseFilter):\n    '''Enlarge the area.'''\n\n    def __init__(self, pixels, color=(1, 1, 1)):\n        self.pixels = pixels\n        self.color = color\n\n    def __call__(self, im, dpi):\n        alpha = np.pad(im[..., 3], self.pixels, 'constant')\n        alpha2 = np.clip(smooth2d(alpha, self.pixels / 72 * dpi) * 5, 0, 1)\n        new_im = np.empty((*alpha2.shape, 4))\n        new_im[:, :, :3] = self.color\n        new_im[:, :, 3] = alpha2\n        offsetx, offsety = -self.pixels, -self.pixels\n        return new_im, offsetx, offsety\n\n\nclass FilteredArtistList(Artist):\n    '''A simple container to filter multiple artists at once.'''\n\n    def __init__(self, artist_list, filter):\n        super().__init__()\n        self._artist_list = artist_list\n        self._filter = filter\n\n    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n\n\ndef filtered_text(ax):\n    # mostly copied from contour_demo.py\n\n    # prepare image\n    delta = 0.025\n    x = np.arange(-3.0, 3.0, delta)\n    y = np.arange(-2.0, 2.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2) * 2\n\n    # draw\n    ax.imshow(Z, interpolation='bilinear', origin='lower',\n              cmap=cm.gray, extent=(-3, 3, -2, 2), aspect='auto')\n    levels = np.arange(-1.2, 1.6, 0.2)\n    CS = ax.contour(Z, levels,\n                    origin='lower',\n                    linewidths=2,\n                    extent=(-3, 3, -2, 2))\n\n    # contour label\n    cl = ax.clabel(CS, levels[1::2],  # label every second level\n                   inline=True,\n                   fmt='%1.1f',\n                   fontsize=11)\n\n    # change clabel color to black\n    from matplotlib.patheffects import Normal\n    for t in cl:\n        t.set_color('k')\n        # to force TextPath (i.e., same font in all backends)\n        t.set_path_effects([Normal()])\n\n    # Add white glows to improve visibility of labels.\n    white_glows = FilteredArtistList(cl, GrowFilter(3))\n    ax.add_artist(white_glows)\n    white_glows.set_zorder(cl[0].get_zorder() - 0.1)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef drop_shadow_line(ax):\n    # copied from examples/misc/svg_filter_line.py\n\n    # draw lines\n    l1, = ax.plot([0.1, 0.5, 0.9], [0.1, 0.9, 0.5], 'bo-')\n    l2, = ax.plot([0.1, 0.5, 0.9], [0.5, 0.2, 0.7], 'ro-')\n\n    gauss = DropShadowFilter(4)\n\n    for l in [l1, l2]:\n\n        # draw shadows with same lines with slight offset.\n        xx = l.get_xdata()\n        yy = l.get_ydata()\n        shadow, = ax.plot(xx, yy)\n        shadow.update_from(l)\n\n        # offset transform\n        transform = mtransforms.offset_copy(l.get_transform(), ax.figure,\n                                            x=4.0, y=-6.0, units='points')\n        shadow.set_transform(transform)\n\n        # adjust zorder of the shadow lines so that it is drawn below the\n        # original lines\n        shadow.set_zorder(l.get_zorder() - 0.5)\n        shadow.set_agg_filter(gauss)\n        shadow.set_rasterized(True)  # to support mixed-mode renderers\n\n    ax.set_xlim(0., 1.)\n    ax.set_ylim(0., 1.)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef drop_shadow_patches(ax):\n    # Copied from barchart_demo.py\n    N = 5\n    group1_means = [20, 35, 30, 35, 27]\n\n    ind = np.arange(N)  # the x locations for the groups\n    width = 0.35  # the width of the bars\n\n    rects1 = ax.bar(ind, group1_means, width, color='r', ec='w', lw=2)\n\n    group2_means = [25, 32, 34, 20, 25]\n    rects2 = ax.bar(ind + width + 0.1, group2_means, width,\n                    color='y', ec='w', lw=2)\n\n    drop = DropShadowFilter(5, offsets=(1, 1))\n    shadow = FilteredArtistList(rects1 + rects2, drop)\n    ax.add_artist(shadow)\n    shadow.set_zorder(rects1[0].get_zorder() - 0.1)\n\n    ax.set_ylim(0, 40)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef light_filter_pie(ax):\n    fracs = [15, 30, 45, 10]\n    explode = (0.1, 0.2, 0.1, 0.1)\n    pies = ax.pie(fracs, explode=explode)\n\n    light_filter = LightFilter(9)\n    for p in pies[0]:\n        p.set_agg_filter(light_filter)\n        p.set_rasterized(True)  # to support mixed-mode renderers\n        p.set(ec='none',\n              lw=2)\n\n    gauss = DropShadowFilter(9, offsets=(3, -4), alpha=0.7)\n    shadow = FilteredArtistList(pies[0], gauss)\n    ax.add_artist(shadow)\n    shadow.set_zorder(pies[0][0].get_zorder() - 0.1)\n\n\nif __name__ == '__main__':\n\n    fix, axs = plt.subplots(2, 2)\n\n    filtered_text(axs[0, 0])\n    drop_shadow_line(axs[0, 1])\n    drop_shadow_patches(axs[1, 0])\n    light_filter_pie(axs[1, 1])\n    axs[1, 1].set_frame_on(True)\n\n    plt.show()\n",
    "id": 236
},
{
    "title": "Ribbon Box",
    "text": "Download Python source code: demo_ribbon_box.py Download Jupyter notebook: demo_ribbon_box.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib import colors as mcolors\nfrom matplotlib.image import AxesImage\nfrom matplotlib.transforms import Bbox, BboxTransformTo, TransformedBbox\n\n\nclass RibbonBox:\n\n    original_image = plt.imread(\n        cbook.get_sample_data('Minduka_Present_Blue_Pack.png'))\n    cut_location = 70\n    b_and_h = original_image[:, :, 2:3]\n    color = original_image[:, :, 2:3] - original_image[:, :, 0:1]\n    alpha = original_image[:, :, 3:4]\n    nx = original_image.shape[1]\n\n    def __init__(self, color):\n        rgb = mcolors.to_rgb(color)\n        self.im = np.dstack(\n            [self.b_and_h - self.color * (1 - np.array(rgb)), self.alpha])\n\n    def get_stretched_image(self, stretch_factor):\n        stretch_factor = max(stretch_factor, 1)\n        ny, nx, nch = self.im.shape\n        ny2 = int(ny*stretch_factor)\n        return np.vstack(\n            [self.im[:self.cut_location],\n             np.broadcast_to(\n                 self.im[self.cut_location], (ny2 - ny, nx, nch)),\n             self.im[self.cut_location:]])\n\n\nclass RibbonBoxImage(AxesImage):\n    zorder = 1\n\n    def __init__(self, ax, bbox, color, *, extent=(0, 1, 0, 1), **kwargs):\n        super().__init__(ax, extent=extent, **kwargs)\n        self._bbox = bbox\n        self._ribbonbox = RibbonBox(color)\n        self.set_transform(BboxTransformTo(bbox))\n\n    def draw(self, renderer, *args, **kwargs):\n        stretch_factor = self._bbox.height / self._bbox.width\n\n        ny = int(stretch_factor*self._ribbonbox.nx)\n        if self.get_array() is None or self.get_array().shape[0] != ny:\n            arr = self._ribbonbox.get_stretched_image(stretch_factor)\n            self.set_array(arr)\n\n        super().draw(renderer, *args, **kwargs)\n\n\ndef main():\n    fig, ax = plt.subplots()\n\n    years = np.arange(2004, 2009)\n    heights = [7900, 8100, 7900, 6900, 2800]\n    box_colors = [\n        (0.8, 0.2, 0.2),\n        (0.2, 0.8, 0.2),\n        (0.2, 0.2, 0.8),\n        (0.7, 0.5, 0.8),\n        (0.3, 0.8, 0.7),\n    ]\n\n    for year, h, bc in zip(years, heights, box_colors):\n        bbox0 = Bbox.from_extents(year - 0.4, 0., year + 0.4, h)\n        bbox = TransformedBbox(bbox0, ax.transData)\n        ax.add_artist(RibbonBoxImage(ax, bbox, bc, interpolation='bicubic'))\n        ax.annotate(str(h), (year, h), va='bottom', ha='center')\n\n    ax.set_xlim(years[0] - 0.5, years[-1] + 0.5)\n    ax.set_ylim(0, 10000)\n\n    background_gradient = np.zeros((2, 2, 4))\n    background_gradient[:, :, :3] = [1, 1, 0]\n    background_gradient[:, :, 3] = [[0.1, 0.3], [0.3, 0.5]]  # alpha channel\n    ax.imshow(background_gradient, interpolation='bicubic', zorder=0.1,\n              extent=(0, 1, 0, 1), transform=ax.transAxes)\n\n    plt.show()\n\n\nmain()\n",
    "id": 237
},
{
    "title": "Adding lines to figures",
    "text": "Adding lines to a figure without any axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.lines matplotlib.lines.Line2D",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.lines as lines\n\nfig = plt.figure()\nfig.add_artist(lines.Line2D([0, 1], [0, 1]))\nfig.add_artist(lines.Line2D([0, 1], [1, 0]))\nplt.show()\n",
    "id": 238
},
{
    "title": "Fill Spiral",
    "text": "Download Python source code: fill_spiral.py Download Jupyter notebook: fill_spiral.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.arange(0, 8*np.pi, 0.1)\na = 1\nb = .2\n\nfor dt in np.arange(0, 2*np.pi, np.pi/2.0):\n\n    x = a*np.cos(theta + dt)*np.exp(b*theta)\n    y = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    dt = dt + np.pi/4.0\n\n    x2 = a*np.cos(theta + dt)*np.exp(b*theta)\n    y2 = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    xf = np.concatenate((x, x2[::-1]))\n    yf = np.concatenate((y, y2[::-1]))\n\n    p1 = plt.fill(xf, yf)\n\nplt.show()\n",
    "id": 239
},
{
    "title": "Findobj Demo",
    "text": "Recursively find all objects that match some criteria",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.text as text\n\na = np.arange(0, 3, .02)\nb = np.arange(0, 3, .02)\nc = np.exp(a)\nd = c[::-1]\n\nfig, ax = plt.subplots()\nplt.plot(a, c, 'k--', a, d, 'k:', a, c + d, 'k')\nplt.legend(('Model length Data length Total message length'),\n           loc='upper center', shadow=True)\nplt.ylim([-1, 20])\nplt.grid(False)\nplt.xlabel('Model complexity --->')\nplt.ylabel('Message length --->')\nplt.title('Minimum Message Length')\n\n\n# match on arbitrary function\ndef myfunc(x):\n    return hasattr(x, 'set_color') and not hasattr(x, 'set_facecolor')\n\n\nfor o in fig.findobj(myfunc):\n    o.set_color('blue')\n\n# match on class instances\nfor o in fig.findobj(text.Text):\n    o.set_fontstyle('italic')\n\n\nplt.show()\n",
    "id": 240
},
{
    "title": "Image Thumbnail",
    "text": "You can use Matplotlib to generate thumbnails from existing images.\nMatplotlib relies on Pillow for reading images, and thus supports all formats\nsupported by Pillow.",
    "code": "from argparse import ArgumentParser\nfrom pathlib import Path\nimport sys\n\nimport matplotlib.image as image\n\nparser = ArgumentParser(\n    description='Build thumbnails of all images in a directory.')\nparser.add_argument('imagedir', type=Path)\nargs = parser.parse_args()\nif not args.imagedir.is_dir():\n    sys.exit(f'Could not find input directory {args.imagedir}')\n\noutdir = Path('thumbs')\noutdir.mkdir(parents=True, exist_ok=True)\n\nfor path in args.imagedir.glob('*.png'):\n    outpath = outdir / path.name\n    fig = image.thumbnail(path, outpath, scale=0.15)\n    print(f'saved thumbnail of {path} to {outpath}')\n",
    "id": 241
},
{
    "title": "Plotting with keywords",
    "text": "Some data structures, like dict, structured numpy array\nor pandas.DataFrame provide access to labelled data via string index access\ndata[key].', \"For these data types, Matplotlib supports passing the whole datastructure via the\ndata keyword argument, and using the string names as plot function parameters,\nwhere you'd normally pass in your data.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndata['b'] = data['a'] + 10 * np.random.randn(50)\ndata['d'] = np.abs(data['d']) * 100\n\nfig, ax = plt.subplots()\nax.scatter('a b', c='c', s='d', data=data)\nax.set(xlabel='entry a', ylabel='entry b')\nplt.show()\n",
    "id": 242
},
{
    "title": "Multipage PDF",
    "text": "This is a demo of creating a pdf file with several pages,\nas well as adding metadata and annotations to pdf files. If you want to use a multipage pdf file using LaTeX, you need\nto use from matplotlib.backends.backend_pgf import PdfPages.\nThis version however does not support attach_note.",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backends.backend_pdf import PdfPages\n\n# Create the PdfPages object to which we will save the pages:\n# The with statement makes sure that the PdfPages object is closed properly at\n# the end of the block, even if an Exception occurs.\nwith PdfPages('multipage_pdf.pdf') as pdf:\n    plt.figure(figsize=(3, 3))\n    plt.plot(range(7), [3, 1, 4, 1, 5, 9, 2], 'r-o')\n    plt.title('Page One')\n    pdf.savefig()  # saves the current figure into a pdf page\n    plt.close()\n\n    # if LaTeX is not installed or error caught, change to `False`\n    plt.rcParams['text.usetex'] = True\n    plt.figure(figsize=(8, 6))\n    x = np.arange(0, 5, 0.1)\n    plt.plot(x, np.sin(x), 'b-')\n    plt.title('Page Two')\n    pdf.attach_note('plot of sin(x)')  # attach metadata (as pdf note) to page\n    pdf.savefig()\n    plt.close()\n\n    plt.rcParams['text.usetex'] = False\n    fig = plt.figure(figsize=(4, 5))\n    plt.plot(x, x ** 2, 'ko')\n    plt.title('Page Three')\n    pdf.savefig(fig)  # or you can pass a Figure object to pdf.savefig\n    plt.close()\n\n    # We can also set the file's metadata via the PdfPages object:\n    d = pdf.infodict()\n    d['Title'] = 'Multipage PDF Example'\n    d['Author'] = 'Jouni K. Sepp\\\\xe4nen'\n    d['Subject'] = 'How to create a multipage pdf file and set its metadata'\n    d['Keywords'] = 'PdfPages multipage keywords author title subject'\n    d['CreationDate'] = datetime.datetime(2009, 11, 13)\n    d['ModDate'] = datetime.datetime.today()\n",
    "id": 243
},
{
    "title": "Packed-bubble chart",
    "text": "Create a packed-bubble chart to represent scalar data.\nThe presented algorithm tries to move all bubbles as close to the center of\nmass as possible while avoiding some collisions by moving around colliding\nobjects. In this example we plot the market share of different desktop\nbrowsers.\n(source: https://gs.statcounter.com/browser-market-share/desktop/worldwidev)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nbrowser_market_share = {\n    'browsers': ['firefox', 'chrome', 'safari', 'edge', 'ie', 'opera'],\n    'market_share': [8.61, 69.55, 8.36, 4.12, 2.76, 2.43],\n    'color': ['#5A69AF', '#579E65', '#F9C784', '#FC944A', '#F24C00', '#00B825']\n}\n\n\nclass BubbleChart:\n    def __init__(self, area, bubble_spacing=0):\n        '''\n        Setup for bubble collapse.\n\n        Parameters\n        ----------\n        area : array-like\n            Area of the bubbles.\n        bubble_spacing : float, default: 0\n            Minimal spacing between bubbles after collapsing.\n\n        Notes\n        -----\n        If 'area' is sorted, the results might look weird.\n        '''\n        area = np.asarray(area)\n        r = np.sqrt(area / np.pi)\n\n        self.bubble_spacing = bubble_spacing\n        self.bubbles = np.ones((len(area), 4))\n        self.bubbles[:, 2] = r\n        self.bubbles[:, 3] = area\n        self.maxstep = 2 * self.bubbles[:, 2].max() + self.bubble_spacing\n        self.step_dist = self.maxstep / 2\n\n        # calculate initial grid layout for bubbles\n        length = np.ceil(np.sqrt(len(self.bubbles)))\n        grid = np.arange(length) * self.maxstep\n        gx, gy = np.meshgrid(grid, grid)\n        self.bubbles[:, 0] = gx.flatten()[:len(self.bubbles)]\n        self.bubbles[:, 1] = gy.flatten()[:len(self.bubbles)]\n\n        self.com = self.center_of_mass()\n\n    def center_of_mass(self):\n        return np.average(\n            self.bubbles[:, :2], axis=0, weights=self.bubbles[:, 3]\n        )\n\n    def center_distance(self, bubble, bubbles):\n        return np.hypot(bubble[0] - bubbles[:, 0],\n                        bubble[1] - bubbles[:, 1])\n\n    def outline_distance(self, bubble, bubbles):\n        center_distance = self.center_distance(bubble, bubbles)\n        return center_distance - bubble[2] - \\\\\n            bubbles[:, 2] - self.bubble_spacing\n\n    def check_collisions(self, bubble, bubbles):\n        distance = self.outline_distance(bubble, bubbles)\n        return len(distance[distance < 0])\n\n    def collides_with(self, bubble, bubbles):\n        distance = self.outline_distance(bubble, bubbles)\n        return np.argmin(distance, keepdims=True)\n\n    def collapse(self, n_iterations=50):\n        '''\n        Move bubbles to the center of mass.\n\n        Parameters\n        ----------\n        n_iterations : int, default: 50\n            Number of moves to perform.\n        '''\n        for _i in range(n_iterations):\n            moves = 0\n            for i in range(len(self.bubbles)):\n                rest_bub = np.delete(self.bubbles, i, 0)\n                # try to move directly towards the center of mass\n                # direction vector from bubble to the center of mass\n                dir_vec = self.com - self.bubbles[i, :2]\n\n                # shorten direction vector to have length of 1\n                dir_vec = dir_vec / np.sqrt(dir_vec.dot(dir_vec))\n\n                # calculate new bubble position\n                new_point = self.bubbles[i, :2] + dir_vec * self.step_dist\n                new_bubble = np.append(new_point, self.bubbles[i, 2:4])\n\n                # check whether new bubble collides with other bubbles\n                if not self.check_collisions(new_bubble, rest_bub):\n                    self.bubbles[i, :] = new_bubble\n                    self.com = self.center_of_mass()\n                    moves += 1\n                else:\n                    # try to move around a bubble that you collide with\n                    # find colliding bubble\n                    for colliding in self.collides_with(new_bubble, rest_bub):\n                        # calculate direction vector\n                        dir_vec = rest_bub[colliding, :2] - self.bubbles[i, :2]\n                        dir_vec = dir_vec / np.sqrt(dir_vec.dot(dir_vec))\n                        # calculate orthogonal vector\n                        orth = np.array([dir_vec[1], -dir_vec[0]])\n                        # test which direction to go\n                        new_point1 = (self.bubbles[i, :2] + orth *\n                                      self.step_dist)\n                        new_point2 = (self.bubbles[i, :2] - orth *\n                                      self.step_dist)\n                        dist1 = self.center_distance(\n                            self.com, np.array([new_point1]))\n                        dist2 = self.center_distance(\n                            self.com, np.array([new_point2]))\n                        new_point = new_point1 if dist1 < dist2 else new_point2\n                        new_bubble = np.append(new_point, self.bubbles[i, 2:4])\n                        if not self.check_collisions(new_bubble, rest_bub):\n                            self.bubbles[i, :] = new_bubble\n                            self.com = self.center_of_mass()\n\n            if moves / len(self.bubbles) < 0.1:\n                self.step_dist = self.step_dist / 2\n\n    def plot(self, ax, labels, colors):\n        '''\n        Draw the bubble plot.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n        labels : list\n            Labels of the bubbles.\n        colors : list\n            Colors of the bubbles.\n        '''\n        for i in range(len(self.bubbles)):\n            circ = plt.Circle(\n                self.bubbles[i, :2], self.bubbles[i, 2], color=colors[i])\n            ax.add_patch(circ)\n            ax.text(*self.bubbles[i, :2], labels[i],\n                    horizontalalignment='center', verticalalignment='center')\n\n\nbubble_chart = BubbleChart(area=browser_market_share['market_share'],\n                           bubble_spacing=0.1)\n\nbubble_chart.collapse()\n\nfig, ax = plt.subplots(subplot_kw=dict(aspect='equal'))\nbubble_chart.plot(\n    ax, browser_market_share['browsers'], browser_market_share['color'])\nax.axis('off')\nax.relim()\nax.autoscale_view()\nax.set_title('Browser market share')\n\nplt.show()\n",
    "id": 244
},
{
    "title": "Patheffect Demo",
    "text": "Download Python source code: patheffect_demo.py Download Jupyter notebook: patheffect_demo.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3))\nax1.imshow([[1, 2], [2, 3]])\ntxt = ax1.annotate('test', (1., 1.), (0., 0),\n                   arrowprops=dict(arrowstyle='->',\n                                   connectionstyle='angle3', lw=2),\n                   size=20, ha='center',\n                   path_effects=[patheffects.withStroke(linewidth=3,\n                                                        foreground='w')])\ntxt.arrow_patch.set_path_effects([\n    patheffects.Stroke(linewidth=5, foreground='w'),\n    patheffects.Normal()])\n\npe = [patheffects.withStroke(linewidth=3,\n                             foreground='w')]\nax1.grid(True, linestyle='-', path_effects=pe)\n\narr = np.arange(25).reshape((5, 5))\nax2.imshow(arr)\ncntr = ax2.contour(arr, colors='k')\n\ncntr.set(path_effects=[patheffects.withStroke(linewidth=3, foreground='w')])\n\nclbls = ax2.clabel(cntr, fmt='%2.0f', use_clabeltext=True)\nplt.setp(clbls, path_effects=[\n    patheffects.withStroke(linewidth=3, foreground='w')])\n\n# shadow as a path effect\np1, = ax3.plot([0, 1], [0, 1])\nleg = ax3.legend([p1], ['Line 1'], fancybox=True, loc='upper left')\nleg.legendPatch.set_path_effects([patheffects.withSimplePatchShadow()])\n\nplt.show()\n",
    "id": 245
},
{
    "title": "Print Stdout",
    "text": "print png to standard out usage: python print_stdout.py > somefile.png",
    "code": "import sys\n\nimport matplotlib\n\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3])\nplt.savefig(sys.stdout.buffer)\n",
    "id": 246
},
{
    "title": "Table Demo",
    "text": "Demo of table function to display a table within a plot.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndata = [[ 66386, 174296,  75131, 577908,  32015],\n        [ 58230, 381139,  78045,  99308, 160454],\n        [ 89135,  80552, 152558, 497981, 603535],\n        [ 78415,  81858, 150656, 193263,  69638],\n        [139361, 331509, 343164, 781380,  52269]]\n\ncolumns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail')\nrows = ['%d year' % x for x in (100, 50, 20, 10, 5)]\n\nvalues = np.arange(0, 2500, 500)\nvalue_increment = 1000\n\n# Get some pastel shades for the colors\ncolors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows)))\nn_rows = len(data)\n\nindex = np.arange(len(columns)) + 0.3\nbar_width = 0.4\n\n# Initialize the vertical-offset for the stacked bar chart.\ny_offset = np.zeros(len(columns))\n\n# Plot bars and create text labels for the table\ncell_text = []\nfor row in range(n_rows):\n    plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row])\n    y_offset = y_offset + data[row]\n    cell_text.append(['%1.1f' % (x / 1000.0) for x in y_offset])\n# Reverse colors and text labels to display the last value at the top.\ncolors = colors[::-1]\ncell_text.reverse()\n\n# Add a table at the bottom of the axes\nthe_table = plt.table(cellText=cell_text,\n                      rowLabels=rows,\n                      rowColours=colors,\n                      colLabels=columns,\n                      loc='bottom')\n\n# Adjust layout to make room for the table:\nplt.subplots_adjust(left=0.2, bottom=0.2)\n\nplt.ylabel(f'Loss in ${value_increment}'s')\nplt.yticks(values * value_increment, ['%d' % val for val in values])\nplt.xticks([])\nplt.title('Loss by Disaster')\n\nplt.show()\n",
    "id": 247
},
{
    "title": "transforms.offset_copy",
    "text": "This illustrates the use of transforms.offset_copy to\nmake a transform that positions a drawing element such as\na text string at a specified offset in screen coordinates\n(dots or inches) relative to a location given in any\ncoordinates. Every Artist (Text, Line2D, etc.) has a transform that can be\nset when the Artist is created, such as by the corresponding\npyplot function. By default, this is usually the Axes.transData\ntransform, going from data units to screen pixels. We can\nuse the offset_copy function to make a modified copy of\nthis transform, where the modification consists of an\noffset.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\nxs = np.arange(7)\nys = xs**2\n\nfig = plt.figure(figsize=(5, 10))\nax = plt.subplot(2, 1, 1)\n\n# If we want the same offset for each text instance,\n# we only need to make one transform.  To get the\n# transform argument to offset_copy, we need to make the axes\n# first; the subplot function above is one way to do this.\ntrans_offset = mtransforms.offset_copy(ax.transData, fig=fig,\n                                       x=0.05, y=0.10, units='inches')\n\nfor x, y in zip(xs, ys):\n    plt.plot(x, y, 'ro')\n    plt.text(x, y, '%d, %d' % (int(x), int(y)), transform=trans_offset)\n\n\n# offset_copy works for polar plots also.\nax = plt.subplot(2, 1, 2, projection='polar')\n\ntrans_offset = mtransforms.offset_copy(ax.transData, fig=fig,\n                                       y=6, units='dots')\n\nfor x, y in zip(xs, ys):\n    plt.polar(x, y, 'ro')\n    plt.text(x, y, '%d, %d' % (int(x), int(y)),\n             transform=trans_offset,\n             horizontalalignment='center',\n             verticalalignment='bottom')\n\nplt.show()\n",
    "id": 248
},
{
    "title": "Plot 2D data on 3D plot",
    "text": "Demonstrates using ax.plot's zdir keyword to plot 2D data on\nselective axes of a 3D plot.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Plot a sin curve using the x and y axes.\nx = np.linspace(0, 1, 100)\ny = np.sin(x * 2 * np.pi) / 2 + 0.5\nax.plot(x, y, zs=0, zdir='z', label='curve in (x, y)')\n\n# Plot scatterplot data (20 2D points per colour) on the x and z axes.\ncolors = ('r g b k')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.sample(20 * len(colors))\ny = np.random.sample(20 * len(colors))\nc_list = []\nfor c in colors:\n    c_list.extend([c] * 20)\n# By using zdir='y', the y value of these points is fixed to the zs value 0\n# and the (x, y) points are plotted on the x and z axes.\nax.scatter(x, y, zs=0, zdir='y', c=c_list, label='points in (x, z)')\n\n# Make legend, set axes limits and labels\nax.legend()\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_zlim(0, 1)\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# Customize the view angle so it's easier to see that the scatter points lie\n# on the plane y=0\nax.view_init(elev=20., azim=-35, roll=0)\n\nplt.show()\n",
    "id": 249
},
{
    "title": "Demo of 3D bar charts",
    "text": "A basic demo of how to plot 3D bars with and without shading.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# set up the figure and axes\nfig = plt.figure(figsize=(8, 3))\nax1 = fig.add_subplot(121, projection='3d')\nax2 = fig.add_subplot(122, projection='3d')\n\n# fake data\n_x = np.arange(4)\n_y = np.arange(5)\n_xx, _yy = np.meshgrid(_x, _y)\nx, y = _xx.ravel(), _yy.ravel()\n\ntop = x + y\nbottom = np.zeros_like(top)\nwidth = depth = 1\n\nax1.bar3d(x, y, bottom, width, depth, top, shade=True)\nax1.set_title('Shaded')\n\nax2.bar3d(x, y, bottom, width, depth, top, shade=False)\nax2.set_title('Not Shaded')\n\nplt.show()\n",
    "id": 250
},
{
    "title": "Create 2D bar graphs in different planes",
    "text": "Demonstrates making a 3D plot which has 2D bar graphs projected onto\nplanes y=0, y=1, etc.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\ncolors = ['r g b y']\nyticks = [3, 2, 1, 0]\nfor c, k in zip(colors, yticks):\n    # Generate the random data for the y=k 'layer'.\n    xs = np.arange(20)\n    ys = np.random.rand(20)\n\n    # You can provide either a single color or an array with the same length as\n    # xs and ys. To demonstrate this, we color the first bar of each set cyan.\n    cs = [c] * len(xs)\n    cs[0] = 'c'\n\n    # Plot the bar graph given by xs and ys on the plane y=k with 80% opacity.\n    ax.bar(xs, ys, zs=k, zdir='y', color=cs, alpha=0.8)\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# On the y-axis let's only label the discrete values that we have data for.\nax.set_yticks(yticks)\n\nplt.show()\n",
    "id": 251
},
{
    "title": "3D box surface plot",
    "text": "Given data on a gridded volume X, Y, Z, this example plots the\ndata values on the volume surfaces. The strategy is to select the data from each surface and plot\ncontours separately using axes3d.Axes3D.contourf with appropriate\nparameters zdir and offset.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Define dimensions\nNx, Ny, Nz = 100, 300, 500\nX, Y, Z = np.meshgrid(np.arange(Nx), np.arange(Ny), -np.arange(Nz))\n\n# Create fake data\ndata = (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1)\n\nkw = {\n    'vmin': data.min(),\n    'vmax': data.max(),\n    'levels': np.linspace(data.min(), data.max(), 10),\n}\n\n# Create a figure with 3D ax\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot contour surfaces\n_ = ax.contourf(\n    X[:, :, 0], Y[:, :, 0], data[:, :, 0],\n    zdir='z', offset=0, **kw\n)\n_ = ax.contourf(\n    X[0, :, :], data[0, :, :], Z[0, :, :],\n    zdir='y', offset=0, **kw\n)\nC = ax.contourf(\n    data[:, -1, :], Y[:, -1, :], Z[:, -1, :],\n    zdir='x', offset=X.max(), **kw\n)\n# --\n\n\n# Set limits of the plot from coord limits\nxmin, xmax = X.min(), X.max()\nymin, ymax = Y.min(), Y.max()\nzmin, zmax = Z.min(), Z.max()\nax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax])\n\n# Plot edges\nedges_kw = dict(color='0.4', linewidth=1, zorder=1e3)\nax.plot([xmax, xmax], [ymin, ymax], 0, **edges_kw)\nax.plot([xmin, xmax], [ymin, ymin], 0, **edges_kw)\nax.plot([xmax, xmax], [ymin, ymin], [zmin, zmax], **edges_kw)\n\n# Set labels and zticks\nax.set(\n    xlabel='X [km]',\n    ylabel='Y [km]',\n    zlabel='Z [m]',\n    zticks=[0, -150, -300, -450],\n)\n\n# Set zoom and angle view\nax.view_init(40, -30, 0)\nax.set_box_aspect(None, zoom=0.9)\n\n# Colorbar\nfig.colorbar(C, ax=ax, fraction=0.02, pad=0.1, label='Name [units]')\n\n# Show Figure\nplt.show()\n",
    "id": 252
},
{
    "title": "Plot contour (level) curves in 3D",
    "text": "This is like a contour plot in 2D except that the f(x, y)=c curve is\nplotted on the plane z=c.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\nax.contour(X, Y, Z, cmap=cm.coolwarm)  # Plot contour curves\n\nplt.show()\n",
    "id": 253
},
{
    "title": "Plot contour (level) curves in 3D using the extend3d option",
    "text": "This modification of the Plot contour (level) curves in 3D example uses extend3d=True to\nextend the curves vertically into 'ribbons'.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contour(X, Y, Z, extend3d=True, cmap=cm.coolwarm)\n\nplt.show()\n",
    "id": 254
},
{
    "title": "Project contour profiles onto a graph",
    "text": "Demonstrates displaying a 3D surface while also projecting contour 'profiles'\nonto the 'walls' of the graph.\nSee Project filled contour onto a graph for the filled version.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph.\nax.contour(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()\n",
    "id": 255
},
{
    "title": "Filled contours",
    "text": "Axes3D.contourf differs from Axes3D.contour in that it creates filled\ncontours, i.e. a discrete number of colours are used to shade the domain. This is like a Axes.contourf plot in 2D except that the shaded region\ncorresponding to the level c is graphed on the plane z=c.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contourf(X, Y, Z, cmap=cm.coolwarm)\n\nplt.show()\n",
    "id": 256
},
{
    "title": "Project filled contour onto a graph",
    "text": "Demonstrates displaying a 3D surface while also projecting filled contour\n'profiles' onto the 'walls' of the graph.\nSee Project contour profiles onto a graph for the unfilled version.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph\nax.contourf(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()\n",
    "id": 257
},
{
    "title": "Custom hillshading in a 3D surface plot",
    "text": "Demonstrates using custom hillshading in a 3D surface plot.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook, cm\nfrom matplotlib.colors import LightSource\n\n# Load and format data\ndem = cbook.get_sample_data('jacksboro_fault_dem.npz')\nz = dem['elevation']\nnrows, ncols = z.shape\nx = np.linspace(dem['xmin'], dem['xmax'], ncols)\ny = np.linspace(dem['ymin'], dem['ymax'], nrows)\nx, y = np.meshgrid(x, y)\n\nregion = np.s_[5:50, 5:50]\nx, y, z = x[region], y[region], z[region]\n\n# Set up plot\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\n\nls = LightSource(270, 45)\n# To use a custom hillshading mode, override the built-in shading and pass\n# in the rgb colors of the shaded surface calculated from 'shade'.\nrgb = ls.shade(z, cmap=cm.gist_earth, vert_exag=0.1, blend_mode='soft')\nsurf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,\n                       linewidth=0, antialiased=False, shade=False)\n\nplt.show()\n",
    "id": 258
},
{
    "title": "3D errorbars",
    "text": "An example of using errorbars with upper and lower limits in mplot3d.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# setting up a parametric curve\nt = np.arange(0, 2*np.pi+.1, 0.01)\nx, y, z = np.sin(t), np.cos(3*t), np.sin(5*t)\n\nestep = 15\ni = np.arange(t.size)\nzuplims = (i % estep == 0) & (i // estep % 3 == 0)\nzlolims = (i % estep == 0) & (i // estep % 3 == 2)\n\nax.errorbar(x, y, z, 0.2, zuplims=zuplims, zlolims=zlolims, errorevery=estep)\n\nax.set_xlabel('X label')\nax.set_ylabel('Y label')\nax.set_zlabel('Z label')\n\nplt.show()\n",
    "id": 259
},
{
    "title": "Create 3D histogram of 2D data",
    "text": "Demo of a histogram for 2D data as a bar graph in 3D.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\nx, y = np.random.rand(2, 100) * 4\nhist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]])\n\n# Construct arrays for the anchor positions of the 16 bars.\nxpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25, indexing='ij')\nxpos = xpos.ravel()\nypos = ypos.ravel()\nzpos = 0\n\n# Construct arrays with the dimensions for the 16 bars.\ndx = dy = 0.5 * np.ones_like(zpos)\ndz = hist.ravel()\n\nax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average')\n\nplt.show()\n",
    "id": 260
},
{
    "title": "Parametric curve",
    "text": "This example demonstrates plotting a parametric curve in 3D.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Prepare arrays x, y, z\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\nax.plot(x, y, z, label='parametric curve')\nax.legend()\n\nplt.show()\n",
    "id": 261
},
{
    "title": "Lorenz attractor",
    "text": "This is an example of plotting Edward Lorenz\\'s 1963 \"Deterministic Nonperiodic\nFlow\" in a 3-dimensional space using mplot3d. Note', \"Because this is a simple non-linear ODE, it would be more easily done using\nSciPy's ODE solver, but this approach depends only upon NumPy.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef lorenz(xyz, *, s=10, r=28, b=2.667):\n    '''\n    Parameters\n    ----------\n    xyz : array-like, shape (3,)\n       Point of interest in three-dimensional space.\n    s, r, b : float\n       Parameters defining the Lorenz attractor.\n\n    Returns\n    -------\n    xyz_dot : array, shape (3,)\n       Values of the Lorenz attractor's partial derivatives at *xyz*.\n    '''\n    x, y, z = xyz\n    x_dot = s*(y - x)\n    y_dot = r*x - y - x*z\n    z_dot = x*y - b*z\n    return np.array([x_dot, y_dot, z_dot])\n\n\ndt = 0.01\nnum_steps = 10000\n\nxyzs = np.empty((num_steps + 1, 3))  # Need one more for the initial values\nxyzs[0] = (0., 1., 1.05)  # Set initial values\n# Step through 'time', calculating the partial derivatives at the current point\n# and using them to estimate the next point\nfor i in range(num_steps):\n    xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt\n\n# Plot\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot(*xyzs.T, lw=0.5)\nax.set_xlabel('X Axis')\nax.set_ylabel('Y Axis')\nax.set_zlabel('Z Axis')\nax.set_title('Lorenz Attractor')\n\nplt.show()\n",
    "id": 262
},
{
    "title": "2D and 3D axes in same figure",
    "text": "This example shows a how to plot a 2D and a 3D plot on the same figure.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.cos(2*np.pi*t) * np.exp(-t)\n\n\n# Set up a figure twice as tall as it is wide\nfig = plt.figure(figsize=plt.figaspect(2.))\nfig.suptitle('A tale of 2 subplots')\n\n# First subplot\nax = fig.add_subplot(2, 1, 1)\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\nt3 = np.arange(0.0, 2.0, 0.01)\n\nax.plot(t1, f(t1), 'bo',\n        t2, f(t2), 'k--', markerfacecolor='green')\nax.grid(True)\nax.set_ylabel('Damped oscillation')\n\n# Second subplot\nax = fig.add_subplot(2, 1, 2, projection='3d')\n\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1, 1)\n\nplt.show()\n",
    "id": 263
},
{
    "title": "Automatic text offsetting",
    "text": "This example demonstrates mplot3d\\'s offset text display.\nAs one rotates the 3D figure, the offsets should remain oriented the\nsame way as the axis label, and should also be located \"away\"\nfrom the center of the plot. This demo triggers the display of the offset text for the x- and\ny-axis by adding 1e5 to X and Y. Anything less would not\nautomatically trigger it.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\nX, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25]\nZ = np.sqrt(np.abs(np.cos(X) + np.cos(Y)))\n\nax.plot_surface(X + 1e5, Y + 1e5, Z, cmap='autumn', cstride=2, rstride=2)\n\nax.set_xlabel('X label')\nax.set_ylabel('Y label')\nax.set_zlabel('Z label')\nax.set_zlim(0, 2)\n\nplt.show()\n",
    "id": 264
},
{
    "title": "Draw flat objects in 3D plot",
    "text": "Demonstrate using pathpatch_2d_to_3d to 'draw' shapes and text on a 3D plot.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.mplot3d.art3d as art3d\n\n\ndef text3d(ax, xyz, s, zdir='z', size=None, angle=0, usetex=False, **kwargs):\n    '''\n    Plots the string *s* on the axes *ax*, with position *xyz*, size *size*,\n    and rotation angle *angle*. *zdir* gives the axis which is to be treated as\n    the third dimension. *usetex* is a boolean indicating whether the string\n    should be run through a LaTeX subprocess or not.  Any additional keyword\n    arguments are forwarded to `.transform_path`.\n\n    Note: zdir affects the interpretation of xyz.\n    '''\n    x, y, z = xyz\n    if zdir == 'y':\n        xy1, z1 = (x, z), y\n    elif zdir == 'x':\n        xy1, z1 = (y, z), x\n    else:\n        xy1, z1 = (x, y), z\n\n    text_path = TextPath((0, 0), s, size=size, usetex=usetex)\n    trans = Affine2D().rotate(angle).translate(xy1[0], xy1[1])\n\n    p1 = PathPatch(trans.transform_path(text_path), **kwargs)\n    ax.add_patch(p1)\n    art3d.pathpatch_2d_to_3d(p1, z=z1, zdir=zdir)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Draw a circle on the x=0 'wall'\np = Circle((5, 5), 3)\nax.add_patch(p)\nart3d.pathpatch_2d_to_3d(p, z=0, zdir='x')\n\n# Manually label the axes\ntext3d(ax, (4, -2, 0), 'X-axis', zdir='z', size=.5, usetex=False,\n       ec='none', fc='k')\ntext3d(ax, (12, 4, 0), 'Y-axis', zdir='z', size=.5, usetex=False,\n       angle=np.pi / 2, ec='none', fc='k')\ntext3d(ax, (12, 10, 4), 'Z-axis', zdir='y', size=.5, usetex=False,\n       angle=np.pi / 2, ec='none', fc='k')\n\n# Write a Latex formula on the z=0 'floor'\ntext3d(ax, (1, 5, 0),\n       r'$\\\\displaystyle G_{\\\\mu\\\nu} + \\\\Lambda g_{\\\\mu\\\nu} = '\n       r'\\\\frac{8\\\\pi G}{c^4} T_{\\\\mu\\\nu}  $',\n       zdir='z', size=1, usetex=True,\n       ec='none', fc='k')\n\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\n\nplt.show()\n",
    "id": 265
},
{
    "title": "Generate polygons to fill under 3D line graph",
    "text": "Demonstrate how to create polygons which fill the space under a line\ngraph. In this example polygons are semi-transparent, creating a sort\nof 'jagged stained glass' effect.",
    "code": "import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PolyCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef polygon_under_graph(x, y):\n    '''\n    Construct the vertex list which defines the polygon filling the space under\n    the (x, y) line graph. This assumes x is in ascending order.\n    '''\n    return [(x[0], 0.), *zip(x, y), (x[-1], 0.)]\n\n\nax = plt.figure().add_subplot(projection='3d')\n\nx = np.linspace(0., 10., 31)\nlambdas = range(1, 9)\n\n# verts[i] is a list of (x, y) pairs defining polygon i.\ngamma = np.vectorize(math.gamma)\nverts = [polygon_under_graph(x, l**x * np.exp(-l) / gamma(x + 1))\n         for l in lambdas]\nfacecolors = plt.colormaps['viridis_r'](np.linspace(0, 1, len(verts)))\n\npoly = PolyCollection(verts, facecolors=facecolors, alpha=.7)\nax.add_collection3d(poly, zs=lambdas, zdir='y')\n\nax.set(xlim=(0, 10), ylim=(1, 9), zlim=(0, 0.35),\n       xlabel='x', ylabel=r'$\\\\lambda$', zlabel='probability')\n\nplt.show()\n",
    "id": 266
},
{
    "title": "3D plot projection types",
    "text": "Demonstrates the different camera projections for 3D plots, and the effects of\nchanging the focal length for a perspective projection. Note that Matplotlib\ncorrects for the 'zoom' effect of changing the focal length.\", 'The default focal length of 1 corresponds to a Field of View (FOV) of 90 deg.\nAn increased focal length between 1 and infinity \"flattens\" the image, while a\ndecreased focal length between 1 and 0 exaggerates the perspective and gives\nthe image more apparent depth. In the limiting case, a focal length of\ninfinity corresponds to an orthographic projection after correction of the\nzoom effect. You can calculate focal length from a FOV via the equation: Or vice versa:",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, axs = plt.subplots(1, 3, subplot_kw={'projection': '3d'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the data\nfor ax in axs:\n    ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the orthographic projection.\naxs[0].set_proj_type('ortho')  # FOV = 0 deg\naxs[0].set_title(''ortho'\\\nfocal_length = \u221e', fontsize=10)\n\n# Set the perspective projections\naxs[1].set_proj_type('persp')  # FOV = 90 deg\naxs[1].set_title(''persp'\\\nfocal_length = 1 (default)', fontsize=10)\n\naxs[2].set_proj_type('persp', focal_length=0.2)  # FOV = 157.4 deg\naxs[2].set_title(''persp'\\\nfocal_length = 0.2', fontsize=10)\n\nplt.show()\n",
    "id": 267
},
{
    "title": "3D quiver plot",
    "text": "Demonstrates plotting directional arrows at points on a 3D meshgrid.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make the grid\nx, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.8))\n\n# Make the direction data for the arrows\nu = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)\nv = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)\nw = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) *\n     np.sin(np.pi * z))\n\nax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)\n\nplt.show()\n",
    "id": 268
},
{
    "title": "Rotating a 3D plot",
    "text": "A very simple animation of a rotating 3D plot about all three axes. See Animate a 3D wireframe plot for another example of animating a 3D plot. (This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run)",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some example data and plot a basic wireframe.\nX, Y, Z = axes3d.get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the axis labels\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\n\n# Rotate the axes and update\nfor angle in range(0, 360*4 + 1):\n    # Normalize the angle to the range [-180, 180] for display\n    angle_norm = (angle + 180) % 360 - 180\n\n    # Cycle through a full rotation of elevation, then azimuth, roll, and all\n    elev = azim = roll = 0\n    if angle <= 360:\n        elev = angle_norm\n    elif angle <= 360*2:\n        azim = angle_norm\n    elif angle <= 360*3:\n        roll = angle_norm\n    else:\n        elev = azim = roll = angle_norm\n\n    # Update the axis view and title\n    ax.view_init(elev, azim, roll)\n    plt.title('Elevation: %d\u00b0, Azimuth: %d\u00b0, Roll: %d\u00b0' % (elev, azim, roll))\n\n    plt.draw()\n    plt.pause(.001)\n",
    "id": 269
},
{
    "title": "3D scatterplot",
    "text": "Demonstration of a basic scatterplot in 3D.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef randrange(n, vmin, vmax):\n    '''\n    Helper function to make an array of random numbers having shape (n, )\n    with each number distributed Uniform(vmin, vmax).\n    '''\n    return (vmax - vmin)*np.random.rand(n) + vmin\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nn = 100\n\n# For each set of style and range settings, plot n random points in the box\n# defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh].\nfor m, zlow, zhigh in [('o', -50, -25), ('^', -30, -5)]:\n    xs = randrange(n, 23, 32)\n    ys = randrange(n, 0, 100)\n    zs = randrange(n, zlow, zhigh)\n    ax.scatter(xs, ys, zs, marker=m)\n\nax.set_xlabel('X Label')\nax.set_ylabel('Y Label')\nax.set_zlabel('Z Label')\n\nplt.show()\n",
    "id": 270
},
{
    "title": "3D plots as subplots",
    "text": "Demonstrate including 3D plots as subplots.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d.axes3d import get_test_data\n\n# set up a figure twice as wide as it is tall\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# =============\n# First subplot\n# =============\n# set up the axes for the first plot\nax = fig.add_subplot(1, 2, 1, projection='3d')\n\n# plot a 3D surface like in the example mplot3d/surface3d_demo\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1.01, 1.01)\nfig.colorbar(surf, shrink=0.5, aspect=10)\n\n# ==============\n# Second subplot\n# ==============\n# set up the axes for the second plot\nax = fig.add_subplot(1, 2, 2, projection='3d')\n\n# plot a 3D wireframe like in the example mplot3d/wire3d_demo\nX, Y, Z = get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()\n",
    "id": 271
},
{
    "title": "3D surface (colormap)",
    "text": "Demonstrates plotting a 3D surface colored with the coolwarm colormap.\nThe surface is made opaque by using antialiased=False. Also demonstrates using the LinearLocator and custom formatting for the\nz axis tick labels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_major_locator matplotlib.ticker.LinearLocator matplotlib.ticker.StrMethodFormatter",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator\n\nfig, ax = plt.subplots(subplot_kw={'projection': '3d'})\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\n\n# Customize the z axis.\nax.set_zlim(-1.01, 1.01)\nax.zaxis.set_major_locator(LinearLocator(10))\n# A StrMethodFormatter is used automatically\nax.zaxis.set_major_formatter('{x:.02f}')\n\n# Add a color bar which maps values to colors.\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nplt.show()\n",
    "id": 272
},
{
    "title": "3D surface (solid color)",
    "text": "Demonstrates a very basic plot of a 3D surface using a solid color.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make data\nu = np.linspace(0, 2 * np.pi, 100)\nv = np.linspace(0, np.pi, 100)\nx = 10 * np.outer(np.cos(u), np.sin(v))\ny = 10 * np.outer(np.sin(u), np.sin(v))\nz = 10 * np.outer(np.ones(np.size(u)), np.cos(v))\n\n# Plot the surface\nax.plot_surface(x, y, z)\n\n# Set an equal aspect ratio\nax.set_aspect('equal')\n\nplt.show()\n",
    "id": 273
},
{
    "title": "3D surface (checkerboard)",
    "text": "Demonstrates plotting a 3D surface colored in a checkerboard pattern.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import LinearLocator\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nxlen = len(X)\nY = np.arange(-5, 5, 0.25)\nylen = len(Y)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Create an empty array of strings with the same shape as the meshgrid, and\n# populate it with two colors in a checkerboard pattern.\ncolortuple = ('y b')\ncolors = np.empty(X.shape, dtype=str)\nfor y in range(ylen):\n    for x in range(xlen):\n        colors[y, x] = colortuple[(x + y) % len(colortuple)]\n\n# Plot the surface with face colors taken from the array we made.\nsurf = ax.plot_surface(X, Y, Z, facecolors=colors, linewidth=0)\n\n# Customize the z axis.\nax.set_zlim(-1, 1)\nax.zaxis.set_major_locator(LinearLocator(6))\n\nplt.show()\n",
    "id": 274
},
{
    "title": "3D surface with polar coordinates",
    "text": "Demonstrates plotting a surface defined in polar coordinates.\nUses the reversed version of the YlGnBu colormap.\nAlso demonstrates writing axis labels with latex math mode. Example contributed by Armin Moser.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create the mesh in polar coordinates and compute corresponding Z.\nr = np.linspace(0, 1.25, 50)\np = np.linspace(0, 2*np.pi, 50)\nR, P = np.meshgrid(r, p)\nZ = ((R**2 - 1)**2)\n\n# Express the mesh in the cartesian system.\nX, Y = R*np.cos(P), R*np.sin(P)\n\n# Plot the surface.\nax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r)\n\n# Tweak the limits and add latex math labels.\nax.set_zlim(0, 1)\nax.set_xlabel(r'$\\\\phi_\\\\mathrm{real}$')\nax.set_ylabel(r'$\\\\phi_\\\\mathrm{im}$')\nax.set_zlabel(r'$V(\\\\phi)$')\n\nplt.show()\n",
    "id": 275
},
{
    "title": "Text annotations in 3D",
    "text": "Demonstrates the placement of text annotations on a 3D plot. Functionality shown:', \"Using the text function with three types of zdir values: None,\nan axis name (ex. 'x'), or a direction tuple (ex. (1, 1, 0)).\", 'Using the text function with the color keyword. Using the text2D function to place text on a fixed position on the ax\nobject.",
    "code": "import matplotlib.pyplot as plt\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Demo 1: zdir\nzdirs = (None, 'x', 'y', 'z', (1, 1, 0), (1, 1, 1))\nxs = (1, 4, 4, 9, 4, 1)\nys = (2, 5, 8, 10, 1, 2)\nzs = (10, 3, 8, 9, 1, 8)\n\nfor zdir, x, y, z in zip(zdirs, xs, ys, zs):\n    label = '(%d, %d, %d), dir=%s' % (x, y, z, zdir)\n    ax.text(x, y, z, label, zdir)\n\n# Demo 2: color\nax.text(9, 0, 0, 'red', color='red')\n\n# Demo 3: text2D\n# Placement 0, 0 would be the bottom left, 1, 1 would be the top right.\nax.text2D(0.05, 0.95, '2D Text', transform=ax.transAxes)\n\n# Tweaking display region and labels\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\nax.set_xlabel('X axis')\nax.set_ylabel('Y axis')\nax.set_zlabel('Z axis')\n\nplt.show()\n",
    "id": 276
},
{
    "title": "Triangular 3D contour plot",
    "text": "Contour plots of unstructured triangular grids. The data used is the same as in the second plot of More triangular 3D surfaces.\nTriangular 3D filled contour plot shows the filled version of this example.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontour(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n",
    "id": 277
},
{
    "title": "Triangular 3D filled contour plot",
    "text": "Filled contour plots of unstructured triangular grids. The data used is the same as in the second plot of More triangular 3D surfaces.\nTriangular 3D contour plot shows the unfilled version of this example.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# First create the x, y, z coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontourf(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n",
    "id": 278
},
{
    "title": "Triangular 3D surfaces",
    "text": "Plot a 3D surface with a triangular mesh.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nn_radii = 8\nn_angles = 36\n\n# Make radii and angles spaces (radius r=0 omitted to eliminate duplication).\nradii = np.linspace(0.125, 1.0, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]\n\n# Convert polar (radii, angles) coords to cartesian (x, y) coords.\n# (0, 0) is manually added at this stage,  so there will be no duplicate\n# points in the (x, y) plane.\nx = np.append(0, (radii*np.cos(angles)).flatten())\ny = np.append(0, (radii*np.sin(angles)).flatten())\n\n# Compute z to make the pringle surface.\nz = np.sin(-x*y)\n\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot_trisurf(x, y, z, linewidth=0.2, antialiased=True)\n\nplt.show()\n",
    "id": 279
},
{
    "title": "More triangular 3D surfaces",
    "text": "Two additional examples of plotting surfaces with triangular mesh.', \"The first demonstrates use of plot_trisurf's triangles argument, and the\nsecond sets a Triangulation object's mask and passes the object directly\nto plot_trisurf.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# ==========\n# First plot\n# ==========\n\n# Make a mesh in the space of parameterisation variables u and v\nu = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)\nv = np.linspace(-0.5, 0.5, endpoint=True, num=10)\nu, v = np.meshgrid(u, v)\nu, v = u.flatten(), v.flatten()\n\n# This is the Mobius mapping, taking a u, v pair and returning an x, y, z\n# triple\nx = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)\ny = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)\nz = 0.5 * v * np.sin(u / 2.0)\n\n# Triangulate parameter space to determine the triangles\ntri = mtri.Triangulation(u, v)\n\n# Plot the surface.  The triangles in parameter space determine which x, y, z\n# points are connected by an edge.\nax = fig.add_subplot(1, 2, 1, projection='3d')\nax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=plt.cm.Spectral)\nax.set_zlim(-1, 1)\n\n\n# ===========\n# Second plot\n# ===========\n\n# Make parameter spaces radii and angles.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\n# Map radius, angle pairs to x, y, z points.\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = mtri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\nxmid = x[triang.triangles].mean(axis=1)\nymid = y[triang.triangles].mean(axis=1)\nmask = xmid**2 + ymid**2 < min_radius**2\ntriang.set_mask(mask)\n\n# Plot the surface.\nax = fig.add_subplot(1, 2, 2, projection='3d')\nax.plot_trisurf(triang, z, cmap=plt.cm.CMRmap)\n\n\nplt.show()\n",
    "id": 280
},
{
    "title": "Primary 3D view planes",
    "text": "This example generates an \"unfolded\" 3D plot that shows each of the primary 3D\nview planes. The elevation, azimuth, and roll angles required for each view are\nlabeled. You could print out this image and fold it into a box where each plane\nforms a side of the box.",
    "code": "import matplotlib.pyplot as plt\n\n\ndef annotate_axes(ax, text, fontsize=18):\n    ax.text(x=0.5, y=0.5, z=0.5, s=text,\n            va='center', ha='center', fontsize=fontsize, color='black')\n\n# (plane, (elev, azim, roll))\nviews = [('XY',   (90, -90, 0)),\n         ('XZ',    (0, -90, 0)),\n         ('YZ',    (0,   0, 0)),\n         ('-XY', (-90,  90, 0)),\n         ('-XZ',   (0,  90, 0)),\n         ('-YZ',   (0, 180, 0))]\n\nlayout = [['XY',  '.',   'L',   '.'],\n          ['XZ', 'YZ', '-XZ', '-YZ'],\n          ['.',   '.', '-XY',   '.']]\nfig, axd = plt.subplot_mosaic(layout, subplot_kw={'projection': '3d'},\n                              figsize=(12, 8.5))\nfor plane, angles in views:\n    axd[plane].set_xlabel('x')\n    axd[plane].set_ylabel('y')\n    axd[plane].set_zlabel('z')\n    axd[plane].set_proj_type('ortho')\n    axd[plane].view_init(elev=angles[0], azim=angles[1], roll=angles[2])\n    axd[plane].set_box_aspect(None, zoom=1.25)\n\n    label = f'{plane}\\\n{angles}'\n    annotate_axes(axd[plane], label, fontsize=14)\n\nfor plane in ('XY', '-XY'):\n    axd[plane].set_zticklabels([])\n    axd[plane].set_zlabel('')\nfor plane in ('XZ', '-XZ'):\n    axd[plane].set_yticklabels([])\n    axd[plane].set_ylabel('')\nfor plane in ('YZ', '-YZ'):\n    axd[plane].set_xticklabels([])\n    axd[plane].set_xlabel('')\n\nlabel = 'mplot3d primary view planes\\\n' + 'ax.view_init(elev, azim, roll)'\nannotate_axes(axd['L'], label, fontsize=18)\naxd['L'].set_axis_off()\n\nplt.show()\n",
    "id": 281
},
{
    "title": "3D voxel / volumetric plot",
    "text": "Demonstrates plotting 3D volumetric objects with Axes3D.voxels.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# prepare some coordinates\nx, y, z = np.indices((8, 8, 8))\n\n# draw cuboids in the top left and bottom right corners, and a link between\n# them\ncube1 = (x < 3) & (y < 3) & (z < 3)\ncube2 = (x >= 5) & (y >= 5) & (z >= 5)\nlink = abs(x - y) + abs(y - z) + abs(z - x) <= 2\n\n# combine the objects into a single boolean array\nvoxelarray = cube1 | cube2 | link\n\n# set the colors of each object\ncolors = np.empty(voxelarray.shape, dtype=object)\ncolors[link] = 'red'\ncolors[cube1] = 'blue'\ncolors[cube2] = 'green'\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(voxelarray, facecolors=colors, edgecolor='k')\n\nplt.show()\n",
    "id": 282
},
{
    "title": "3D voxel plot of the NumPy logo",
    "text": "Demonstrates using Axes3D.voxels with uneven coordinates.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef explode(data):\n    size = np.array(data.shape)*2\n    data_e = np.zeros(size - 1, dtype=data.dtype)\n    data_e[::2, ::2, ::2] = data\n    return data_e\n\n# build up the numpy logo\nn_voxels = np.zeros((4, 3, 4), dtype=bool)\nn_voxels[0, 0, :] = True\nn_voxels[-1, 0, :] = True\nn_voxels[1, 0, 2] = True\nn_voxels[2, 0, 1] = True\nfacecolors = np.where(n_voxels, '#FFD65DC0 #7A88CCC0')\nedgecolors = np.where(n_voxels, '#BFAB6E #7D84A6')\nfilled = np.ones(n_voxels.shape)\n\n# upscale the above voxel image, leaving gaps\nfilled_2 = explode(filled)\nfcolors_2 = explode(facecolors)\necolors_2 = explode(edgecolors)\n\n# Shrink the gaps\nx, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2\nx[0::2, :, :] += 0.05\ny[:, 0::2, :] += 0.05\nz[:, :, 0::2] += 0.05\nx[1::2, :, :] += 0.95\ny[:, 1::2, :] += 0.95\nz[:, :, 1::2] += 0.95\n\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2)\nax.set_aspect('equal')\n\nplt.show()\n",
    "id": 283
},
{
    "title": "3D voxel / volumetric plot with RGB colors",
    "text": "Demonstrates using Axes3D.voxels to visualize parts of a color space. Total running time of the script: (0 minutes 1.252 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef midpoints(x):\n    sl = ()\n    for _ in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, g, b = np.indices((17, 17, 17)) / 16.0\nrc = midpoints(r)\ngc = midpoints(g)\nbc = midpoints(b)\n\n# define a sphere about [0.5, 0.5, 0.5]\nsphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2\n\n# combine the color components\ncolors = np.zeros(sphere.shape + (3,))\ncolors[..., 0] = rc\ncolors[..., 1] = gc\ncolors[..., 2] = bc\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(r, g, b, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\nax.set(xlabel='r', ylabel='g', zlabel='b')\nax.set_aspect('equal')\n\nplt.show()\n",
    "id": 284
},
{
    "title": "3D voxel / volumetric plot with cylindrical coordinates",
    "text": "Demonstrates using the x, y, z parameters of Axes3D.voxels.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors\n\n\ndef midpoints(x):\n    sl = ()\n    for i in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j]\nx = r*np.cos(theta)\ny = r*np.sin(theta)\n\nrc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z)\n\n# define a wobbly torus about [0.7, *, 0]\nsphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 < 0.2**2\n\n# combine the color components\nhsv = np.zeros(sphere.shape + (3,))\nhsv[..., 0] = thetac / (np.pi*2)\nhsv[..., 1] = rc\nhsv[..., 2] = zc + 0.5\ncolors = matplotlib.colors.hsv_to_rgb(hsv)\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\n\nplt.show()\n",
    "id": 285
},
{
    "title": "3D wireframe plot",
    "text": "A very basic demonstration of a wireframe plot.",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some test data.\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot a basic wireframe.\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()\n",
    "id": 286
},
{
    "title": "Animate a 3D wireframe plot",
    "text": "A very simple \"animation\" of a 3D plot. See also Rotating a 3D plot. (This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run.)",
    "code": "import time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make the X, Y meshgrid.\nxs = np.linspace(-1, 1, 50)\nys = np.linspace(-1, 1, 50)\nX, Y = np.meshgrid(xs, ys)\n\n# Set the z axis limits, so they aren't recalculated each frame.\nax.set_zlim(-1, 1)\n\n# Begin plotting.\nwframe = None\ntstart = time.time()\nfor phi in np.linspace(0, 180. / np.pi, 100):\n    # If a line collection is already remove it before drawing.\n    if wframe:\n        wframe.remove()\n    # Generate data.\n    Z = np.cos(2 * np.pi * X + phi) * (1 - np.hypot(X, Y))\n    # Plot the new wireframe and pause briefly before continuing.\n    wframe = ax.plot_wireframe(X, Y, Z, rstride=2, cstride=2)\n    plt.pause(.001)\n\nprint('Average FPS: %f' % (100 / (time.time() - tstart)))\n",
    "id": 287
},
{
    "title": "3D wireframe plots in one direction",
    "text": "Demonstrates that setting rstride or cstride to 0 causes wires to not be\ngenerated in the corresponding direction. Total running time of the script: (0 minutes 1.274 seconds)",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, (ax1, ax2) = plt.subplots(\n    2, 1, figsize=(8, 12), subplot_kw={'projection': '3d'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Give the first plot only wireframes of the type y = c\nax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0)\nax1.set_title('Column (x) stride set to 0')\n\n# Give the second plot only wireframes of the type x = c\nax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10)\nax2.set_title('Row (y) stride set to 0')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 288
},
{
    "title": "Loglog Aspect",
    "text": "Download Python source code: aspect_loglog.py Download Jupyter notebook: aspect_loglog.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.set_xscale('log')\nax1.set_yscale('log')\nax1.set_xlim(1e1, 1e3)\nax1.set_ylim(1e2, 1e3)\nax1.set_aspect(1)\nax1.set_title('adjustable = box')\n\nax2.set_xscale('log')\nax2.set_yscale('log')\nax2.set_adjustable('datalim')\nax2.plot([1, 3, 10], [1, 9, 100], 'o-')\nax2.set_xlim(1e-1, 1e2)\nax2.set_ylim(1e-1, 1e3)\nax2.set_aspect(1)\nax2.set_title('adjustable = datalim')\n\nplt.show()\n",
    "id": 289
},
{
    "title": "Custom scale",
    "text": "Create a custom scale, by implementing the scaling use for latitude data in a\nMercator Projection.', \"Unless you are making special use of the Transform class, you probably\ndon't need to use this verbose method, and instead can use FuncScale\nand the 'function' option of set_xscale and set_yscale.\nSee the last example in Scales.",
    "code": "import numpy as np\nfrom numpy import ma\n\nfrom matplotlib import scale as mscale\nfrom matplotlib import transforms as mtransforms\nfrom matplotlib.ticker import FixedLocator, FuncFormatter\n\n\nclass MercatorLatitudeScale(mscale.ScaleBase):\n    '''\n    Scales data in range -pi/2 to pi/2 (-90 to 90 degrees) using\n    the system used to scale latitudes in a Mercator__ projection.\n\n    The scale function:\n      ln(tan(y) + sec(y))\n\n    The inverse scale function:\n      atan(sinh(y))\n\n    Since the Mercator scale tends to infinity at +/- 90 degrees,\n    there is user-defined threshold, above and below which nothing\n    will be plotted.  This defaults to +/- 85 degrees.\n\n    __ https://en.wikipedia.org/wiki/Mercator_projection\n    '''\n\n    # The scale class must have a member ``name`` that defines the string used\n    # to select the scale.  For example, ``ax.set_yscale('mercator')`` would be\n    # used to select this scale.\n    name = 'mercator'\n\n    def __init__(self, axis, *, thresh=np.deg2rad(85), **kwargs):\n        '''\n        Any keyword arguments passed to ``set_xscale`` and ``set_yscale`` will\n        be passed along to the scale's constructor.\n\n        thresh: The degree above which to crop the data.\n        '''\n        super().__init__(axis)\n        if thresh >= np.pi / 2:\n            raise ValueError('thresh must be less than pi/2')\n        self.thresh = thresh\n\n    def get_transform(self):\n        '''\n        Override this method to return a new instance that does the\n        actual transformation of the data.\n\n        The MercatorLatitudeTransform class is defined below as a\n        nested class of this one.\n        '''\n        return self.MercatorLatitudeTransform(self.thresh)\n\n    def set_default_locators_and_formatters(self, axis):\n        '''\n        Override to set up the locators and formatters to use with the\n        scale.  This is only required if the scale requires custom\n        locators and formatters.  Writing custom locators and\n        formatters is rather outside the scope of this example, but\n        there are many helpful examples in :mod:`.ticker`.\n\n        In our case, the Mercator example uses a fixed locator from -90 to 90\n        degrees and a custom formatter to convert the radians to degrees and\n        put a degree symbol after the value.\n        '''\n        fmt = FuncFormatter(\n            lambda x, pos=None: f'{np.degrees(x):.0f}\\\\N{DEGREE SIGN}')\n        axis.set(major_locator=FixedLocator(np.radians(range(-90, 90, 10))),\n                 major_formatter=fmt, minor_formatter=fmt)\n\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        '''\n        Override to limit the bounds of the axis to the domain of the\n        transform.  In the case of Mercator, the bounds should be\n        limited to the threshold that was passed in.  Unlike the\n        autoscaling provided by the tick locators, this range limiting\n        will always be adhered to, whether the axis range is set\n        manually, determined automatically or changed through panning\n        and zooming.\n        '''\n        return max(vmin, -self.thresh), min(vmax, self.thresh)\n\n    class MercatorLatitudeTransform(mtransforms.Transform):\n        # There are two value members that must be defined.\n        # ``input_dims`` and ``output_dims`` specify number of input\n        # dimensions and output dimensions to the transformation.\n        # These are used by the transformation framework to do some\n        # error checking and prevent incompatible transformations from\n        # being connected together.  When defining transforms for a\n        # scale, which are, by definition, separable and have only one\n        # dimension, these members should always be set to 1.\n        input_dims = output_dims = 1\n\n        def __init__(self, thresh):\n            mtransforms.Transform.__init__(self)\n            self.thresh = thresh\n\n        def transform_non_affine(self, a):\n            '''\n            This transform takes a numpy array and returns a transformed copy.\n            Since the range of the Mercator scale is limited by the\n            user-specified threshold, the input array must be masked to\n            contain only valid values.  Matplotlib will handle masked arrays\n            and remove the out-of-range data from the plot.  However, the\n            returned array *must* have the same shape as the input array, since\n            these values need to remain synchronized with values in the other\n            dimension.\n            '''\n            masked = ma.masked_where((a < -self.thresh) | (a > self.thresh), a)\n            if masked.mask.any():\n                return ma.log(np.abs(ma.tan(masked) + 1 / ma.cos(masked)))\n            else:\n                return np.log(np.abs(np.tan(a) + 1 / np.cos(a)))\n\n        def inverted(self):\n            '''\n            Override this method so Matplotlib knows how to get the\n            inverse transform for this transform.\n            '''\n            return MercatorLatitudeScale.InvertedMercatorLatitudeTransform(\n                self.thresh)\n\n    class InvertedMercatorLatitudeTransform(mtransforms.Transform):\n        input_dims = output_dims = 1\n\n        def __init__(self, thresh):\n            mtransforms.Transform.__init__(self)\n            self.thresh = thresh\n\n        def transform_non_affine(self, a):\n            return np.arctan(np.sinh(a))\n\n        def inverted(self):\n            return MercatorLatitudeScale.MercatorLatitudeTransform(self.thresh)\n\n\n# Now that the Scale class has been defined, it must be registered so\n# that Matplotlib can find it.\nmscale.register_scale(MercatorLatitudeScale)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    t = np.arange(-180.0, 180.0, 0.1)\n    s = np.radians(t)/2.\n\n    plt.plot(t, s, '-', lw=2)\n    plt.yscale('mercator')\n\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title('Mercator projection')\n    plt.grid(True)\n\n    plt.show()\n",
    "id": 290
},
{
    "title": "Log Bar",
    "text": "Plotting a bar chart with a logarithmic y-axis.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndata = ((3, 1000), (10, 3), (100, 30), (500, 800), (50, 1))\n\ndim = len(data[0])\nw = 0.75\ndimw = w / dim\n\nfig, ax = plt.subplots()\nx = np.arange(len(data))\nfor i in range(len(data[0])):\n    y = [d[i] for d in data]\n    b = ax.bar(x + i * dimw, y, dimw, bottom=0.001)\n\nax.set_xticks(x + dimw / 2, labels=map(str, x))\nax.set_yscale('log')\n\nax.set_xlabel('x')\nax.set_ylabel('y')\n\nplt.show()\n",
    "id": 291
},
{
    "title": "Log Demo",
    "text": "Examples of plots with logarithmic axes. Total running time of the script: (0 minutes 1.172 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.01, 20.0, 0.01)\n\n# Create figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n\n# log y axis\nax1.semilogy(t, np.exp(-t / 5.0))\nax1.set(title='semilogy')\nax1.grid()\n\n# log x axis\nax2.semilogx(t, np.sin(2 * np.pi * t))\nax2.set(title='semilogx')\nax2.grid()\n\n# log x and y axis\nax3.loglog(t, 20 * np.exp(-t / 10.0))\nax3.set_xscale('log', base=2)\nax3.set(title='loglog base 2 on x')\nax3.grid()\n\n# With errorbars: clip non-positive values\n# Use new data for plotting\nx = 10.0**np.linspace(0.0, 2.0, 20)\ny = x**2.0\n\nax4.set_xscale('log', nonpositive='clip')\nax4.set_yscale('log', nonpositive='clip')\nax4.set(title='Errorbars go negative')\nax4.errorbar(x, y, xerr=0.1 * x, yerr=5.0 + 0.75 * y)\n# ylim must be set after errorbar to allow errorbar to autoscale limits\nax4.set_ylim(bottom=0.1)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 292
},
{
    "title": "Logit Demo",
    "text": "Examples of plots with logit axes. Total running time of the script: (0 minutes 1.635 seconds)",
    "code": "import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nxmax = 10\nx = np.linspace(-xmax, xmax, 10000)\ncdf_norm = [math.erf(w / np.sqrt(2)) / 2 + 1 / 2 for w in x]\ncdf_laplacian = np.where(x < 0, 1 / 2 * np.exp(x), 1 - 1 / 2 * np.exp(-x))\ncdf_cauchy = np.arctan(x) / np.pi + 1 / 2\n\nfig, axs = plt.subplots(nrows=3, ncols=2, figsize=(6.4, 8.5))\n\n# Common part, for the example, we will do the same plots on all graphs\nfor i in range(3):\n    for j in range(2):\n        axs[i, j].plot(x, cdf_norm, label=r'$\\\\mathcal{N}$')\n        axs[i, j].plot(x, cdf_laplacian, label=r'$\\\\mathcal{L}$')\n        axs[i, j].plot(x, cdf_cauchy, label='Cauchy')\n        axs[i, j].legend()\n        axs[i, j].grid()\n\n# First line, logitscale, with standard notation\naxs[0, 0].set(title='logit scale')\naxs[0, 0].set_yscale('logit')\naxs[0, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[0, 1].set(title='logit scale')\naxs[0, 1].set_yscale('logit')\naxs[0, 1].set_xlim(0, xmax)\naxs[0, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Second line, logitscale, with survival notation (with `use_overline`), and\n# other format display 1/2\naxs[1, 0].set(title='logit scale')\naxs[1, 0].set_yscale('logit', one_half='1/2', use_overline=True)\naxs[1, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[1, 1].set(title='logit scale')\naxs[1, 1].set_yscale('logit', one_half='1/2', use_overline=True)\naxs[1, 1].set_xlim(0, xmax)\naxs[1, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Third line, linear scale\naxs[2, 0].set(title='linear scale')\naxs[2, 0].set_ylim(0, 1)\n\naxs[2, 1].set(title='linear scale')\naxs[2, 1].set_xlim(0, xmax)\naxs[2, 1].set_ylim(0.8, 1)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 293
},
{
    "title": "Exploring normalizations",
    "text": "Various normalization on a multivariate normal distribution. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors matplotlib.colors.PowerNorm matplotlib.axes.Axes.hist2d matplotlib.pyplot.hist2d",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import multivariate_normal\n\nimport matplotlib.colors as mcolors\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\ndata = np.vstack([\n    multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),\n    multivariate_normal([30, 20], [[3, 1], [1, 3]], size=1000)\n])\n\ngammas = [0.8, 0.5, 0.3]\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].set_title('Linear normalization')\naxs[0, 0].hist2d(data[:, 0], data[:, 1], bins=100)\n\nfor ax, gamma in zip(axs.flat[1:], gammas):\n    ax.set_title(r'Power law $(\\\\gamma=%1.1f)$' % gamma)\n    ax.hist2d(data[:, 0], data[:, 1], bins=100, norm=mcolors.PowerNorm(gamma))\n\nfig.tight_layout()\n\nplt.show()\n",
    "id": 294
},
{
    "title": "Scales",
    "text": "Illustrate the scale transformations applied to axes, e.g. log, symlog, logit.', \"The last two examples are examples of using the 'function' scale by\nsupplying forward and inverse functions for the scale transformation.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.set_xscale matplotlib.axes.Axes.set_yscale matplotlib.axis.Axis.set_major_locator matplotlib.scale.LinearScale matplotlib.scale.LogScale matplotlib.scale.SymmetricalLogScale matplotlib.scale.LogitScale matplotlib.scale.FuncScale Total running time of the script: (0 minutes 1.508 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import FixedLocator, NullFormatter\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# make up some data in the interval ]0, 1[\ny = np.random.normal(loc=0.5, scale=0.4, size=1000)\ny = y[(y > 0) & (y < 1)]\ny.sort()\nx = np.arange(len(y))\n\n# plot with various axes scales\nfig, axs = plt.subplots(3, 2, figsize=(6, 8), layout='constrained')\n\n# linear\nax = axs[0, 0]\nax.plot(x, y)\nax.set_yscale('linear')\nax.set_title('linear')\nax.grid(True)\n\n\n# log\nax = axs[0, 1]\nax.plot(x, y)\nax.set_yscale('log')\nax.set_title('log')\nax.grid(True)\n\n\n# symmetric log\nax = axs[1, 1]\nax.plot(x, y - y.mean())\nax.set_yscale('symlog', linthresh=0.02)\nax.set_title('symlog')\nax.grid(True)\n\n# logit\nax = axs[1, 0]\nax.plot(x, y)\nax.set_yscale('logit')\nax.set_title('logit')\nax.grid(True)\n\n\n# Function x**(1/2)\ndef forward(x):\n    return x**(1/2)\n\n\ndef inverse(x):\n    return x**2\n\n\nax = axs[2, 0]\nax.plot(x, y)\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: $x^{1/2}$')\nax.grid(True)\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 1, 0.2)**2))\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 1, 0.2)))\n\n\n# Function Mercator transform\ndef forward(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.log(np.abs(np.tan(a) + 1.0 / np.cos(a))))\n\n\ndef inverse(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.arctan(np.sinh(a)))\n\nax = axs[2, 1]\n\nt = np.arange(0, 170.0, 0.1)\ns = t / 2.\n\nax.plot(t, s, '-', lw=2)\n\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: Mercator')\nax.grid(True)\nax.set_xlim([0, 180])\nax.yaxis.set_minor_formatter(NullFormatter())\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 90, 10)))\n\nplt.show()\n",
    "id": 295
},
{
    "title": "Log Axis",
    "text": "This is an example of assigning a log-scale for the x-axis using\nsemilogx.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\ndt = 0.01\nt = np.arange(dt, 20.0, dt)\n\nax.semilogx(t, np.exp(-t / 5.0))\nax.grid()\n\nplt.show()\n",
    "id": 296
},
{
    "title": "Symlog Demo",
    "text": "Example use of symlog (symmetric log) axis scaling. It should be noted that the coordinate transform used by symlog\nhas a discontinuous gradient at the transition between its linear\nand logarithmic regions. The asinh axis scale is an alternative\ntechnique that may avoid visual artifacts caused by these discontinuities. References matplotlib.scale.SymmetricalLogScale matplotlib.ticker.SymmetricalLogLocator matplotlib.scale.AsinhScale",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndt = 0.01\nx = np.arange(-50.0, 50.0, dt)\ny = np.arange(0, 100.0, dt)\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3)\n\nax0.plot(x, y)\nax0.set_xscale('symlog')\nax0.set_ylabel('symlogx')\nax0.grid()\nax0.xaxis.grid(which='minor')  # minor grid on too\n\nax1.plot(y, x)\nax1.set_yscale('symlog')\nax1.set_ylabel('symlogy')\n\nax2.plot(x, np.sin(x / 3.0))\nax2.set_xscale('symlog')\nax2.set_yscale('symlog', linthresh=0.015)\nax2.grid()\nax2.set_ylabel('symlog both')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 297
},
{
    "title": "Hillshading",
    "text": "Demonstrates a few common tricks with shaded plots. Total running time of the script: (0 minutes 2.251 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LightSource, Normalize\n\n\ndef display_colorbar():\n    '''Display a correct numeric colorbar for a shaded plot.'''\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.cm.copper\n    ls = LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation='bilinear')\n\n    # Use a proxy artist for the colorbar...\n    im = ax.imshow(z, cmap=cmap)\n    im.remove()\n    fig.colorbar(im, ax=ax)\n\n    ax.set_title('Using a colorbar with a shaded plot', size='x-large')\n\n\ndef avoid_outliers():\n    '''Use a custom norm to control the displayed z-range of a shaded plot.'''\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    # Add some outliers...\n    z[100, 105] = 2000\n    z[120, 110] = -9000\n\n    ls = LightSource(315, 45)\n    fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4.5))\n\n    rgb = ls.shade(z, plt.cm.copper)\n    ax1.imshow(rgb, interpolation='bilinear')\n    ax1.set_title('Full range of data')\n\n    rgb = ls.shade(z, plt.cm.copper, vmin=-10, vmax=10)\n    ax2.imshow(rgb, interpolation='bilinear')\n    ax2.set_title('Manually set range')\n\n    fig.suptitle('Avoiding Outliers in Shaded Plots', size='x-large')\n\n\ndef shade_other_data():\n    '''Demonstrates displaying different variables through shade and color.'''\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z1 = np.sin(x**2)  # Data to hillshade\n    z2 = np.cos(x**2 + y**2)  # Data to color\n\n    norm = Normalize(z2.min(), z2.max())\n    cmap = plt.cm.RdBu\n\n    ls = LightSource(315, 45)\n    rgb = ls.shade_rgb(cmap(norm(z2)), z1)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation='bilinear')\n    ax.set_title('Shade by one variable, color by another', size='x-large')\n\ndisplay_colorbar()\navoid_outliers()\nshade_other_data()\nplt.show()\n",
    "id": 298
},
{
    "title": "Anscombe's quartet",
    "text": "Anscombe's quartet is a group of datasets (x, y) that have the same mean,\nstandard deviation, and regression line, but which are qualitatively different.\", 'It is often used to illustrate the importance of looking at a set of data\ngraphically and not only relying on basic statistic properties. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.axline / matplotlib.pyplot.axline matplotlib.axes.Axes.text / matplotlib.pyplot.text matplotlib.axes.Axes.tick_params / matplotlib.pyplot.tick_params`",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\ny2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74]\ny3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73]\nx4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8]\ny4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89]\n\ndatasets = {\n    'I': (x, y1),\n    'II': (x, y2),\n    'III': (x, y3),\n    'IV': (x4, y4)\n}\n\nfig, axs = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 6),\n                        gridspec_kw={'wspace': 0.08, 'hspace': 0.08})\naxs[0, 0].set(xlim=(0, 20), ylim=(2, 14))\naxs[0, 0].set(xticks=(0, 10, 20), yticks=(4, 8, 12))\n\nfor ax, (label, (x, y)) in zip(axs.flat, datasets.items()):\n    ax.text(0.1, 0.9, label, fontsize=20, transform=ax.transAxes, va='top')\n    ax.tick_params(direction='in', top=True, right=True)\n    ax.plot(x, y, 'o')\n\n    # linear regression\n    p1, p0 = np.polyfit(x, y, deg=1)  # slope, intercept\n    ax.axline(xy1=(0, p0), slope=p1, color='r', lw=2)\n\n    # add text box for the statistics\n    stats = (f'$\\\\\\\\mu$ = {np.mean(y):.2f}\\\n'\n             f'$\\\\\\\\sigma$ = {np.std(y):.2f}\\\n'\n             f'$r$ = {np.corrcoef(x, y)[0][1]:.2f}')\n    bbox = dict(boxstyle='round', fc='blanchedalmond', ec='orange', alpha=0.5)\n    ax.text(0.95, 0.07, stats, fontsize=9, bbox=bbox,\n            transform=ax.transAxes, horizontalalignment='right')\n\nplt.show()\n",
    "id": 299
},
{
    "title": "Hinton diagrams",
    "text": "Hinton diagrams are useful for visualizing the values of a 2D array (e.g.\na weight matrix): Positive and negative values are represented by white and\nblack squares, respectively, and the size of each square represents the\nmagnitude of each value. Initial idea from David Warde-Farley on the SciPy Cookbook",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hinton(matrix, max_weight=None, ax=None):\n    '''Draw Hinton diagram for visualizing a weight matrix.'''\n    ax = ax if ax is not None else plt.gca()\n\n    if not max_weight:\n        max_weight = 2 ** np.ceil(np.log2(np.abs(matrix).max()))\n\n    ax.patch.set_facecolor('gray')\n    ax.set_aspect('equal', 'box')\n    ax.xaxis.set_major_locator(plt.NullLocator())\n    ax.yaxis.set_major_locator(plt.NullLocator())\n\n    for (x, y), w in np.ndenumerate(matrix):\n        color = 'white' if w > 0 else 'black'\n        size = np.sqrt(abs(w) / max_weight)\n        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,\n                             facecolor=color, edgecolor=color)\n        ax.add_patch(rect)\n\n    ax.autoscale_view()\n    ax.invert_yaxis()\n\n\nif __name__ == '__main__':\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    hinton(np.random.rand(20, 20) - 0.5)\n    plt.show()\n",
    "id": 300
},
{
    "title": "Ishikawa Diagram",
    "text": "Ishikawa Diagrams, fishbone diagrams, herringbone diagrams, or cause-and-effect\ndiagrams are used to identify problems in a system by showing how causes and\neffects are linked.\nSource: https://en.wikipedia.org/wiki/Ishikawa_diagram Total running time of the script: (0 minutes 1.068 seconds)",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Polygon, Wedge\n\n# Create the fishbone diagram\nfig, ax = plt.subplots(figsize=(10, 6), layout='constrained')\nax.set_xlim(-5, 5)\nax.set_ylim(-5, 5)\nax.axis('off')\n\n\ndef problems(data: str,\n             problem_x: float, problem_y: float,\n             prob_angle_x: float, prob_angle_y: float):\n    '''\n    Draw each problem section of the Ishikawa plot.\n\n    Parameters\n    ----------\n    data : str\n        The category name.\n    problem_x, problem_y : float, optional\n        The `X` and `Y` positions of the problem arrows (`Y` defaults to zero).\n    prob_angle_x, prob_angle_y : float, optional\n        The angle of the problem annotations. They are angled towards\n        the tail of the plot.\n\n    Returns\n    -------\n    None.\n\n    '''\n    ax.annotate(str.upper(data), xy=(problem_x, problem_y),\n                xytext=(prob_angle_x, prob_angle_y),\n                fontsize='10',\n                color='white',\n                weight='bold',\n                xycoords='data',\n                verticalalignment='center',\n                horizontalalignment='center',\n                textcoords='offset fontsize',\n                arrowprops=dict(arrowstyle='->', facecolor='black'),\n                bbox=dict(boxstyle='square',\n                          facecolor='tab:blue',\n                          pad=0.8))\n\n\ndef causes(data: list, cause_x: float, cause_y: float,\n           cause_xytext=(-9, -0.3), top: bool = True):\n    '''\n    Place each cause to a position relative to the problems\n    annotations.\n\n    Parameters\n    ----------\n    data : indexable object\n        The input data. IndexError is\n        raised if more than six arguments are passed.\n    cause_x, cause_y : float\n        The `X` and `Y` position of the cause annotations.\n    cause_xytext : tuple, optional\n        Adjust to set the distance of the cause text from the problem\n        arrow in fontsize units.\n    top : bool\n\n    Returns\n    -------\n    None.\n\n    '''\n    for index, cause in enumerate(data):\n        # First cause annotation is placed in the middle of the problems arrow\n        # and each subsequent cause is plotted above or below it in succession.\n\n        # [<x pos>, [<y pos top>, <y pos bottom>]]\n        coords = [[0, [0, 0]],\n                  [0.23, [0.5, -0.5]],\n                  [-0.46, [-1, 1]],\n                  [0.69, [1.5, -1.5]],\n                  [-0.92, [-2, 2]],\n                  [1.15, [2.5, -2.5]]]\n        if top:\n            cause_y += coords[index][1][0]\n        else:\n            cause_y += coords[index][1][1]\n        cause_x -= coords[index][0]\n\n        ax.annotate(cause, xy=(cause_x, cause_y),\n                    horizontalalignment='center',\n                    xytext=cause_xytext,\n                    fontsize='9',\n                    xycoords='data',\n                    textcoords='offset fontsize',\n                    arrowprops=dict(arrowstyle='->',\n                                    facecolor='black'))\n\n\ndef draw_body(data: dict):\n    '''\n    Place each section in its correct place by changing\n    the coordinates on each loop.\n\n    Parameters\n    ----------\n    data : dict\n        The input data (can be list or tuple). ValueError is\n        raised if more than six arguments are passed.\n\n    Returns\n    -------\n    None.\n\n    '''\n    second_sections = []\n    third_sections = []\n    # Resize diagram to automatically scale in response to the number\n    # of problems in the input data.\n    if len(data) == 1 or len(data) == 2:\n        spine_length = (-2.1, 2)\n        head_pos = (2, 0)\n        tail_pos = ((-2.8, 0.8), (-2.8, -0.8), (-2.0, -0.01))\n        first_section = [1.6, 0.8]\n    elif len(data) == 3 or len(data) == 4:\n        spine_length = (-3.1, 3)\n        head_pos = (3, 0)\n        tail_pos = ((-3.8, 0.8), (-3.8, -0.8), (-3.0, -0.01))\n        first_section = [2.6, 1.8]\n        second_sections = [-0.4, -1.2]\n    else:  # len(data) == 5 or 6\n        spine_length = (-4.1, 4)\n        head_pos = (4, 0)\n        tail_pos = ((-4.8, 0.8), (-4.8, -0.8), (-4.0, -0.01))\n        first_section = [3.5, 2.7]\n        second_sections = [1, 0.2]\n        third_sections = [-1.5, -2.3]\n\n    # Change the coordinates of the annotations on each loop.\n    for index, problem in enumerate(data.values()):\n        top_row = True\n        cause_arrow_y = 1.7\n        if index % 2 != 0:  # Plot problems below the spine.\n            top_row = False\n            y_prob_angle = -16\n            cause_arrow_y = -1.7\n        else:  # Plot problems above the spine.\n            y_prob_angle = 16\n        # Plot the 3 sections in pairs along the main spine.\n        if index in (0, 1):\n            prob_arrow_x = first_section[0]\n            cause_arrow_x = first_section[1]\n        elif index in (2, 3):\n            prob_arrow_x = second_sections[0]\n            cause_arrow_x = second_sections[1]\n        else:\n            prob_arrow_x = third_sections[0]\n            cause_arrow_x = third_sections[1]\n        if index > 5:\n            raise ValueError(f'Maximum number of problems is 6, you have entered '\n                             f'{len(data)}')\n\n        # draw main spine\n        ax.plot(spine_length, [0, 0], color='tab:blue', linewidth=2)\n        # draw fish head\n        ax.text(head_pos[0] + 0.1, head_pos[1] - 0.05, 'PROBLEM', fontsize=10,\n                weight='bold', color='white')\n        semicircle = Wedge(head_pos, 1, 270, 90, fc='tab:blue')\n        ax.add_patch(semicircle)\n        # draw fishtail\n        triangle = Polygon(tail_pos, fc='tab:blue')\n        ax.add_patch(triangle)\n        # Pass each category name to the problems function as a string on each loop.\n        problems(list(data.keys())[index], prob_arrow_x, 0, -12, y_prob_angle)\n        # Start the cause function with the first annotation being plotted at\n        # the cause_arrow_x, cause_arrow_y coordinates.\n        causes(problem, cause_arrow_x, cause_arrow_y, top=top_row)\n\n\n# Input data\ncategories = {\n    'Method': ['Time consumption', 'Cost', 'Procedures', 'Inefficient process',\n               'Sampling'],\n    'Machine': ['Faulty equipment', 'Compatibility'],\n    'Material': ['Poor-quality input', 'Raw materials', 'Supplier',\n                 'Shortage'],\n    'Measurement': ['Calibration', 'Performance', 'Wrong measurements'],\n    'Environment': ['Bad conditions'],\n    'People': ['Lack of training', 'Managers', 'Labor shortage',\n               'Procedures', 'Sales strategy']\n}\n\ndraw_body(categories)\nplt.show()\n",
    "id": 301
},
{
    "title": "Left ventricle bullseye",
    "text": "This example demonstrates how to create the 17 segment model for the left\nventricle recommended by the American Heart Association (AHA). See also the Nested pie charts example. Total running time of the script: (0 minutes 1.731 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\n\ndef bullseye_plot(ax, data, seg_bold=None, cmap='viridis', norm=None):\n    '''\n    Bullseye representation for the left ventricle.\n\n    Parameters\n    ----------\n    ax : axes\n    data : list[float]\n        The intensity values for each of the 17 segments.\n    seg_bold : list[int], optional\n        A list with the segments to highlight.\n    cmap : colormap, default: 'viridis'\n        Colormap for the data.\n    norm : Normalize or None, optional\n        Normalizer for the data.\n\n    Notes\n    -----\n    This function creates the 17 segment model for the left ventricle according\n    to the American Heart Association (AHA) [1]_\n\n    References\n    ----------\n    .. [1] M. D. Cerqueira, N. J. Weissman, V. Dilsizian, A. K. Jacobs,\n        S. Kaul, W. K. Laskey, D. J. Pennell, J. A. Rumberger, T. Ryan,\n        and M. S. Verani, 'Standardized myocardial segmentation and\n        nomenclature for tomographic imaging of the heart',\n        Circulation, vol. 105, no. 4, pp. 539-542, 2002.\n    '''\n\n    data = np.ravel(data)\n    if seg_bold is None:\n        seg_bold = []\n    if norm is None:\n        norm = mpl.colors.Normalize(vmin=data.min(), vmax=data.max())\n\n    r = np.linspace(0.2, 1, 4)\n\n    ax.set(ylim=[0, 1], xticklabels=[], yticklabels=[])\n    ax.grid(False)  # Remove grid\n\n    # Fill segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n            (16, 17, 0, r[0]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               color=cmap(norm(data[start:stop])))\n\n    # Now, draw the segment borders.  In order for the outer bold borders not\n    # to be covered by inner segments, the borders are all drawn separately\n    # after the segments have all been filled.  We also disable clipping, which\n    # would otherwise affect the outermost segment edges.\n    # Draw edges of segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               clip_on=False, color='none', edgecolor='k', linewidth=[\n                   4 if i + 1 in seg_bold else 2 for i in range(start, stop)])\n    # Draw edge of segment 17 -- here; the edge needs to be drawn differently,\n    # using plot().\n    ax.plot(np.linspace(0, 2*np.pi), np.linspace(r[0], r[0]), 'k',\n            linewidth=(4 if 17 in seg_bold else 2))\n\n\n# Create the fake data\ndata = np.arange(17) + 1\n\n\n# Make a figure and axes with dimensions as desired.\nfig = plt.figure(figsize=(10, 5), layout='constrained')\nfig.get_layout_engine().set(wspace=.1, w_pad=.2)\naxs = fig.subplots(1, 3, subplot_kw=dict(projection='polar'))\nfig.canvas.manager.set_window_title('Left Ventricle Bulls Eyes (AHA)')\n\n\n# Set the colormap and norm to correspond to the data for which\n# the colorbar will be used.\ncmap = mpl.cm.viridis\nnorm = mpl.colors.Normalize(vmin=1, vmax=17)\n# Create an empty ScalarMappable to set the colorbar's colormap and norm.\n# The following gives a basic continuous colorbar with ticks and labels.\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap, norm=norm),\n             cax=axs[0].inset_axes([0, -.15, 1, .1]),\n             orientation='horizontal', label='Some units')\n\n\n# And again for the second colorbar.\ncmap2 = mpl.cm.cool\nnorm2 = mpl.colors.Normalize(vmin=1, vmax=17)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap2, norm=norm2),\n             cax=axs[1].inset_axes([0, -.15, 1, .1]),\n             orientation='horizontal', label='Some other units')\n\n\n# The second example illustrates the use of a ListedColormap, a\n# BoundaryNorm, and extended ends to show the 'over' and 'under'\n# value colors.\ncmap3 = (mpl.colors.ListedColormap(['r', 'g', 'b', 'c'])\n         .with_extremes(over='0.35', under='0.75'))\n# If a ListedColormap is used, the length of the bounds array must be\n# one greater than the length of the color list.  The bounds must be\n# monotonically increasing.\nbounds = [2, 3, 7, 9, 15]\nnorm3 = mpl.colors.BoundaryNorm(bounds, cmap3.N)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap3, norm=norm3),\n             cax=axs[2].inset_axes([0, -.15, 1, .1]),\n             extend='both',\n             ticks=bounds,  # optional\n             spacing='proportional',\n             orientation='horizontal',\n             label='Discrete intervals, some other units')\n\n\n# Create the 17 segment model\nbullseye_plot(axs[0], data, cmap=cmap, norm=norm)\naxs[0].set_title('Bulls Eye (AHA)')\n\nbullseye_plot(axs[1], data, cmap=cmap2, norm=norm2)\naxs[1].set_title('Bulls Eye (AHA)')\n\nbullseye_plot(axs[2], data, seg_bold=[3, 5, 6, 11, 12, 16],\n              cmap=cmap3, norm=norm3)\naxs[2].set_title('Segments [3, 5, 6, 11, 12, 16] in bold')\n\nplt.show()\n",
    "id": 302
},
{
    "title": "MRI with EEG",
    "text": "Displays a set of subplots with an MRI image, its intensity\nhistogram and some EEG traces.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\nfig, axd = plt.subplot_mosaic(\n    [['image', 'density'],\n     ['EEG', 'EEG']],\n    layout='constrained',\n    # 'image' will contain a square image. We fine-tune the width so that\n    # there is no excess horizontal or vertical margin around the image.\n    width_ratios=[1.05, 2],\n)\n\n# Load the MRI data (256x256 16-bit integers)\nwith cbook.get_sample_data('s1045.ima.gz') as dfile:\n    im = np.frombuffer(dfile.read(), np.uint16).reshape((256, 256))\n\n# Plot the MRI image\naxd['image'].imshow(im, cmap='gray')\naxd['image'].axis('off')\n\n# Plot the histogram of MRI intensity\nim = im[im.nonzero()]  # Ignore the background\naxd['density'].hist(im, bins=np.arange(0, 2**16+1, 512))\naxd['density'].set(xlabel='Intensity (a.u.)', xlim=(0, 2**16),\n                   ylabel='MRI density', yticks=[])\naxd['density'].minorticks_on()\n\n# Load the EEG data\nn_samples, n_rows = 800, 4\nwith cbook.get_sample_data('eeg.dat') as eegfile:\n    data = np.fromfile(eegfile, dtype=float).reshape((n_samples, n_rows))\nt = 10 * np.arange(n_samples) / n_samples\n\n# Plot the EEG\naxd['EEG'].set_xlabel('Time (s)')\naxd['EEG'].set_xlim(0, 10)\ndy = (data.min() - data.max()) * 0.7  # Crowd them a bit.\naxd['EEG'].set_ylim(-dy, n_rows * dy)\naxd['EEG'].set_yticks([0, dy, 2*dy, 3*dy], labels=['PG3', 'PG5', 'PG7', 'PG9'])\n\nfor i, data_col in enumerate(data.T):\n    axd['EEG'].plot(t, data_col + i*dy, color='C0')\n\nplt.show()\n",
    "id": 303
},
{
    "title": "Radar chart (aka spider or star chart)",
    "text": "This example creates a radar chart, also known as a spider or star chart [1].', \"Although this example allows a frame of either 'circle' or 'polygon', polygon\nframes don't have proper gridlines (the lines are circles instead of polygons).\nIt's possible to get a polygon grid by setting GRIDLINE_INTERPOLATION_STEPS in\nmatplotlib.axis to the desired number of vertices, but the orientation of the\npolygon is not aligned with the radial axes.\", 'https://en.wikipedia.org/wiki/Radar_chart References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.spines matplotlib.spines.Spine matplotlib.projections matplotlib.projections.polar matplotlib.projections.polar.PolarAxes matplotlib.projections.register_projection Total running time of the script: (0 minutes 1.206 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, RegularPolygon\nfrom matplotlib.path import Path\nfrom matplotlib.projections import register_projection\nfrom matplotlib.projections.polar import PolarAxes\nfrom matplotlib.spines import Spine\nfrom matplotlib.transforms import Affine2D\n\n\ndef radar_factory(num_vars, frame='circle'):\n    '''\n    Create a radar chart with `num_vars` axes.\n\n    This function creates a RadarAxes projection and registers it.\n\n    Parameters\n    ----------\n    num_vars : int\n        Number of variables for radar chart.\n    frame : {'circle', 'polygon'}\n        Shape of frame surrounding axes.\n\n    '''\n    # calculate evenly-spaced axis angles\n    theta = np.linspace(0, 2*np.pi, num_vars, endpoint=False)\n\n    class RadarTransform(PolarAxes.PolarTransform):\n\n        def transform_path_non_affine(self, path):\n            # Paths with non-unit interpolation steps correspond to gridlines,\n            # in which case we force interpolation (to defeat PolarTransform's\n            # autoconversion to circular arcs).\n            if path._interpolation_steps > 1:\n                path = path.interpolated(num_vars)\n            return Path(self.transform(path.vertices), path.codes)\n\n    class RadarAxes(PolarAxes):\n\n        name = 'radar'\n        PolarTransform = RadarTransform\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            # rotate plot such that the first axis is at the top\n            self.set_theta_zero_location('N')\n\n        def fill(self, *args, closed=True, **kwargs):\n            '''Override fill so that line is closed by default'''\n            return super().fill(closed=closed, *args, **kwargs)\n\n        def plot(self, *args, **kwargs):\n            '''Override plot so that line is closed by default'''\n            lines = super().plot(*args, **kwargs)\n            for line in lines:\n                self._close_line(line)\n\n        def _close_line(self, line):\n            x, y = line.get_data()\n            # FIXME: markers at x[0], y[0] get doubled-up\n            if x[0] != x[-1]:\n                x = np.append(x, x[0])\n                y = np.append(y, y[0])\n                line.set_data(x, y)\n\n        def set_varlabels(self, labels):\n            self.set_thetagrids(np.degrees(theta), labels)\n\n        def _gen_axes_patch(self):\n            # The Axes patch must be centered at (0.5, 0.5) and of radius 0.5\n            # in axes coordinates.\n            if frame == 'circle':\n                return Circle((0.5, 0.5), 0.5)\n            elif frame == 'polygon':\n                return RegularPolygon((0.5, 0.5), num_vars,\n                                      radius=.5, edgecolor='k')\n            else:\n                raise ValueError('Unknown value for 'frame': %s' % frame)\n\n        def _gen_axes_spines(self):\n            if frame == 'circle':\n                return super()._gen_axes_spines()\n            elif frame == 'polygon':\n                # spine_type must be 'left'/'right'/'top'/'bottom'/'circle'.\n                spine = Spine(axes=self,\n                              spine_type='circle',\n                              path=Path.unit_regular_polygon(num_vars))\n                # unit_regular_polygon gives a polygon of radius 1 centered at\n                # (0, 0) but we want a polygon of radius 0.5 centered at (0.5,\n                # 0.5) in axes coordinates.\n                spine.set_transform(Affine2D().scale(.5).translate(.5, .5)\n                                    + self.transAxes)\n                return {'polar': spine}\n            else:\n                raise ValueError('Unknown value for 'frame': %s' % frame)\n\n    register_projection(RadarAxes)\n    return theta\n\n\ndef example_data():\n    # The following data is from the Denver Aerosol Sources and Health study.\n    # See doi:10.1016/j.atmosenv.2008.12.017\n    #\n    # The data are pollution source profile estimates for five modeled\n    # pollution sources (e.g., cars, wood-burning, etc) that emit 7-9 chemical\n    # species. The radar charts are experimented with here to see if we can\n    # nicely visualize how the modeled source profiles change across four\n    # scenarios:\n    #  1) No gas-phase species present, just seven particulate counts on\n    #     Sulfate\n    #     Nitrate\n    #     Elemental Carbon (EC)\n    #     Organic Carbon fraction 1 (OC)\n    #     Organic Carbon fraction 2 (OC2)\n    #     Organic Carbon fraction 3 (OC3)\n    #     Pyrolyzed Organic Carbon (OP)\n    #  2)Inclusion of gas-phase specie carbon monoxide (CO)\n    #  3)Inclusion of gas-phase specie ozone (O3).\n    #  4)Inclusion of both gas-phase species is present...\n    data = [\n        ['Sulfate', 'Nitrate', 'EC', 'OC1', 'OC2', 'OC3', 'OP', 'CO', 'O3'],\n        ('Basecase', [\n            [0.88, 0.01, 0.03, 0.03, 0.00, 0.06, 0.01, 0.00, 0.00],\n            [0.07, 0.95, 0.04, 0.05, 0.00, 0.02, 0.01, 0.00, 0.00],\n            [0.01, 0.02, 0.85, 0.19, 0.05, 0.10, 0.00, 0.00, 0.00],\n            [0.02, 0.01, 0.07, 0.01, 0.21, 0.12, 0.98, 0.00, 0.00],\n            [0.01, 0.01, 0.02, 0.71, 0.74, 0.70, 0.00, 0.00, 0.00]]),\n        ('With CO', [\n            [0.88, 0.02, 0.02, 0.02, 0.00, 0.05, 0.00, 0.05, 0.00],\n            [0.08, 0.94, 0.04, 0.02, 0.00, 0.01, 0.12, 0.04, 0.00],\n            [0.01, 0.01, 0.79, 0.10, 0.00, 0.05, 0.00, 0.31, 0.00],\n            [0.00, 0.02, 0.03, 0.38, 0.31, 0.31, 0.00, 0.59, 0.00],\n            [0.02, 0.02, 0.11, 0.47, 0.69, 0.58, 0.88, 0.00, 0.00]]),\n        ('With O3', [\n            [0.89, 0.01, 0.07, 0.00, 0.00, 0.05, 0.00, 0.00, 0.03],\n            [0.07, 0.95, 0.05, 0.04, 0.00, 0.02, 0.12, 0.00, 0.00],\n            [0.01, 0.02, 0.86, 0.27, 0.16, 0.19, 0.00, 0.00, 0.00],\n            [0.01, 0.03, 0.00, 0.32, 0.29, 0.27, 0.00, 0.00, 0.95],\n            [0.02, 0.00, 0.03, 0.37, 0.56, 0.47, 0.87, 0.00, 0.00]]),\n        ('CO & O3', [\n            [0.87, 0.01, 0.08, 0.00, 0.00, 0.04, 0.00, 0.00, 0.01],\n            [0.09, 0.95, 0.02, 0.03, 0.00, 0.01, 0.13, 0.06, 0.00],\n            [0.01, 0.02, 0.71, 0.24, 0.13, 0.16, 0.00, 0.50, 0.00],\n            [0.01, 0.03, 0.00, 0.28, 0.24, 0.23, 0.00, 0.44, 0.88],\n            [0.02, 0.00, 0.18, 0.45, 0.64, 0.55, 0.86, 0.00, 0.16]])\n    ]\n    return data\n\n\nif __name__ == '__main__':\n    N = 9\n    theta = radar_factory(N, frame='polygon')\n\n    data = example_data()\n    spoke_labels = data.pop(0)\n\n    fig, axs = plt.subplots(figsize=(9, 9), nrows=2, ncols=2,\n                            subplot_kw=dict(projection='radar'))\n    fig.subplots_adjust(wspace=0.25, hspace=0.20, top=0.85, bottom=0.05)\n\n    colors = ['b', 'r', 'g', 'm', 'y']\n    # Plot the four cases from the example data on separate axes\n    for ax, (title, case_data) in zip(axs.flat, data):\n        ax.set_rgrids([0.2, 0.4, 0.6, 0.8])\n        ax.set_title(title, weight='bold', size='medium', position=(0.5, 1.1),\n                     horizontalalignment='center', verticalalignment='center')\n        for d, color in zip(case_data, colors):\n            ax.plot(theta, d, color=color)\n            ax.fill(theta, d, facecolor=color, alpha=0.25, label='_nolegend_')\n        ax.set_varlabels(spoke_labels)\n\n    # add legend relative to top-left plot\n    labels = ('Factor 1', 'Factor 2', 'Factor 3', 'Factor 4', 'Factor 5')\n    legend = axs[0, 0].legend(labels, loc=(0.9, .95),\n                              labelspacing=0.1, fontsize='small')\n\n    fig.text(0.5, 0.965, '5-Factor Solution Profiles Across Four Scenarios',\n             horizontalalignment='center', color='black', weight='bold',\n             size='large')\n\n    plt.show()\n",
    "id": 304
},
{
    "title": "Long chain of connections using Sankey",
    "text": "Demonstrate/test the Sankey class by producing a long chain of connections. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.sankey matplotlib.sankey.Sankey matplotlib.sankey.Sankey.add matplotlib.sankey.Sankey.finish",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nlinks_per_side = 6\n\n\ndef side(sankey, n=1):\n    '''Generate a side chain.'''\n    prior = len(sankey.diagrams)\n    for i in range(0, 2*n, 2):\n        sankey.add(flows=[1, -1], orientations=[-1, -1],\n                   patchlabel=str(prior + i),\n                   prior=prior + i - 1, connect=(1, 0), alpha=0.5)\n        sankey.add(flows=[1, -1], orientations=[1, 1],\n                   patchlabel=str(prior + i + 1),\n                   prior=prior + i, connect=(1, 0), alpha=0.5)\n\n\ndef corner(sankey):\n    '''Generate a corner link.'''\n    prior = len(sankey.diagrams)\n    sankey.add(flows=[1, -1], orientations=[0, 1],\n               patchlabel=str(prior), facecolor='k',\n               prior=prior - 1, connect=(1, 0), alpha=0.5)\n\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title='Why would you want to do this?\\\n(But you could.)')\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=[1, -1], orientations=[0, 1],\n           patchlabel='0', facecolor='k',\n           rotation=45)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\nsankey.finish()\n# Notice:\n# 1. The alignment doesn't drift significantly (if at all; with 16007\n#    subdiagrams there is still closure).\n# 2. The first diagram is rotated 45 deg, so all other diagrams are rotated\n#    accordingly.\n\nplt.show()\n",
    "id": 305
},
{
    "title": "Rankine power cycle",
    "text": "Demonstrate the Sankey class with a practical example of a Rankine power cycle. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.sankey matplotlib.sankey.Sankey matplotlib.sankey.Sankey.add matplotlib.sankey.Sankey.finish",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nfig = plt.figure(figsize=(8, 9))\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title='Rankine Power Cycle: Example 8.6 from Moran and '\n                     'Shapiro\\\n\\\\x22Fundamentals of Engineering Thermodynamics '\n                     '\\\\x22, 6th ed., 2008')\nHdot = [260.431, 35.078, 180.794, 221.115, 22.700,\n        142.361, 10.193, 10.210, 43.670, 44.312,\n        68.631, 10.758, 10.758, 0.017, 0.642,\n        232.121, 44.559, 100.613, 132.168]  # MW\nsankey = Sankey(ax=ax, format='%.3G', unit=' MW', gap=0.5, scale=1.0/Hdot[0])\nsankey.add(patchlabel='\\\n\\\nPump 1', rotation=90, facecolor='#37c959',\n           flows=[Hdot[13], Hdot[6], -Hdot[7]],\n           labels=['Shaft power', '', None],\n           pathlengths=[0.4, 0.883, 0.25],\n           orientations=[1, -1, 0])\nsankey.add(patchlabel='\\\n\\\nOpen\\\nheater', facecolor='#37c959',\n           flows=[Hdot[11], Hdot[7], Hdot[4], -Hdot[8]],\n           labels=[None, '', None, None],\n           pathlengths=[0.25, 0.25, 1.93, 0.25],\n           orientations=[1, 0, -1, 0], prior=0, connect=(2, 1))\nsankey.add(patchlabel='\\\n\\\nPump 2', facecolor='#37c959',\n           flows=[Hdot[14], Hdot[8], -Hdot[9]],\n           labels=['Shaft power', '', None],\n           pathlengths=[0.4, 0.25, 0.25],\n           orientations=[1, 0, 0], prior=1, connect=(3, 1))\nsankey.add(patchlabel='Closed\\\nheater', trunklength=2.914, fc='#37c959',\n           flows=[Hdot[9], Hdot[1], -Hdot[11], -Hdot[10]],\n           pathlengths=[0.25, 1.543, 0.25, 0.25],\n           labels=['', '', None, None],\n           orientations=[0, -1, 1, -1], prior=2, connect=(2, 0))\nsankey.add(patchlabel='Trap', facecolor='#37c959', trunklength=5.102,\n           flows=[Hdot[11], -Hdot[12]],\n           labels=['\\\n', None],\n           pathlengths=[1.0, 1.01],\n           orientations=[1, 1], prior=3, connect=(2, 0))\nsankey.add(patchlabel='Steam\\\ngenerator', facecolor='#ff5555',\n           flows=[Hdot[15], Hdot[10], Hdot[2], -Hdot[3], -Hdot[0]],\n           labels=['Heat rate', '', '', None, None],\n           pathlengths=0.25,\n           orientations=[1, 0, -1, -1, -1], prior=3, connect=(3, 1))\nsankey.add(patchlabel='\\\n\\\n\\\nTurbine 1', facecolor='#37c959',\n           flows=[Hdot[0], -Hdot[16], -Hdot[1], -Hdot[2]],\n           labels=['', None, None, None],\n           pathlengths=[0.25, 0.153, 1.543, 0.25],\n           orientations=[0, 1, -1, -1], prior=5, connect=(4, 0))\nsankey.add(patchlabel='\\\n\\\n\\\nReheat', facecolor='#37c959',\n           flows=[Hdot[2], -Hdot[2]],\n           labels=[None, None],\n           pathlengths=[0.725, 0.25],\n           orientations=[-1, 0], prior=6, connect=(3, 0))\nsankey.add(patchlabel='Turbine 2', trunklength=3.212, facecolor='#37c959',\n           flows=[Hdot[3], Hdot[16], -Hdot[5], -Hdot[4], -Hdot[17]],\n           labels=[None, 'Shaft power', None, '', 'Shaft power'],\n           pathlengths=[0.751, 0.15, 0.25, 1.93, 0.25],\n           orientations=[0, -1, 0, -1, 1], prior=6, connect=(1, 1))\nsankey.add(patchlabel='Condenser', facecolor='#58b1fa', trunklength=1.764,\n           flows=[Hdot[5], -Hdot[18], -Hdot[6]],\n           labels=['', 'Heat rate', None],\n           pathlengths=[0.45, 0.25, 0.883],\n           orientations=[-1, 1, 0], prior=8, connect=(2, 0))\ndiagrams = sankey.finish()\nfor diagram in diagrams:\n    diagram.text.set_fontweight('bold')\n    diagram.text.set_fontsize('10')\n    for text in diagram.texts:\n        text.set_fontsize('10')\n# Notice that the explicit connections are handled automatically, but the\n# implicit ones currently are not.  The lengths of the paths and the trunks\n# must be adjusted manually, and that is a bit tricky.\n\nplt.show()\n",
    "id": 306
},
{
    "title": "SkewT-logP diagram: using transforms and custom projections",
    "text": "This serves as an intensive exercise of Matplotlib's transforms and custom\nprojection API. This example produces a so-called SkewT-logP diagram, which is\na common plot in meteorology for displaying vertical profiles of temperature.\nAs far as Matplotlib is concerned, the complexity comes from having X and Y\naxes that are not orthogonal. This is handled by including a skew component to\nthe basic Axes transforms. Additional complexity comes in handling the fact\nthat the upper and lower X-axes have different data ranges, which necessitates\na bunch of custom classes for ticks, spines, and axis to handle this.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.transforms matplotlib.spines matplotlib.spines.Spine matplotlib.spines.Spine.register_axis matplotlib.projections matplotlib.projections.register_projection",
    "code": "from contextlib import ExitStack\n\nfrom matplotlib.axes import Axes\nimport matplotlib.axis as maxis\nfrom matplotlib.projections import register_projection\nimport matplotlib.spines as mspines\nimport matplotlib.transforms as transforms\n\n\n# The sole purpose of this class is to look at the upper, lower, or total\n# interval as appropriate and see what parts of the tick to draw, if any.\nclass SkewXTick(maxis.XTick):\n    def draw(self, renderer):\n        # When adding the callbacks with `stack.callback`, we fetch the current\n        # visibility state of the artist with `get_visible`; the ExitStack will\n        # restore these states (`set_visible`) at the end of the block (after\n        # the draw).\n        with ExitStack() as stack:\n            for artist in [self.gridline, self.tick1line, self.tick2line,\n                           self.label1, self.label2]:\n                stack.callback(artist.set_visible, artist.get_visible())\n            needs_lower = transforms.interval_contains(\n                self.axes.lower_xlim, self.get_loc())\n            needs_upper = transforms.interval_contains(\n                self.axes.upper_xlim, self.get_loc())\n            self.tick1line.set_visible(\n                self.tick1line.get_visible() and needs_lower)\n            self.label1.set_visible(\n                self.label1.get_visible() and needs_lower)\n            self.tick2line.set_visible(\n                self.tick2line.get_visible() and needs_upper)\n            self.label2.set_visible(\n                self.label2.get_visible() and needs_upper)\n            super().draw(renderer)\n\n    def get_view_interval(self):\n        return self.axes.xaxis.get_view_interval()\n\n\n# This class exists to provide two separate sets of intervals to the tick,\n# as well as create instances of the custom tick\nclass SkewXAxis(maxis.XAxis):\n    def _get_tick(self, major):\n        return SkewXTick(self.axes, None, major=major)\n\n    def get_view_interval(self):\n        return self.axes.upper_xlim[0], self.axes.lower_xlim[1]\n\n\n# This class exists to calculate the separate data range of the\n# upper X-axis and draw the spine there. It also provides this range\n# to the X-axis artist for ticking and gridlines\nclass SkewSpine(mspines.Spine):\n    def _adjust_location(self):\n        pts = self._path.vertices\n        if self.spine_type == 'top':\n            pts[:, 0] = self.axes.upper_xlim\n        else:\n            pts[:, 0] = self.axes.lower_xlim\n\n\n# This class handles registration of the skew-xaxes as a projection as well\n# as setting up the appropriate transformations. It also overrides standard\n# spines and axes instances as appropriate.\nclass SkewXAxes(Axes):\n    # The projection must specify a name.  This will be used be the\n    # user to select the projection, i.e. ``subplot(projection='skewx')``.\n    name = 'skewx'\n\n    def _init_axis(self):\n        # Taken from Axes and modified to use our modified X-axis\n        self.xaxis = SkewXAxis(self)\n        self.spines.top.register_axis(self.xaxis)\n        self.spines.bottom.register_axis(self.xaxis)\n        self.yaxis = maxis.YAxis(self)\n        self.spines.left.register_axis(self.yaxis)\n        self.spines.right.register_axis(self.yaxis)\n\n    def _gen_axes_spines(self):\n        spines = {'top': SkewSpine.linear_spine(self, 'top'),\n                  'bottom': mspines.Spine.linear_spine(self, 'bottom'),\n                  'left': mspines.Spine.linear_spine(self, 'left'),\n                  'right': mspines.Spine.linear_spine(self, 'right')}\n        return spines\n\n    def _set_lim_and_transforms(self):\n        '''\n        This is called once when the plot is created to set up all the\n        transforms for the data, text and grids.\n        '''\n        rot = 30\n\n        # Get the standard transform setup from the Axes base class\n        super()._set_lim_and_transforms()\n\n        # Need to put the skew in the middle, after the scale and limits,\n        # but before the transAxes. This way, the skew is done in Axes\n        # coordinates thus performing the transform around the proper origin\n        # We keep the pre-transAxes transform around for other users, like the\n        # spines for finding bounds\n        self.transDataToAxes = (\n            self.transScale\n            + self.transLimits\n            + transforms.Affine2D().skew_deg(rot, 0)\n        )\n        # Create the full transform from Data to Pixels\n        self.transData = self.transDataToAxes + self.transAxes\n\n        # Blended transforms like this need to have the skewing applied using\n        # both axes, in axes coords like before.\n        self._xaxis_transform = (\n            transforms.blended_transform_factory(\n                self.transScale + self.transLimits,\n                transforms.IdentityTransform())\n            + transforms.Affine2D().skew_deg(rot, 0)\n            + self.transAxes\n        )\n\n    @property\n    def lower_xlim(self):\n        return self.axes.viewLim.intervalx\n\n    @property\n    def upper_xlim(self):\n        pts = [[0., 1.], [1., 1.]]\n        return self.transDataToAxes.inverted().transform(pts)[:, 0]\n\n\n# Now register the projection with matplotlib so the user can select it.\nregister_projection(SkewXAxes)\n\nif __name__ == '__main__':\n    # Now make a simple example using the custom projection.\n    from io import StringIO\n\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    from matplotlib.ticker import (MultipleLocator, NullFormatter,\n                                   ScalarFormatter)\n\n    # Some example data.\n    data_txt = '''\n        978.0    345    7.8    0.8\n        971.0    404    7.2    0.2\n        946.7    610    5.2   -1.8\n        944.0    634    5.0   -2.0\n        925.0    798    3.4   -2.6\n        911.8    914    2.4   -2.7\n        906.0    966    2.0   -2.7\n        877.9   1219    0.4   -3.2\n        850.0   1478   -1.3   -3.7\n        841.0   1563   -1.9   -3.8\n        823.0   1736    1.4   -0.7\n        813.6   1829    4.5    1.2\n        809.0   1875    6.0    2.2\n        798.0   1988    7.4   -0.6\n        791.0   2061    7.6   -1.4\n        783.9   2134    7.0   -1.7\n        755.1   2438    4.8   -3.1\n        727.3   2743    2.5   -4.4\n        700.5   3048    0.2   -5.8\n        700.0   3054    0.2   -5.8\n        698.0   3077    0.0   -6.0\n        687.0   3204   -0.1   -7.1\n        648.9   3658   -3.2  -10.9\n        631.0   3881   -4.7  -12.7\n        600.7   4267   -6.4  -16.7\n        592.0   4381   -6.9  -17.9\n        577.6   4572   -8.1  -19.6\n        555.3   4877  -10.0  -22.3\n        536.0   5151  -11.7  -24.7\n        533.8   5182  -11.9  -25.0\n        500.0   5680  -15.9  -29.9\n        472.3   6096  -19.7  -33.4\n        453.0   6401  -22.4  -36.0\n        400.0   7310  -30.7  -43.7\n        399.7   7315  -30.8  -43.8\n        387.0   7543  -33.1  -46.1\n        382.7   7620  -33.8  -46.8\n        342.0   8398  -40.5  -53.5\n        320.4   8839  -43.7  -56.7\n        318.0   8890  -44.1  -57.1\n        310.0   9060  -44.7  -58.7\n        306.1   9144  -43.9  -57.9\n        305.0   9169  -43.7  -57.7\n        300.0   9280  -43.5  -57.5\n        292.0   9462  -43.7  -58.7\n        276.0   9838  -47.1  -62.1\n        264.0  10132  -47.5  -62.5\n        251.0  10464  -49.7  -64.7\n        250.0  10490  -49.7  -64.7\n        247.0  10569  -48.7  -63.7\n        244.0  10649  -48.9  -63.9\n        243.3  10668  -48.9  -63.9\n        220.0  11327  -50.3  -65.3\n        212.0  11569  -50.5  -65.5\n        210.0  11631  -49.7  -64.7\n        200.0  11950  -49.9  -64.9\n        194.0  12149  -49.9  -64.9\n        183.0  12529  -51.3  -66.3\n        164.0  13233  -55.3  -68.3\n        152.0  13716  -56.5  -69.5\n        150.0  13800  -57.1  -70.1\n        136.0  14414  -60.5  -72.5\n        132.0  14600  -60.1  -72.1\n        131.4  14630  -60.2  -72.2\n        128.0  14792  -60.9  -72.9\n        125.0  14939  -60.1  -72.1\n        119.0  15240  -62.2  -73.8\n        112.0  15616  -64.9  -75.9\n        108.0  15838  -64.1  -75.1\n        107.8  15850  -64.1  -75.1\n        105.0  16010  -64.7  -75.7\n        103.0  16128  -62.9  -73.9\n        100.0  16310  -62.5  -73.5\n    '''\n\n    # Parse the data\n    sound_data = StringIO(data_txt)\n    p, h, T, Td = np.loadtxt(sound_data, unpack=True)\n\n    # Create a new figure. The dimensions here give a good aspect ratio\n    fig = plt.figure(figsize=(6.5875, 6.2125))\n    ax = fig.add_subplot(projection='skewx')\n\n    plt.grid(True)\n\n    # Plot the data using normal plotting functions, in this case using\n    # log scaling in Y, as dictated by the typical meteorological plot\n    ax.semilogy(T, p, color='C3')\n    ax.semilogy(Td, p, color='C2')\n\n    # An example of a slanted line at constant X\n    l = ax.axvline(0, color='C0')\n\n    # Disables the log-formatting that comes with semilogy\n    ax.yaxis.set_major_formatter(ScalarFormatter())\n    ax.yaxis.set_minor_formatter(NullFormatter())\n    ax.set_yticks(np.linspace(100, 1000, 10))\n    ax.set_ylim(1050, 100)\n\n    ax.xaxis.set_major_locator(MultipleLocator(10))\n    ax.set_xlim(-50, 50)\n\n    plt.show()\n",
    "id": 307
},
{
    "title": "Topographic hillshading",
    "text": "Demonstrates the visual effect of varying blend mode and vertical exaggeration\non \"hillshaded\" plots. Note that the \"overlay\" and \"soft\" blend modes work well for complex surfaces\nsuch as this example, while the default \"hsv\" blend mode works best for smooth\nsurfaces such as many mathematical functions. In most cases, hillshading is used purely for visual purposes, and dx/dy\ncan be safely ignored. In that case, you can tweak vert_exag (vertical\nexaggeration) by trial and error to give the desired visual effect. However,\nthis example demonstrates how to use the dx and dy keyword arguments to\nensure that the vert_exag parameter is the true vertical exaggeration. Total running time of the script: (0 minutes 1.734 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.colors import LightSource\n\ndem = get_sample_data('jacksboro_fault_dem.npz')\nz = dem['elevation']\n# -- Optional dx and dy for accurate vertical exaggeration --------------------\n# If you need topographically accurate vertical exaggeration, or you don't want\n# to guess at what *vert_exag* should be, you'll need to specify the cellsize\n# of the grid (i.e. the *dx* and *dy* parameters).  Otherwise, any *vert_exag*\n# value you specify will be relative to the grid spacing of your input data\n# (in other words, *dx* and *dy* default to 1.0, and *vert_exag* is calculated\n# relative to those parameters).  Similarly, *dx* and *dy* are assumed to be in\n# the same units as your input z-values.  Therefore, we'll need to convert the\n# given dx and dy from decimal degrees to meters.\ndx, dy = dem['dx'], dem['dy']\ndy = 111200 * dy\ndx = 111200 * dx * np.cos(np.radians(dem['ymin']))\n# -----------------------------------------------------------------------------\n\n# Shade from the northwest, with the sun 45 degrees from horizontal\nls = LightSource(azdeg=315, altdeg=45)\ncmap = plt.cm.gist_earth\n\nfig, axs = plt.subplots(nrows=4, ncols=3, figsize=(8, 9))\nplt.setp(axs.flat, xticks=[], yticks=[])\n\n# Vary vertical exaggeration and blend mode and plot all combinations\nfor col, ve in zip(axs.T, [0.1, 1, 10]):\n    # Show the hillshade intensity image in the first row\n    col[0].imshow(ls.hillshade(z, vert_exag=ve, dx=dx, dy=dy), cmap='gray')\n\n    # Place hillshaded plots with different blend modes in the rest of the rows\n    for ax, mode in zip(col[1:], ['hsv overlay soft']):\n        rgb = ls.shade(z, cmap=cmap, blend_mode=mode,\n                       vert_exag=ve, dx=dx, dy=dy)\n        ax.imshow(rgb)\n\n# Label rows and columns\nfor ax, ve in zip(axs[0], [0.1, 1, 10]):\n    ax.set_title(f'{ve}', size=18)\nfor ax, mode in zip(axs[:, 0], ['Hillshade hsv overlay soft']):\n    ax.set_ylabel(mode, size=18)\n\n# Group labels...\naxs[0, 1].annotate('Vertical Exaggeration', (0.5, 1), xytext=(0, 30),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='center', va='bottom', size=20)\naxs[2, 0].annotate('Blend Mode', (0, 0.5), xytext=(-30, 0),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='right', va='center', size=20, rotation=90)\nfig.subplots_adjust(bottom=0.05, right=0.95)\n\nplt.show()\n",
    "id": 308
},
{
    "title": "Spines",
    "text": "This demo compares: normal Axes, with spines on all four sides; an Axes with spines only on the left and bottom; an Axes using custom bounds to limit the extent of the spine. Each axes.Axes has a list of Spine objects, accessible\nvia the container ax.spines. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.artist.Artist.set_visible matplotlib.spines.Spine.set_bounds",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 100)\ny = 2 * np.sin(x)\n\n# Constrained layout makes sure the labels don't overlap the axes.\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3, layout='constrained')\n\nax0.plot(x, y)\nax0.set_title('normal spines')\n\nax1.plot(x, y)\nax1.set_title('bottom-left spines')\n\n# Hide the right and top spines\nax1.spines.right.set_visible(False)\nax1.spines.top.set_visible(False)\n\nax2.plot(x, y)\nax2.set_title('spines with bounds limited to data range')\n\n# Only draw spines for the data range, not in the margins\nax2.spines.bottom.set_bounds(x.min(), x.max())\nax2.spines.left.set_bounds(y.min(), y.max())\n# Hide the right and top spines\nax2.spines.right.set_visible(False)\nax2.spines.top.set_visible(False)\n\nplt.show()\n",
    "id": 309
},
{
    "title": "Dropped spines",
    "text": "Demo of spines offset from the axes (a.k.a. \"dropped spines\").",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjust_spines(ax, visible_spines):\n    ax.label_outer(remove_inner_ticks=True)\n    ax.grid(color='0.9')\n\n    for loc, spine in ax.spines.items():\n        if loc in visible_spines:\n            spine.set_position(('outward', 10))  # outward by 10 points\n        else:\n            spine.set_visible(False)\n\n\nx = np.linspace(0, 2 * np.pi, 100)\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(x, np.sin(x))\naxs[0, 1].plot(x, np.cos(x))\naxs[1, 0].plot(x, -np.cos(x))\naxs[1, 1].plot(x, -np.sin(x))\n\nadjust_spines(axs[0, 0], ['left'])\nadjust_spines(axs[0, 1], [])\nadjust_spines(axs[1, 0], ['left bottom'])\nadjust_spines(axs[1, 1], ['bottom'])\n\nplt.show()\n",
    "id": 310
},
{
    "title": "Multiple y-axis with Spines",
    "text": "Create multiple y axes with a shared x-axis. This is done by creating\na twinx axes, turning all spines but the right one invisible\nand offset its position using set_position. Note that this approach uses matplotlib.axes.Axes and their\nSpines. Alternative approaches using non-standard axes\nare shown in the Parasite Axes demo and\nParasite axis demo examples.",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(right=0.75)\n\ntwin1 = ax.twinx()\ntwin2 = ax.twinx()\n\n# Offset the right spine of twin2.  The ticks and label have already been\n# placed on the right by twinx above.\ntwin2.spines.right.set_position(('axes', 1.2))\n\np1, = ax.plot([0, 1, 2], [0, 1, 2], 'C0', label='Density')\np2, = twin1.plot([0, 1, 2], [0, 3, 2], 'C1', label='Temperature')\np3, = twin2.plot([0, 1, 2], [50, 30, 15], 'C2', label='Velocity')\n\nax.set(xlim=(0, 2), ylim=(0, 2), xlabel='Distance', ylabel='Density')\ntwin1.set(ylim=(0, 4), ylabel='Temperature')\ntwin2.set(ylim=(1, 65), ylabel='Velocity')\n\nax.yaxis.label.set_color(p1.get_color())\ntwin1.yaxis.label.set_color(p2.get_color())\ntwin2.yaxis.label.set_color(p3.get_color())\n\nax.tick_params(axis='y', colors=p1.get_color())\ntwin1.tick_params(axis='y', colors=p2.get_color())\ntwin2.tick_params(axis='y', colors=p3.get_color())\n\nax.legend(handles=[p1, p2, p3])\n\nplt.show()\n",
    "id": 311
},
{
    "title": "Centered spines with arrows",
    "text": "This example shows a way to draw a \"math textbook\" style plot, where the\nspines (\"axes lines\") are drawn at x = 0 and y = 0, and have arrows at\ntheir ends.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n# Move the left and bottom spines to x = 0 and y = 0, respectively.\nax.spines[['left', 'bottom']].set_position(('data', 0))\n# Hide the top and right spines.\nax.spines[['top', 'right']].set_visible(False)\n\n# Draw arrows (as black triangles: '>k'/'^k') at the end of the axes.  In each\n# case, one of the coordinates (0) is a data coordinate (i.e., y = 0 or x = 0,\n# respectively) and the other one (1) is an axes coordinate (i.e., at the very\n# right/top of the axes).  Also, disable clipping (clip_on=False) as the marker\n# actually spills out of the axes.\nax.plot(1, 0, '>k', transform=ax.get_yaxis_transform(), clip_on=False)\nax.plot(0, 1, '^k', transform=ax.get_xaxis_transform(), clip_on=False)\n\n# Some sample data.\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()\n",
    "id": 312
},
{
    "title": "Custom Ticker",
    "text": "The matplotlib.ticker module defines many preset tickers, but was\nprimarily designed for extensibility, i.e., to support user customized ticking. In this example, a user defined function is used to format the ticks in\nmillions of dollars on the y-axis. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axis.Axis.set_major_formatter",
    "code": "import matplotlib.pyplot as plt\n\n\ndef millions(x, pos):\n    '''The two arguments are the value and tick position.'''\n    return f'${x*1e-6:1.1f}M'\n\n\nfig, ax = plt.subplots()\n# set_major_formatter internally creates a FuncFormatter from the callable.\nax.yaxis.set_major_formatter(millions)\nmoney = [1.5e5, 2.5e6, 5.5e6, 2.0e7]\nax.bar(['Bill', 'Fred', 'Mary', 'Sue'], money)\nplt.show()\n",
    "id": 313
},
{
    "title": "Date Demo Convert",
    "text": "Download Python source code: date_demo_convert.py Download Jupyter notebook: date_demo_convert.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import DateFormatter, DayLocator, HourLocator, drange\n\ndate1 = datetime.datetime(2000, 3, 2)\ndate2 = datetime.datetime(2000, 3, 6)\ndelta = datetime.timedelta(hours=6)\ndates = drange(date1, date2, delta)\n\ny = np.arange(len(dates))\n\nfig, ax = plt.subplots()\nax.plot(dates, y**2, 'o')\n\n# this is superfluous, since the autoscaler should get it right, but\n# use date2num and num2date to convert between dates and floats if\n# you want; both date2num and num2date convert an instance or sequence\nax.set_xlim(dates[0], dates[-1])\n\n# The hour locator takes the hour or sequence of hours you want to\n# tick, not the base multiple\n\nax.xaxis.set_major_locator(DayLocator())\nax.xaxis.set_minor_locator(HourLocator(range(0, 25, 6)))\nax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))\n\nax.fmt_xdata = DateFormatter('%Y-%m-%d %H:%M:%S')\nfig.autofmt_xdate()\n\nplt.show()\n",
    "id": 314
},
{
    "title": "Placing date ticks using recurrence rules",
    "text": "The iCalender RFC specifies recurrence rules (rrules), that define\ndate sequences. You can use rrules in Matplotlib to place date ticks. This example sets custom date ticks on every 5th easter. See https://dateutil.readthedocs.io/en/stable/rrule.html for help with rrules.",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (YEARLY, DateFormatter, RRuleLocator, drange,\n                              rrulewrapper)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# tick every 5th easter\nrule = rrulewrapper(YEARLY, byeaster=1, interval=5)\nloc = RRuleLocator(rule)\nformatter = DateFormatter('%m/%d/%y')\ndate1 = datetime.date(1952, 1, 1)\ndate2 = datetime.date(2004, 4, 12)\ndelta = datetime.timedelta(days=100)\n\ndates = drange(date1, date2, delta)\ns = np.random.rand(len(dates))  # make up some random y values\n\n\nfig, ax = plt.subplots()\nplt.plot(dates, s, 'o')\nax.xaxis.set_major_locator(loc)\nax.xaxis.set_major_formatter(formatter)\nax.xaxis.set_tick_params(rotation=30, labelsize=10)\n\nplt.show()\n",
    "id": 315
},
{
    "title": "Dollar ticks",
    "text": "Use a FormatStrFormatter to prepend dollar signs on y-axis labels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_tick_params matplotlib.axis.Tick matplotlib.ticker.StrMethodFormatter",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.plot(100*np.random.rand(20))\n\n# Use automatic StrMethodFormatter\nax.yaxis.set_major_formatter('${x:1.2f}')\n\nax.yaxis.set_tick_params(which='major', labelcolor='green',\n                         labelleft=False, labelright=True)\n\nplt.show()\n",
    "id": 316
},
{
    "title": "The default tick formatter",
    "text": "By default, tick labels are formatted using a ScalarFormatter, which can be\nconfigured via ticklabel_format. This example illustrates some\npossible configurations: Default. useMathText=True: Fancy formatting of mathematical expressions. useOffset=False: Do not use offset notation; see\nScalarFormatter.set_useOffset. Total running time of the script: (0 minutes 1.477 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 1, .01)\nfig, axs = plt.subplots(\n    3, 3, figsize=(9, 9), layout='constrained', gridspec_kw={'hspace': 0.1})\n\nfor col in axs.T:\n    col[0].plot(x * 1e5 + 1e10, x * 1e-10 + 1e-5)\n    col[1].plot(x * 1e5, x * 1e-4)\n    col[2].plot(-x * 1e5 - 1e10, -x * 1e-5 - 1e-10)\n\nfor ax in axs[:, 1]:\n    ax.ticklabel_format(useMathText=True)\nfor ax in axs[:, 2]:\n    ax.ticklabel_format(useOffset=False)\n\nplt.rcParams.update({'axes.titleweight': 'bold', 'axes.titley': 1.1})\naxs[0, 0].set_title('default settings')\naxs[0, 1].set_title('useMathText=True')\naxs[0, 2].set_title('useOffset=False')\n\nplt.show()\n",
    "id": 317
},
{
    "title": "Tick formatters",
    "text": "Tick formatters define how the numeric value associated with a tick on an axis\nis formatted as a string. This example illustrates the usage and effect of the most common formatters. The tick format is configured via the function set_major_formatter\nor set_minor_formatter. It accepts: a format string, which implicitly creates a StrMethodFormatter. a function, implicitly creates a FuncFormatter. an instance of a Formatter subclass. The most common are NullFormatter: No labels on the ticks. StrMethodFormatter: Use string str.format method. FormatStrFormatter: Use %-style formatting. FuncFormatter: Define labels through a function. FixedFormatter: Set the label strings explicitly. ScalarFormatter: Default formatter for scalars: auto-pick the format string. PercentFormatter: Format labels as a percentage. See Tick formatting for a complete list. Total running time of the script: (0 minutes 1.165 seconds)",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import ticker\n\n\ndef setup(ax, title):\n    '''Set up common parameters for the Axes in the example.'''\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    # define tick positions\n    ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00))\n    ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25))\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig = plt.figure(figsize=(8, 8), layout='constrained')\nfig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5])\n\nfig0.suptitle('String Formatting', fontsize=16, x=0, ha='left')\nax0 = fig0.subplots()\n\nsetup(ax0, title=''{x} km'')\nax0.xaxis.set_major_formatter('{x} km')\n\n\nfig1.suptitle('Function Formatting', fontsize=16, x=0, ha='left')\nax1 = fig1.subplots()\n\nsetup(ax1, title='def(x, pos): return str(x-5)')\nax1.xaxis.set_major_formatter(lambda x, pos: str(x-5))\n\n\nfig2.suptitle('Formatter Object Formatting', fontsize=16, x=0, ha='left')\naxs2 = fig2.subplots(7, 1)\n\nsetup(axs2[0], title='NullFormatter()')\naxs2[0].xaxis.set_major_formatter(ticker.NullFormatter())\n\nsetup(axs2[1], title='StrMethodFormatter('{x:.3f}')')\naxs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter('{x:.3f}'))\n\nsetup(axs2[2], title='FormatStrFormatter('#%d')')\naxs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter('#%d'))\n\n\ndef fmt_two_digits(x, pos):\n    return f'[{x:.2f}]'\n\n\nsetup(axs2[3], title='FuncFormatter('[{:.2f}]'.format)')\naxs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits))\n\nsetup(axs2[4], title='FixedFormatter(['A', 'B', 'C', 'D', 'E', 'F'])')\n# FixedFormatter should only be used together with FixedLocator.\n# Otherwise, one cannot be sure where the labels will end up.\npositions = [0, 1, 2, 3, 4, 5]\nlabels = ['A', 'B', 'C', 'D', 'E', 'F']\naxs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions))\naxs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels))\n\nsetup(axs2[5], title='ScalarFormatter()')\naxs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))\n\nsetup(axs2[6], title='PercentFormatter(xmax=5)')\naxs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5))\n\nplt.show()\n",
    "id": 318
},
{
    "title": "Tick locators",
    "text": "Tick locators define the position of the ticks. This example illustrates the usage and effect of the most common locators. References The following functions, methods, classes and modules are used in this example: matplotlib.axis.Axis.set_major_locator matplotlib.axis.Axis.set_minor_locator matplotlib.ticker.NullLocator matplotlib.ticker.MultipleLocator matplotlib.ticker.FixedLocator matplotlib.ticker.LinearLocator matplotlib.ticker.IndexLocator matplotlib.ticker.AutoLocator matplotlib.ticker.MaxNLocator matplotlib.ticker.LogLocator",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n\n\ndef setup(ax, title):\n    '''Set up common parameters for the Axes in the example.'''\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[['left', 'right', 'top']].set_visible(False)\n\n    ax.xaxis.set_ticks_position('bottom')\n    ax.tick_params(which='major', width=1.00, length=5)\n    ax.tick_params(which='minor', width=0.75, length=2.5)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname='Monospace', color='tab:blue')\n\n\nfig, axs = plt.subplots(8, 1, figsize=(8, 6))\n\n# Null Locator\nsetup(axs[0], title='NullLocator()')\naxs[0].xaxis.set_major_locator(ticker.NullLocator())\naxs[0].xaxis.set_minor_locator(ticker.NullLocator())\n\n# Multiple Locator\nsetup(axs[1], title='MultipleLocator(0.5, offset=0.2)')\naxs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5, offset=0.2))\naxs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))\n\n# Fixed Locator\nsetup(axs[2], title='FixedLocator([0, 1, 5])')\naxs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5]))\naxs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))\n\n# Linear Locator\nsetup(axs[3], title='LinearLocator(numticks=3)')\naxs[3].xaxis.set_major_locator(ticker.LinearLocator(3))\naxs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))\n\n# Index Locator\nsetup(axs[4], title='IndexLocator(base=0.5, offset=0.25)')\naxs[4].plot([0]*5, color='white')\naxs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))\n\n# Auto Locator\nsetup(axs[5], title='AutoLocator()')\naxs[5].xaxis.set_major_locator(ticker.AutoLocator())\naxs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())\n\n# MaxN Locator\nsetup(axs[6], title='MaxNLocator(n=4)')\naxs[6].xaxis.set_major_locator(ticker.MaxNLocator(4))\naxs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))\n\n# Log Locator\nsetup(axs[7], title='LogLocator(base=10, numticks=15)')\naxs[7].set_xlim(10**3, 10**10)\naxs[7].set_xscale('log')\naxs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\n\nplt.tight_layout()\nplt.show()\n",
    "id": 319
},
{
    "title": "Set default y-axis tick labels on the right",
    "text": "We can use rcParamsytick.labelright (default: False), rcParamsytick.right (default: False), rcParamsytick.labelleft (default: True),\nand rcParamsytick.left (default: True) to control where on the axes ticks and their labels\nappear. These properties can also be set in .matplotlib/matplotlibrc.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['ytick.right'] = plt.rcParams['ytick.labelright'] = True\nplt.rcParams['ytick.left'] = plt.rcParams['ytick.labelleft'] = False\n\nx = np.arange(10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1, sharex=True, figsize=(6, 6))\n\nax0.plot(x)\nax0.yaxis.tick_left()\n\n# use default parameter in rcParams, not calling tick_right()\nax1.plot(x)\n\nplt.show()\n",
    "id": 320
},
{
    "title": "Setting tick labels from a list of values",
    "text": "Using Axes.set_xticks causes the tick labels to be set on the currently\nchosen ticks. However, you may want to allow matplotlib to dynamically\nchoose the number of ticks and their spacing. In this case it may be better to determine the tick label from the\nvalue at the tick. The following example shows how to do this. NB: The ticker.MaxNLocator is used here to ensure that the tick values\ntake integer values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_major_locator matplotlib.ticker.FuncFormatter matplotlib.ticker.MaxNLocator",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.ticker import MaxNLocator\n\nfig, ax = plt.subplots()\nxs = range(26)\nys = range(26)\nlabels = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef format_fn(tick_val, tick_pos):\n    if int(tick_val) in xs:\n        return labels[int(tick_val)]\n    else:\n        return ''\n\n\n# A FuncFormatter is created automatically.\nax.xaxis.set_major_formatter(format_fn)\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nax.plot(xs, ys)\nplt.show()\n",
    "id": 321
},
{
    "title": "Rotating custom tick labels",
    "text": "Demo of custom tick-labels with user-defined rotation.",
    "code": "import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [1, 4, 9, 6]\nlabels = ['Frogs Hogs Bogs Slogs']\n\nplt.plot(x, y)\n# You can specify a rotation for the tick labels in degrees or with keywords.\nplt.xticks(x, labels, rotation='vertical')\n# Pad margins so that markers don't get clipped by the axes\nplt.margins(0.2)\n# Tweak spacing to prevent clipping of tick-labels\nplt.subplots_adjust(bottom=0.15)\nplt.show()\n",
    "id": 322
},
{
    "title": "Annotation with units",
    "text": "The example illustrates how to create text and arrow\nannotations using a centimeter-scale plot. This example requires basic_units.py",
    "code": "from basic_units import cm\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.annotate('Note 01', [0.5*cm, 0.5*cm])\n\n# xy and text both unitized\nax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',\n            xytext=(0.8*cm, 0.95*cm), textcoords='data',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='right', verticalalignment='top')\n\n# mixing units w/ nonunits\nax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',\n            xytext=(0.8, 0.95), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='right', verticalalignment='top')\n\n\nax.set_xlim(0*cm, 4*cm)\nax.set_ylim(0*cm, 4*cm)\nplt.show()\n",
    "id": 323
},
{
    "title": "Artist tests",
    "text": "Test unit support with each of the Matplotlib primitive artist types. The axis handles unit conversions and the artists keep a pointer to their axis\nparent. You must initialize the artists with the axis instance if you want to\nuse them with unit data, or else they will not know how to convert the units\nto scalars. This example requires basic_units.py",
    "code": "import random\n\nfrom basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.collections as collections\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.text as text\n\nfig, ax = plt.subplots()\nax.xaxis.set_units(cm)\nax.yaxis.set_units(cm)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nif 0:\n    # test a line collection\n    # Not supported at present.\n    verts = []\n    for i in range(10):\n        # a random line segment in inches\n        verts.append(zip(*inch*10*np.random.rand(2, random.randint(2, 15))))\n    lc = collections.LineCollection(verts, axes=ax)\n    ax.add_collection(lc)\n\n# test a plain-ol-line\nline = lines.Line2D([0*cm, 1.5*cm], [0*cm, 2.5*cm],\n                    lw=2, color='black', axes=ax)\nax.add_line(line)\n\nif 0:\n    # test a patch\n    # Not supported at present.\n    rect = patches.Rectangle((1*cm, 1*cm), width=5*cm, height=2*cm,\n                             alpha=0.2, axes=ax)\n    ax.add_patch(rect)\n\n\nt = text.Text(3*cm, 2.5*cm, 'text label', ha='left', va='bottom', axes=ax)\nax.add_artist(t)\n\nax.set_xlim(-1*cm, 10*cm)\nax.set_ylim(-1*cm, 10*cm)\n# ax.xaxis.set_units(inch)\nax.grid(True)\nax.set_title('Artists with units')\nplt.show()\n",
    "id": 324
},
{
    "title": "Bar demo with units",
    "text": "A plot using a variety of centimetre and inch conversions. This example shows\nhow default unit introspection works (ax1), how various keywords can be used to\nset the x and y units to override the defaults (ax2, ax3, ax4) and how one can\nset the xlimits using scalars (ax3, current units assumed) or units\n(conversions applied to get the numbers to current units). This example requires basic_units.py",
    "code": "from basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncms = cm * np.arange(0, 10, 2)\nbottom = 0 * cm\nwidth = 0.8 * cm\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].bar(cms, cms, bottom=bottom)\n\naxs[0, 1].bar(cms, cms, bottom=bottom, width=width, xunits=cm, yunits=inch)\n\naxs[1, 0].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=cm)\naxs[1, 0].set_xlim(2, 6)  # scalars are interpreted in current units\n\naxs[1, 1].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=inch)\naxs[1, 1].set_xlim(2 * cm, 6 * cm)  # cm are converted to inches\n\nfig.tight_layout()\nplt.show()\n",
    "id": 325
},
{
    "title": "Group barchart with units",
    "text": "This is the same example as\nthe barchart in\ncentimeters. This example requires basic_units.py",
    "code": "from basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN = 5\ntea_means = [15*cm, 10*cm, 8*cm, 12*cm, 5*cm]\ntea_std = [2*cm, 1*cm, 1*cm, 4*cm, 2*cm]\n\nfig, ax = plt.subplots()\nax.yaxis.set_units(inch)\n\nind = np.arange(N)    # the x locations for the groups\nwidth = 0.35         # the width of the bars\nax.bar(ind, tea_means, width, bottom=0*cm, yerr=tea_std, label='Tea')\n\ncoffee_means = (14*cm, 19*cm, 7*cm, 5*cm, 10*cm)\ncoffee_std = (3*cm, 5*cm, 2*cm, 1*cm, 2*cm)\nax.bar(ind + width, coffee_means, width, bottom=0*cm, yerr=coffee_std,\n       label='Coffee')\n\nax.set_title('Cup height by group and beverage choice')\nax.set_xticks(ind + width / 2, labels=['G1 G2 G3 G4 G5'])\n\nax.legend()\nax.autoscale_view()\n\nplt.show()\n",
    "id": 326
},
{
    "title": "Basic Units",
    "text": "Download Python source code: basic_units.py Download Jupyter notebook: basic_units.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import math\n\nfrom packaging.version import parse as parse_version\n\nimport numpy as np\n\nimport matplotlib.ticker as ticker\nimport matplotlib.units as units\n\n\nclass ProxyDelegate:\n    def __init__(self, fn_name, proxy_type):\n        self.proxy_type = proxy_type\n        self.fn_name = fn_name\n\n    def __get__(self, obj, objtype=None):\n        return self.proxy_type(self.fn_name, obj)\n\n\nclass TaggedValueMeta(type):\n    def __init__(self, name, bases, dict):\n        for fn_name in self._proxies:\n            if not hasattr(self, fn_name):\n                setattr(self, fn_name,\n                        ProxyDelegate(fn_name, self._proxies[fn_name]))\n\n\nclass PassThroughProxy:\n    def __init__(self, fn_name, obj):\n        self.fn_name = fn_name\n        self.target = obj.proxy_target\n\n    def __call__(self, *args):\n        fn = getattr(self.target, self.fn_name)\n        ret = fn(*args)\n        return ret\n\n\nclass ConvertArgsProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        converted_args = []\n        for a in args:\n            try:\n                converted_args.append(a.convert_to(self.unit))\n            except AttributeError:\n                converted_args.append(TaggedValue(a, self.unit))\n        converted_args = tuple([c.get_value() for c in converted_args])\n        return super().__call__(*converted_args)\n\n\nclass ConvertReturnProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        ret = super().__call__(*args)\n        return (NotImplemented if ret is NotImplemented\n                else TaggedValue(ret, self.unit))\n\n\nclass ConvertAllProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        converted_args = []\n        arg_units = [self.unit]\n        for a in args:\n            if hasattr(a, 'get_unit') and not hasattr(a, 'convert_to'):\n                # If this argument has a unit type but no conversion ability,\n                # this operation is prohibited.\n                return NotImplemented\n\n            if hasattr(a, 'convert_to'):\n                try:\n                    a = a.convert_to(self.unit)\n                except Exception:\n                    pass\n                arg_units.append(a.get_unit())\n                converted_args.append(a.get_value())\n            else:\n                converted_args.append(a)\n                if hasattr(a, 'get_unit'):\n                    arg_units.append(a.get_unit())\n                else:\n                    arg_units.append(None)\n        converted_args = tuple(converted_args)\n        ret = super().__call__(*converted_args)\n        if ret is NotImplemented:\n            return NotImplemented\n        ret_unit = unit_resolver(self.fn_name, arg_units)\n        if ret_unit is NotImplemented:\n            return NotImplemented\n        return TaggedValue(ret, ret_unit)\n\n\nclass TaggedValue(metaclass=TaggedValueMeta):\n\n    _proxies = {'__add__': ConvertAllProxy,\n                '__sub__': ConvertAllProxy,\n                '__mul__': ConvertAllProxy,\n                '__rmul__': ConvertAllProxy,\n                '__cmp__': ConvertAllProxy,\n                '__lt__': ConvertAllProxy,\n                '__gt__': ConvertAllProxy,\n                '__len__': PassThroughProxy}\n\n    def __new__(cls, value, unit):\n        # generate a new subclass for value\n        value_class = type(value)\n        try:\n            subcls = type(f'TaggedValue_of_{value_class.__name__}',\n                          (cls, value_class), {})\n            return object.__new__(subcls)\n        except TypeError:\n            return object.__new__(cls)\n\n    def __init__(self, value, unit):\n        self.value = value\n        self.unit = unit\n        self.proxy_target = self.value\n\n    def __copy__(self):\n        return TaggedValue(self.value, self.unit)\n\n    def __getattribute__(self, name):\n        if name.startswith('__'):\n            return object.__getattribute__(self, name)\n        variable = object.__getattribute__(self, 'value')\n        if hasattr(variable, name) and name not in self.__class__.__dict__:\n            return getattr(variable, name)\n        return object.__getattribute__(self, name)\n\n    def __array__(self, dtype=object):\n        return np.asarray(self.value, dtype)\n\n    def __array_wrap__(self, array, context):\n        return TaggedValue(array, self.unit)\n\n    def __repr__(self):\n        return f'TaggedValue({self.value!r}, {self.unit!r})'\n\n    def __str__(self):\n        return f'{self.value} in {self.unit}'\n\n    def __len__(self):\n        return len(self.value)\n\n    if parse_version(np.__version__) >= parse_version('1.20'):\n        def __getitem__(self, key):\n            return TaggedValue(self.value[key], self.unit)\n\n    def __iter__(self):\n        # Return a generator expression rather than use `yield`, so that\n        # TypeError is raised by iter(self) if appropriate when checking for\n        # iterability.\n        return (TaggedValue(inner, self.unit) for inner in self.value)\n\n    def get_compressed_copy(self, mask):\n        new_value = np.ma.masked_array(self.value, mask=mask).compressed()\n        return TaggedValue(new_value, self.unit)\n\n    def convert_to(self, unit):\n        if unit == self.unit or not unit:\n            return self\n        try:\n            new_value = self.unit.convert_value_to(self.value, unit)\n        except AttributeError:\n            new_value = self\n        return TaggedValue(new_value, unit)\n\n    def get_value(self):\n        return self.value\n\n    def get_unit(self):\n        return self.unit\n\n\nclass BasicUnit:\n    def __init__(self, name, fullname=None):\n        self.name = name\n        if fullname is None:\n            fullname = name\n        self.fullname = fullname\n        self.conversions = dict()\n\n    def __repr__(self):\n        return f'BasicUnit({self.name})'\n\n    def __str__(self):\n        return self.fullname\n\n    def __call__(self, value):\n        return TaggedValue(value, self)\n\n    def __mul__(self, rhs):\n        value = rhs\n        unit = self\n        if hasattr(rhs, 'get_unit'):\n            value = rhs.get_value()\n            unit = rhs.get_unit()\n            unit = unit_resolver('__mul__', (self, unit))\n        if unit is NotImplemented:\n            return NotImplemented\n        return TaggedValue(value, unit)\n\n    def __rmul__(self, lhs):\n        return self*lhs\n\n    def __array_wrap__(self, array, context):\n        return TaggedValue(array, self)\n\n    def __array__(self, t=None, context=None):\n        ret = np.array(1)\n        if t is not None:\n            return ret.astype(t)\n        else:\n            return ret\n\n    def add_conversion_factor(self, unit, factor):\n        def convert(x):\n            return x*factor\n        self.conversions[unit] = convert\n\n    def add_conversion_fn(self, unit, fn):\n        self.conversions[unit] = fn\n\n    def get_conversion_fn(self, unit):\n        return self.conversions[unit]\n\n    def convert_value_to(self, value, unit):\n        conversion_fn = self.conversions[unit]\n        ret = conversion_fn(value)\n        return ret\n\n    def get_unit(self):\n        return self\n\n\nclass UnitResolver:\n    def addition_rule(self, units):\n        for unit_1, unit_2 in zip(units[:-1], units[1:]):\n            if unit_1 != unit_2:\n                return NotImplemented\n        return units[0]\n\n    def multiplication_rule(self, units):\n        non_null = [u for u in units if u]\n        if len(non_null) > 1:\n            return NotImplemented\n        return non_null[0]\n\n    op_dict = {\n        '__mul__': multiplication_rule,\n        '__rmul__': multiplication_rule,\n        '__add__': addition_rule,\n        '__radd__': addition_rule,\n        '__sub__': addition_rule,\n        '__rsub__': addition_rule}\n\n    def __call__(self, operation, units):\n        if operation not in self.op_dict:\n            return NotImplemented\n\n        return self.op_dict[operation](self, units)\n\n\nunit_resolver = UnitResolver()\n\ncm = BasicUnit('cm', 'centimeters')\ninch = BasicUnit('inch', 'inches')\ninch.add_conversion_factor(cm, 2.54)\ncm.add_conversion_factor(inch, 1/2.54)\n\nradians = BasicUnit('rad', 'radians')\ndegrees = BasicUnit('deg', 'degrees')\nradians.add_conversion_factor(degrees, 180.0/np.pi)\ndegrees.add_conversion_factor(radians, np.pi/180.0)\n\nsecs = BasicUnit('s', 'seconds')\nhertz = BasicUnit('Hz', 'Hertz')\nminutes = BasicUnit('min', 'minutes')\n\nsecs.add_conversion_fn(hertz, lambda x: 1./x)\nsecs.add_conversion_factor(minutes, 1/60.0)\n\n\n# radians formatting\ndef rad_fn(x, pos=None):\n    if x >= 0:\n        n = int((x / np.pi) * 2.0 + 0.25)\n    else:\n        n = int((x / np.pi) * 2.0 - 0.25)\n\n    if n == 0:\n        return '0'\n    elif n == 1:\n        return r'$\\\\pi/2$'\n    elif n == 2:\n        return r'$\\\\pi$'\n    elif n == -1:\n        return r'$-\\\\pi/2$'\n    elif n == -2:\n        return r'$-\\\\pi$'\n    elif n % 2 == 0:\n        return fr'${n//2}\\\\pi$'\n    else:\n        return fr'${n}\\\\pi/2$'\n\n\nclass BasicUnitConverter(units.ConversionInterface):\n    @staticmethod\n    def axisinfo(unit, axis):\n        '''Return AxisInfo instance for x and unit.'''\n\n        if unit == radians:\n            return units.AxisInfo(\n                majloc=ticker.MultipleLocator(base=np.pi/2),\n                majfmt=ticker.FuncFormatter(rad_fn),\n                label=unit.fullname,\n            )\n        elif unit == degrees:\n            return units.AxisInfo(\n                majloc=ticker.AutoLocator(),\n                majfmt=ticker.FormatStrFormatter(r'$%i^\\\\circ$'),\n                label=unit.fullname,\n            )\n        elif unit is not None:\n            if hasattr(unit, 'fullname'):\n                return units.AxisInfo(label=unit.fullname)\n            elif hasattr(unit, 'unit'):\n                return units.AxisInfo(label=unit.unit.fullname)\n        return None\n\n    @staticmethod\n    def convert(val, unit, axis):\n        if np.iterable(val):\n            if isinstance(val, np.ma.MaskedArray):\n                val = val.astype(float).filled(np.nan)\n            out = np.empty(len(val))\n            for i, thisval in enumerate(val):\n                if np.ma.is_masked(thisval):\n                    out[i] = np.nan\n                else:\n                    try:\n                        out[i] = thisval.convert_to(unit).get_value()\n                    except AttributeError:\n                        out[i] = thisval\n            return out\n        if np.ma.is_masked(val):\n            return np.nan\n        else:\n            return val.convert_to(unit).get_value()\n\n    @staticmethod\n    def default_units(x, axis):\n        '''Return the default unit for x or None.'''\n        if np.iterable(x):\n            for thisx in x:\n                return thisx.unit\n        return x.unit\n\n\ndef cos(x):\n    if np.iterable(x):\n        return [math.cos(val.convert_to(radians).get_value()) for val in x]\n    else:\n        return math.cos(x.convert_to(radians).get_value())\n\n\nunits.registry[BasicUnit] = units.registry[TaggedValue] = BasicUnitConverter()\n",
    "id": 327
},
{
    "title": "Evans test",
    "text": "A mockup \"Foo\" units class which supports conversion and different tick\nformatting depending on the \"unit\". Here the \"unit\" is just a scalar\nconversion factor, but this example shows that Matplotlib is entirely agnostic\nto what kind of units client packages use.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\nimport matplotlib.units as units\n\n\nclass Foo:\n    def __init__(self, val, unit=1.0):\n        self.unit = unit\n        self._val = val * unit\n\n    def value(self, unit):\n        if unit is None:\n            unit = self.unit\n        return self._val / unit\n\n\nclass FooConverter(units.ConversionInterface):\n    @staticmethod\n    def axisinfo(unit, axis):\n        '''Return the Foo AxisInfo.'''\n        if unit == 1.0 or unit == 2.0:\n            return units.AxisInfo(\n                majloc=ticker.IndexLocator(8, 0),\n                majfmt=ticker.FormatStrFormatter('VAL: %s'),\n                label='foo',\n                )\n\n        else:\n            return None\n\n    @staticmethod\n    def convert(obj, unit, axis):\n        '''\n        Convert *obj* using *unit*.\n\n        If *obj* is a sequence, return the converted sequence.\n        '''\n        if np.iterable(obj):\n            return [o.value(unit) for o in obj]\n        else:\n            return obj.value(unit)\n\n    @staticmethod\n    def default_units(x, axis):\n        '''Return the default unit for *x* or None.'''\n        if np.iterable(x):\n            for thisx in x:\n                return thisx.unit\n        else:\n            return x.unit\n\n\nunits.registry[Foo] = FooConverter()\n\n# create some Foos\nx = [Foo(val, 1.0) for val in range(0, 50, 2)]\n# and some arbitrary y data\ny = [i for i in range(len(x))]\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.suptitle('Custom units')\nfig.subplots_adjust(bottom=0.2)\n\n# plot specifying units\nax2.plot(x, y, 'o', xunits=2.0)\nax2.set_title('xunits = 2.0')\nplt.setp(ax2.get_xticklabels(), rotation=30, ha='right')\n\n# plot without specifying units; will use the None branch for axisinfo\nax1.plot(x, y)  # uses default units\nax1.set_title('default units')\nplt.setp(ax1.get_xticklabels(), rotation=30, ha='right')\n\nplt.show()\n",
    "id": 328
},
{
    "title": "Radian ticks",
    "text": "Plot with radians from the basic_units mockup example package. This example shows how the unit class can determine the tick locating,\nformatting and axis labeling. This example requires basic_units.py",
    "code": "from basic_units import cos, degrees, radians\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [val*radians for val in np.arange(0, 15, 0.01)]\n\nfig, axs = plt.subplots(2)\n\naxs[0].plot(x, cos(x), xunits=radians)\naxs[1].plot(x, cos(x), xunits=degrees)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 329
},
{
    "title": "Inches and Centimeters",
    "text": "The example illustrates the ability to override default x and y units (ax1) to\ninches and centimeters using the xunits and yunits parameters for the\nplot function. Note that conversions are applied to get numbers\nto correct units. This example requires basic_units.py",
    "code": "from basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncms = cm * np.arange(0, 10, 2)\n\nfig, axs = plt.subplots(2, 2, layout='constrained')\n\naxs[0, 0].plot(cms, cms)\n\naxs[0, 1].plot(cms, cms, xunits=cm, yunits=inch)\n\naxs[1, 0].plot(cms, cms, xunits=inch, yunits=cm)\naxs[1, 0].set_xlim(-1, 4)  # scalars are interpreted in current units\n\naxs[1, 1].plot(cms, cms, xunits=inch, yunits=inch)\naxs[1, 1].set_xlim(3*cm, 6*cm)  # cm are converted to inches\n\nplt.show()\n",
    "id": 330
},
{
    "title": "Unit handling",
    "text": "The example below shows support for unit conversions over masked\narrays. This example requires basic_units.py",
    "code": "from basic_units import hertz, minutes, secs\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# create masked array\ndata = (1, 2, 3, 4, 5, 6, 7, 8)\nmask = (1, 0, 1, 0, 0, 0, 1, 0)\nxsecs = secs * np.ma.MaskedArray(data, mask, float)\n\nfig, (ax1, ax2, ax3) = plt.subplots(nrows=3, sharex=True)\n\nax1.scatter(xsecs, xsecs)\nax1.yaxis.set_units(secs)\nax2.scatter(xsecs, xsecs, yunits=hertz)\nax3.scatter(xsecs, xsecs, yunits=minutes)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 331
},
{
    "title": "CanvasAgg demo",
    "text": "This example shows how to use the agg backend directly to create images, which\nmay be of use to web application developers who want full control over their\ncode without using the pyplot interface to manage figures, figure closing etc. Note It is not necessary to avoid using the pyplot interface in order to\ncreate figures without a graphical front-end - simply setting\nthe backend to \"Agg\" would be sufficient. In this example, we show how to save the contents of the agg canvas to a file,\nand how to extract them to a numpy array, which can in turn be passed off\nto Pillow. The latter functionality allows e.g. to use Matplotlib inside a\ncgi-script without needing to write a figure to disk, and to write images in\nany format supported by Pillow. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.backends.backend_agg.FigureCanvasAgg matplotlib.figure.Figure matplotlib.figure.Figure.add_subplot matplotlib.figure.Figure.savefig / matplotlib.pyplot.savefig matplotlib.axes.Axes.plot / matplotlib.pyplot.plot",
    "code": "from PIL import Image\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\nfrom matplotlib.figure import Figure\n\nfig = Figure(figsize=(5, 4), dpi=100)\n# A canvas must be manually attached to the figure (pyplot would automatically\n# do it).  This is done by instantiating the canvas with the figure as\n# argument.\ncanvas = FigureCanvasAgg(fig)\n\n# Do some plotting.\nax = fig.add_subplot()\nax.plot([1, 2, 3])\n\n# Option 1: Save the figure to a file; can also be a file-like object (BytesIO,\n# etc.).\nfig.savefig('test.png')\n\n# Option 2: Retrieve a memoryview on the renderer buffer, and convert it to a\n# numpy array.\ncanvas.draw()\nrgba = np.asarray(canvas.buffer_rgba())\n# ... and pass it to PIL.\nim = Image.fromarray(rgba)\n# This image can then be saved to any format supported by Pillow, e.g.:\nim.save('test.bmp')\n\n# Uncomment this line to display the image using ImageMagick's `display` tool.\n# im.show()\n",
    "id": 332
},
{
    "title": "Embedding in GTK3 with a navigation toolbar",
    "text": "Demonstrate NavigationToolbar with GTK3 accessed via pygobject.",
    "code": "import gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3 import \\\\\n    NavigationToolbar2GTK3 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk3agg import \\\\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect('delete-event', Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title('Embedding in GTK3')\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot(1, 1, 1)\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nvbox = Gtk.VBox()\nwin.add(vbox)\n\n# Add canvas to vbox\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\nvbox.pack_start(canvas, True, True, 0)\n\n# Create toolbar\ntoolbar = NavigationToolbar(canvas)\nvbox.pack_start(toolbar, False, False, 0)\n\nwin.show_all()\nGtk.main()\n",
    "id": 333
},
{
    "title": "Embedding in GTK3",
    "text": "Demonstrate adding a FigureCanvasGTK3Agg widget to a Gtk.ScrolledWindow using\nGTK3 accessed via pygobject.",
    "code": "import gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect('delete-event', Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title('Embedding in GTK3')\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot()\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nsw = Gtk.ScrolledWindow()\nwin.add(sw)\n# A scrolled window border goes outside the scrollbars and viewport\nsw.set_border_width(10)\n\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\ncanvas.set_size_request(800, 600)\nsw.add(canvas)\n\nwin.show_all()\nGtk.main()\n",
    "id": 334
},
{
    "title": "Embedding in GTK4 with a navigation toolbar",
    "text": "Demonstrate NavigationToolbar with GTK4 accessed via pygobject.",
    "code": "import gi\n\ngi.require_version('Gtk', '4.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk4 import \\\\\n    NavigationToolbar2GTK4 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk4agg import \\\\\n    FigureCanvasGTK4Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\ndef on_activate(app):\n    win = Gtk.ApplicationWindow(application=app)\n    win.set_default_size(400, 300)\n    win.set_title('Embedding in GTK4')\n\n    fig = Figure(figsize=(5, 4), dpi=100)\n    ax = fig.add_subplot(1, 1, 1)\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    ax.plot(t, s)\n\n    vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)\n    win.set_child(vbox)\n\n    # Add canvas to vbox\n    canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n    canvas.set_hexpand(True)\n    canvas.set_vexpand(True)\n    vbox.append(canvas)\n\n    # Create toolbar\n    toolbar = NavigationToolbar(canvas)\n    vbox.append(toolbar)\n\n    win.show()\n\n\napp = Gtk.Application(\n    application_id='org.matplotlib.examples.EmbeddingInGTK4PanZoom')\napp.connect('activate', on_activate)\napp.run(None)\n",
    "id": 335
},
{
    "title": "Embedding in GTK4",
    "text": "Demonstrate adding a FigureCanvasGTK4Agg widget to a Gtk.ScrolledWindow using\nGTK4 accessed via pygobject.",
    "code": "import gi\n\ngi.require_version('Gtk', '4.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk4agg import \\\\\n    FigureCanvasGTK4Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\ndef on_activate(app):\n    win = Gtk.ApplicationWindow(application=app)\n    win.set_default_size(400, 300)\n    win.set_title('Embedding in GTK4')\n\n    fig = Figure(figsize=(5, 4), dpi=100)\n    ax = fig.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    ax.plot(t, s)\n\n    # A scrolled margin goes outside the scrollbars and viewport.\n    sw = Gtk.ScrolledWindow(margin_top=10, margin_bottom=10,\n                            margin_start=10, margin_end=10)\n    win.set_child(sw)\n\n    canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.set_child(canvas)\n\n    win.show()\n\n\napp = Gtk.Application(application_id='org.matplotlib.examples.EmbeddingInGTK4')\napp.connect('activate', on_activate)\napp.run(None)\n",
    "id": 336
},
{
    "title": "Embedding in Qt",
    "text": "Simple Qt application embedding Matplotlib canvases. This program will work\nequally well using any Qt binding (PyQt6, PySide6, PyQt5, PySide2). The\nbinding can be selected by setting the QT_API environment variable to\nthe binding name, or by first importing it.",
    "code": "import sys\nimport time\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_qtagg import FigureCanvas\nfrom matplotlib.backends.backend_qtagg import \\\\\n    NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.backends.qt_compat import QtWidgets\nfrom matplotlib.figure import Figure\n\n\nclass ApplicationWindow(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self._main = QtWidgets.QWidget()\n        self.setCentralWidget(self._main)\n        layout = QtWidgets.QVBoxLayout(self._main)\n\n        static_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        # Ideally one would use self.addToolBar here, but it is slightly\n        # incompatible between PyQt6 and other bindings, so we just add the\n        # toolbar as a plain widget instead.\n        layout.addWidget(NavigationToolbar(static_canvas, self))\n        layout.addWidget(static_canvas)\n\n        dynamic_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        layout.addWidget(dynamic_canvas)\n        layout.addWidget(NavigationToolbar(dynamic_canvas, self))\n\n        self._static_ax = static_canvas.figure.subplots()\n        t = np.linspace(0, 10, 501)\n        self._static_ax.plot(t, np.tan(t), '.')\n\n        self._dynamic_ax = dynamic_canvas.figure.subplots()\n        t = np.linspace(0, 10, 101)\n        # Set up a Line2D.\n        self._line, = self._dynamic_ax.plot(t, np.sin(t + time.time()))\n        self._timer = dynamic_canvas.new_timer(50)\n        self._timer.add_callback(self._update_canvas)\n        self._timer.start()\n\n    def _update_canvas(self):\n        t = np.linspace(0, 10, 101)\n        # Shift the sinusoid as a function of time.\n        self._line.set_data(t, np.sin(t + time.time()))\n        self._line.figure.canvas.draw()\n\n\nif __name__ == '__main__':\n    # Check whether there is already a running QApplication (e.g., if running\n    # from an IDE).\n    qapp = QtWidgets.QApplication.instance()\n    if not qapp:\n        qapp = QtWidgets.QApplication(sys.argv)\n\n    app = ApplicationWindow()\n    app.show()\n    app.activateWindow()\n    app.raise_()\n    qapp.exec()\n",
    "id": 337
},
{
    "title": "Embedding in Tk",
    "text": "Download Python source code: embedding_in_tk_sgskip.py Download Jupyter notebook: embedding_in_tk_sgskip.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import tkinter\n\nimport numpy as np\n\n# Implement the default Matplotlib key bindings.\nfrom matplotlib.backend_bases import key_press_handler\nfrom matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,\n                                               NavigationToolbar2Tk)\nfrom matplotlib.figure import Figure\n\nroot = tkinter.Tk()\nroot.wm_title('Embedding in Tk')\n\nfig = Figure(figsize=(5, 4), dpi=100)\nt = np.arange(0, 3, .01)\nax = fig.add_subplot()\nline, = ax.plot(t, 2 * np.sin(2 * np.pi * t))\nax.set_xlabel('time [s]')\nax.set_ylabel('f(t)')\n\ncanvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.\ncanvas.draw()\n\n# pack_toolbar=False will make it easier to use a layout manager later on.\ntoolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)\ntoolbar.update()\n\ncanvas.mpl_connect(\n    'key_press_event', lambda event: print(f'you pressed {event.key}'))\ncanvas.mpl_connect('key_press_event', key_press_handler)\n\nbutton_quit = tkinter.Button(master=root, text='Quit', command=root.destroy)\n\n\ndef update_frequency(new_val):\n    # retrieve frequency\n    f = float(new_val)\n\n    # update data\n    y = 2 * np.sin(2 * np.pi * f * t)\n    line.set_data(t, y)\n\n    # required to update canvas and attached toolbar!\n    canvas.draw()\n\n\nslider_update = tkinter.Scale(root, from_=1, to=5, orient=tkinter.HORIZONTAL,\n                              command=update_frequency, label='Frequency [Hz]')\n\n# Packing order is important. Widgets are processed sequentially and if there\n# is no space left, because the window is too small, they are not displayed.\n# The canvas is rather flexible in its size, so we pack it last which makes\n# sure the UI controls are displayed as long as possible.\nbutton_quit.pack(side=tkinter.BOTTOM)\nslider_update.pack(side=tkinter.BOTTOM)\ntoolbar.pack(side=tkinter.BOTTOM, fill=tkinter.X)\ncanvas.get_tk_widget().pack(side=tkinter.TOP, fill=tkinter.BOTH, expand=True)\n\ntkinter.mainloop()\n",
    "id": 338
},
{
    "title": "Embedding in wx #2",
    "text": "An example of how to use wxagg in an application with the new\ntoolbar - comment out the add_toolbar line for no toolbar.",
    "code": "import wx\nimport wx.lib.mixins.inspection as WIT\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.add_toolbar()  # comment this out for no toolbar\n\n    def add_toolbar(self):\n        self.toolbar = NavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n\n# Alternatively you could use:\n# class App(wx.App):\nclass App(WIT.InspectableApp):\n    def OnInit(self):\n        '''Create the main window and insert the custom frame.'''\n        self.Init()\n        frame = CanvasFrame()\n        frame.Show(True)\n\n        return True\n\n\nif __name__ == '__main__':\n    app = App()\n    app.MainLoop()\n",
    "id": 339
},
{
    "title": "Embedding in wx #3",
    "text": "Copyright (C) 2003-2004 Andrew Straw, Jeremy O'Donoghue and others\", 'License: This work is licensed under the PSF. A copy should be included\nwith this source code, and is also available at\nhttps://docs.python.org/3/license.html This is yet another example of using matplotlib with wx. Hopefully\nthis is pretty full-featured: both matplotlib toolbar and WX buttons manipulate plot full wxApp framework, including widget interaction XRC (XML wxWidgets resource) file to create GUI (made with XRCed) This was derived from embedding_in_wx and dynamic_image_wxagg. Thanks to matplotlib and wx teams for creating such great software!",
    "code": "import wx\nimport wx.xrc as xrc\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nimport matplotlib.cbook as cbook\nimport matplotlib.cm as cm\nfrom matplotlib.figure import Figure\n\nERR_TOL = 1e-5  # floating point slop for peak-detection\n\n\nclass PlotPanel(wx.Panel):\n    def __init__(self, parent):\n        super().__init__(parent, -1)\n\n        self.fig = Figure((5, 4), 75)\n        self.canvas = FigureCanvas(self, -1, self.fig)\n        self.toolbar = NavigationToolbar(self.canvas)  # matplotlib toolbar\n        self.toolbar.Realize()\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        # Best to allow the toolbar to resize!\n        sizer.Add(self.toolbar, 0, wx.GROW)\n        self.SetSizer(sizer)\n        self.Fit()\n\n    def init_plot_data(self):\n        ax = self.fig.add_subplot()\n\n        x = np.arange(120.0) * 2 * np.pi / 60.0\n        y = np.arange(100.0) * 2 * np.pi / 50.0\n        self.x, self.y = np.meshgrid(x, y)\n        z = np.sin(self.x) + np.cos(self.y)\n        self.im = ax.imshow(z, cmap=cm.RdBu, origin='lower')\n\n        zmax = np.max(z) - ERR_TOL\n        ymax_i, xmax_i = np.nonzero(z >= zmax)\n        if self.im.origin == 'upper':\n            ymax_i = z.shape[0] - ymax_i\n        self.lines = ax.plot(xmax_i, ymax_i, 'ko')\n\n        self.toolbar.update()  # Not sure why this is needed - ADS\n\n    def GetToolBar(self):\n        # You will need to override GetToolBar if you are using an\n        # unmanaged toolbar in your frame\n        return self.toolbar\n\n    def OnWhiz(self, event):\n        self.x += np.pi / 15\n        self.y += np.pi / 20\n        z = np.sin(self.x) + np.cos(self.y)\n        self.im.set_array(z)\n\n        zmax = np.max(z) - ERR_TOL\n        ymax_i, xmax_i = np.nonzero(z >= zmax)\n        if self.im.origin == 'upper':\n            ymax_i = z.shape[0] - ymax_i\n        self.lines[0].set_data(xmax_i, ymax_i)\n\n        self.canvas.draw()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        xrcfile = cbook.get_sample_data('embedding_in_wx3.xrc',\n                                        asfileobj=False)\n        print('loading', xrcfile)\n\n        self.res = xrc.XmlResource(xrcfile)\n\n        # main frame and panel ---------\n\n        self.frame = self.res.LoadFrame(None, 'MainFrame')\n        self.panel = xrc.XRCCTRL(self.frame, 'MainPanel')\n\n        # matplotlib panel -------------\n\n        # container for matplotlib panel (I like to make a container\n        # panel for our panel so I know where it'll go when in XRCed.)\n        plot_container = xrc.XRCCTRL(self.frame, 'plot_container_panel')\n        sizer = wx.BoxSizer(wx.VERTICAL)\n\n        # matplotlib panel itself\n        self.plotpanel = PlotPanel(plot_container)\n        self.plotpanel.init_plot_data()\n\n        # wx boilerplate\n        sizer.Add(self.plotpanel, 1, wx.EXPAND)\n        plot_container.SetSizer(sizer)\n\n        # whiz button ------------------\n        whiz_button = xrc.XRCCTRL(self.frame, 'whiz_button')\n        whiz_button.Bind(wx.EVT_BUTTON, self.plotpanel.OnWhiz)\n\n        # bang button ------------------\n        bang_button = xrc.XRCCTRL(self.frame, 'bang_button')\n        bang_button.Bind(wx.EVT_BUTTON, self.OnBang)\n\n        # final setup ------------------\n        self.frame.Show()\n\n        self.SetTopWindow(self.frame)\n\n        return True\n\n    def OnBang(self, event):\n        bang_count = xrc.XRCCTRL(self.frame, 'bang_count')\n        bangs = bang_count.GetValue()\n        bangs = int(bangs) + 1\n        bang_count.SetValue(str(bangs))\n\n\nif __name__ == '__main__':\n    app = MyApp()\n    app.MainLoop()\n",
    "id": 340
},
{
    "title": "Embedding in wx #4",
    "text": "An example of how to use wxagg in a wx application with a custom toolbar.",
    "code": "import wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass MyNavigationToolbar(NavigationToolbar):\n    '''Extend the default wx toolbar with your own event handlers.'''\n\n    def __init__(self, canvas):\n        super().__init__(canvas)\n        # We use a stock wx bitmap, but you could also use your own image file.\n        bmp = wx.ArtProvider.GetBitmap(wx.ART_CROSS_MARK, wx.ART_TOOLBAR)\n        tool = self.AddTool(wx.ID_ANY, 'Click me', bmp,\n                            'Activate custom control')\n        self.Bind(wx.EVT_TOOL, self._on_custom, id=tool.GetId())\n\n    def _on_custom(self, event):\n        # add some text to the axes in a random location in axes coords with a\n        # random color\n        ax = self.canvas.figure.axes[0]\n        x, y = np.random.rand(2)  # generate a random location\n        rgb = np.random.rand(3)  # generate a random color\n        ax.text(x, y, 'You clicked me', transform=ax.transAxes, color=rgb)\n        self.canvas.draw()\n        event.Skip()\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure(figsize=(5, 4), dpi=100)\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n\n        self.toolbar = MyNavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        '''Create the main window and insert the custom frame.'''\n        frame = CanvasFrame()\n        frame.Show(True)\n        return True\n\n\nif __name__ == '__main__':\n    app = App()\n    app.MainLoop()\n",
    "id": 341
},
{
    "title": "Embedding in wx #5",
    "text": "Download Python source code: embedding_in_wx5_sgskip.py Download Jupyter notebook: embedding_in_wx5_sgskip.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import wx\nimport wx.lib.agw.aui as aui\nimport wx.lib.mixins.inspection as wit\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass Plot(wx.Panel):\n    def __init__(self, parent, id=-1, dpi=None, **kwargs):\n        super().__init__(parent, id=id, **kwargs)\n        self.figure = Figure(dpi=dpi, figsize=(2, 2))\n        self.canvas = FigureCanvas(self, -1, self.figure)\n        self.toolbar = NavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.SetSizer(sizer)\n\n\nclass PlotNotebook(wx.Panel):\n    def __init__(self, parent, id=-1):\n        super().__init__(parent, id=id)\n        self.nb = aui.AuiNotebook(self)\n        sizer = wx.BoxSizer()\n        sizer.Add(self.nb, 1, wx.EXPAND)\n        self.SetSizer(sizer)\n\n    def add(self, name='plot'):\n        page = Plot(self.nb)\n        self.nb.AddPage(page, name)\n        return page.figure\n\n\ndef demo():\n    # Alternatively you could use:\n    # app = wx.App()\n    # InspectableApp is a great debug tool, see:\n    # http://wiki.wxpython.org/Widget%20Inspection%20Tool\n    app = wit.InspectableApp()\n    frame = wx.Frame(None, -1, 'Plotter')\n    plotter = PlotNotebook(frame)\n    axes1 = plotter.add('figure 1').add_subplot()\n    axes1.plot([1, 2, 3], [2, 1, 4])\n    axes2 = plotter.add('figure 2').add_subplot()\n    axes2.plot([1, 2, 3, 4, 5], [2, 1, 4, 2, 3])\n    frame.Show()\n    app.MainLoop()\n\nif __name__ == '__main__':\n    demo()\n",
    "id": 342
},
{
    "title": "Embedding WebAgg",
    "text": "This example demonstrates how to embed Matplotlib WebAgg interactive plotting\nin your own web application and framework. It is not necessary to do all this\nif you merely want to display a plot in a browser or use Matplotlib\\'s built-in\nTornado-based server \"on the side\". The framework being used must support web sockets.",
    "code": "import argparse\nimport io\nimport json\nimport mimetypes\nfrom pathlib import Path\nimport signal\nimport socket\n\ntry:\n    import tornado\nexcept ImportError as err:\n    raise RuntimeError('This example requires tornado.') from err\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.backends.backend_webagg import (\n    FigureManagerWebAgg, new_figure_manager_given_figure)\nfrom matplotlib.figure import Figure\n\n\ndef create_figure():\n    '''\n    Creates a simple example figure.\n    '''\n    fig = Figure()\n    ax = fig.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2 * np.pi * t)\n    ax.plot(t, s)\n    return fig\n\n\n# The following is the content of the web page.  You would normally\n# generate this using some sort of template facility in your web\n# framework, but here we just use Python string formatting.\nhtml_content = '''<!DOCTYPE html>\n<html lang='en'>\n  <head>\n    <!-- TODO: There should be a way to include all of the required javascript\n               and CSS so matplotlib can add to the set in the future if it\n               needs to. -->\n    <link rel='stylesheet' href='_static/css/page.css' type='text/css'>\n    <link rel='stylesheet' href='_static/css/boilerplate.css' type='text/css'>\n    <link rel='stylesheet' href='_static/css/fbm.css' type='text/css'>\n    <link rel='stylesheet' href='_static/css/mpl.css' type='text/css'>\n    <script src='mpl.js'></script>\n\n    <script>\n      /* This is a callback that is called when the user saves\n         (downloads) a file.  Its purpose is really to map from a\n         figure and file format to a url in the application. */\n      function ondownload(figure, format) {\n        window.open('download.' + format, '_blank');\n      };\n\n      function ready(fn) {\n        if (document.readyState != 'loading') {\n          fn();\n        } else {\n          document.addEventListener('DOMContentLoaded', fn);\n        }\n      }\n\n      ready(\n        function() {\n          /* It is up to the application to provide a websocket that the figure\n             will use to communicate to the server.  This websocket object can\n             also be a 'fake' websocket that underneath multiplexes messages\n             from multiple figures, if necessary. */\n          var websocket_type = mpl.get_websocket_type();\n          var websocket = new websocket_type('%(ws_uri)sws');\n\n          // mpl.figure creates a new figure on the webpage.\n          var fig = new mpl.figure(\n              // A unique numeric identifier for the figure\n              %(fig_id)s,\n              // A websocket object (or something that behaves like one)\n              websocket,\n              // A function called when a file type is selected for download\n              ondownload,\n              // The HTML element in which to place the figure\n              document.getElementById('figure'));\n        }\n      );\n    </script>\n\n    <title>matplotlib</title>\n  </head>\n\n  <body>\n    <div id='figure'>\n    </div>\n  </body>\n</html>\n'''\n\n\nclass MyApplication(tornado.web.Application):\n    class MainPage(tornado.web.RequestHandler):\n        '''\n        Serves the main HTML page.\n        '''\n\n        def get(self):\n            manager = self.application.manager\n            ws_uri = f'ws://{self.request.host}/'\n            content = html_content % {\n                'ws_uri': ws_uri, 'fig_id': manager.num}\n            self.write(content)\n\n    class MplJs(tornado.web.RequestHandler):\n        '''\n        Serves the generated matplotlib javascript file.  The content\n        is dynamically generated based on which toolbar functions the\n        user has defined.  Call `FigureManagerWebAgg` to get its\n        content.\n        '''\n\n        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n            js_content = FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)\n\n    class Download(tornado.web.RequestHandler):\n        '''\n        Handles downloading of the figure in various file formats.\n        '''\n\n        def get(self, fmt):\n            manager = self.application.manager\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = io.BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())\n\n    class WebSocket(tornado.websocket.WebSocketHandler):\n        '''\n        A websocket for interactive communication between the plot in\n        the browser and the server.\n\n        In addition to the methods required by tornado, it is required to\n        have two callback methods:\n\n            - ``send_json(json_content)`` is called by matplotlib when\n              it needs to send json to the browser.  `json_content` is\n              a JSON tree (Python dictionary), and it is the responsibility\n              of this implementation to encode it as a string to send over\n              the socket.\n\n            - ``send_binary(blob)`` is called to send binary image data\n              to the browser.\n        '''\n        supports_binary = True\n\n        def open(self):\n            # Register the websocket with the FigureManager.\n            manager = self.application.manager\n            manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)\n\n        def on_close(self):\n            # When the socket is closed, deregister the websocket with\n            # the FigureManager.\n            manager = self.application.manager\n            manager.remove_web_socket(self)\n\n        def on_message(self, message):\n            # The 'supports_binary' message is relevant to the\n            # websocket itself.  The other messages get passed along\n            # to matplotlib as-is.\n\n            # Every message has a 'type' and a 'figure_id'.\n            message = json.loads(message)\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = self.application.manager\n                manager.handle_json(message)\n\n        def send_json(self, content):\n            self.write_message(json.dumps(content))\n\n        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = ('data:image/png;base64,' +\n                            blob.encode('base64').replace('\\\n', ''))\n                self.write_message(data_uri)\n\n    def __init__(self, figure):\n        self.figure = figure\n        self.manager = new_figure_manager_given_figure(id(figure), figure)\n\n        super().__init__([\n            # Static files for the CSS and JS\n            (r'/_static/(.*)',\n             tornado.web.StaticFileHandler,\n             {'path': FigureManagerWebAgg.get_static_file_path()}),\n\n            # Static images for the toolbar\n            (r'/_images/(.*)',\n             tornado.web.StaticFileHandler,\n             {'path': Path(mpl.get_data_path(), 'images')}),\n\n            # The page that contains all of the pieces\n            ('/', self.MainPage),\n\n            ('/mpl.js', self.MplJs),\n\n            # Sends images and events to the browser, and receives\n            # events from the browser\n            ('/ws', self.WebSocket),\n\n            # Handles the downloading (i.e., saving) of static images\n            (r'/download.([a-z0-9.]+)', self.Download),\n        ])\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-p', '--port', type=int, default=8080,\n                        help='Port to listen on (0 for a random port).')\n    args = parser.parse_args()\n\n    figure = create_figure()\n    application = MyApplication(figure)\n\n    http_server = tornado.httpserver.HTTPServer(application)\n    sockets = tornado.netutil.bind_sockets(args.port, '')\n    http_server.add_sockets(sockets)\n\n    for s in sockets:\n        addr, port = s.getsockname()[:2]\n        if s.family is socket.AF_INET6:\n            addr = f'[{addr}]'\n        print(f'Listening on http://{addr}:{port}/')\n    print('Press Ctrl+C to quit')\n\n    ioloop = tornado.ioloop.IOLoop.instance()\n\n    def shutdown():\n        ioloop.stop()\n        print('Server stopped')\n\n    old_handler = signal.signal(\n        signal.SIGINT,\n        lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n\n    try:\n        ioloop.start()\n    finally:\n        signal.signal(signal.SIGINT, old_handler)\n",
    "id": 343
},
{
    "title": "Fourier Demo WX",
    "text": "Download Python source code: fourier_demo_wx_sgskip.py Download Jupyter notebook: fourier_demo_wx_sgskip.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Knob:\n    '''\n    Knob - simple class with a 'setKnob' method.\n    A Knob instance is attached to a Param instance, e.g., param.attach(knob)\n    Base class is for documentation purposes.\n    '''\n\n    def setKnob(self, value):\n        pass\n\n\nclass Param:\n    '''\n    The idea of the 'Param' class is that some parameter in the GUI may have\n    several knobs that both control it and reflect the parameter's state, e.g.\n    a slider, text, and dragging can all change the value of the frequency in\n    the waveform of this example.\n    The class allows a cleaner way to update/'feedback' to the other knobs when\n    one is being changed.  Also, this class handles min/max constraints for all\n    the knobs.\n    Idea - knob list - in 'set' method, knob object is passed as well\n      - the other knobs in the knob list have a 'set' method which gets\n        called for the others.\n    '''\n\n    def __init__(self, initialValue=None, minimum=0., maximum=1.):\n        self.minimum = minimum\n        self.maximum = maximum\n        if initialValue != self.constrain(initialValue):\n            raise ValueError('illegal initial value')\n        self.value = initialValue\n        self.knobs = []\n\n    def attach(self, knob):\n        self.knobs += [knob]\n\n    def set(self, value, knob=None):\n        self.value = value\n        self.value = self.constrain(value)\n        for feedbackKnob in self.knobs:\n            if feedbackKnob != knob:\n                feedbackKnob.setKnob(self.value)\n        return self.value\n\n    def constrain(self, value):\n        if value <= self.minimum:\n            value = self.minimum\n        if value >= self.maximum:\n            value = self.maximum\n        return value\n\n\nclass SliderGroup(Knob):\n    def __init__(self, parent, label, param):\n        self.sliderLabel = wx.StaticText(parent, label=label)\n        self.sliderText = wx.TextCtrl(parent, -1, style=wx.TE_PROCESS_ENTER)\n        self.slider = wx.Slider(parent, -1)\n        # self.slider.SetMax(param.maximum*1000)\n        self.slider.SetRange(0, int(param.maximum * 1000))\n        self.setKnob(param.value)\n\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.Add(self.sliderLabel, 0,\n                  wx.EXPAND | wx.ALL,\n                  border=2)\n        sizer.Add(self.sliderText, 0,\n                  wx.EXPAND | wx.ALL,\n                  border=2)\n        sizer.Add(self.slider, 1, wx.EXPAND)\n        self.sizer = sizer\n\n        self.slider.Bind(wx.EVT_SLIDER, self.sliderHandler)\n        self.sliderText.Bind(wx.EVT_TEXT_ENTER, self.sliderTextHandler)\n\n        self.param = param\n        self.param.attach(self)\n\n    def sliderHandler(self, event):\n        value = event.GetInt() / 1000.\n        self.param.set(value)\n\n    def sliderTextHandler(self, event):\n        value = float(self.sliderText.GetValue())\n        self.param.set(value)\n\n    def setKnob(self, value):\n        self.sliderText.SetValue(f'{value:g}')\n        self.slider.SetValue(int(value * 1000))\n\n\nclass FourierDemoFrame(wx.Frame):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        panel = wx.Panel(self)\n\n        # create the GUI elements\n        self.createCanvas(panel)\n        self.createSliders(panel)\n\n        # place them in a sizer for the Layout\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        sizer.Add(self.frequencySliderGroup.sizer, 0,\n                  wx.EXPAND | wx.ALL, border=5)\n        sizer.Add(self.amplitudeSliderGroup.sizer, 0,\n                  wx.EXPAND | wx.ALL, border=5)\n        panel.SetSizer(sizer)\n\n    def createCanvas(self, parent):\n        self.lines = []\n        self.figure = Figure()\n        self.canvas = FigureCanvas(parent, -1, self.figure)\n        self.canvas.callbacks.connect('button_press_event', self.mouseDown)\n        self.canvas.callbacks.connect('motion_notify_event', self.mouseMotion)\n        self.canvas.callbacks.connect('button_release_event', self.mouseUp)\n        self.state = ''\n        self.mouseInfo = (None, None, None, None)\n        self.f0 = Param(2., minimum=0., maximum=6.)\n        self.A = Param(1., minimum=0.01, maximum=2.)\n        self.createPlots()\n\n        # Not sure I like having two params attached to the same Knob,\n        # but that is what we have here... it works but feels kludgy -\n        # although maybe it's not too bad since the knob changes both params\n        # at the same time (both f0 and A are affected during a drag)\n        self.f0.attach(self)\n        self.A.attach(self)\n\n    def createSliders(self, panel):\n        self.frequencySliderGroup = SliderGroup(\n            panel,\n            label='Frequency f0:',\n            param=self.f0)\n        self.amplitudeSliderGroup = SliderGroup(panel, label=' Amplitude a:',\n                                                param=self.A)\n\n    def mouseDown(self, event):\n        if self.lines[0].contains(event)[0]:\n            self.state = 'frequency'\n        elif self.lines[1].contains(event)[0]:\n            self.state = 'time'\n        else:\n            self.state = ''\n        self.mouseInfo = (event.xdata, event.ydata,\n                          max(self.f0.value, .1),\n                          self.A.value)\n\n    def mouseMotion(self, event):\n        if self.state == '':\n            return\n        x, y = event.xdata, event.ydata\n        if x is None:  # outside the axes\n            return\n        x0, y0, f0Init, AInit = self.mouseInfo\n        self.A.set(AInit + (AInit * (y - y0) / y0), self)\n        if self.state == 'frequency':\n            self.f0.set(f0Init + (f0Init * (x - x0) / x0))\n        elif self.state == 'time':\n            if (x - x0) / x0 != -1.:\n                self.f0.set(1. / (1. / f0Init + (1. / f0Init * (x - x0) / x0)))\n\n    def mouseUp(self, event):\n        self.state = ''\n\n    def createPlots(self):\n        # This method creates the subplots, waveforms and labels.\n        # Later, when the waveforms or sliders are dragged, only the\n        # waveform data will be updated (not here, but below in setKnob).\n        self.subplot1, self.subplot2 = self.figure.subplots(2)\n        x1, y1, x2, y2 = self.compute(self.f0.value, self.A.value)\n        color = (1., 0., 0.)\n        self.lines += self.subplot1.plot(x1, y1, color=color, linewidth=2)\n        self.lines += self.subplot2.plot(x2, y2, color=color, linewidth=2)\n        # Set some plot attributes\n        self.subplot1.set_title(\n            'Click and drag waveforms to change frequency and amplitude',\n            fontsize=12)\n        self.subplot1.set_ylabel('Frequency Domain Waveform X(f)', fontsize=8)\n        self.subplot1.set_xlabel('frequency f', fontsize=8)\n        self.subplot2.set_ylabel('Time Domain Waveform x(t)', fontsize=8)\n        self.subplot2.set_xlabel('time t', fontsize=8)\n        self.subplot1.set_xlim([-6, 6])\n        self.subplot1.set_ylim([0, 1])\n        self.subplot2.set_xlim([-2, 2])\n        self.subplot2.set_ylim([-2, 2])\n        self.subplot1.text(0.05, .95,\n                           r'$X(f) = \\\\mathcal{F}\\\\{x(t)\\\\}$',\n                           verticalalignment='top',\n                           transform=self.subplot1.transAxes)\n        self.subplot2.text(0.05, .95,\n                           r'$x(t) = a \\\\cdot \\\\cos(2\\\\pi f_0 t) e^{-\\\\pi t^2}$',\n                           verticalalignment='top',\n                           transform=self.subplot2.transAxes)\n\n    def compute(self, f0, A):\n        f = np.arange(-6., 6., 0.02)\n        t = np.arange(-2., 2., 0.01)\n        x = A * np.cos(2 * np.pi * f0 * t) * np.exp(-np.pi * t ** 2)\n        X = A / 2 * \\\\\n            (np.exp(-np.pi * (f - f0) ** 2) + np.exp(-np.pi * (f + f0) ** 2))\n        return f, X, t, x\n\n    def setKnob(self, value):\n        # Note, we ignore value arg here and just go by state of the params\n        x1, y1, x2, y2 = self.compute(self.f0.value, self.A.value)\n        # update the data of the two waveforms\n        self.lines[0].set(xdata=x1, ydata=y1)\n        self.lines[1].set(xdata=x2, ydata=y2)\n        # make the canvas draw its contents again with the new data\n        self.canvas.draw()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        self.frame1 = FourierDemoFrame(parent=None, title='Fourier Demo',\n                                       size=(640, 480))\n        self.frame1.Show()\n        return True\n\n\nif __name__ == '__main__':\n    app = App()\n    app.MainLoop()\n",
    "id": 344
},
{
    "title": "GTK3 spreadsheet",
    "text": "Example of embedding Matplotlib in an application and interacting with a\ntreeview to store data. Double-click on an entry to update plot data.",
    "code": "import gi\n\ngi.require_version('Gtk 3.0')\ngi.require_version('Gdk 3.0')\nfrom gi.repository import Gdk, Gtk\n\nfrom numpy.random import random\n\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvas  # or gtk3cairo.\nfrom matplotlib.figure import Figure\n\n\nclass DataManager(Gtk.Window):\n    num_rows, num_cols = 20, 10\n\n    data = random((num_rows, num_cols))\n\n    def __init__(self):\n        super().__init__()\n        self.set_default_size(600, 600)\n        self.connect('destroy', lambda win: Gtk.main_quit())\n\n        self.set_title('GtkListStore demo')\n        self.set_border_width(8)\n\n        vbox = Gtk.VBox(homogeneous=False, spacing=8)\n        self.add(vbox)\n\n        label = Gtk.Label(label='Double click a row to plot the data')\n\n        vbox.pack_start(label, False, False, 0)\n\n        sw = Gtk.ScrolledWindow()\n        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)\n        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        vbox.pack_start(sw, True, True, 0)\n\n        model = self.create_model()\n\n        self.treeview = Gtk.TreeView(model=model)\n\n        # Matplotlib stuff\n        fig = Figure(figsize=(6, 4))\n\n        self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n        vbox.pack_start(self.canvas, True, True, 0)\n        ax = fig.add_subplot()\n        self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row\n\n        self.treeview.connect('row-activated', self.plot_row)\n        sw.add(self.treeview)\n\n        self.add_columns()\n\n        self.add_events(Gdk.EventMask.BUTTON_PRESS_MASK |\n                        Gdk.EventMask.KEY_PRESS_MASK |\n                        Gdk.EventMask.KEY_RELEASE_MASK)\n\n    def plot_row(self, treeview, path, view_column):\n        ind, = path  # get the index into data\n        points = self.data[ind, :]\n        self.line.set_ydata(points)\n        self.canvas.draw()\n\n    def add_columns(self):\n        for i in range(self.num_cols):\n            column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)\n            self.treeview.append_column(column)\n\n    def create_model(self):\n        types = [float] * self.num_cols\n        store = Gtk.ListStore(*types)\n        for row in self.data:\n            store.append(tuple(row))\n        return store\n\n\nmanager = DataManager()\nmanager.show_all()\nGtk.main()\n",
    "id": 345
},
{
    "title": "GTK4 spreadsheet",
    "text": "Example of embedding Matplotlib in an application and interacting with a\ntreeview to store data. Double-click on an entry to update plot data.",
    "code": "import gi\n\ngi.require_version('Gtk 4.0')\ngi.require_version('Gdk 4.0')\nfrom gi.repository import Gtk\n\nfrom numpy.random import random\n\nfrom matplotlib.backends.backend_gtk4agg import FigureCanvas  # or gtk4cairo.\nfrom matplotlib.figure import Figure\n\n\nclass DataManager(Gtk.ApplicationWindow):\n    num_rows, num_cols = 20, 10\n\n    data = random((num_rows, num_cols))\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_default_size(600, 600)\n\n        self.set_title('GtkListStore demo')\n\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, homogeneous=False,\n                       spacing=8)\n        self.set_child(vbox)\n\n        label = Gtk.Label(label='Double click a row to plot the data')\n        vbox.append(label)\n\n        sw = Gtk.ScrolledWindow()\n        sw.set_has_frame(True)\n        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        sw.set_hexpand(True)\n        sw.set_vexpand(True)\n        vbox.append(sw)\n\n        model = self.create_model()\n        self.treeview = Gtk.TreeView(model=model)\n        self.treeview.connect('row-activated', self.plot_row)\n        sw.set_child(self.treeview)\n\n        # Matplotlib stuff\n        fig = Figure(figsize=(6, 4), layout='constrained')\n\n        self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n        self.canvas.set_hexpand(True)\n        self.canvas.set_vexpand(True)\n        vbox.append(self.canvas)\n        ax = fig.add_subplot()\n        self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row\n\n        self.add_columns()\n\n    def plot_row(self, treeview, path, view_column):\n        ind, = path  # get the index into data\n        points = self.data[ind, :]\n        self.line.set_ydata(points)\n        self.canvas.draw()\n\n    def add_columns(self):\n        for i in range(self.num_cols):\n            column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)\n            self.treeview.append_column(column)\n\n    def create_model(self):\n        types = [float] * self.num_cols\n        store = Gtk.ListStore(*types)\n        for row in self.data:\n            # Gtk.ListStore.append is broken in PyGObject, so insert manually.\n            it = store.insert(-1)\n            store.set(it, {i: val for i, val in enumerate(row)})\n        return store\n\n\ndef on_activate(app):\n    manager = DataManager(application=app)\n    manager.show()\n\n\napp = Gtk.Application(application_id='org.matplotlib.examples.GTK4Spreadsheet')\napp.connect('activate', on_activate)\napp.run()\n",
    "id": 346
},
{
    "title": "Display mathtext in WX",
    "text": "Demonstrates how to convert (math)text to a wx.Bitmap for display in various\ncontrols on wxPython.",
    "code": "from io import BytesIO\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nIS_WIN = 'wxMSW' in wx.PlatformInfo\n\n\ndef mathtext_to_wxbitmap(s):\n    # We draw the text at position (0, 0) but then rely on\n    # ``facecolor='none'`` and ``bbox_inches='tight', pad_inches=0`` to get a\n    # transparent mask that is then loaded into a wx.Bitmap.\n    fig = Figure(facecolor='none')\n    text_color = (\n        np.array(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)) / 255)\n    fig.text(0, 0, s, fontsize=10, color=text_color)\n    buf = BytesIO()\n    fig.savefig(buf, format='png', dpi=150, bbox_inches='tight', pad_inches=0)\n    s = buf.getvalue()\n    return wx.Bitmap.NewFromPNGData(s, len(s))\n\n\nfunctions = [\n    (r'$\\\\sin(2 \\\\pi x)$', lambda x: np.sin(2*np.pi*x)),\n    (r'$\\\\frac{4}{3}\\\\pi x^3$', lambda x: (4/3)*np.pi*x**3),\n    (r'$\\\\cos(2 \\\\pi x)$', lambda x: np.cos(2*np.pi*x)),\n    (r'$\\\\log(x)$', lambda x: np.log(x))\n]\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, parent, title):\n        super().__init__(parent, -1, title, size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.change_plot(0)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.add_buttonbar()\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.add_toolbar()  # comment this out for no toolbar\n\n        menuBar = wx.MenuBar()\n\n        # File Menu\n        menu = wx.Menu()\n        m_exit = menu.Append(\n            wx.ID_EXIT, 'E&xit\\\\tAlt-X', 'Exit this simple sample')\n        menuBar.Append(menu, '&File')\n        self.Bind(wx.EVT_MENU, self.OnClose, m_exit)\n\n        if IS_WIN:\n            # Equation Menu\n            menu = wx.Menu()\n            for i, (mt, func) in enumerate(functions):\n                bm = mathtext_to_wxbitmap(mt)\n                item = wx.MenuItem(menu, 1000 + i, ' ')\n                item.SetBitmap(bm)\n                menu.Append(item)\n                self.Bind(wx.EVT_MENU, self.OnChangePlot, item)\n            menuBar.Append(menu, '&Functions')\n\n        self.SetMenuBar(menuBar)\n\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n    def add_buttonbar(self):\n        self.button_bar = wx.Panel(self)\n        self.button_bar_sizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.sizer.Add(self.button_bar, 0, wx.LEFT | wx.TOP | wx.GROW)\n\n        for i, (mt, func) in enumerate(functions):\n            bm = mathtext_to_wxbitmap(mt)\n            button = wx.BitmapButton(self.button_bar, 1000 + i, bm)\n            self.button_bar_sizer.Add(button, 1, wx.GROW)\n            self.Bind(wx.EVT_BUTTON, self.OnChangePlot, button)\n\n        self.button_bar.SetSizer(self.button_bar_sizer)\n\n    def add_toolbar(self):\n        '''Copied verbatim from embedding_wx2.py'''\n        self.toolbar = NavigationToolbar2Wx(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n    def OnChangePlot(self, event):\n        self.change_plot(event.GetId() - 1000)\n\n    def change_plot(self, plot_number):\n        t = np.arange(1.0, 3.0, 0.01)\n        s = functions[plot_number][1](t)\n        self.axes.clear()\n        self.axes.plot(t, s)\n        self.canvas.draw()\n\n    def OnClose(self, event):\n        self.Destroy()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        frame = CanvasFrame(None, 'wxPython mathtext demo app')\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == '__main__':\n    app = MyApp()\n    app.MainLoop()\n",
    "id": 347
},
{
    "title": "Matplotlib with Glade 3",
    "text": "Download Python source code: mpl_with_glade3_sgskip.py Download Jupyter notebook: mpl_with_glade3_sgskip.ipynb Gallery generated by Sphinx-Gallery",
    "code": "from pathlib import Path\n\nimport gi\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Window1Signals:\n    def on_window1_destroy(self, widget):\n        Gtk.main_quit()\n\n\ndef main():\n    builder = Gtk.Builder()\n    builder.add_objects_from_file(\n        str(Path(__file__).parent / 'mpl_with_glade3.glade'),\n        ('window1', ''))\n    builder.connect_signals(Window1Signals())\n    window = builder.get_object('window1')\n    sw = builder.get_object('scrolledwindow1')\n\n    # Start of Matplotlib specific code\n    figure = Figure(figsize=(8, 6), dpi=71)\n    axis = figure.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    axis.plot(t, s)\n\n    axis.set_xlabel('time [s]')\n    axis.set_ylabel('voltage [V]')\n\n    canvas = FigureCanvas(figure)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.add(canvas)\n    # End of Matplotlib specific code\n\n    window.show_all()\n    Gtk.main()\n\nif __name__ == '__main__':\n    main()\n",
    "id": 348
},
{
    "title": "mplcvd -- an example of figure hook",
    "text": "To use this hook, ensure that this module is in your PYTHONPATH, and set\nrcParamsfigure.hooks = mplcvd:setup. This hook depends on\nthe colorspacious third-party module.",
    "code": "import functools\nfrom pathlib import Path\n\nimport colorspacious\n\nimport numpy as np\n\n_BUTTON_NAME = 'Filter'\n_BUTTON_HELP = 'Simulate color vision deficiencies'\n_MENU_ENTRIES = {\n    'None': None,\n    'Greyscale': 'greyscale',\n    'Deuteranopia': 'deuteranomaly',\n    'Protanopia': 'protanomaly',\n    'Tritanopia': 'tritanomaly',\n}\n\n\ndef _get_color_filter(name):\n    '''\n    Given a color filter name, create a color filter function.\n\n    Parameters\n    ----------\n    name : str\n        The color filter name, one of the following:\n\n        - ``'none'``: ...\n        - ``'greyscale'``: Convert the input to luminosity.\n        - ``'deuteranopia'``: Simulate the most common form of red-green\n          colorblindness.\n        - ``'protanopia'``: Simulate a rarer form of red-green colorblindness.\n        - ``'tritanopia'``: Simulate the rare form of blue-yellow\n          colorblindness.\n\n        Color conversions use `colorspacious`_.\n\n    Returns\n    -------\n    callable\n        A color filter function that has the form:\n\n        def filter(input: np.ndarray[M, N, D])-> np.ndarray[M, N, D]\n\n        where (M, N) are the image dimensions, and D is the color depth (3 for\n        RGB, 4 for RGBA). Alpha is passed through unchanged and otherwise\n        ignored.\n    '''\n    if name not in _MENU_ENTRIES:\n        raise ValueError(f'Unsupported filter name: {name!r}')\n    name = _MENU_ENTRIES[name]\n\n    if name is None:\n        return None\n\n    elif name == 'greyscale':\n        rgb_to_jch = colorspacious.cspace_converter('sRGB1', 'JCh')\n        jch_to_rgb = colorspacious.cspace_converter('JCh', 'sRGB1')\n\n        def convert(im):\n            greyscale_JCh = rgb_to_jch(im)\n            greyscale_JCh[..., 1] = 0\n            im = jch_to_rgb(greyscale_JCh)\n            return im\n\n    else:\n        cvd_space = {'name': 'sRGB1+CVD', 'cvd_type': name, 'severity': 100}\n        convert = colorspacious.cspace_converter(cvd_space, 'sRGB1')\n\n    def filter_func(im, dpi):\n        alpha = None\n        if im.shape[-1] == 4:\n            im, alpha = im[..., :3], im[..., 3]\n        im = convert(im)\n        if alpha is not None:\n            im = np.dstack((im, alpha))\n        return np.clip(im, 0, 1), 0, 0\n\n    return filter_func\n\n\ndef _set_menu_entry(tb, name):\n    tb.canvas.figure.set_agg_filter(_get_color_filter(name))\n    tb.canvas.draw_idle()\n\n\ndef setup(figure):\n    tb = figure.canvas.toolbar\n    if tb is None:\n        return\n    for cls in type(tb).__mro__:\n        pkg = cls.__module__.split('.')[0]\n        if pkg != 'matplotlib':\n            break\n    if pkg == 'gi':\n        _setup_gtk(tb)\n    elif pkg in ('PyQt5', 'PySide2', 'PyQt6', 'PySide6'):\n        _setup_qt(tb)\n    elif pkg == 'tkinter':\n        _setup_tk(tb)\n    elif pkg == 'wx':\n        _setup_wx(tb)\n    else:\n        raise NotImplementedError('The current backend is not supported')\n\n\ndef _setup_gtk(tb):\n    from gi.repository import Gio, GLib, Gtk\n\n    for idx in range(tb.get_n_items()):\n        children = tb.get_nth_item(idx).get_children()\n        if children and isinstance(children[0], Gtk.Label):\n            break\n\n    toolitem = Gtk.SeparatorToolItem()\n    tb.insert(toolitem, idx)\n\n    image = Gtk.Image.new_from_gicon(\n        Gio.Icon.new_for_string(\n            str(Path(__file__).parent / 'images/eye-symbolic.svg')),\n        Gtk.IconSize.LARGE_TOOLBAR)\n\n    # The type of menu is progressively downgraded depending on GTK version.\n    if Gtk.check_version(3, 6, 0) is None:\n\n        group = Gio.SimpleActionGroup.new()\n        action = Gio.SimpleAction.new_stateful('cvdsim',\n                                               GLib.VariantType('s'),\n                                               GLib.Variant('s', 'none'))\n        group.add_action(action)\n\n        @functools.partial(action.connect, 'activate')\n        def set_filter(action, parameter):\n            _set_menu_entry(tb, parameter.get_string())\n            action.set_state(parameter)\n\n        menu = Gio.Menu()\n        for name in _MENU_ENTRIES:\n            menu.append(name, f'local.cvdsim::{name}')\n\n        button = Gtk.MenuButton.new()\n        button.remove(button.get_children()[0])\n        button.add(image)\n        button.insert_action_group('local', group)\n        button.set_menu_model(menu)\n        button.get_style_context().add_class('flat')\n\n        item = Gtk.ToolItem()\n        item.add(button)\n        tb.insert(item, idx + 1)\n\n    else:\n\n        menu = Gtk.Menu()\n        group = []\n        for name in _MENU_ENTRIES:\n            item = Gtk.RadioMenuItem.new_with_label(group, name)\n            item.set_active(name == 'None')\n            item.connect(\n                'activate', lambda item: _set_menu_entry(tb, item.get_label()))\n            group.append(item)\n            menu.append(item)\n        menu.show_all()\n\n        tbutton = Gtk.MenuToolButton.new(image, _BUTTON_NAME)\n        tbutton.set_menu(menu)\n        tb.insert(tbutton, idx + 1)\n\n    tb.show_all()\n\n\ndef _setup_qt(tb):\n    from matplotlib.backends.qt_compat import QtGui, QtWidgets\n\n    menu = QtWidgets.QMenu()\n    try:\n        QActionGroup = QtGui.QActionGroup  # Qt6\n    except AttributeError:\n        QActionGroup = QtWidgets.QActionGroup  # Qt5\n    group = QActionGroup(menu)\n    group.triggered.connect(lambda action: _set_menu_entry(tb, action.text()))\n\n    for name in _MENU_ENTRIES:\n        action = menu.addAction(name)\n        action.setCheckable(True)\n        action.setActionGroup(group)\n        action.setChecked(name == 'None')\n\n    actions = tb.actions()\n    before = next(\n        (action for action in actions\n         if isinstance(tb.widgetForAction(action), QtWidgets.QLabel)), None)\n\n    tb.insertSeparator(before)\n    button = QtWidgets.QToolButton()\n    # FIXME: _icon needs public API.\n    button.setIcon(tb._icon(str(Path(__file__).parent / 'images/eye.png')))\n    button.setText(_BUTTON_NAME)\n    button.setToolTip(_BUTTON_HELP)\n    button.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)\n    button.setMenu(menu)\n    tb.insertWidget(before, button)\n\n\ndef _setup_tk(tb):\n    import tkinter as tk\n\n    tb._Spacer()  # FIXME: _Spacer needs public API.\n\n    button = tk.Menubutton(master=tb, relief='raised')\n    button._image_file = str(Path(__file__).parent / 'images/eye.png')\n    # FIXME: _set_image_for_button needs public API (perhaps like _icon).\n    tb._set_image_for_button(button)\n    button.pack(side=tk.LEFT)\n\n    menu = tk.Menu(master=button, tearoff=False)\n    for name in _MENU_ENTRIES:\n        menu.add('radiobutton', label=name,\n                 command=lambda _name=name: _set_menu_entry(tb, _name))\n    menu.invoke(0)\n    button.config(menu=menu)\n\n\ndef _setup_wx(tb):\n    import wx\n\n    idx = next(idx for idx in range(tb.ToolsCount)\n               if tb.GetToolByPos(idx).IsStretchableSpace())\n    tb.InsertSeparator(idx)\n    tool = tb.InsertTool(\n        idx + 1, -1, _BUTTON_NAME,\n        # FIXME: _icon needs public API.\n        tb._icon(str(Path(__file__).parent / 'images/eye.png')),\n        # FIXME: ITEM_DROPDOWN is not supported on macOS.\n        kind=wx.ITEM_DROPDOWN, shortHelp=_BUTTON_HELP)\n\n    menu = wx.Menu()\n    for name in _MENU_ENTRIES:\n        item = menu.AppendRadioItem(-1, name)\n        menu.Bind(\n            wx.EVT_MENU,\n            lambda event, _name=name: _set_menu_entry(tb, _name),\n            id=item.Id,\n        )\n    tb.SetDropdownMenu(tool.Id, menu)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    from matplotlib import cbook\n\n    plt.rcParams['figure.hooks'].append('mplcvd:setup')\n\n    fig, axd = plt.subplot_mosaic(\n        [\n            ['viridis', 'turbo'],\n            ['photo', 'lines']\n        ]\n    )\n\n    delta = 0.025\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2) * 2\n\n    imv = axd['viridis'].imshow(\n        Z, interpolation='bilinear',\n        origin='lower', extent=[-3, 3, -3, 3],\n        vmax=abs(Z).max(), vmin=-abs(Z).max()\n    )\n    fig.colorbar(imv)\n    imt = axd['turbo'].imshow(\n        Z, interpolation='bilinear', cmap='turbo',\n        origin='lower', extent=[-3, 3, -3, 3],\n        vmax=abs(Z).max(), vmin=-abs(Z).max()\n    )\n    fig.colorbar(imt)\n\n    # A sample image\n    with cbook.get_sample_data('grace_hopper.jpg') as image_file:\n        photo = plt.imread(image_file)\n    axd['photo'].imshow(photo)\n\n    th = np.linspace(0, 2*np.pi, 1024)\n    for j in [1, 2, 4, 6]:\n        axd['lines'].plot(th, np.sin(th * j), label=f'$\\\\\\\\omega={j}$')\n    axd['lines'].legend(ncols=2, loc='upper right')\n    plt.show()\n",
    "id": 349
},
{
    "title": "pyplot with GTK3",
    "text": "An example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets.",
    "code": "import matplotlib\n\nmatplotlib.use('GTK3Agg')  # or 'GTK3Cairo'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version('Gtk', '3.0')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3')\nax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let's add a button to the toolbar\nbutton = Gtk.Button(label='Click me')\nbutton.show()\nbutton.connect('clicked', lambda button: print('hi mom'))\n\ntoolitem = Gtk.ToolItem()\ntoolitem.show()\ntoolitem.set_tooltip_text('Click me for fun and profit')\ntoolitem.add(button)\n\npos = 8  # where to insert this in the toolbar\ntoolbar.insert(toolitem, pos)\n\n# now let's add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup('Drag mouse over axes for position')\nlabel.show()\nvbox.pack_start(label, False, False, 0)\nvbox.reorder_child(toolbar, -1)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup('Drag mouse over axes for position')\n    else:\n        label.set_markup(\n            f'<span color='#ef0000'>x,y=({event.xdata}, {event.ydata})</span>')\n\n\nfig.canvas.mpl_connect('motion_notify_event', update)\n\nplt.show()\n",
    "id": 350
},
{
    "title": "pyplot with GTK4",
    "text": "An example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets.",
    "code": "import matplotlib\n\nmatplotlib.use('GTK4Agg')  # or 'GTK4Cairo'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version('Gtk', '4.0')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], 'ro-', label='easy as 1 2 3')\nax.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let's add a button to the toolbar\nbutton = Gtk.Button(label='Click me')\nbutton.connect('clicked', lambda button: print('hi mom'))\nbutton.set_tooltip_text('Click me for fun and profit')\ntoolbar.append(button)\n\n# now let's add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup('Drag mouse over axes for position')\nvbox.insert_child_after(label, fig.canvas)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup('Drag mouse over axes for position')\n    else:\n        label.set_markup(\n            f'<span color='#ef0000'>x,y=({event.xdata}, {event.ydata})</span>')\n\n\nfig.canvas.mpl_connect('motion_notify_event', update)\n\nplt.show()\n",
    "id": 351
},
{
    "title": "SVG Histogram",
    "text": "Demonstrate how to create an interactive histogram, in which bars\nare hidden or shown by clicking on legend markers. The interactivity is encoded in ecmascript (javascript) and inserted in\nthe SVG code in a post-processing step. To render the image, open it in\na web browser. SVG is supported in most web browsers used by Linux and\nOSX users. Windows IE9 supports SVG, but earlier versions do not. The matplotlib backend lets us assign ids to each object. This is the\nmechanism used here to relate matplotlib objects created in python and\nthe corresponding SVG constructs that are parsed in the second step.\nWhile flexible, ids are cumbersome to use for large collection of\nobjects. Two mechanisms could be used to simplify things: systematic grouping of objects into SVG <g> tags, assigning classes to each SVG object according to its origin. For example, instead of modifying the properties of each individual bar,\nthe bars from the hist function could either be grouped in\na PatchCollection, or be assigned a class=\"hist_##\" attribute. CSS could also be used more extensively to replace repetitive markup\nthroughout the generated SVG. Author: david.huard@gmail.com",
    "code": "from io import BytesIO\nimport json\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams['svg.fonttype'] = 'none'\n\n# Apparently, this `register_namespace` method is necessary to avoid garbling\n# the XML namespace with ns0.\nET.register_namespace('', 'http://www.w3.org/2000/svg')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# --- Create histogram, legend and title ---\nplt.figure()\nr = np.random.randn(100)\nr1 = r + 1\nlabels = ['Rabbits', 'Frogs']\nH = plt.hist([r, r1], label=labels)\ncontainers = H[-1]\nleg = plt.legend(frameon=False)\nplt.title('From a web browser, click on the legend\\\n'\n          'marker to toggle the corresponding histogram.')\n\n\n# --- Add ids to the svg objects we'll modify\n\nhist_patches = {}\nfor ic, c in enumerate(containers):\n    hist_patches[f'hist_{ic}'] = []\n    for il, element in enumerate(c):\n        element.set_gid(f'hist_{ic}_patch_{il}')\n        hist_patches[f'hist_{ic}'].append(f'hist_{ic}_patch_{il}')\n\n# Set ids for the legend patches\nfor i, t in enumerate(leg.get_patches()):\n    t.set_gid(f'leg_patch_{i}')\n\n# Set ids for the text patches\nfor i, t in enumerate(leg.get_texts()):\n    t.set_gid(f'leg_text_{i}')\n\n# Save SVG in a fake file object.\nf = BytesIO()\nplt.savefig(f, format='svg')\n\n# Create XML tree from the SVG file.\ntree, xmlid = ET.XMLID(f.getvalue())\n\n\n# --- Add interactivity ---\n\n# Add attributes to the patch objects.\nfor i, t in enumerate(leg.get_patches()):\n    el = xmlid[f'leg_patch_{i}']\n    el.set('cursor', 'pointer')\n    el.set('onclick', 'toggle_hist(this)')\n\n# Add attributes to the text objects.\nfor i, t in enumerate(leg.get_texts()):\n    el = xmlid[f'leg_text_{i}']\n    el.set('cursor', 'pointer')\n    el.set('onclick', 'toggle_hist(this)')\n\n# Create script defining the function `toggle_hist`.\n# We create a global variable `container` that stores the patches id\n# belonging to each histogram. Then a function 'toggle_element' sets the\n# visibility attribute of all patches of each histogram and the opacity\n# of the marker itself.\n\nscript = '''\n<script type='text/ecmascript'>\n<![CDATA[\nvar container = %s\n\nfunction toggle(oid, attribute, values) {\n    /* Toggle the style attribute of an object between two values.\n\n    Parameters\n    ----------\n    oid : str\n      Object identifier.\n    attribute : str\n      Name of style attribute.\n    values : [on state, off state]\n      The two values that are switched between.\n    */\n    var obj = document.getElementById(oid);\n    var a = obj.style[attribute];\n\n    a = (a == values[0] || a == '') ? values[1] : values[0];\n    obj.style[attribute] = a;\n    }\n\nfunction toggle_hist(obj) {\n\n    var num = obj.id.slice(-1);\n\n    toggle('leg_patch_' + num, 'opacity', [1, 0.3]);\n    toggle('leg_text_' + num, 'opacity', [1, 0.5]);\n\n    var names = container['hist_'+num]\n\n    for (var i=0; i < names.length; i++) {\n        toggle(names[i], 'opacity', [1, 0])\n    };\n    }\n]]>\n</script>\n''' % json.dumps(hist_patches)\n\n# Add a transition effect\ncss = tree.find('.//{http://www.w3.org/2000/svg}style')\ncss.text = css.text + 'g {-webkit-transition:opacity 0.4s ease-out;' + \\\\\n    '-moz-transition:opacity 0.4s ease-out;}'\n\n# Insert the script and save to file.\ntree.insert(0, ET.XML(script))\n\nET.ElementTree(tree).write('svg_histogram.svg')\n",
    "id": 352
},
{
    "title": "SVG Tooltip",
    "text": "This example shows how to create a tooltip that will show up when\nhovering over a matplotlib patch. Although it is possible to create the tooltip from CSS or javascript,\nhere we create it in matplotlib and simply toggle its visibility on\nwhen hovering over the patch. This approach provides total control over\nthe tooltip placement and appearance, at the expense of more code up\nfront. The alternative approach would be to put the tooltip content in title\nattributes of SVG objects. Then, using an existing js/CSS library, it\nwould be relatively straightforward to create the tooltip in the\nbrowser. The content would be dictated by the title attribute, and\nthe appearance by the CSS. David Huard",
    "code": "from io import BytesIO\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nET.register_namespace('', 'http://www.w3.org/2000/svg')\n\nfig, ax = plt.subplots()\n\n# Create patches to which tooltips will be assigned.\nrect1 = plt.Rectangle((10, -20), 10, 5, fc='blue')\nrect2 = plt.Rectangle((-20, 15), 10, 5, fc='green')\n\nshapes = [rect1, rect2]\nlabels = ['This is a blue rectangle.', 'This is a green rectangle']\n\nfor i, (item, label) in enumerate(zip(shapes, labels)):\n    patch = ax.add_patch(item)\n    annotate = ax.annotate(labels[i], xy=item.get_xy(), xytext=(0, 0),\n                           textcoords='offset points', color='w', ha='center',\n                           fontsize=8, bbox=dict(boxstyle='round, pad=.5',\n                                                 fc=(.1, .1, .1, .92),\n                                                 ec=(1., 1., 1.), lw=1,\n                                                 zorder=1))\n\n    ax.add_patch(patch)\n    patch.set_gid(f'mypatch_{i:03d}')\n    annotate.set_gid(f'mytooltip_{i:03d}')\n\n# Save the figure in a fake file object\nax.set_xlim(-30, 30)\nax.set_ylim(-30, 30)\nax.set_aspect('equal')\n\nf = BytesIO()\nplt.savefig(f, format='svg')\n\n# --- Add interactivity ---\n\n# Create XML tree from the SVG file.\ntree, xmlid = ET.XMLID(f.getvalue())\ntree.set('onload', 'init(event)')\n\nfor i in shapes:\n    # Get the index of the shape\n    index = shapes.index(i)\n    # Hide the tooltips\n    tooltip = xmlid[f'mytooltip_{index:03d}']\n    tooltip.set('visibility', 'hidden')\n    # Assign onmouseover and onmouseout callbacks to patches.\n    mypatch = xmlid[f'mypatch_{index:03d}']\n    mypatch.set('onmouseover', 'ShowTooltip(this)')\n    mypatch.set('onmouseout', 'HideTooltip(this)')\n\n# This is the script defining the ShowTooltip and HideTooltip functions.\nscript = '''\n    <script type='text/ecmascript'>\n    <![CDATA[\n\n    function init(event) {\n        if ( window.svgDocument == null ) {\n            svgDocument = event.target.ownerDocument;\n            }\n        }\n\n    function ShowTooltip(obj) {\n        var cur = obj.id.split('_')[1];\n        var tip = svgDocument.getElementById('mytooltip_' + cur);\n        tip.setAttribute('visibility', 'visible')\n        }\n\n    function HideTooltip(obj) {\n        var cur = obj.id.split('_')[1];\n        var tip = svgDocument.getElementById('mytooltip_' + cur);\n        tip.setAttribute('visibility', 'hidden')\n        }\n\n    ]]>\n    </script>\n    '''\n\n# Insert the script at the top of the file and save it.\ntree.insert(0, ET.XML(script))\nET.ElementTree(tree).write('svg_tooltip.svg')\n",
    "id": 353
},
{
    "title": "Tool Manager",
    "text": "This example demonstrates how to modify the Toolbar create tools add tools remove tools using matplotlib.backend_managers.ToolManager.",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import ToolBase, ToolToggleBase\n\nplt.rcParams['toolbar'] = 'toolmanager'\n\n\nclass ListTools(ToolBase):\n    '''List all the tools controlled by the `ToolManager`.'''\n    default_keymap = 'm'  # keyboard shortcut\n    description = 'List Tools'\n\n    def trigger(self, *args, **kwargs):\n        print('_' * 80)\n        fmt_tool = '{:12} {:45} {}'.format\n        print(fmt_tool('Name (id)', 'Tool description', 'Keymap'))\n        print('-' * 80)\n        tools = self.toolmanager.tools\n        for name in sorted(tools):\n            if not tools[name].description:\n                continue\n            keys = ', '.join(sorted(self.toolmanager.get_tool_keymap(name)))\n            print(fmt_tool(name, tools[name].description, keys))\n        print('_' * 80)\n        fmt_active_toggle = '{!s:12} {!s:45}'.format\n        print('Active Toggle tools')\n        print(fmt_active_toggle('Group', 'Active'))\n        print('-' * 80)\n        for group, active in self.toolmanager.active_toggle.items():\n            print(fmt_active_toggle(group, active))\n\n\nclass GroupHideTool(ToolToggleBase):\n    '''Show lines with a given gid.'''\n    default_keymap = 'S'\n    description = 'Show by gid'\n    default_toggled = True\n\n    def __init__(self, *args, gid, **kwargs):\n        self.gid = gid\n        super().__init__(*args, **kwargs)\n\n    def enable(self, *args):\n        self.set_lines_visibility(True)\n\n    def disable(self, *args):\n        self.set_lines_visibility(False)\n\n    def set_lines_visibility(self, state):\n        for ax in self.figure.get_axes():\n            for line in ax.get_lines():\n                if line.get_gid() == self.gid:\n                    line.set_visible(state)\n        self.figure.canvas.draw()\n\n\nfig = plt.figure()\nplt.plot([1, 2, 3], gid='mygroup')\nplt.plot([2, 3, 4], gid='unknown')\nplt.plot([3, 2, 1], gid='mygroup')\n\n# Add the custom tools that we created\nfig.canvas.manager.toolmanager.add_tool('List', ListTools)\nfig.canvas.manager.toolmanager.add_tool('Show', GroupHideTool, gid='mygroup')\n\n# Add an existing tool to new group `foo`.\n# It can be added as many times as we want\nfig.canvas.manager.toolbar.add_tool('zoom', 'foo')\n\n# Remove the forward button\nfig.canvas.manager.toolmanager.remove_tool('forward')\n\n# To add a custom tool to the toolbar at specific location inside\n# the navigation group\nfig.canvas.manager.toolbar.add_tool('Show', 'navigation', 1)\n\nplt.show()\n",
    "id": 354
},
{
    "title": "Adding a cursor in WX",
    "text": "Example to draw a cursor and report the data coords in wx.",
    "code": "import wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, ):\n        super().__init__(None, -1, 'CanvasFrame', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2*np.pi*t)\n\n        self.axes.plot(t, s)\n        self.axes.set_xlabel('t')\n        self.axes.set_ylabel('sin(t)')\n        self.figure_canvas = FigureCanvas(self, -1, self.figure)\n\n        # Note that event is a MplEvent\n        self.figure_canvas.mpl_connect(\n            'motion_notify_event', self.UpdateStatusBar)\n        self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.statusBar = wx.StatusBar(self, -1)\n        self.SetStatusBar(self.statusBar)\n\n        self.toolbar = NavigationToolbar2Wx(self.figure_canvas)\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.toolbar.Show()\n\n    def ChangeCursor(self, event):\n        self.figure_canvas.SetCursor(wx.Cursor(wx.CURSOR_BULLSEYE))\n\n    def UpdateStatusBar(self, event):\n        if event.inaxes:\n            self.statusBar.SetStatusText(f'x={event.xdata}  y={event.ydata}')\n\n\nclass App(wx.App):\n    def OnInit(self):\n        '''Create the main window and insert the custom frame.'''\n        frame = CanvasFrame()\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == '__main__':\n    app = App()\n    app.MainLoop()\n",
    "id": 355
},
{
    "title": "Buttons",
    "text": "Constructing a simple button GUI to modify a sine wave. The next and previous button widget helps visualize the wave with\nnew frequencies. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Button",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button\n\nfreqs = np.arange(2, 20, 3)\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.2)\nt = np.arange(0.0, 1.0, 0.001)\ns = np.sin(2*np.pi*freqs[0]*t)\nl, = ax.plot(t, s, lw=2)\n\n\nclass Index:\n    ind = 0\n\n    def next(self, event):\n        self.ind += 1\n        i = self.ind % len(freqs)\n        ydata = np.sin(2*np.pi*freqs[i]*t)\n        l.set_ydata(ydata)\n        plt.draw()\n\n    def prev(self, event):\n        self.ind -= 1\n        i = self.ind % len(freqs)\n        ydata = np.sin(2*np.pi*freqs[i]*t)\n        l.set_ydata(ydata)\n        plt.draw()\n\ncallback = Index()\naxprev = fig.add_axes([0.7, 0.05, 0.1, 0.075])\naxnext = fig.add_axes([0.81, 0.05, 0.1, 0.075])\nbnext = Button(axnext, 'Next')\nbnext.on_clicked(callback.next)\nbprev = Button(axprev, 'Previous')\nbprev.on_clicked(callback.prev)\n\nplt.show()\n",
    "id": 356
},
{
    "title": "Check buttons",
    "text": "Turning visual elements on and off with check buttons. This program shows the use of CheckButtons which is similar to\ncheck boxes. There are 3 different sine waves shown, and we can choose which\nwaves are displayed with the check buttons. Check buttons may be styled using the check_props, frame_props, and label_props\nparameters. The parameters each take a dictionary with keys of artist property names and\nvalues of lists of settings with length matching the number of buttons. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.CheckButtons",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import CheckButtons\n\nt = np.arange(0.0, 2.0, 0.01)\ns0 = np.sin(2*np.pi*t)\ns1 = np.sin(4*np.pi*t)\ns2 = np.sin(6*np.pi*t)\n\nfig, ax = plt.subplots()\nl0, = ax.plot(t, s0, visible=False, lw=2, color='black', label='1 Hz')\nl1, = ax.plot(t, s1, lw=2, color='red', label='2 Hz')\nl2, = ax.plot(t, s2, lw=2, color='green', label='3 Hz')\n\nlines_by_label = {l.get_label(): l for l in [l0, l1, l2]}\nline_colors = [l.get_color() for l in lines_by_label.values()]\n\n# Make checkbuttons with all plotted lines with correct visibility\nrax = ax.inset_axes([0.0, 0.0, 0.12, 0.2])\ncheck = CheckButtons(\n    ax=rax,\n    labels=lines_by_label.keys(),\n    actives=[l.get_visible() for l in lines_by_label.values()],\n    label_props={'color': line_colors},\n    frame_props={'edgecolor': line_colors},\n    check_props={'facecolor': line_colors},\n)\n\n\ndef callback(label):\n    ln = lines_by_label[label]\n    ln.set_visible(not ln.get_visible())\n    ln.figure.canvas.draw_idle()\n\ncheck.on_clicked(callback)\n\nplt.show()\n",
    "id": 357
},
{
    "title": "Cursor",
    "text": "References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Cursor",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Cursor\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots(figsize=(8, 6))\n\nx, y = 4*(np.random.rand(2, 100) - .5)\nax.plot(x, y, 'o')\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\n# Set useblit=True on most backends for enhanced performance.\ncursor = Cursor(ax, useblit=True, color='red', linewidth=2)\n\nplt.show()\n",
    "id": 358
},
{
    "title": "Lasso Selector",
    "text": "Interactively selecting data points with the lasso tool. This examples plots a scatter plot. You can then select a few points by drawing\na lasso loop around the points on the graph. To draw, just click\non the graph, hold, and drag it around the points you need to select. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.LassoSelector matplotlib.path.Path",
    "code": "import numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.widgets import LassoSelector\n\n\nclass SelectFromCollection:\n    '''\n    Select indices from a matplotlib collection using `LassoSelector`.\n\n    Selected indices are saved in the `ind` attribute. This tool fades out the\n    points that are not part of the selection (i.e., reduces their alpha\n    values). If your collection has alpha < 1, this tool will permanently\n    alter the alpha values.\n\n    Note that this tool selects collection objects based on their *origins*\n    (i.e., `offsets`).\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        Axes to interact with.\n    collection : `matplotlib.collections.Collection` subclass\n        Collection you want to select from.\n    alpha_other : 0 <= float <= 1\n        To highlight a selection, this tool sets all selected points to an\n        alpha value of 1 and non-selected points to *alpha_other*.\n    '''\n\n    def __init__(self, ax, collection, alpha_other=0.3):\n        self.canvas = ax.figure.canvas\n        self.collection = collection\n        self.alpha_other = alpha_other\n\n        self.xys = collection.get_offsets()\n        self.Npts = len(self.xys)\n\n        # Ensure that we have separate colors for each object\n        self.fc = collection.get_facecolors()\n        if len(self.fc) == 0:\n            raise ValueError('Collection must have a facecolor')\n        elif len(self.fc) == 1:\n            self.fc = np.tile(self.fc, (self.Npts, 1))\n\n        self.lasso = LassoSelector(ax, onselect=self.onselect)\n        self.ind = []\n\n    def onselect(self, verts):\n        path = Path(verts)\n        self.ind = np.nonzero(path.contains_points(self.xys))[0]\n        self.fc[:, -1] = self.alpha_other\n        self.fc[self.ind, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n    def disconnect(self):\n        self.lasso.disconnect_events()\n        self.fc[:, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    data = np.random.rand(100, 2)\n\n    subplot_kw = dict(xlim=(0, 1), ylim=(0, 1), autoscale_on=False)\n    fig, ax = plt.subplots(subplot_kw=subplot_kw)\n\n    pts = ax.scatter(data[:, 0], data[:, 1], s=80)\n    selector = SelectFromCollection(ax, pts)\n\n    def accept(event):\n        if event.key == 'enter':\n            print('Selected points:')\n            print(selector.xys[selector.ind])\n            selector.disconnect()\n            ax.set_title('')\n            fig.canvas.draw()\n\n    fig.canvas.mpl_connect('key_press_event', accept)\n    ax.set_title('Press enter to accept selected points.')\n\n    plt.show()\n",
    "id": 359
},
{
    "title": "Menu",
    "text": "Download Python source code: menu.py Download Jupyter notebook: menu.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.artist as artist\nimport matplotlib.patches as patches\nfrom matplotlib.transforms import IdentityTransform\n\n\nclass ItemProperties:\n    def __init__(self, fontsize=14, labelcolor='black', bgcolor='yellow',\n                 alpha=1.0):\n        self.fontsize = fontsize\n        self.labelcolor = labelcolor\n        self.bgcolor = bgcolor\n        self.alpha = alpha\n\n\nclass MenuItem(artist.Artist):\n    padx = 5\n    pady = 5\n\n    def __init__(self, fig, labelstr, props=None, hoverprops=None,\n                 on_select=None):\n        super().__init__()\n\n        self.set_figure(fig)\n        self.labelstr = labelstr\n\n        self.props = props if props is not None else ItemProperties()\n        self.hoverprops = (\n            hoverprops if hoverprops is not None else ItemProperties())\n        if self.props.fontsize != self.hoverprops.fontsize:\n            raise NotImplementedError(\n                'support for different font sizes not implemented')\n\n        self.on_select = on_select\n\n        # Setting the transform to IdentityTransform() lets us specify\n        # coordinates directly in pixels.\n        self.label = fig.text(0, 0, labelstr, transform=IdentityTransform(),\n                              size=props.fontsize)\n        self.text_bbox = self.label.get_window_extent(\n            fig.canvas.get_renderer())\n\n        self.rect = patches.Rectangle((0, 0), 1, 1)  # Will be updated later.\n\n        self.set_hover_props(False)\n\n        fig.canvas.mpl_connect('button_release_event', self.check_select)\n\n    def check_select(self, event):\n        over, _ = self.rect.contains(event)\n        if not over:\n            return\n        if self.on_select is not None:\n            self.on_select(self)\n\n    def set_extent(self, x, y, w, h, depth):\n        self.rect.set(x=x, y=y, width=w, height=h)\n        self.label.set(position=(x + self.padx, y + depth + self.pady/2))\n        self.hover = False\n\n    def draw(self, renderer):\n        self.rect.draw(renderer)\n        self.label.draw(renderer)\n\n    def set_hover_props(self, b):\n        props = self.hoverprops if b else self.props\n        self.label.set(color=props.labelcolor)\n        self.rect.set(facecolor=props.bgcolor, alpha=props.alpha)\n\n    def set_hover(self, event):\n        '''\n        Update the hover status of event and return whether it was changed.\n        '''\n        b, _ = self.rect.contains(event)\n        changed = (b != self.hover)\n        if changed:\n            self.set_hover_props(b)\n        self.hover = b\n        return changed\n\n\nclass Menu:\n    def __init__(self, fig, menuitems):\n        self.figure = fig\n\n        self.menuitems = menuitems\n\n        maxw = max(item.text_bbox.width for item in menuitems)\n        maxh = max(item.text_bbox.height for item in menuitems)\n        depth = max(-item.text_bbox.y0 for item in menuitems)\n\n        x0 = 100\n        y0 = 400\n\n        width = maxw + 2*MenuItem.padx\n        height = maxh + MenuItem.pady\n\n        for item in menuitems:\n            left = x0\n            bottom = y0 - maxh - MenuItem.pady\n\n            item.set_extent(left, bottom, width, height, depth)\n\n            fig.artists.append(item)\n            y0 -= maxh + MenuItem.pady\n\n        fig.canvas.mpl_connect('motion_notify_event', self.on_move)\n\n    def on_move(self, event):\n        if any(item.set_hover(event) for item in self.menuitems):\n            self.figure.canvas.draw()\n\n\nfig = plt.figure()\nfig.subplots_adjust(left=0.3)\nprops = ItemProperties(labelcolor='black', bgcolor='yellow',\n                       fontsize=15, alpha=0.2)\nhoverprops = ItemProperties(labelcolor='white', bgcolor='blue',\n                            fontsize=15, alpha=0.2)\n\nmenuitems = []\nfor label in ('open', 'close', 'save', 'save as', 'quit'):\n    def on_select(item):\n        print('you selected %s' % item.labelstr)\n    item = MenuItem(fig, label, props=props, hoverprops=hoverprops,\n                    on_select=on_select)\n    menuitems.append(item)\n\nmenu = Menu(fig, menuitems)\nplt.show()\n",
    "id": 360
},
{
    "title": "Mouse Cursor",
    "text": "This example sets an alternative cursor on a figure canvas. Note, this is an interactive example, and must be run to see the effect. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.backend_bases.FigureCanvasBase.set_cursor",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import Cursors\n\nfig, axs = plt.subplots(len(Cursors), figsize=(6, len(Cursors) + 0.5),\n                        gridspec_kw={'hspace': 0})\nfig.suptitle('Hover over an Axes to see alternate Cursors')\n\nfor cursor, ax in zip(Cursors, axs):\n    ax.cursor_to_use = cursor\n    ax.text(0.5, 0.5, cursor.name,\n            horizontalalignment='center', verticalalignment='center')\n    ax.set(xticks=[], yticks=[])\n\n\ndef hover(event):\n    if fig.canvas.widgetlock.locked():\n        # Don't do anything if the zoom/pan tools have been enabled.\n        return\n\n    fig.canvas.set_cursor(\n        event.inaxes.cursor_to_use if event.inaxes else Cursors.POINTER)\n\n\nfig.canvas.mpl_connect('motion_notify_event', hover)\n\nplt.show()\n",
    "id": 361
},
{
    "title": "Multicursor",
    "text": "Showing a cursor on multiple plots simultaneously. This example generates three axes split over two different figures. On\nhovering the cursor over data in one subplot, the values of that datapoint are\nshown in all axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.MultiCursor",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import MultiCursor\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(3*np.pi*t)\ns3 = np.sin(4*np.pi*t)\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nax1.plot(t, s1)\nax2.plot(t, s2)\nfig, ax3 = plt.subplots()\nax3.plot(t, s3)\n\nmulti = MultiCursor(None, (ax1, ax2, ax3), color='r', lw=1)\nplt.show()\n",
    "id": 362
},
{
    "title": "Radio Buttons",
    "text": "Using radio buttons to choose properties of your plot. Radio buttons let you choose between multiple options in a visualization.\nIn this case, the buttons let the user choose one of the three different sine\nwaves to be shown in the plot. Radio buttons may be styled using the label_props and radio_props parameters, which\neach take a dictionary with keys of artist property names and values of lists of\nsettings with length matching the number of buttons. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.RadioButtons",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import RadioButtons\n\nt = np.arange(0.0, 2.0, 0.01)\ns0 = np.sin(2*np.pi*t)\ns1 = np.sin(4*np.pi*t)\ns2 = np.sin(8*np.pi*t)\n\nfig, ax = plt.subplot_mosaic(\n    [\n        ['main freq'],\n        ['main color'],\n        ['main linestyle'],\n    ],\n    width_ratios=[5, 1],\n    layout='constrained',\n)\nl, = ax['main'].plot(t, s0, lw=2, color='red')\n\nradio_background = 'lightgoldenrodyellow'\n\nax['freq'].set_facecolor(radio_background)\nradio = RadioButtons(ax['freq'], ('1 Hz 2 Hz 4 Hz'),\n                     label_props={'color': 'cmy fontsize': [12, 14, 16]},\n                     radio_props={'s': [16, 32, 64]})\n\n\ndef hzfunc(label):\n    hzdict = {'1 Hz': s0, '2 Hz': s1, '4 Hz': s2}\n    ydata = hzdict[label]\n    l.set_ydata(ydata)\n    fig.canvas.draw()\nradio.on_clicked(hzfunc)\n\nax['color'].set_facecolor(radio_background)\nradio2 = RadioButtons(\n    ax['color'], ('red blue green'),\n    label_props={'color': ['red blue green']},\n    radio_props={\n        'facecolor': ['red blue green'],\n        'edgecolor': ['darkred darkblue darkgreen'],\n    })\n\n\ndef colorfunc(label):\n    l.set_color(label)\n    fig.canvas.draw()\nradio2.on_clicked(colorfunc)\n\nax['linestyle'].set_facecolor(radio_background)\nradio3 = RadioButtons(ax['linestyle'], ('- -- -. :'))\n\n\ndef stylefunc(label):\n    l.set_linestyle(label)\n    fig.canvas.draw()\nradio3.on_clicked(stylefunc)\n\nplt.show()\n",
    "id": 363
},
{
    "title": "Thresholding an Image with RangeSlider",
    "text": "Using the RangeSlider widget to control the thresholding of an image.', \"The RangeSlider widget can be used similarly to the widgets.Slider\nwidget. The major difference is that RangeSlider's val attribute\nis a tuple of floats (lower val, upper val) rather than a single float.\", 'See Slider for an example of using\na Slider to control a single float. See Snapping Sliders to Discrete Values for an example of having\nthe Slider snap to discrete values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.RangeSlider",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import RangeSlider\n\n# generate a fake image\nnp.random.seed(19680801)\nN = 128\nimg = np.random.randn(N, N)\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nfig.subplots_adjust(bottom=0.25)\n\nim = axs[0].imshow(img)\naxs[1].hist(img.flatten(), bins='auto')\naxs[1].set_title('Histogram of pixel intensities')\n\n# Create the RangeSlider\nslider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03])\nslider = RangeSlider(slider_ax, 'Threshold', img.min(), img.max())\n\n# Create the Vertical lines on the histogram\nlower_limit_line = axs[1].axvline(slider.val[0], color='k')\nupper_limit_line = axs[1].axvline(slider.val[1], color='k')\n\n\ndef update(val):\n    # The val passed to a callback by the RangeSlider will\n    # be a tuple of (min, max)\n\n    # Update the image's colormap\n    im.norm.vmin = val[0]\n    im.norm.vmax = val[1]\n\n    # Update the position of the vertical lines\n    lower_limit_line.set_xdata([val[0], val[0]])\n    upper_limit_line.set_xdata([val[1], val[1]])\n\n    # Redraw the figure to ensure it updates\n    fig.canvas.draw_idle()\n\n\nslider.on_changed(update)\nplt.show()\n",
    "id": 364
},
{
    "title": "Rectangle and ellipse selectors",
    "text": "Click somewhere, move the mouse, and release the mouse button.\nRectangleSelector and EllipseSelector draw a rectangle or an ellipse\nfrom the initial click position to the current mouse position (within the same\naxes) until the button is released. A connected callback receives the click-\nand release-events. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.RectangleSelector matplotlib.widgets.EllipseSelector",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import EllipseSelector, RectangleSelector\n\n\ndef select_callback(eclick, erelease):\n    '''\n    Callback for line selection.\n\n    *eclick* and *erelease* are the press and release events.\n    '''\n    x1, y1 = eclick.xdata, eclick.ydata\n    x2, y2 = erelease.xdata, erelease.ydata\n    print(f'({x1:3.2f}, {y1:3.2f}) --> ({x2:3.2f}, {y2:3.2f})')\n    print(f'The buttons you used were: {eclick.button} {erelease.button}')\n\n\ndef toggle_selector(event):\n    print('Key pressed.')\n    if event.key == 't':\n        for selector in selectors:\n            name = type(selector).__name__\n            if selector.active:\n                print(f'{name} deactivated.')\n                selector.set_active(False)\n            else:\n                print(f'{name} activated.')\n                selector.set_active(True)\n\n\nfig = plt.figure(layout='constrained')\naxs = fig.subplots(2)\n\nN = 100000  # If N is large one can see improvement by using blitting.\nx = np.linspace(0, 10, N)\n\nselectors = []\nfor ax, selector_class in zip(axs, [RectangleSelector, EllipseSelector]):\n    ax.plot(x, np.sin(2*np.pi*x))  # plot something\n    ax.set_title(f'Click and drag to draw a {selector_class.__name__}.')\n    selectors.append(selector_class(\n        ax, select_callback,\n        useblit=True,\n        button=[1, 3],  # disable middle button\n        minspanx=5, minspany=5,\n        spancoords='pixels',\n        interactive=True))\n    fig.canvas.mpl_connect('key_press_event', toggle_selector)\naxs[0].set_title('Press 't' to toggle the selectors on and off.\\\n'\n                 + axs[0].get_title())\nplt.show()\n",
    "id": 365
},
{
    "title": "Slider",
    "text": "In this example, sliders are used to control the frequency and amplitude of\na sine wave. See Snapping Sliders to Discrete Values for an example of having\nthe Slider snap to discrete values. See Thresholding an Image with RangeSlider for an example of using\na RangeSlider to define a range of values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Button matplotlib.widgets.Slider",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button, Slider\n\n\n# The parametrized function to be plotted\ndef f(t, amplitude, frequency):\n    return amplitude * np.sin(2 * np.pi * frequency * t)\n\nt = np.linspace(0, 1, 1000)\n\n# Define initial parameters\ninit_amplitude = 5\ninit_frequency = 3\n\n# Create the figure and the line that we will manipulate\nfig, ax = plt.subplots()\nline, = ax.plot(t, f(t, init_amplitude, init_frequency), lw=2)\nax.set_xlabel('Time [s]')\n\n# adjust the main plot to make room for the sliders\nfig.subplots_adjust(left=0.25, bottom=0.25)\n\n# Make a horizontal slider to control the frequency.\naxfreq = fig.add_axes([0.25, 0.1, 0.65, 0.03])\nfreq_slider = Slider(\n    ax=axfreq,\n    label='Frequency [Hz]',\n    valmin=0.1,\n    valmax=30,\n    valinit=init_frequency,\n)\n\n# Make a vertically oriented slider to control the amplitude\naxamp = fig.add_axes([0.1, 0.25, 0.0225, 0.63])\namp_slider = Slider(\n    ax=axamp,\n    label='Amplitude',\n    valmin=0,\n    valmax=10,\n    valinit=init_amplitude,\n    orientation='vertical'\n)\n\n\n# The function to be called anytime a slider's value changes\ndef update(val):\n    line.set_ydata(f(t, amp_slider.val, freq_slider.val))\n    fig.canvas.draw_idle()\n\n\n# register the update function with each slider\nfreq_slider.on_changed(update)\namp_slider.on_changed(update)\n\n# Create a `matplotlib.widgets.Button` to reset the sliders to initial values.\nresetax = fig.add_axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(resetax, 'Reset', hovercolor='0.975')\n\n\ndef reset(event):\n    freq_slider.reset()\n    amp_slider.reset()\nbutton.on_clicked(reset)\n\nplt.show()\n",
    "id": 366
},
{
    "title": "Snapping Sliders to Discrete Values",
    "text": "You can snap slider values to discrete values using the valstep argument. In this example the Freq slider is constrained to be multiples of pi, and the\nAmp slider uses an array as the valstep argument to more densely sample\nthe first part of its range. See Slider for an example of using\na Slider to control a single float. See Thresholding an Image with RangeSlider for an example of using\na RangeSlider to define a range of values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Slider matplotlib.widgets.Button",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button, Slider\n\nt = np.arange(0.0, 1.0, 0.001)\na0 = 5\nf0 = 3\ns = a0 * np.sin(2 * np.pi * f0 * t)\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.25)\nl, = ax.plot(t, s, lw=2)\n\nax_freq = fig.add_axes([0.25, 0.1, 0.65, 0.03])\nax_amp = fig.add_axes([0.25, 0.15, 0.65, 0.03])\n\n# define the values to use for snapping\nallowed_amplitudes = np.concatenate([np.linspace(.1, 5, 100), [6, 7, 8, 9]])\n\n# create the sliders\nsamp = Slider(\n    ax_amp, 'Amp', 0.1, 9.0,\n    valinit=a0, valstep=allowed_amplitudes,\n    color='green'\n)\n\nsfreq = Slider(\n    ax_freq, 'Freq', 0, 10*np.pi,\n    valinit=2*np.pi, valstep=np.pi,\n    initcolor='none'  # Remove the line marking the valinit position.\n)\n\n\ndef update(val):\n    amp = samp.val\n    freq = sfreq.val\n    l.set_ydata(amp*np.sin(2*np.pi*freq*t))\n    fig.canvas.draw_idle()\n\n\nsfreq.on_changed(update)\nsamp.on_changed(update)\n\nax_reset = fig.add_axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(ax_reset, 'Reset', hovercolor='0.975')\n\n\ndef reset(event):\n    sfreq.reset()\n    samp.reset()\nbutton.on_clicked(reset)\n\n\nplt.show()\n",
    "id": 367
},
{
    "title": "Span Selector",
    "text": "The SpanSelector is a mouse widget that enables selecting a range on an\naxis. Here, an x-range can be selected on the upper axis; a detailed view of the\nselected range is then plotted on the lower axis. Note If the SpanSelector object is garbage collected you will lose the\ninteractivity. You must keep a hard reference to it to prevent this. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.SpanSelector",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import SpanSelector\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, (ax1, ax2) = plt.subplots(2, figsize=(8, 6))\n\nx = np.arange(0.0, 5.0, 0.01)\ny = np.sin(2 * np.pi * x) + 0.5 * np.random.randn(len(x))\n\nax1.plot(x, y)\nax1.set_ylim(-2, 2)\nax1.set_title('Press left mouse button and drag '\n              'to select a region in the top graph')\n\nline2, = ax2.plot([], [])\n\n\ndef onselect(xmin, xmax):\n    indmin, indmax = np.searchsorted(x, (xmin, xmax))\n    indmax = min(len(x) - 1, indmax)\n\n    region_x = x[indmin:indmax]\n    region_y = y[indmin:indmax]\n\n    if len(region_x) >= 2:\n        line2.set_data(region_x, region_y)\n        ax2.set_xlim(region_x[0], region_x[-1])\n        ax2.set_ylim(region_y.min(), region_y.max())\n        fig.canvas.draw_idle()\n\n\nspan = SpanSelector(\n    ax1,\n    onselect,\n    'horizontal',\n    useblit=True,\n    props=dict(alpha=0.5, facecolor='tab:blue'),\n    interactive=True,\n    drag_from_anywhere=True\n)\n# Set useblit=True on most backends for enhanced performance.\n\n\nplt.show()\n",
    "id": 368
},
{
    "title": "Textbox",
    "text": "The Textbox widget lets users interactively provide text input, including\nformulas. In this example, the plot is updated using the on_submit method.\nThis method triggers the execution of the submit function when the\nuser presses enter in the textbox or leaves the textbox. Note: The matplotlib.widgets.TextBox widget is different from the following\nstatic elements: Annotations and\nPlacing text boxes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.TextBox",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import TextBox\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.2)\n\nt = np.arange(-2.0, 2.0, 0.001)\nl, = ax.plot(t, np.zeros_like(t), lw=2)\n\n\ndef submit(expression):\n    '''\n    Update the plotted function to the new math *expression*.\n\n    *expression* is a string using 't' as its independent variable, e.g.\n    't ** 3'.\n    '''\n    ydata = eval(expression, {'np': np}, {'t': t})\n    l.set_ydata(ydata)\n    ax.relim()\n    ax.autoscale_view()\n    plt.draw()\n\n\naxbox = fig.add_axes([0.1, 0.05, 0.8, 0.075])\ntext_box = TextBox(axbox, 'Evaluate', textalignment='center')\ntext_box.on_submit(submit)\ntext_box.set_val('t ** 2')  # Trigger `submit` with the initial string.\n\nplt.show()\n",
    "id": 369
},
{
    "title": "Annotate Explain",
    "text": "Download Python source code: annotate_explain.py Download Jupyter notebook: annotate_explain.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nfig, axs = plt.subplots(2, 2)\nx1, y1 = 0.3, 0.3\nx2, y2 = 0.7, 0.7\n\nax = axs.flat[0]\nax.plot([x1, x2], [y1, y2], '.')\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='-',\n                            color='0.5',\n                            patchB=None,\n                            shrinkB=0,\n                            connectionstyle='arc3,rad=0.3',\n                            ),\n            )\nax.text(.05, .95, 'connect', transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[1]\nax.plot([x1, x2], [y1, y2], '.')\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='-',\n                            color='0.5',\n                            patchB=el,\n                            shrinkB=0,\n                            connectionstyle='arc3,rad=0.3',\n                            ),\n            )\nax.text(.05, .95, 'clip', transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[2]\nax.plot([x1, x2], [y1, y2], '.')\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='-',\n                            color='0.5',\n                            patchB=el,\n                            shrinkB=5,\n                            connectionstyle='arc3,rad=0.3',\n                            ),\n            )\nax.text(.05, .95, 'shrink', transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[3]\nax.plot([x1, x2], [y1, y2], '.')\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='fancy',\n                            color='0.5',\n                            patchB=el,\n                            shrinkB=5,\n                            connectionstyle='arc3,rad=0.3',\n                            ),\n            )\nax.text(.05, .95, 'mutate', transform=ax.transAxes, ha='left', va='top')\n\nfor ax in axs.flat:\n    ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[], aspect=1)\n\nplt.show()\n",
    "id": 370
},
{
    "title": "Annotate Text Arrow",
    "text": "Download Python source code: annotate_text_arrow.py Download Jupyter notebook: annotate_text_arrow.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots(figsize=(5, 5))\nax.set_aspect(1)\n\nx1 = -1 + np.random.randn(100)\ny1 = -1 + np.random.randn(100)\nx2 = 1. + np.random.randn(100)\ny2 = 1. + np.random.randn(100)\n\nax.scatter(x1, y1, color='r')\nax.scatter(x2, y2, color='g')\n\nbbox_props = dict(boxstyle='round', fc='w', ec='0.5', alpha=0.9)\nax.text(-2, -2, 'Sample A', ha='center', va='center', size=20,\n        bbox=bbox_props)\nax.text(2, 2, 'Sample B', ha='center', va='center', size=20,\n        bbox=bbox_props)\n\n\nbbox_props = dict(boxstyle='rarrow', fc=(0.8, 0.9, 0.9), ec='b', lw=2)\nt = ax.text(0, 0, 'Direction', ha='center', va='center', rotation=45,\n            size=15,\n            bbox=bbox_props)\n\nbb = t.get_bbox_patch()\nbb.set_boxstyle('rarrow', pad=0.6)\n\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\n\nplt.show()\n",
    "id": 371
},
{
    "title": "Connection styles for annotations",
    "text": "When creating an annotation using annotate, the arrow shape can be\ncontrolled via the connectionstyle parameter of arrowprops. For further\ndetails see the description of FancyArrowPatch. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.annotate matplotlib.patches.FancyArrowPatch",
    "code": "import matplotlib.pyplot as plt\n\n\ndef demo_con_style(ax, connectionstyle):\n    x1, y1 = 0.3, 0.2\n    x2, y2 = 0.8, 0.6\n\n    ax.plot([x1, x2], [y1, y2], '.')\n    ax.annotate('',\n                xy=(x1, y1), xycoords='data',\n                xytext=(x2, y2), textcoords='data',\n                arrowprops=dict(arrowstyle='->', color='0.5',\n                                shrinkA=5, shrinkB=5,\n                                patchA=None, patchB=None,\n                                connectionstyle=connectionstyle,\n                                ),\n                )\n\n    ax.text(.05, .95, connectionstyle.replace(',', ',\\\n'),\n            transform=ax.transAxes, ha='left', va='top')\n\n\nfig, axs = plt.subplots(3, 5, figsize=(7, 6.3), layout='constrained')\ndemo_con_style(axs[0, 0], 'angle3,angleA=90,angleB=0')\ndemo_con_style(axs[1, 0], 'angle3,angleA=0,angleB=90')\ndemo_con_style(axs[0, 1], 'arc3,rad=0.')\ndemo_con_style(axs[1, 1], 'arc3,rad=0.3')\ndemo_con_style(axs[2, 1], 'arc3,rad=-0.3')\ndemo_con_style(axs[0, 2], 'angle,angleA=-90,angleB=180,rad=0')\ndemo_con_style(axs[1, 2], 'angle,angleA=-90,angleB=180,rad=5')\ndemo_con_style(axs[2, 2], 'angle,angleA=-90,angleB=10,rad=5')\ndemo_con_style(axs[0, 3], 'arc,angleA=-90,angleB=0,armA=30,armB=30,rad=0')\ndemo_con_style(axs[1, 3], 'arc,angleA=-90,angleB=0,armA=30,armB=30,rad=5')\ndemo_con_style(axs[2, 3], 'arc,angleA=-90,angleB=0,armA=0,armB=40,rad=0')\ndemo_con_style(axs[0, 4], 'bar,fraction=0.3')\ndemo_con_style(axs[1, 4], 'bar,fraction=-0.3')\ndemo_con_style(axs[2, 4], 'bar,angle=180,fraction=-0.2')\n\nfor ax in axs.flat:\n    ax.set(xlim=(0, 1), ylim=(0, 1.25), xticks=[], yticks=[], aspect=1.25)\nfig.get_layout_engine().set(wspace=0, hspace=0, w_pad=0, h_pad=0)\n\nplt.show()\n",
    "id": 372
},
{
    "title": "subplot2grid demo",
    "text": "This example demonstrates the use of pyplot.subplot2grid to generate\nsubplots. Using GridSpec, as demonstrated in\nGridSpec demo is generally preferred.",
    "code": "import matplotlib.pyplot as plt\n\n\ndef annotate_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, 'ax%d' % (i+1), va='center', ha='center')\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\nfig = plt.figure()\nax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)\nax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\nax4 = plt.subplot2grid((3, 3), (2, 0))\nax5 = plt.subplot2grid((3, 3), (2, 1))\n\nannotate_axes(fig)\n\nplt.show()\n",
    "id": 373
},
{
    "title": "Nested GridSpecs",
    "text": "This example demonstrates the use of nested GridSpecs. Total running time of the script: (0 minutes 2.299 seconds)",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef squiggle_xy(a, b, c, d):\n    i = np.arange(0.0, 2*np.pi, 0.05)\n    return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)\n\n\nfig = plt.figure(figsize=(8, 8))\nouter_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0)\n\nfor a in range(4):\n    for b in range(4):\n        # gridspec inside gridspec\n        inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0)\n        axs = inner_grid.subplots()  # Create all subplots for the inner grid.\n        for (c, d), ax in np.ndenumerate(axs):\n            ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1))\n            ax.set(xticks=[], yticks=[])\n\n# show only the outside spines\nfor ax in fig.get_axes():\n    ss = ax.get_subplotspec()\n    ax.spines.top.set_visible(ss.is_first_row())\n    ax.spines.bottom.set_visible(ss.is_last_row())\n    ax.spines.left.set_visible(ss.is_first_col())\n    ax.spines.right.set_visible(ss.is_last_col())\n\nplt.show()\n",
    "id": 374
},
{
    "title": "PGF preamble",
    "text": "Download Python source code: pgf_preamble_sgskip.py Download Jupyter notebook: pgf_preamble_sgskip.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib as mpl\n\nmpl.use('pgf')\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    'font.family': 'serif',  # use serif/main font for text elements\n    'text.usetex': True,     # use inline math for ticks\n    'pgf.rcfonts': False,    # don't setup fonts from rc parameters\n    'pgf.preamble': '\\\n'.join([\n         r'\\\\usepackage{url}',            # load additional packages\n         r'\\\\usepackage{unicode-math}',   # unicode math setup\n         r'\\\\setmainfont{DejaVu Serif}',  # serif font via preamble\n    ])\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.set_xlabel('unicode text: \u044f, \u03c8, \u20ac, \u00fc')\nax.set_ylabel(r'\\\\url{https://matplotlib.org}')\nax.legend(['unicode math: $\u03bb=\u2211_i^\u221e \u03bc_i^2$'])\n\nfig.tight_layout(pad=.5)\n\nfig.savefig('pgf_preamble.pdf')\nfig.savefig('pgf_preamble.png')\n",
    "id": 375
},
{
    "title": "PGF texsystem",
    "text": "Download Python source code: pgf_texsystem.py Download Jupyter notebook: pgf_texsystem.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    'pgf.texsystem': 'pdflatex',\n    'pgf.preamble': '\\\n'.join([\n         r'\\\\usepackage[utf8x]{inputenc}',\n         r'\\\\usepackage[T1]{fontenc}',\n         r'\\\\usepackage{cmbright}',\n    ]),\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.text(0.5, 3., 'serif', family='serif')\nax.text(0.5, 2., 'monospace', family='monospace')\nax.text(2.5, 2., 'sans-serif', family='sans-serif')\nax.set_xlabel(r'\u00b5 is not $\\\\mu$')\n\nfig.tight_layout(pad=.5)\n\nfig.savefig('pgf_texsystem.pdf')\nfig.savefig('pgf_texsystem.png')\n",
    "id": 376
},
{
    "title": "Simple Annotate01",
    "text": "Download Python source code: simple_annotate01.py Download Jupyter notebook: simple_annotate01.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nfig, axs = plt.subplots(2, 4)\nx1, y1 = 0.3, 0.3\nx2, y2 = 0.7, 0.7\n\nax = axs.flat[0]\nax.plot([x1, x2], [y1, y2], 'o')\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='->'))\nax.text(.05, .95, 'A $->$ B',\n        transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[2]\nax.plot([x1, x2], [y1, y2], 'o')\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.3',\n                            shrinkB=5))\nax.text(.05, .95, 'shrinkB=5',\n        transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[3]\nax.plot([x1, x2], [y1, y2], 'o')\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.3'))\nax.text(.05, .95, 'connectionstyle=arc3',\n        transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[4]\nax.plot([x1, x2], [y1, y2], 'o')\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.5)\nax.add_artist(el)\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.2'))\n\nax = axs.flat[5]\nax.plot([x1, x2], [y1, y2], 'o')\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.5)\nax.add_artist(el)\nax.annotate('',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.2',\n                            patchB=el))\nax.text(.05, .95, 'patchB',\n        transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[6]\nax.plot([x1], [y1], 'o')\nax.annotate('Test',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            ha='center', va='center',\n            bbox=dict(boxstyle='round', fc='w'),\n            arrowprops=dict(arrowstyle='->'))\nax.text(.05, .95, 'annotate',\n        transform=ax.transAxes, ha='left', va='top')\n\nax = axs.flat[7]\nax.plot([x1], [y1], 'o')\nax.annotate('Test',\n            xy=(x1, y1), xycoords='data',\n            xytext=(x2, y2), textcoords='data',\n            ha='center', va='center',\n            bbox=dict(boxstyle='round', fc='w', ),\n            arrowprops=dict(arrowstyle='->', relpos=(0., 0.)))\nax.text(.05, .95, 'relpos=(0, 0)',\n        transform=ax.transAxes, ha='left', va='top')\n\nfor ax in axs.flat:\n    ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[], aspect=1)\n\nplt.show()\n",
    "id": 377
},
{
    "title": "Simple Legend01",
    "text": "Download Python source code: simple_legend01.py Download Jupyter notebook: simple_legend01.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\n\nax = fig.add_subplot(211)\nax.plot([1, 2, 3], label='test1')\nax.plot([3, 2, 1], label='test2')\n# Place a legend above this subplot, expanding itself to\n# fully use the given bounding box.\nax.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc='lower left',\n           ncols=2, mode='expand', borderaxespad=0.)\n\nax = fig.add_subplot(223)\nax.plot([1, 2, 3], label='test1')\nax.plot([3, 2, 1], label='test2')\n# Place a legend to the right of this smaller subplot.\nax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\n\nplt.show()\n",
    "id": 378
},
{
    "title": "Simple Legend02",
    "text": "Download Python source code: simple_legend02.py Download Jupyter notebook: simple_legend02.ipynb Gallery generated by Sphinx-Gallery",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nline1, = ax.plot([1, 2, 3], label='Line 1', linestyle='--')\nline2, = ax.plot([3, 2, 1], label='Line 2', linewidth=4)\n\n# Create a legend for the first line.\nfirst_legend = ax.legend(handles=[line1], loc='upper right')\n\n# Add the legend manually to the current Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second line.\nax.legend(handles=[line2], loc='lower right')\n\nplt.show()\n",
    "id": 379
}
]