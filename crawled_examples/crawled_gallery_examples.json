[
{
    "title": "Bar color demo#",
    "text": "This is an example showing how to control bar color and legend entries\nusing the color and label parameters of bar.\nNote that labels with a preceding underscore won't show up in the legend.\", 'Download Python source code: bar_colors.py Download Jupyter notebook: bar_colors.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nfruits = apple blueberry cherry orange\ncounts = [40, 100, 30, 55]\nbar_labels = red blue _red orange\nbar_colors = tab:red tab:blue tab:red tab:orange\n\nax.bar(fruits, counts, label=bar_labels, color=bar_colors)\n\nax.set_ylabel('fruit supply')\nax.set_title('Fruit supply by kind and color')\nax.legend(title='Fruit color')\n\nplt.show()\n",
    "id": 1
},
{
    "title": "Bar Label Demo#",
    "text": "This example shows how to use the bar_label helper function\nto create bar chart labels. See also the grouped bar,\nstacked bar and\nhorizontal bar chart examples. data from https://allisonhorst.github.io/palmerpenguins/ Horizontal bar chart Some of the more advanced things that one can do with bar labels Bar labels using {}-style format string Bar labels using a callable References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.barh / matplotlib.pyplot.barh matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label Total running time of the script: (0 minutes 1.189 seconds) Download Python source code: bar_label_demo.py Download Jupyter notebook: bar_label_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n', \"species = ('Adelie Chinstrap Gentoo')\nsex_counts = {\n    'Male': np.array([73, 34, 61]),\n    'Female': np.array([73, 34, 58]),\n}\nwidth = 0.6  # the width of the bars: can also be len(x) sequence\n\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor sex, sex_count in sex_counts.items():\n    p = ax.bar(species, sex_count, width, label=sex, bottom=bottom)\n    bottom += sex_count\n\n    ax.bar_label(p, label_type='center')\n\nax.set_title('Number of penguins by sex')\nax.legend()\n\nplt.show()\n\", \"# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Example data\npeople = ('Tom Dick Harry Slim Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nfig, ax = plt.subplots()\n\nhbars = ax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\n# Label with specially formatted floats\nax.bar_label(hbars, fmt='%.2f')\nax.set_xlim(right=15)  # adjust xlim to fit labels\n\nplt.show()\n\", \"fig, ax = plt.subplots()\n\nhbars = ax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\n# Label with given captions, custom padding and annotate options\nax.bar_label(hbars, labels=[f'\u00b1{e:.2f}' for e in error],\n             padding=8, color='b', fontsize=14)\nax.set_xlim(right=16)\n\nplt.show()\n\", \"fruit_names = Coffee Salted Caramel Pistachio\nfruit_counts = [4000, 2000, 7000]\n\nfig, ax = plt.subplots()\nbar_container = ax.bar(fruit_names, fruit_counts)\nax.set(ylabel='pints sold', title='Gelato sales by flavor', ylim=(0, 8000))\nax.bar_label(bar_container, fmt='{:,.0f}')\n\", \"animal_names = Lion Gazelle Cheetah\nmph_speed = [50, 60, 75]\n\nfig, ax = plt.subplots()\nbar_container = ax.bar(animal_names, mph_speed)\nax.set(ylabel='speed in MPH', title='Running speeds', ylim=(0, 80))\nax.bar_label(bar_container, fmt=lambda x: f'{x * 1.61:.1f} km/h')\n",
    "id": 2
},
{
    "title": "Stacked bar chart#",
    "text": "This is an example of creating a stacked bar plot\nusing bar. Download Python source code: bar_stacked.py Download Jupyter notebook: bar_stacked.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# data from https://allisonhorst.github.io/palmerpenguins/\n\nspecies = (\n    \"Adelie\\\n $\\\\\\\\mu=$3700.66g\",\n    \"Chinstrap\\\n $\\\\\\\\mu=$3733.09g\",\n    \"Gentoo\\\n $\\\\\\\\mu=5076.02g$\",\n)\nweight_counts = {\n    \"Below\": np.array([70, 31, 58]),\n    \"Above\": np.array([82, 37, 66]),\n}\nwidth = 0.5\n\nfig, ax = plt.subplots()\nbottom = np.zeros(3)\n\nfor boolean, weight_count in weight_counts.items():\n    p = ax.bar(species, weight_count, width, label=boolean, bottom=bottom)\n    bottom += weight_count\n\nax.set_title(\"Number of penguins with above average body mass\")\nax.legend(loc=\"upper right\")\n\nplt.show()\n",
    "id": 3
},
{
    "title": "Grouped bar chart with labels#",
    "text": "This example shows a how to create a grouped bar chart and how to annotate\nbars with labels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label Download Python source code: barchart.py Download Jupyter notebook: barchart.ipynb ",
    "code": "# data from https://allisonhorst.github.io/palmerpenguins/\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nspecies = (\"Adelie\", \"Chinstrap\", \"Gentoo\")\npenguin_means = {\n    \\'Bill Depth\\': (18.35, 18.43, 14.98),\n    \\'Bill Length\\': (38.79, 48.83, 47.50),\n    \\'Flipper Length\\': (189.95, 195.82, 217.19),\n}\n\nx = np.arange(len(species))  # the label locations\nwidth = 0.25  # the width of the bars\nmultiplier = 0\n\nfig, ax = plt.subplots(layout=\\'constrained\\')\n\nfor attribute, measurement in penguin_means.items():\n    offset = width * multiplier\n    rects = ax.bar(x + offset, measurement, width, label=attribute)\n    ax.bar_label(rects, padding=3)\n    multiplier += 1\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_ylabel(\\'Length (mm)\\')\nax.set_title(\\'Penguin attributes by species\\')\nax.set_xticks(x + width, species)\nax.legend(loc=\\'upper left\\', ncols=3)\nax.set_ylim(0, 250)\n\nplt.show()\n",
    "id": 4
},
{
    "title": "Horizontal bar chart#",
    "text": "This example showcases a simple horizontal bar chart. Download Python source code: barh.py Download Jupyter notebook: barh.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\n# Example data\npeople = ('Tom Dick Harry Slim Jim')\ny_pos = np.arange(len(people))\nperformance = 3 + 10 * np.random.rand(len(people))\nerror = np.random.rand(len(people))\n\nax.barh(y_pos, performance, xerr=error, align='center')\nax.set_yticks(y_pos, labels=people)\nax.invert_yaxis()  # labels read top-to-bottom\nax.set_xlabel('Performance')\nax.set_title('How fast do you want to go today?')\n\nplt.show()\n",
    "id": 5
},
{
    "title": "Broken Barh#",
    "text": "Make a \"broken\" horizontal bar plot, i.e., one with gaps Download Python source code: broken_barh.py Download Jupyter notebook: broken_barh.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n# Horizontal bar plot with gaps\nfig, ax = plt.subplots()\nax.broken_barh([(110, 30), (150, 10)], (10, 9), facecolors='tab:blue')\nax.broken_barh([(10, 50), (100, 20), (130, 10)], (20, 9),\n               facecolors=('tab:orange tab:green tab:red'))\nax.set_ylim(5, 35)\nax.set_xlim(0, 200)\nax.set_xlabel('seconds since start')\nax.set_yticks([15, 25], labels=Bill Jim)     # Modify y-axis tick labels\nax.grid(True)                                       # Make grid lines visible\nax.annotate('race interrupted', (61, 25),\n            xytext=(0.8, 0.9), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            fontsize=16,\n            horizontalalignment='right', verticalalignment='top')\n\nplt.show()\n",
    "id": 6
},
{
    "title": "CapStyle#",
    "text": "The matplotlib._enums.CapStyle controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\nCapStyle docs. Download Python source code: capstyle.py Download Jupyter notebook: capstyle.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib._enums import CapStyle\n\nCapStyle.demo()\nplt.show()\n",
    "id": 7
},
{
    "title": "Plotting categorical variables#",
    "text": "You can pass categorical values (i.e. strings) directly as x- or y-values to\nmany plotting functions: This works on both axes: Download Python source code: categorical_variables.py Download Jupyter notebook: categorical_variables.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\ndata = {'apple': 10, 'orange': 15, 'lemon': 5, 'lime': 20}\nnames = list(data.keys())\nvalues = list(data.values())\n\nfig, axs = plt.subplots(1, 3, figsize=(9, 3), sharey=True)\naxs[0].bar(names, values)\naxs[1].scatter(names, values)\naxs[2].plot(names, values)\nfig.suptitle('Categorical Plotting')\n\", 'cat = bored\", \"happy\", \"bored\", \"bored\", \"happy\", \"bored\ndog = happy\", \"happy\", \"happy\", \"happy\", \"bored\", \"bored\nactivity = combing\", \"drinking\", \"feeding\", \"napping\", \"playing\", \"washing\n\nfig, ax = plt.subplots()\nax.plot(activity, dog, label=\"dog\")\nax.plot(activity, cat, label=\"cat\")\nax.legend()\n\nplt.show()\n",
    "id": 8
},
{
    "title": "Plotting the coherence of two signals#",
    "text": "An example showing how to plot the coherence of two signals using cohere. Download Python source code: cohere.py Download Jupyter notebook: cohere.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 30, dt)\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\n\n# Two signals with a coherent part at 10 Hz and a random part\ns1 = np.sin(2 * np.pi * 10 * t) + nse1\ns2 = np.sin(2 * np.pi * 10 * t) + nse2\n\nfig, axs = plt.subplots(2, 1, layout='constrained')\naxs[0].plot(t, s1, t, s2)\naxs[0].set_xlim(0, 2)\naxs[0].set_xlabel('Time (s)')\naxs[0].set_ylabel('s1 and s2')\naxs[0].grid(True)\n\ncxy, f = axs[1].cohere(s1, s2, 256, 1. / dt)\naxs[1].set_ylabel('Coherence')\n\nplt.show()\n",
    "id": 9
},
{
    "title": "Cross spectral density (CSD)#",
    "text": "Plot the cross spectral density (CSD) of two signals using csd. Download Python source code: csd_demo.py Download Jupyter notebook: csd_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax1, ax2) = plt.subplots(2, 1, layout='constrained')\n\ndt = 0.01\nt = np.arange(0, 30, dt)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nnse1 = np.random.randn(len(t))                 # white noise 1\nnse2 = np.random.randn(len(t))                 # white noise 2\nr = np.exp(-t / 0.05)\n\ncnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1\ncnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2\n\n# two signals with a coherent part and a random part\ns1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1\ns2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2\n\nax1.plot(t, s1, t, s2)\nax1.set_xlim(0, 5)\nax1.set_xlabel('Time (s)')\nax1.set_ylabel('s1 and s2')\nax1.grid(True)\n\ncxy, f = ax2.csd(s1, s2, 256, 1. / dt)\nax2.set_ylabel('CSD (dB)')\n\nplt.show()\n",
    "id": 10
},
{
    "title": "Curve with error band#",
    "text": "This example illustrates how to draw an error band around a parametrized curve. A parametrized curve x(t), y(t) can directly be drawn using plot. An error band can be used to indicate the uncertainty of the curve.\nIn this example we assume that the error can be given as a scalar err\nthat describes the uncertainty perpendicular to the curve in every point. We visualize this error as a colored band around the path using a\nPathPatch. The patch is created from two path segments (xp, yp), and\n(xn, yn) that are shifted by +/- err perpendicular to the curve (x, y). Note: This method of using a PathPatch is suited to arbitrary curves in\n2D. If you just have a standard y-vs.-x plot, you can use the simpler\nfill_between method (see also\nFilling the area between lines). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.PathPatch matplotlib.path.Path Download Python source code: curve_error_band.py Download Jupyter notebook: curve_error_band.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nN = 400\nt = np.linspace(0, 2 * np.pi, N)\nr = 0.5 + np.cos(t)\nx, y = r * np.cos(t), r * np.sin(t)\n\nfig, ax = plt.subplots()\nax.plot(x, y, \"k\")\nax.set(aspect=1)\n def draw_error_band(ax, x, y, err, **kwargs):\n    # Calculate normals via centered finite differences (except the first point\n    # which uses a forward difference and the last point which uses a backward\n    # difference).\n    dx = np.concatenate([[x[1] - x[0]], x[2:] - x[:-2], [x[-1] - x[-2]]])\n    dy = np.concatenate([[y[1] - y[0]], y[2:] - y[:-2], [y[-1] - y[-2]]])\n    l = np.hypot(dx, dy)\n    nx = dy / l\n    ny = -dx / l\n\n    # end points of errors\n    xp = x + nx * err\n    yp = y + ny * err\n    xn = x - nx * err\n    yn = y - ny * err\n\n    vertices = np.block([[xp, xn[::-1]],\n                         [yp, yn[::-1]]]).T\n    codes = np.full(len(vertices), Path.LINETO)\n    codes[0] = codes[len(xp)] = Path.MOVETO\n    path = Path(vertices, codes)\n    ax.add_patch(PathPatch(path, **kwargs))\n\n\n_, axs = plt.subplots(1, 2, layout=\\'constrained\\', sharex=True, sharey=True)\nerrs = [\n    (axs[0], \"constant error\", 0.05),\n    (axs[1], \"variable error\", 0.05 * np.sin(2 * t) ** 2 + 0.04),\n]\nfor i, (ax, title, err) in enumerate(errs):\n    ax.set(title=title, aspect=1, xticks=[], yticks=[])\n    ax.plot(x, y, \"k\")\n    draw_error_band(ax, x, y, err=err,\n                    facecolor=f\"C{i}\", edgecolor=\"none\", alpha=.3)\n\nplt.show()\n",
    "id": 11
},
{
    "title": "Errorbar limit selection#",
    "text": "Illustration of selectively drawing lower and/or upper limit symbols on\nerrorbars using the parameters uplims, lolims of errorbar. Alternatively, you can use 2xN values to draw errorbars in only one direction. Similarly xuplims and xlolims can be used on the horizontal xerr\nerrorbars. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar Download Python source code: errorbar_limits_simple.py Download Jupyter notebook: errorbar_limits_simple.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nx = np.arange(10)\ny = 2.5 * np.sin(x / 20 * np.pi)\nyerr = np.linspace(0.05, 0.2, 10)\n\nplt.errorbar(x, y + 3, yerr=yerr, label='both limits (default)')\n\nplt.errorbar(x, y + 2, yerr=yerr, uplims=True, label='uplims=True')\n\nplt.errorbar(x, y + 1, yerr=yerr, uplims=True, lolims=True,\n             label='uplims=True, lolims=True')\n\nupperlimits = [True, False] * 5\nlowerlimits = [False, True] * 5\nplt.errorbar(x, y, yerr=yerr, uplims=upperlimits, lolims=lowerlimits,\n             label='subsets of uplims and lolims')\n\nplt.legend(loc='lower right')\n\", \"fig = plt.figure()\nx = np.arange(10) / 10\ny = (x + 0.1)**2\n\nplt.errorbar(x, y, xerr=0.1, xlolims=True, label='xlolims=True')\ny = (x + 0.1)**3\n\nplt.errorbar(x + 0.6, y, xerr=0.1, xuplims=upperlimits, xlolims=lowerlimits,\n             label='subsets of xuplims and xlolims')\n\ny = (x + 0.1)**4\nplt.errorbar(x + 1.2, y, xerr=0.1, xuplims=True, label='xuplims=True')\n\nplt.legend()\nplt.show()\n",
    "id": 12
},
{
    "title": "Errorbar subsampling#",
    "text": "The parameter errorevery of Axes.errorbar can be used to draw error bars\nonly on a subset of data points. This is particularly useful if there are many\ndata points with similar errors. Download Python source code: errorbar_subsample.py Download Jupyter notebook: errorbar_subsample.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.1)\ny1 = np.exp(-1.0 * x)\ny2 = np.exp(-0.5 * x)\n\n# example variable error bar values\ny1err = 0.1 + 0.1 * np.sqrt(x)\ny2err = 0.1 + 0.1 * np.sqrt(x/2)\n\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=1, ncols=3, sharex=True,\n                                    figsize=(12, 6))\n\nax0.set_title('all errorbars')\nax0.errorbar(x, y1, yerr=y1err)\nax0.errorbar(x, y2, yerr=y2err)\n\nax1.set_title('only every 6th errorbar')\nax1.errorbar(x, y1, yerr=y1err, errorevery=6)\nax1.errorbar(x, y2, yerr=y2err, errorevery=6)\n\nax2.set_title('second series shifted by 3')\nax2.errorbar(x, y1, yerr=y1err, errorevery=(0, 6))\nax2.errorbar(x, y2, yerr=y2err, errorevery=(3, 6))\n\nfig.suptitle('Errorbar subsampling')\nplt.show()\n",
    "id": 13
},
{
    "title": "EventCollection Demo#",
    "text": "Plot two curves, then use EventCollections to mark the locations of the x\nand y data points on the respective axes for each curve. Download Python source code: eventcollection_demo.py Download Jupyter notebook: eventcollection_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EventCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# create random data\nxdata = np.random.random([2, 10])\n\n# split the data into two parts\nxdata1 = xdata[0, :]\nxdata2 = xdata[1, :]\n\n# sort the data so it makes clean curves\nxdata1.sort()\nxdata2.sort()\n\n# create some y data points\nydata1 = xdata1 ** 2\nydata2 = 1 - xdata2 ** 3\n\n# plot the data\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.plot(xdata1, ydata1, color='tab:blue')\nax.plot(xdata2, ydata2, color='tab:orange')\n\n# create the events marking the x data points\nxevents1 = EventCollection(xdata1, color='tab:blue', linelength=0.05)\nxevents2 = EventCollection(xdata2, color='tab:orange', linelength=0.05)\n\n# create the events marking the y data points\nyevents1 = EventCollection(ydata1, color='tab:blue', linelength=0.05,\n                           orientation='vertical')\nyevents2 = EventCollection(ydata2, color='tab:orange', linelength=0.05,\n                           orientation='vertical')\n\n# add the events to the axis\nax.add_collection(xevents1)\nax.add_collection(xevents2)\nax.add_collection(yevents1)\nax.add_collection(yevents2)\n\n# set the limits\nax.set_xlim([0, 1])\nax.set_ylim([0, 1])\n\nax.set_title('line plot with data points')\n\n# display the plot\nplt.show()\n",
    "id": 14
},
{
    "title": "Eventplot demo#",
    "text": "An eventplot showing sequences of events with various line\nproperties. The plot is shown in both horizontal and vertical orientations. Download Python source code: eventplot_demo.py Download Jupyter notebook: eventplot_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\n\nmatplotlib.rcParamsfont.size = 8.0\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# create random data\ndata1 = np.random.random([6, 50])\n\n# set different colors for each set of positions\ncolors1 = [f'C{i}' for i in range(6)]\n\n# set different line properties for each set of positions\n# note that some overlap\nlineoffsets1 = [-15, -3, 1, 1.5, 6, 10]\nlinelengths1 = [5, 2, 1, 1, 3, 1.5]\n\nfig, axs = plt.subplots(2, 2)\n\n# create a horizontal plot\naxs[0, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1)\n\n# create a vertical plot\naxs[1, 0].eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,\n                    linelengths=linelengths1, orientation='vertical')\n\n# create another set of random data.\n# the gamma distribution is only used for aesthetic purposes\ndata2 = np.random.gamma(4, size=[60, 50])\n\n# use individual values for the parameters this time\n# these values will be used for all data sets (except lineoffsets2, which\n# sets the increment between each data set in this usage)\ncolors2 = 'black'\nlineoffsets2 = 1\nlinelengths2 = 1\n\n# create a horizontal plot\naxs[0, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2)\n\n\n# create a vertical plot\naxs[1, 1].eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,\n                    linelengths=linelengths2, orientation='vertical')\n\nplt.show()\n",
    "id": 15
},
{
    "title": "Filled polygon#",
    "text": "fill() draws a filled polygon based on lists of point\ncoordinates x, y. This example uses the Koch snowflake as an example polygon. Basic usage: Use keyword arguments facecolor and edgecolor to modify the colors\nof the polygon. Since the linewidth of the edge is 0 in the default\nMatplotlib style, we have to set it as well for the edge to become visible. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.fill / matplotlib.pyplot.fill matplotlib.axes.Axes.axis / matplotlib.pyplot.axis Download Python source code: fill.py Download Jupyter notebook: fill.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef koch_snowflake(order, scale=10):\n    \"\"\"\n    Return two lists x, y of point coordinates of the Koch snowflake.\n\n    Parameters\n    ----------\n    order : int\n        The recursion depth.\n    scale : float\n        The extent of the snowflake (edge length of the base triangle).\n    \"\"\"\n    def _koch_snowflake_complex(order):\n        if order == 0:\n            # initial triangle\n            angles = np.array([0, 120, 240]) + 90\n            return scale / np.sqrt(3) * np.exp(np.deg2rad(angles) * 1j)\n        else:\n            ZR = 0.5 - 0.5j * np.sqrt(3) / 3\n\n            p1 = _koch_snowflake_complex(order - 1)  # start points\n            p2 = np.roll(p1, shift=-1)  # end points\n            dp = p2 - p1  # connection vectors\n\n            new_points = np.empty(len(p1) * 4, dtype=np.complex128)\n            new_points[::4] = p1\n            new_points[1::4] = p1 + dp / 3\n            new_points[2::4] = p1 + dp * ZR\n            new_points[3::4] = p1 + dp / 3 * 2\n            return new_points\n\n    points = _koch_snowflake_complex(order)\n    x, y = points.real, points.imag\n    return x, y\n', \"x, y = koch_snowflake(order=5)\n\nplt.figure(figsize=(8, 8))\nplt.axis('equal')\nplt.fill(x, y)\nplt.show()\n\", \"x, y = koch_snowflake(order=2)\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(9, 3),\n                                    subplot_kw={'aspect': 'equal'})\nax1.fill(x, y)\nax2.fill(x, y, facecolor='lightsalmon', edgecolor='orangered', linewidth=3)\nax3.fill(x, y, facecolor='none', edgecolor='purple', linewidth=3)\n\nplt.show()\n",
    "id": 16
},
{
    "title": "Fill Between and Alpha#",
    "text": "The fill_between function generates a shaded\nregion between a min and max boundary that is useful for illustrating ranges.\nIt has a very handy where argument to combine filling with logical ranges,\ne.g., to just fill in a curve over some threshold value.', \"At its most basic level, fill_between can be used to enhance a graph's\nvisual appearance. Let's compare two graphs of financial data with a simple\nline plot on the left and a filled line on the right.\", \"The alpha channel is not necessary here, but it can be used to soften\ncolors for more visually appealing plots. In other examples, as we'll\nsee below, the alpha channel is functionally useful as the shaded\nregions can overlap and alpha allows you to see both. Note that the\npostscript format does not support alpha (this is a postscript\nlimitation, not a matplotlib limitation), so when using alpha save\nyour figures in PNG, PDF or SVG.\", 'Our next example computes two populations of random walkers with a\ndifferent mean and standard deviation of the normal distributions from\nwhich the steps are drawn. We use filled regions to plot +/- one\nstandard deviation of the mean position of the population. Here the\nalpha channel is useful, not just aesthetic. The where keyword argument is very handy for highlighting certain\nregions of the graph. where takes a boolean mask the same length\nas the x, ymin and ymax arguments, and only fills in the region where\nthe boolean mask is True. In the example below, we simulate a single\nrandom walker and compute the analytic mean and standard deviation of\nthe population positions. The population mean is shown as the dashed\nline, and the plus/minus one sigma deviation from the mean is shown\nas the filled region. We use the where mask X > upper_bound to\nfind the region where the walker is outside the one sigma boundary,\nand shade that region red. Another handy use of filled regions is to highlight horizontal or vertical\nspans of an Axes -- for that Matplotlib has the helper functions\naxhspan and axvspan. See\naxhspan Demo. Total running time of the script: (0 minutes 1.064 seconds) Download Python source code: fill_between_alpha.py Download Jupyter notebook: fill_between_alpha.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# load up some sample financial data\nr = cbook.get_sample_data(\\'goog.npz\\')[\\'price_data\\\n# create two subplots with the shared x and y axes\nfig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)\n\npricemin = rclose.min()\n\nax1.plot(rdate, rclose, lw=2)\nax2.fill_between(rdate, pricemin, rclose, alpha=0.7)\n\nfor ax in ax1, ax2:\n    ax.grid(True)\n    ax.label_outer()\n\nax1.set_ylabel(\\'price\\')\n\nfig.suptitle(\\'Google (GOOG) daily closing price\\')\nfig.autofmt_xdate()\n', \"# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nNsteps, Nwalkers = 100, 250\nt = np.arange(Nsteps)\n\n# an (Nsteps x Nwalkers) array of random walk steps\nS1 = 0.004 + 0.02*np.random.randn(Nsteps, Nwalkers)\nS2 = 0.002 + 0.01*np.random.randn(Nsteps, Nwalkers)\n\n# an (Nsteps x Nwalkers) array of random walker positions\nX1 = S1.cumsum(axis=0)\nX2 = S2.cumsum(axis=0)\n\n\n# Nsteps length arrays empirical means and standard deviations of both\n# populations over time\nmu1 = X1.mean(axis=1)\nsigma1 = X1.std(axis=1)\nmu2 = X2.mean(axis=1)\nsigma2 = X2.std(axis=1)\n\n# plot it!\nfig, ax = plt.subplots(1)\nax.plot(t, mu1, lw=2, label='mean population 1')\nax.plot(t, mu2, lw=2, label='mean population 2')\nax.fill_between(t, mu1+sigma1, mu1-sigma1, facecolor='C0', alpha=0.4)\nax.fill_between(t, mu2+sigma2, mu2-sigma2, facecolor='C1', alpha=0.4)\nax.set_title(r'random walkers empirical $\\\\mu$ and $\\\\pm \\\\sigma$ interval')\nax.legend(loc='upper left')\nax.set_xlabel('num steps')\nax.set_ylabel('position')\nax.grid()\n\", \"# Fixing random state for reproducibility\nnp.random.seed(1)\n\nNsteps = 500\nt = np.arange(Nsteps)\n\nmu = 0.002\nsigma = 0.01\n\n# the steps and position\nS = mu + sigma*np.random.randn(Nsteps)\nX = S.cumsum()\n\n# the 1 sigma upper and lower analytic population bounds\nlower_bound = mu*t - sigma*np.sqrt(t)\nupper_bound = mu*t + sigma*np.sqrt(t)\n\nfig, ax = plt.subplots(1)\nax.plot(t, X, lw=2, label='walker position')\nax.plot(t, mu*t, lw=1, label='population mean', color='C0', ls='--')\nax.fill_between(t, lower_bound, upper_bound, facecolor='C0', alpha=0.4,\n                label='1 sigma range')\nax.legend(loc='upper left')\n\n# here we use the where argument to only fill the region where the\n# walker is above the population 1 sigma boundary\nax.fill_between(t, upper_bound, X, where=X > upper_bound, fc='red', alpha=0.4)\nax.fill_between(t, lower_bound, X, where=X < lower_bound, fc='red', alpha=0.4)\nax.set_xlabel('num steps')\nax.set_ylabel('position')\nax.grid()\n\", 'plt.show()\n",
    "id": 17
},
{
    "title": "Filling the area between lines#",
    "text": "This example shows how to use fill_between to color the area\nbetween two lines. The parameters y1 and y2 can be scalars, indicating a horizontal\nboundary at the given y-values. If only y1 is given, y2 defaults to 0. A common application for fill_between is the indication of\nconfidence bands. fill_between uses the colors of the color cycle as the fill\ncolor. These may be a bit strong when applied to fill areas. It is\ntherefore often a good practice to lighten the color by making the area\nsemi-transparent using alpha.', \"The parameter where allows to specify the x-ranges to fill. It's a boolean\narray with the same size as x.\", 'Only x-ranges of contiguous True sequences are filled. As a result the\nrange between neighboring True and False values is never filled. This\noften undesired when the data points should represent a contiguous quantity.\nIt is therefore recommended to set interpolate=True unless the\nx-distance of the data points is fine enough so that the above effect is not\nnoticeable. Interpolation approximates the actual x position at which the\nwhere condition will change and extends the filling up to there. Note Similar gaps will occur if y1 or y2 are masked arrays. Since missing\nvalues cannot be approximated, interpolate has no effect in this case.\nThe gaps around masked values can only be reduced by adding more data\npoints close to the masked values. The same selection mechanism can be applied to fill the full vertical height\nof the axes. To be independent of y-limits, we add a transform that\ninterprets the x-values in data coordinates and the y-values in axes\ncoordinates. The following example marks the regions in which the y-data are above a\ngiven threshold. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.fill_between / matplotlib.pyplot.fill_between matplotlib.axes.Axes.get_xaxis_transform Total running time of the script: (0 minutes 1.586 seconds) Download Python source code: fill_between_demo.py Download Jupyter notebook: fill_between_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n', \"x = np.arange(0.0, 2, 0.01)\ny1 = np.sin(2 * np.pi * x)\ny2 = 0.8 * np.sin(4 * np.pi * x)\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True, figsize=(6, 6))\n\nax1.fill_between(x, y1)\nax1.set_title('fill between y1 and 0')\n\nax2.fill_between(x, y1, 1)\nax2.set_title('fill between y1 and 1')\n\nax3.fill_between(x, y1, y2)\nax3.set_title('fill between y1 and y2')\nax3.set_xlabel('x')\nfig.tight_layout()\n\", \"N = 21\nx = np.linspace(0, 10, 11)\ny = [3.9, 4.4, 10.8, 10.3, 11.2, 13.1, 14.1,  9.9, 13.9, 15.1, 12.5]\n\n# fit a linear curve and estimate its y-values and their error.\na, b = np.polyfit(x, y, deg=1)\ny_est = a * x + b\ny_err = x.std() * np.sqrt(1/len(x) +\n                          (x - x.mean())**2 / np.sum((x - x.mean())**2))\n\nfig, ax = plt.subplots()\nax.plot(x, y_est, '-')\nax.fill_between(x, y_est - y_err, y_est + y_err, alpha=0.2)\nax.plot(x, y, 'o', color='tab:brown')\n\", \"x = np.array([0, 1, 2, 3])\ny1 = np.array([0.8, 0.8, 0.2, 0.2])\ny2 = np.array([0, 0, 1, 1])\n\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n\nax1.set_title('interpolation=False')\nax1.plot(x, y1, 'o--')\nax1.plot(x, y2, 'o--')\nax1.fill_between(x, y1, y2, where=(y1 > y2), color='C0', alpha=0.3)\nax1.fill_between(x, y1, y2, where=(y1 < y2), color='C1', alpha=0.3)\n\nax2.set_title('interpolation=True')\nax2.plot(x, y1, 'o--')\nax2.plot(x, y2, 'o--')\nax2.fill_between(x, y1, y2, where=(y1 > y2), color='C0', alpha=0.3,\n                 interpolate=True)\nax2.fill_between(x, y1, y2, where=(y1 <= y2), color='C1', alpha=0.3,\n                 interpolate=True)\nfig.tight_layout()\n\", \"fig, ax = plt.subplots()\nx = np.arange(0, 4 * np.pi, 0.01)\ny = np.sin(x)\nax.plot(x, y, color='black')\n\nthreshold = 0.75\nax.axhline(threshold, color='green', lw=2, alpha=0.7)\nax.fill_between(x, 0, 1, where=y > threshold,\n                color='green', alpha=0.5, transform=ax.get_xaxis_transform())\n",
    "id": 18
},
{
    "title": "Fill Betweenx Demo#",
    "text": "Using fill_betweenx to color along the horizontal direction between\ntwo curves. Now fill between x1 and x2 where a logical condition is met. Note this is\ndifferent than calling: because of edge effects over multiple contiguous regions. This example illustrates a problem; because of the data gridding, there are\nundesired unfilled triangles at the crossover points. A brute-force solution\nwould be to interpolate all arrays to a very fine grid before plotting. Download Python source code: fill_betweenx_demo.py Download Jupyter notebook: fill_betweenx_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ny = np.arange(0.0, 2, 0.01)\nx1 = np.sin(2 * np.pi * y)\nx2 = 1.2 * np.sin(4 * np.pi * y)\n\nfig, [ax1, ax2, ax3] = plt.subplots(1, 3, sharey=True, figsize=(6, 6))\n\nax1.fill_betweenx(y, 0, x1)\nax1.set_title('between (x1, 0)')\n\nax2.fill_betweenx(y, x1, 1)\nax2.set_title('between (x1, 1)')\nax2.set_xlabel('x')\n\nax3.fill_betweenx(y, x1, x2)\nax3.set_title('between (x1, x2)')\n\", 'fill_between(y[where], x1[where], x2[where])\n', \"fig, [ax, ax1] = plt.subplots(1, 2, sharey=True, figsize=(6, 6))\nax.plot(x1, y, x2, y, color='black')\nax.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')\nax.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')\nax.set_title('fill_betweenx where')\n\n# Test support for masked arrays.\nx2 = np.ma.masked_greater(x2, 1.0)\nax1.plot(x1, y, x2, y, color='black')\nax1.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')\nax1.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')\nax1.set_title('regions with x2 > 1 are masked')\n\", 'plt.show()\n",
    "id": 19
},
{
    "title": "Hatch-filled histograms#",
    "text": "Hatching capabilities for plotting histograms. Work with plain arrays Work with labeled data References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.fill_betweenx / matplotlib.pyplot.fill_betweenx matplotlib.axes.Axes.fill_between / matplotlib.pyplot.fill_between matplotlib.axis.Axis.set_major_locator Total running time of the script: (0 minutes 1.098 seconds) Download Python source code: filled_step.py Download Jupyter notebook: filled_step.ipynb ",
    "code": "from functools import partial\nimport itertools\n\nfrom cycler import cycler\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as mticker\n\n\ndef filled_hist(ax, edges, values, bottoms=None, orientation=\\'v\\',\n                **kwargs):\n    \"\"\"\n    Draw a histogram as a stepped patch.\n\n    Parameters\n    ----------\n    ax : Axes\n        The axes to plot to\n\n    edges : array\n        A length n+1 array giving the left edges of each bin and the\n        right edge of the last bin.\n\n    values : array\n        A length n array of bin counts or values\n\n    bottoms : float or array, optional\n        A length n array of the bottom of the bars.  If None, zero is used.\n\n    orientation : {\\'v\\', \\'h\\'}\n       Orientation of the histogram.  \\'v\\' (default) has\n       the bars increasing in the positive y-direction.\n\n    **kwargs\n        Extra keyword arguments are passed through to `.fill_between`.\n\n    Returns\n    -------\n    ret : PolyCollection\n        Artist added to the Axes\n    \"\"\"\n    print(orientation)\n    if orientation not in \\'hv\\':\n        raise ValueError(f\"orientation must be in {{\\'h\\', \\'v\\'}} \"\n                         f\"not {orientation}\")\n\n    kwargs.setdefault(\\'step\\', \\'post\\')\n    kwargs.setdefault(\\'alpha\\', 0.7)\n    edges = np.asarray(edges)\n    values = np.asarray(values)\n    if len(edges) - 1 != len(values):\n        raise ValueError(f\\'Must provide one more bin edge than value not: \\'\n                         f\\'{len(edges)=} {len(values)=}\\')\n\n    if bottoms is None:\n        bottoms = 0\n    bottoms = np.broadcast_to(bottoms, values.shape)\n\n    values = np.append(values, values[-1])\n    bottoms = np.append(bottoms, bottoms[-1])\n    if orientation == \\'h\\':\n        return ax.fill_betweenx(edges, values, bottoms,\n                                **kwargs)\n    elif orientation == \\'v\\':\n        return ax.fill_between(edges, values, bottoms,\n                               **kwargs)\n    else:\n        raise AssertionError(\"you should never be here\")\n\n\ndef stack_hist(ax, stacked_data, sty_cycle, bottoms=None,\n               hist_func=None, labels=None,\n               plot_func=None, plot_kwargs=None):\n    \"\"\"\n    Parameters\n    ----------\n    ax : axes.Axes\n        The axes to add artists too\n\n    stacked_data : array or Mapping\n        A (M, N) shaped array.  The first dimension will be iterated over to\n        compute histograms row-wise\n\n    sty_cycle : Cycler or operable of dict\n        Style to apply to each set\n\n    bottoms : array, default: 0\n        The initial positions of the bottoms.\n\n    hist_func : callable, optional\n        Must have signature `bin_vals, bin_edges = f(data)`.\n        `bin_edges` expected to be one longer than `bin_vals`\n\n    labels : list of str, optional\n        The label for each set.\n\n        If not given and stacked data is an array defaults to \\'default set {n}\\'\n\n        If *stacked_data* is a mapping, and *labels* is None, default to the\n        keys.\n\n        If *stacked_data* is a mapping and *labels* is given then only the\n        columns listed will be plotted.\n\n    plot_func : callable, optional\n        Function to call to draw the histogram must have signature:\n\n          ret = plot_func(ax, edges, top, bottoms=bottoms,\n                          label=label, **kwargs)\n\n    plot_kwargs : dict, optional\n        Any extra keyword arguments to pass through to the plotting function.\n        This will be the same for all calls to the plotting function and will\n        override the values in *sty_cycle*.\n\n    Returns\n    -------\n    arts : dict\n        Dictionary of artists keyed on their labels\n    \"\"\"\n    # deal with default binning function\n    if hist_func is None:\n        hist_func = np.histogram\n\n    # deal with default plotting function\n    if plot_func is None:\n        plot_func = filled_hist\n\n    # deal with default\n    if plot_kwargs is None:\n        plot_kwargs = {}\n    print(plot_kwargs)\n    try:\n        l_keys = stacked_data.keys()\n        label_data = True\n        if labels is None:\n            labels = l_keys\n\n    except AttributeError:\n        label_data = False\n        if labels is None:\n            labels = itertools.repeat(None)\n\n    if label_data:\n        loop_iter = enumerate((stacked_data[lab], lab, s)\n                              for lab, s in zip(labels, sty_cycle))\n    else:\n        loop_iter = enumerate(zip(stacked_data, labels, sty_cycle))\n\n    arts = {}\n    for j, (data, label, sty) in loop_iter:\n        if label is None:\n            label = f\\'dflt set {j}\\'\n        label = sty.pop(\\'label\\', label)\n        vals, edges = hist_func(data)\n        if bottoms is None:\n            bottoms = np.zeros_like(vals)\n        top = bottoms + vals\n        print(sty)\n        sty.update(plot_kwargs)\n        print(sty)\n        ret = plot_func(ax, edges, top, bottoms=bottoms,\n                        label=label, **sty)\n        bottoms = top\n        arts[label] = ret\n    ax.legend(fontsize=10)\n    return arts\n\n\n# set up histogram function to fixed bins\nedges = np.linspace(-3, 3, 20, endpoint=True)\nhist_func = partial(np.histogram, bins=edges)\n\n# set up style cycles\ncolor_cycle = cycler(facecolor=plt.rcParams[\\'axes.prop_cycle\\[:4])\nlabel_cycle = cycler(label=[f\\'set {n}\\' for n in range(4)])\nhatch_cycle = cycler(hatch=[\\'/\\', \\'*\\', \\'+\\', \\'|\\)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nstack_data = np.random.randn(4, 12250)\ndict_data = dict(zip((c[\\'label\\ for c in label_cycle), stack_data))\n', \"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4.5), tight_layout=True)\narts = stack_hist(ax1, stack_data, color_cycle + label_cycle + hatch_cycle,\n                  hist_func=hist_func)\n\narts = stack_hist(ax2, stack_data, color_cycle,\n                  hist_func=hist_func,\n                  plot_kwargs=dict(edgecolor='w', orientation='h'))\nax1.set_ylabel('counts')\nax1.set_xlabel('x')\nax2.set_xlabel('counts')\nax2.set_ylabel('x')\n\", \"{}\n{'facecolor': '#1f77b4 hatch': '/'}\n{'facecolor': '#1f77b4 hatch': '/'}\nv\n{'facecolor': '#ff7f0e hatch': '*'}\n{'facecolor': '#ff7f0e hatch': '*'}\nv\n{'facecolor': '#2ca02c hatch': '+'}\n{'facecolor': '#2ca02c hatch': '+'}\nv\n{'facecolor': '#d62728 hatch': '|'}\n{'facecolor': '#d62728 hatch': '|'}\nv\n{'edgecolor': 'w orientation': 'h'}\n{'facecolor': '#1f77b4'}\n{'facecolor': '#1f77b4 edgecolor': 'w orientation': 'h'}\nh\n{'facecolor': '#ff7f0e'}\n{'facecolor': '#ff7f0e edgecolor': 'w orientation': 'h'}\nh\n{'facecolor': '#2ca02c'}\n{'facecolor': '#2ca02c edgecolor': 'w orientation': 'h'}\nh\n{'facecolor': '#d62728'}\n{'facecolor': '#d62728 edgecolor': 'w orientation': 'h'}\nh\n\", \"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 4.5),\n                               tight_layout=True, sharey=True)\n\narts = stack_hist(ax1, dict_data, color_cycle + hatch_cycle,\n                  hist_func=hist_func)\n\narts = stack_hist(ax2, dict_data, color_cycle + hatch_cycle,\n                  hist_func=hist_func, labels=set 0 set 3)\nax1.xaxis.set_major_locator(mticker.MaxNLocator(5))\nax1.set_xlabel('counts')\nax1.set_ylabel('x')\nax2.set_ylabel('x')\n\nplt.show()\n\", \"{}\n{'facecolor': '#1f77b4 hatch': '/'}\n{'facecolor': '#1f77b4 hatch': '/'}\nv\n{'facecolor': '#ff7f0e hatch': '*'}\n{'facecolor': '#ff7f0e hatch': '*'}\nv\n{'facecolor': '#2ca02c hatch': '+'}\n{'facecolor': '#2ca02c hatch': '+'}\nv\n{'facecolor': '#d62728 hatch': '|'}\n{'facecolor': '#d62728 hatch': '|'}\nv\n{}\n{'facecolor': '#1f77b4 hatch': '/'}\n{'facecolor': '#1f77b4 hatch': '/'}\nv\n{'facecolor': '#ff7f0e hatch': '*'}\n{'facecolor': '#ff7f0e hatch': '*'}\nv\n",
    "id": 20
},
{
    "title": "Bar chart with gradients#",
    "text": "Matplotlib does not natively support gradients. However, we can emulate a\ngradient-filled rectangle by an AxesImage of the right size and coloring. In particular, we use a colormap to generate the actual colors. It is then\nsufficient to define the underlying values on the corners of the image and\nlet bicubic interpolation fill out the area. We define the gradient direction\nby a unit vector v. The values at the corners are then obtained by the\nlengths of the projections of the corner vectors on v. A similar approach can be used to create a gradient background for an Axes.\nIn that case, it is helpful to use Axes coordinates (extent=(0, 1, 0, 1),\ntransform=ax.transAxes) to be independent of the data coordinates. Download Python source code: gradient_bar.py Download Jupyter notebook: gradient_bar.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\ndef gradient_image(ax, direction=0.3, cmap_range=(0, 1), **kwargs):\n    \"\"\"\n    Draw a gradient image based on a colormap.\n\n    Parameters\n    ----------\n    ax : Axes\n        The axes to draw on.\n    direction : float\n        The direction of the gradient. This is a number in\n        range 0 (=vertical) to 1 (=horizontal).\n    cmap_range : float, float\n        The fraction (cmin, cmax) of the colormap that should be\n        used for the gradient, where the complete colormap is (0, 1).\n    **kwargs\n        Other parameters are passed on to `.Axes.imshow()`.\n        In particular, *cmap*, *extent*, and *transform* may be useful.\n    \"\"\"\n    phi = direction * np.pi / 2\n    v = np.array([np.cos(phi), np.sin(phi)])\n    X = np.array([[v @ [1, 0], v @ [1, 1]],\n                  [v @ [0, 0], v @ [0, 1]]])\n    a, b = cmap_range\n    X = a + (b - a) / X.max() * X\n    im = ax.imshow(X, interpolation=\\'bicubic\\', clim=(0, 1),\n                   aspect=\\'auto\\', **kwargs)\n    return im\n\n\ndef gradient_bar(ax, x, y, width=0.5, bottom=0):\n    for left, top in zip(x, y):\n        right = left + width\n        gradient_image(ax, extent=(left, right, bottom, top),\n                       cmap=plt.cm.Blues_r, cmap_range=(0, 0.8))\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 1))\n\n# background image\ngradient_image(ax, direction=1, extent=(0, 1, 0, 1), transform=ax.transAxes,\n               cmap=plt.cm.RdYlGn, cmap_range=(0.2, 0.8), alpha=0.5)\n\nN = 10\nx = np.arange(N) + 0.15\ny = np.random.rand(N)\ngradient_bar(ax, x, y, width=0.7)\nplt.show()\n",
    "id": 21
},
{
    "title": "Hat graph#",
    "text": "This example shows how to create a hat graph and how to annotate it with\nlabels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate Download Python source code: hat_graph.py Download Jupyter notebook: hat_graph.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hat_graph(ax, xlabels, values, group_labels):\n    \"\"\"\n    Create a hat graph.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        The Axes to plot into.\n    xlabels : list of str\n        The category names to be displayed on the x-axis.\n    values : (M, N) array-like\n        The data values.\n        Rows are the groups (len(group_labels) == M).\n        Columns are the categories (len(xlabels) == N).\n    group_labels : list of str\n        The group labels displayed in the legend.\n    \"\"\"\n\n    def label_bars(heights, rects):\n        \"\"\"Attach a text label on top of each bar.\"\"\"\n        for height, rect in zip(heights, rects):\n            ax.annotate(f\\'{height}\\',\n                        xy=(rect.get_x() + rect.get_width() / 2, height),\n                        xytext=(0, 4),  # 4 points vertical offset.\n                        textcoords=\\'offset points\\',\n                        ha=\\'center\\', va=\\'bottom\\')\n\n    values = np.asarray(values)\n    x = np.arange(values.shape[1])\n    ax.set_xticks(x, labels=xlabels)\n    spacing = 0.3  # spacing between hat groups\n    width = (1 - spacing) / values.shape[0]\n    heights0 = values[0]\n    for i, (heights, group_label) in enumerate(zip(values, group_labels)):\n        style = {\\'fill\\': False} if i == 0 else {\\'edgecolor\\': \\'black\\'}\n        rects = ax.bar(x - spacing/2 + i * width, heights - heights0,\n                       width, bottom=heights0, label=group_label, **style)\n        label_bars(heights, rects)\n\n\n# initialise labels and a numpy array make sure you have\n# N labels of N number of values in the array\nxlabels = ['I', 'II', 'III', 'IV', 'V']\nplayerA = np.array([5, 15, 22, 20, 25])\nplayerB = np.array([25, 32, 34, 30, 27])\n\nfig, ax = plt.subplots()\nhat_graph(ax, xlabels, [playerA, playerB], [\\'Player A\\', \\'Player B\\)\n\n# Add some text for labels, title and custom x-axis tick labels, etc.\nax.set_xlabel(\\'Games\\')\nax.set_ylabel(\\'Score\\')\nax.set_ylim(0, 60)\nax.set_title(\\'Scores by number of game and players\\')\nax.legend()\n\nfig.tight_layout()\nplt.show()\n",
    "id": 22
},
{
    "title": "Discrete distribution as horizontal bar chart#",
    "text": "Stacked bar charts can be used to visualize discrete distributions. This example visualizes the result of a survey in which people could rate\ntheir agreement to questions on a five-element scale. The horizontal stacking is achieved by calling barh() for each\ncategory and passing the starting point as the cumulative sum of the\nalready drawn bars via the parameter left. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.barh / matplotlib.pyplot.barh matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label matplotlib.axes.Axes.legend / matplotlib.pyplot.legend Download Python source code: horizontal_barchart_distribution.py Download Jupyter notebook: horizontal_barchart_distribution.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ncategory_names = [\\'Strongly disagree\\', \\'Disagree\\',\n                  \\'Neither agree nor disagree\\', \\'Agree\\', \\'Strongly agree\\\nresults = {\n    \\'Question 1\\': [10, 15, 17, 32, 26],\n    \\'Question 2\\': [26, 22, 29, 10, 13],\n    \\'Question 3\\': [35, 37, 7, 2, 19],\n    \\'Question 4\\': [32, 11, 9, 15, 33],\n    \\'Question 5\\': [21, 29, 5, 5, 40],\n    \\'Question 6\\': [8, 19, 5, 30, 38]\n}\n\n\ndef survey(results, category_names):\n    \"\"\"\n    Parameters\n    ----------\n    results : dict\n        A mapping from question labels to a list of answers per category.\n        It is assumed all lists contain the same number of entries and that\n        it matches the length of *category_names*.\n    category_names : list of str\n        The category labels.\n    \"\"\"\n    labels = list(results.keys())\n    data = np.array(list(results.values()))\n    data_cum = data.cumsum(axis=1)\n    category_colors = plt.colormaps[\\'RdYlGn\\(\n        np.linspace(0.15, 0.85, data.shape[1]))\n\n    fig, ax = plt.subplots(figsize=(9.2, 5))\n    ax.invert_yaxis()\n    ax.xaxis.set_visible(False)\n    ax.set_xlim(0, np.sum(data, axis=1).max())\n\n    for i, (colname, color) in enumerate(zip(category_names, category_colors)):\n        widths = data[:, i]\n        starts = data_cum[:, i] - widths\n        rects = ax.barh(labels, widths, left=starts, height=0.5,\n                        label=colname, color=color)\n\n        r, g, b, _ = color\n        text_color = \\'white\\' if r * g * b < 0.5 else \\'darkgrey\\'\n        ax.bar_label(rects, label_type=\\'center\\', color=text_color)\n    ax.legend(ncols=len(category_names), bbox_to_anchor=(0, 1),\n              loc=\\'lower left\\', fontsize=\\'small\\')\n\n    return fig, ax\n\n\nsurvey(results, category_names)\nplt.show()\n",
    "id": 23
},
{
    "title": "JoinStyle#",
    "text": "The matplotlib._enums.JoinStyle controls how Matplotlib draws the corners\nwhere two different line segments meet. For more details, see the\nJoinStyle docs. Download Python source code: joinstyle.py Download Jupyter notebook: joinstyle.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib._enums import JoinStyle\n\nJoinStyle.demo()\nplt.show()\n",
    "id": 24
},
{
    "title": "Customizing dashed line styles#",
    "text": "The dashing of a line is controlled via a dash sequence. It can be modified\nusing Line2D.set_dashes. The dash sequence is a series of on/off lengths in points, e.g.\n[3, 1] would be 3pt long lines separated by 1pt spaces. Some functions like Axes.plot support passing Line properties as keyword\narguments. In such a case, you can already set the dashing when creating the\nline. Note: The dash style can also be configured via a\nproperty_cycle\nby passing a list of dash sequences using the keyword dashes to the\ncycler. This is not shown within this example. Other attributes of the dash may also be set either with the relevant method\n(set_dash_capstyle, set_dash_joinstyle,\nset_gapcolor) or by passing the property through a plotting\nfunction. Download Python source code: line_demo_dash_control.py Download Jupyter notebook: line_demo_dash_control.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 500)\ny = np.sin(x)\n\nplt.rc('lines', linewidth=2.5)\nfig, ax = plt.subplots()\n\n# Using set_dashes() and set_capstyle() to modify dashing of an existing line.\nline1, = ax.plot(x, y, label='Using set_dashes() and set_dash_capstyle()')\nline1.set_dashes([2, 2, 10, 2])  # 2pt line, 2pt break, 10pt line, 2pt break.\nline1.set_dash_capstyle('round')\n\n# Using plot(..., dashes=...) to set the dashing when creating a line.\nline2, = ax.plot(x, y - 0.2, dashes=[6, 2], label='Using the dashes parameter')\n\n# Using plot(..., dashes=..., gapcolor=...) to set the dashing and\n# alternating color when creating a line.\nline3, = ax.plot(x, y - 0.4, dashes=[4, 4], gapcolor='tab:pink',\n                 label='Using the dashes and gapcolor parameters')\n\nax.legend(handlelength=4)\nplt.show()\n",
    "id": 25
},
{
    "title": "Lines with a ticked patheffect#",
    "text": "Ticks can be added along a line to mark one side as a barrier using\nTickedStroke. You can control the angle,\nspacing, and length of the ticks. The ticks will also appear appropriately in the legend. Download Python source code: lines_with_ticks_demo.py Download Jupyter notebook: lines_with_ticks_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\n# Plot a straight diagonal line with ticked style path\nfig, ax = plt.subplots(figsize=(6, 6))\nax.plot([0, 1], [0, 1], label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\n# Plot a curved line with ticked style path\nnx = 101\nx = np.linspace(0.0, 1.0, nx)\ny = 0.3*np.sin(x*8) + 0.4\nax.plot(x, y, label=\"Curve\", path_effects=[patheffects.withTickedStroke()])\n\nax.legend()\n\nplt.show()\n",
    "id": 26
},
{
    "title": "Linestyles#",
    "text": "Simple linestyles can be defined using the strings \"solid\", \"dotted\", \"dashed\"\nor \"dashdot\". More refined control can be achieved by providing a dash tuple\n(offset, (on_off_seq)). For example, (0, (3, 10, 1, 15)) means\n(3pt line, 10pt space, 1pt line, 15pt space) with no offset, while\n(5, (10, 3)), means (10pt line, 3pt space), but skip the first 5pt line.\nSee also Line2D.set_linestyle. Note: The dash style can also be configured via Line2D.set_dashes\nas shown in Customizing dashed line styles\nand passing a list of dash sequences using the keyword dashes to the\ncycler in property_cycle. Download Python source code: linestyles.py Download Jupyter notebook: linestyles.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nlinestyle_str = [\n     (\\'solid\\', \\'solid\\'),      # Same as (0, ()) or \\'-\\'\n     (\\'dotted\\', \\'dotted\\'),    # Same as (0, (1, 1)) or \\':\\'\n     (\\'dashed\\', \\'dashed\\'),    # Same as \\'--\\'\n     (\\'dashdot\\', \\'dashdot\\')]  # Same as \\'-.\\'\n\nlinestyle_tuple = [\n     (\\'loosely dotted\\',        (0, (1, 10))),\n     (\\'dotted\\',                (0, (1, 1))),\n     (\\'densely dotted\\',        (0, (1, 1))),\n     (\\'long dash with offset\\', (5, (10, 3))),\n     (\\'loosely dashed\\',        (0, (5, 10))),\n     (\\'dashed\\',                (0, (5, 5))),\n     (\\'densely dashed\\',        (0, (5, 1))),\n\n     (\\'loosely dashdotted\\',    (0, (3, 10, 1, 10))),\n     (\\'dashdotted\\',            (0, (3, 5, 1, 5))),\n     (\\'densely dashdotted\\',    (0, (3, 1, 1, 1))),\n\n     (\\'dashdotdotted\\',         (0, (3, 5, 1, 5, 1, 5))),\n     (\\'loosely dashdotdotted\\', (0, (3, 10, 1, 10, 1, 10))),\n     (\\'densely dashdotdotted\\', (0, (3, 1, 1, 1, 1, 1)))]\n\n\ndef plot_linestyles(ax, linestyles, title):\n    X, Y = np.linspace(0, 100, 10), np.zeros(10)\n    yticklabels = []\n\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.plot(X, Y+i, linestyle=linestyle, linewidth=1.5, color=\\'black\\')\n        yticklabels.append(name)\n\n    ax.set_title(title)\n    ax.set(ylim=(-0.5, len(linestyles)-0.5),\n           yticks=np.arange(len(linestyles)),\n           yticklabels=yticklabels)\n    ax.tick_params(left=False, bottom=False, labelbottom=False)\n    ax.spines[:].set_visible(False)\n\n    # For each line style, add a text annotation with a small offset from\n    # the reference point (0 in Axes coords, y tick value in Data coords).\n    for i, (name, linestyle) in enumerate(linestyles):\n        ax.annotate(repr(linestyle),\n                    xy=(0.0, i), xycoords=ax.get_yaxis_transform(),\n                    xytext=(-6, -12), textcoords=\\'offset points\\',\n                    color=\"blue\", fontsize=8, ha=\"right\", family=\"monospace\")\n\n\nfig, (ax0, ax1) = plt.subplots(2, 1, figsize=(10, 8), height_ratios=[1, 3])\n\nplot_linestyles(ax0, linestyle_str[::-1], title=\\'Named linestyles\\')\nplot_linestyles(ax1, linestyle_tuple[::-1], title=\\'Parametrized linestyles\\')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 27
},
{
    "title": "Marker reference#",
    "text": "Matplotlib supports multiple categories of markers which are selected using\nthe marker parameter of plot commands: Unfilled markers Filled markers Markers created from TeX symbols Markers created from Paths For a list of all markers see also the matplotlib.markers documentation. For example usages see\nMarker examples. Unfilled markers are single-colored. The edge color and fill color of filled markers can be specified separately.\nAdditionally, the fillstyle can be configured to be unfilled, fully\nfilled, or half-filled in various directions. The half-filled styles use\nmarkerfacecoloralt as secondary fill color. Use MathText, to use custom marker symbols,\nlike e.g. \"$\\\\u266B$\". For an overview over the STIX font symbols refer\nto the STIX font table.\nAlso see the STIX Fonts. Any Path can be used as a marker. The following example shows two\nsimple paths star and circle, and a more elaborate path of a circle with\na cut-out star. Markers can be modified by passing a transform to the MarkerStyle\nconstructor. Following example shows how a supplied rotation is applied to\nseveral marker shapes. Markers have default cap and join styles, but these can be\ncustomized when creating a MarkerStyle. Modifying the join style: Total running time of the script: (0 minutes 1.888 seconds) Download Python source code: marker_reference.py Download Jupyter notebook: marker_reference.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.lines import Line2D\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.transforms import Affine2D\n\ntext_style = dict(horizontalalignment=\\'right\\', verticalalignment=\\'center\\',\n                  fontsize=12, fontfamily=\\'monospace\\')\nmarker_style = dict(linestyle=\\':\\', color=\\'0.8\\', markersize=10,\n                    markerfacecolor=\"tab:blue\", markeredgecolor=\"tab:blue\")\n\n\ndef format_axes(ax):\n    ax.margins(0.2)\n    ax.set_axis_off()\n    ax.invert_yaxis()\n\n\ndef split_list(a_list):\n    i_half = len(a_list) // 2\n    return a_list[:i_half], a_list[i_half:]\n', \"fig, axs = plt.subplots(ncols=2)\nfig.suptitle('Un-filled markers', fontsize=14)\n\n# Filter out filled markers and marker settings that do nothing.\nunfilled_markers = [m for m, func in Line2D.markers.items()\n                    if func != 'nothing' and m not in Line2D.filled_markers]\n\nfor ax, markers in zip(axs, split_list(unfilled_markers)):\n    for y, marker in enumerate(markers):\n        ax.text(-0.5, y, repr(marker), **text_style)\n        ax.plot([y] * 3, marker=marker, **marker_style)\n    format_axes(ax)\n\", \"fig, axs = plt.subplots(ncols=2)\nfig.suptitle('Filled markers', fontsize=14)\nfor ax, markers in zip(axs, split_list(Line2D.filled_markers)):\n    for y, marker in enumerate(markers):\n        ax.text(-0.5, y, repr(marker), **text_style)\n        ax.plot([y] * 3, marker=marker, **marker_style)\n    format_axes(ax)\n\", \"fig, ax = plt.subplots()\nfig.suptitle('Marker fillstyle', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nfilled_marker_style = dict(marker='o', linestyle=':', markersize=15,\n                           color='darkgrey',\n                           markerfacecolor='tab:blue',\n                           markerfacecoloralt='lightsteelblue',\n                           markeredgecolor='brown')\n\nfor y, fill_style in enumerate(Line2D.fillStyles):\n    ax.text(-0.5, y, repr(fill_style), **text_style)\n    ax.plot([y] * 3, fillstyle=fill_style, **filled_marker_style)\nformat_axes(ax)\n\", 'fig, ax = plt.subplots()\nfig.suptitle(\\'Mathtext markers\\', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nmarker_style.update(markeredgecolor=\"none\", markersize=15)\nmarkers = $1$\", r\"$\\\\frac{1}{2}$\", \"$f$\", \"$\\\\u266B$\", r\"$\\\\mathcal{A}$\n\nfor y, marker in enumerate(markers):\n    # Escape dollars so that the text is written \"as is\", not as mathtext.\n    ax.text(-0.5, y, repr(marker).replace(\"$\", r\"\\\\$\"), **text_style)\n    ax.plot([y] * 3, marker=marker, **marker_style)\nformat_axes(ax)\n', \"import numpy as np\n\nimport matplotlib.path as mpath\n\nstar = mpath.Path.unit_regular_star(6)\ncircle = mpath.Path.unit_circle()\n# concatenate the circle with an internal cutout of the star\ncut_star = mpath.Path(\n    vertices=np.concatenate([circle.vertices, star.vertices[::-1, ...]]),\n    codes=np.concatenate([circle.codes, star.codes]))\n\nfig, ax = plt.subplots()\nfig.suptitle('Path markers', fontsize=14)\nfig.subplots_adjust(left=0.4)\n\nmarkers = {'star': star, 'circle': circle, 'cut_star': cut_star}\n\nfor y, (name, marker) in enumerate(markers.items()):\n    ax.text(-0.5, y, name, **text_style)\n    ax.plot([y] * 3, marker=marker, **marker_style)\nformat_axes(ax)\n\", 'common_style = {k: v for k, v in filled_marker_style.items() if k != \\'marker\\'}\nangles = [0, 10, 20, 30, 45, 60, 90]\n\nfig, ax = plt.subplots()\nfig.suptitle(\\'Rotated markers\\', fontsize=14)\n\nax.text(-0.5, 0, \\'Filled marker\\', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    ax.plot(x, 0, marker=MarkerStyle(\\'o\\', \\'left\\', t), **common_style)\n\nax.text(-0.5, 1, \\'Un-filled marker\\', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    ax.plot(x, 1, marker=MarkerStyle(\\'1\\', \\'left\\', t), **common_style)\n\nax.text(-0.5, 2, \\'Equation marker\\', **text_style)\nfor x, theta in enumerate(angles):\n    t = Affine2D().rotate_deg(theta)\n    eq = r\\'$\\\\frac{1}{x}$\\'\n    ax.plot(x, 2, marker=MarkerStyle(eq, \\'left\\', t), **common_style)\n\nfor x, theta in enumerate(angles):\n    ax.text(x, 2.5, f\"{theta}\u00b0\", horizontalalignment=\"center\")\nformat_axes(ax)\n\nfig.tight_layout()\n', \"from matplotlib.markers import CapStyle, JoinStyle\n\nmarker_inner = dict(markersize=35,\n                    markerfacecolor='tab:blue',\n                    markerfacecoloralt='lightsteelblue',\n                    markeredgecolor='brown',\n                    markeredgewidth=8,\n                    )\n\nmarker_outer = dict(markersize=35,\n                    markerfacecolor='tab:blue',\n                    markerfacecoloralt='lightsteelblue',\n                    markeredgecolor='white',\n                    markeredgewidth=1,\n                    )\n\nfig, ax = plt.subplots()\nfig.suptitle('Marker CapStyle', fontsize=14)\nfig.subplots_adjust(left=0.1)\n\nfor y, cap_style in enumerate(CapStyle):\n    ax.text(-0.5, y, cap_style.name, **text_style)\n    for x, theta in enumerate(angles):\n        t = Affine2D().rotate_deg(theta)\n        m = MarkerStyle('1', transform=t, capstyle=cap_style)\n        ax.plot(x, y, marker=m, **marker_inner)\n        ax.plot(x, y, marker=m, **marker_outer)\n        ax.text(x, len(CapStyle) - .5, f'{theta}\u00b0', ha='center')\nformat_axes(ax)\n\", \"fig, ax = plt.subplots()\nfig.suptitle('Marker JoinStyle', fontsize=14)\nfig.subplots_adjust(left=0.05)\n\nfor y, join_style in enumerate(JoinStyle):\n    ax.text(-0.5, y, join_style.name, **text_style)\n    for x, theta in enumerate(angles):\n        t = Affine2D().rotate_deg(theta)\n        m = MarkerStyle('*', transform=t, joinstyle=join_style)\n        ax.plot(x, y, marker=m, **marker_inner)\n        ax.text(x, len(JoinStyle) - .5, f'{theta}\u00b0', ha='center')\nformat_axes(ax)\n\nplt.show()\n",
    "id": 28
},
{
    "title": "Markevery Demo#",
    "text": "The markevery property of Line2D allows drawing markers at a subset of\ndata points. The list of possible parameters is specified at Line2D.set_markevery.\nIn short: A single integer N draws every N-th marker. A tuple of integers (start, N) draws every N-th marker, starting at data\nindex start. A list of integers draws the markers at the specified indices. A slice draws the markers at the sliced indices. A float specifies the distance between markers as a fraction of the Axes\ndiagonal in screen space. This will lead to a visually uniform distribution\nof the points along the line, irrespective of scales and zooming.', \"Note that the log scale causes a visual asymmetry in the marker distance for\nwhen subsampling the data using an integer. In contrast, subsampling on\nfraction of figure size creates even distributions, because it's based on\nfractions of the Axes diagonal, not on data coordinates or data indices.\", 'Integer-based markevery specifications select points from the underlying\ndata and are independent on the view. In contrast, float-based specifications\nare related to the Axes diagonal. While zooming does not change the Axes\ndiagonal, it changes the displayed data range, and more points will be\ndisplayed when zooming. Total running time of the script: (0 minutes 8.411 seconds) Download Python source code: markevery_demo.py Download Jupyter notebook: markevery_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# define a list of markevery cases to plot\ncases = [\n    None,\n    8,\n    (30, 8),\n    [16, 24, 32],\n    [0, -1],\n    slice(100, 200, 3),\n    0.1,\n    0.4,\n    (0.2, 0.4)\n]\n\n# data points\ndelta = 0.11\nx = np.linspace(0, 10 - 2 * delta, 200) + delta\ny = np.sin(x) + 1.0 + delta\n', \"fig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n\", \"fig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n\", \"fig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained')\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(x, y, 'o', ls='-', ms=4, markevery=markevery)\n    ax.set_xlim((6, 6.7))\n    ax.set_ylim((1.1, 1.7))\n\", \"r = np.linspace(0, 3.0, 200)\ntheta = 2 * np.pi * r\n\nfig, axs = plt.subplots(3, 3, figsize=(10, 6), layout='constrained',\n                        subplot_kw={'projection': 'polar'})\nfor ax, markevery in zip(axs.flat, cases):\n    ax.set_title(f'markevery={markevery}')\n    ax.plot(theta, r, 'o', ls='-', ms=4, markevery=markevery)\n\nplt.show()\n",
    "id": 29
},
{
    "title": "Plotting masked and NaN values#",
    "text": "Sometimes you need to plot data with missing values. One possibility is to simply remove undesired data points. The line plotted\nthrough the remaining data will be continuous, and not indicate where the\nmissing data is located. If it is useful to have gaps in the line where the data is missing, then the\nundesired points can be indicated using a masked array or by setting their\nvalues to NaN. No marker will be drawn where either x or y are masked and, if\nplotting with a line, it will be broken there. The following example illustrates the three cases: Removing points. Masking points. Setting to NaN. Download Python source code: masked_demo.py Download Jupyter notebook: masked_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-np.pi/2, np.pi/2, 31)\ny = np.cos(x)**3\n\n# 1) remove points where y > 0.7\nx2 = x[y <= 0.7]\ny2 = y[y <= 0.7]\n\n# 2) mask points where y > 0.7\ny3 = np.ma.masked_where(y > 0.7, y)\n\n# 3) set to NaN where y > 0.7\ny4 = y.copy()\ny4[y3 > 0.7] = np.nan\n\nplt.plot(x*0.1, y, 'o-', color='lightgrey', label='No mask')\nplt.plot(x2*0.4, y2, 'o-', label='Points removed')\nplt.plot(x*0.7, y3, 'o-', label='Masked values')\nplt.plot(x*1.0, y4, 'o-', label='NaN values')\nplt.legend()\nplt.title('Masked and NaN data')\nplt.show()\n",
    "id": 30
},
{
    "title": "Multicolored lines#",
    "text": "This example shows how to make a multicolored line. In this example, the line\nis colored based on its derivative. Download Python source code: multicolored_line.py Download Jupyter notebook: multicolored_line.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\nfrom matplotlib.colors import BoundaryNorm, ListedColormap\n\nx = np.linspace(0, 3 * np.pi, 500)\ny = np.sin(x)\ndydx = np.cos(0.5 * (x[:-1] + x[1:]))  # first derivative\n\n# Create a set of line segments so that we can color them individually\n# This creates the points as an N x 1 x 2 array so that we can stack points\n# together easily to get the segments. The segments array for line collection\n# needs to be (numlines) x (points per line) x 2 (for x and y)\npoints = np.array([x, y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis=1)\n\nfig, axs = plt.subplots(2, 1, sharex=True, sharey=True)\n\n# Create a continuous norm to map from data points to colors\nnorm = plt.Normalize(dydx.min(), dydx.max())\nlc = LineCollection(segments, cmap='viridis', norm=norm)\n# Set the values used for colormapping\nlc.set_array(dydx)\nlc.set_linewidth(2)\nline = axs[0].add_collection(lc)\nfig.colorbar(line, ax=axs[0])\n\n# Use a boundary norm instead\ncmap = ListedColormap(r g b)\nnorm = BoundaryNorm([-1, -0.5, 0.5, 1], cmap.N)\nlc = LineCollection(segments, cmap=cmap, norm=norm)\nlc.set_array(dydx)\nlc.set_linewidth(2)\nline = axs[1].add_collection(lc)\nfig.colorbar(line, ax=axs[1])\n\naxs[0].set_xlim(x.min(), x.max())\naxs[0].set_ylim(-1.1, 1.1)\nplt.show()\n",
    "id": 31
},
{
    "title": "Mapping marker properties to multivariate data#",
    "text": "This example shows how to use different properties of markers to plot\nmultivariate datasets. Here we represent a successful baseball throw as a\nsmiley face with marker size mapped to the skill of thrower, marker rotation to\nthe take-off angle, and thrust to the marker color. Download Python source code: multivariate_marker_plot.py Download Jupyter notebook: multivariate_marker_plot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\n\nSUCCESS_SYMBOLS = [\n    TextPath((0, 0), \"\u2639\"),\n    TextPath((0, 0), \"\ud83d\ude12\"),\n    TextPath((0, 0), \"\u263a\"),\n]\n\nN = 25\nnp.random.seed(42)\nskills = np.random.uniform(5, 80, size=N) * 0.1 + 5\ntakeoff_angles = np.random.normal(0, 90, N)\nthrusts = np.random.uniform(size=N)\nsuccessful = np.random.randint(0, 3, size=N)\npositions = np.random.normal(size=(N, 2)) * 5\ndata = zip(skills, takeoff_angles, thrusts, successful, positions)\n\ncmap = plt.colormapsplasma\nfig, ax = plt.subplots()\nfig.suptitle(\"Throwing success\", size=14)\nfor skill, takeoff, thrust, mood, pos in data:\n    t = Affine2D().scale(skill).rotate_deg(takeoff)\n    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t)\n    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust))\nfig.colorbar(plt.cm.ScalarMappable(norm=Normalize(0, 1), cmap=cmap),\n             ax=ax, label=\"Normalized Thrust [a.u.]\")\nax.set_xlabel(\"X position [m]\")\nax.set_ylabel(\"Y position [m]\")\n\nplt.show()\n",
    "id": 32
},
{
    "title": "Power spectral density (PSD)#",
    "text": "Plotting power spectral density (PSD) using psd. The PSD is a common plot in the field of signal processing. NumPy has\nmany useful libraries for computing a PSD. Below we demo a few examples\nof how this can be accomplished and visualized with Matplotlib. Compare this with the equivalent Matlab code to accomplish the same thing:', \"Below we'll show a slightly more complex example that demonstrates\nhow padding affects the resulting PSD.\", \"This is a ported version of a MATLAB example from the signal\nprocessing toolbox that showed some difference at one time between\nMatplotlib's and MATLAB's scaling of the PSD.\", \"This is a ported version of a MATLAB example from the signal\nprocessing toolbox that showed some difference at one time between\nMatplotlib's and MATLAB's scaling of the PSD.\", \"It uses a complex signal so we can see that complex PSD's work properly.\", 'Total running time of the script: (0 minutes 2.611 seconds) Download Python source code: psd_demo.py Download Jupyter notebook: psd_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.mlab as mlab\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.01\nt = np.arange(0, 10, dt)\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\n\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\ns = 0.1 * np.sin(2 * np.pi * t) + cnse\n\nfig, (ax0, ax1) = plt.subplots(2, 1, layout='constrained')\nax0.plot(t, s)\nax0.set_xlabel('Time (s)')\nax0.set_ylabel('Signal')\nax1.psd(s, 512, 1 / dt)\n\nplt.show()\n\", 'dt = 0.01;\nt = [0:dt:10];\nnse = randn(size(t));\nr = exp(-t/0.05);\ncnse = conv(nse, r)*dt;\ncnse = cnse(1:length(t));\ns = 0.1*sin(2*pi*t) + cnse;\n\nsubplot(211)\nplot(t, s)\nsubplot(212)\npsd(s, 512, 1/dt)\n', \"dt = np.pi / 100.\nfs = 1. / dt\nt = np.arange(0, 8, dt)\ny = 10. * np.sin(2 * np.pi * 4 * t) + 5. * np.sin(2 * np.pi * 4.25 * t)\ny = y + np.random.randn(*t.shape)\n\n# Plot the raw time series\nfig, axs = plt.subplot_mosaic([\n    signal signal signal,\n    zero padding block size overlap,\n], layout='constrained')\n\naxssignal.plot(t, y)\naxssignal.set_xlabel('Time (s)')\naxssignal.set_ylabel('Signal')\n\n# Plot the PSD with different amounts of zero padding. This uses the entire\n# time series at once\naxszero padding.psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)\naxszero padding.psd(y, NFFT=len(t), pad_to=len(t) * 2, Fs=fs)\naxszero padding.psd(y, NFFT=len(t), pad_to=len(t) * 4, Fs=fs)\n\n# Plot the PSD with different block sizes, Zero pad to the length of the\n# original data sequence.\naxsblock size.psd(y, NFFT=len(t), pad_to=len(t), Fs=fs)\naxsblock size.psd(y, NFFT=len(t) // 2, pad_to=len(t), Fs=fs)\naxsblock size.psd(y, NFFT=len(t) // 4, pad_to=len(t), Fs=fs)\naxsblock size.set_ylabel('')\n\n# Plot the PSD with different amounts of overlap between blocks\naxsoverlap.psd(y, NFFT=len(t) // 2, pad_to=len(t), noverlap=0, Fs=fs)\naxsoverlap.psd(y, NFFT=len(t) // 2, pad_to=len(t),\n                   noverlap=int(0.025 * len(t)), Fs=fs)\naxsoverlap.psd(y, NFFT=len(t) // 2, pad_to=len(t),\n                   noverlap=int(0.1 * len(t)), Fs=fs)\naxsoverlap.set_ylabel('')\naxsoverlap.set_title('overlap')\n\nfor title, ax in axs.items():\n    if title == 'signal':\n        continue\n\n    ax.set_title(title)\n    ax.sharex(axszero padding)\n    ax.sharey(axszero padding)\n\nplt.show()\n\", \"fs = 1000\nt = np.linspace(0, 0.3, 301)\nA = np.array([2, 8]).reshape(-1, 1)\nf = np.array([150, 140]).reshape(-1, 1)\nxn = (A * np.sin(2 * np.pi * f * t)).sum(axis=0)\nxn += 5 * np.random.randn(*t.shape)\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, layout='constrained')\n\nyticks = np.arange(-50, 30, 10)\nyrange = (yticks[0], yticks[-1])\nxticks = np.arange(0, 550, 100)\n\nax0.psd(xn, NFFT=301, Fs=fs, window=mlab.window_none, pad_to=1024,\n        scale_by_freq=True)\nax0.set_title('Periodogram')\nax0.set_yticks(yticks)\nax0.set_xticks(xticks)\nax0.grid(True)\nax0.set_ylim(yrange)\n\nax1.psd(xn, NFFT=150, Fs=fs, window=mlab.window_none, pad_to=512, noverlap=75,\n        scale_by_freq=True)\nax1.set_title('Welch')\nax1.set_xticks(xticks)\nax1.set_yticks(yticks)\nax1.set_ylabel('')  # overwrite the y-label added by `psd`\nax1.grid(True)\nax1.set_ylim(yrange)\n\nplt.show()\n\", \"prng = np.random.RandomState(19680801)  # to ensure reproducibility\n\nfs = 1000\nt = np.linspace(0, 0.3, 301)\nA = np.array([2, 8]).reshape(-1, 1)\nf = np.array([150, 140]).reshape(-1, 1)\nxn = (A * np.exp(2j * np.pi * f * t)).sum(axis=0) + 5 * prng.randn(*t.shape)\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, layout='constrained')\n\nyticks = np.arange(-50, 30, 10)\nyrange = (yticks[0], yticks[-1])\nxticks = np.arange(-500, 550, 200)\n\nax0.psd(xn, NFFT=301, Fs=fs, window=mlab.window_none, pad_to=1024,\n        scale_by_freq=True)\nax0.set_title('Periodogram')\nax0.set_yticks(yticks)\nax0.set_xticks(xticks)\nax0.grid(True)\nax0.set_ylim(yrange)\n\nax1.psd(xn, NFFT=150, Fs=fs, window=mlab.window_none, pad_to=512, noverlap=75,\n        scale_by_freq=True)\nax1.set_title('Welch')\nax1.set_xticks(xticks)\nax1.set_yticks(yticks)\nax1.set_ylabel('')  # overwrite the y-label added by `psd`\nax1.grid(True)\nax1.set_ylim(yrange)\n\nplt.show()\n",
    "id": 33
},
{
    "title": "Scatter Demo2#",
    "text": "Demo of scatter plot with varying marker colors and sizes. Download Python source code: scatter_demo2.py Download Jupyter notebook: scatter_demo2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit (\\'D\\') in\n# the date column.\nprice_data = cbook.get_sample_data(\\'goog.npz\\')[\\'price_data\\\nprice_data = price_data[-250:]  # get the most recent 250 trading days\n\ndelta1 = np.diff(price_dataadj_close) / price_dataadj_close[:-1]\n\n# Marker size in units of points^2\nvolume = (15 * price_datavolume[:-2] / price_datavolume[0])**2\nclose = 0.003 * price_dataclose[:-2] / 0.003 * price_dataopen[:-2]\n\nfig, ax = plt.subplots()\nax.scatter(delta1[:-1], delta1[1:], c=close, s=volume, alpha=0.5)\n\nax.set_xlabel(r\\'$\\\\Delta_i$\\', fontsize=15)\nax.set_ylabel(r\\'$\\\\Delta_{i+1}$\\', fontsize=15)\nax.set_title(\\'Volume and percent change\\')\n\nax.grid(True)\nfig.tight_layout()\n\nplt.show()\n",
    "id": 34
},
{
    "title": "Scatter plot with histograms#",
    "text": "Show the marginal distributions of a scatter plot as histograms at the sides of\nthe plot. For a nice alignment of the main axes with the marginals, two options are shown\nbelow: Defining the axes positions using a gridspec Defining the axes positions using inset_axes While Axes.inset_axes may be a bit more complex, it allows correct handling\nof main axes with a fixed aspect ratio. An alternative method to produce a similar figure using the axes_grid1\ntoolkit is shown in the Scatter Histogram (Locatable Axes)\nexample. Finally, it is also possible to position all axes in absolute\ncoordinates using Figure.add_axes (not shown here). Let us first define a function that takes x and y data as input, as well\nas three axes, the main axes for the scatter, and two marginal axes. It will\nthen create the scatter and histograms inside the provided axes. We define a gridspec with unequal width- and height-ratios to achieve desired\nlayout. Also see the Arranging multiple Axes in a Figure tutorial. inset_axes can be used to position marginals outside the main\naxes. The advantage of doing so is that the aspect ratio of the main axes\ncan be fixed, and the marginals will always be drawn relative to the position\nof the axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.add_subplot matplotlib.figure.Figure.add_gridspec matplotlib.axes.Axes.inset_axes matplotlib.axes.Axes.scatter matplotlib.axes.Axes.hist Download Python source code: scatter_hist.py Download Jupyter notebook: scatter_hist.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# some random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\ndef scatter_hist(x, y, ax, ax_histx, ax_histy):\n    # no labels\n    ax_histx.tick_params(axis=\"x\", labelbottom=False)\n    ax_histy.tick_params(axis=\"y\", labelleft=False)\n\n    # the scatter plot:\n    ax.scatter(x, y)\n\n    # now determine nice limits by hand:\n    binwidth = 0.25\n    xymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\n    lim = (int(xymax/binwidth) + 1) * binwidth\n\n    bins = np.arange(-lim, lim + binwidth, binwidth)\n    ax_histx.hist(x, bins=bins)\n    ax_histy.hist(y, bins=bins, orientation=\\'horizontal\\')\n # Start with a square Figure.\nfig = plt.figure(figsize=(6, 6))\n# Add a gridspec with two rows and two columns and a ratio of 1 to 4 between\n# the size of the marginal axes and the main axes in both directions.\n# Also adjust the subplot parameters for a square plot.\ngs = fig.add_gridspec(2, 2,  width_ratios=(4, 1), height_ratios=(1, 4),\n                      left=0.1, right=0.9, bottom=0.1, top=0.9,\n                      wspace=0.05, hspace=0.05)\n# Create the Axes.\nax = fig.add_subplot(gs[1, 0])\nax_histx = fig.add_subplot(gs[0, 0], sharex=ax)\nax_histy = fig.add_subplot(gs[1, 1], sharey=ax)\n# Draw the scatter plot and marginals.\nscatter_hist(x, y, ax, ax_histx, ax_histy)\n', \"# Create a Figure, which doesn't have to be square.\nfig = plt.figure(layout='constrained')\n# Create the main axes, leaving 25% of the figure space at the top and on the\n# right to position marginals.\nax = fig.add_gridspec(top=0.75, right=0.75).subplots()\n# The main axes' aspect can be fixed.\nax.set(aspect=1)\n# Create marginal axes, which have 25% of the size of the main axes.  Note that\n# the inset axes are positioned *outside* (on the right and the top) of the\n# main axes, by specifying axes coordinates greater than 1.  Axes coordinates\n# less than 0 would likewise specify positions on the left and the bottom of\n# the main axes.\nax_histx = ax.inset_axes([0, 1.05, 1, 0.25], sharex=ax)\nax_histy = ax.inset_axes([1.05, 0, 0.25, 1], sharey=ax)\n# Draw the scatter plot and marginals.\nscatter_hist(x, y, ax, ax_histx, ax_histy)\n\nplt.show()\n",
    "id": 35
},
{
    "title": "Scatter Masked#",
    "text": "Mask some data points and add a line demarking\nmasked regions. Download Python source code: scatter_masked.py Download Jupyter notebook: scatter_masked.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 100\nr0 = 0.6\nx = 0.9 * np.random.rand(N)\ny = 0.9 * np.random.rand(N)\narea = (20 * np.random.rand(N))**2  # 0 to 10 point radii\nc = np.sqrt(area)\nr = np.sqrt(x ** 2 + y ** 2)\narea1 = np.ma.masked_where(r < r0, area)\narea2 = np.ma.masked_where(r >= r0, area)\nplt.scatter(x, y, s=area1, marker='^', c=c)\nplt.scatter(x, y, s=area2, marker='o', c=c)\n# Show the boundary between the regions:\ntheta = np.arange(0, np.pi / 2, 0.01)\nplt.plot(r0 * np.cos(theta), r0 * np.sin(theta))\n\nplt.show()\n",
    "id": 36
},
{
    "title": "Marker examples#",
    "text": "Example with different ways to specify markers. See also the matplotlib.markers documentation for a list of all markers and\nMarker reference for more information\non configuring markers. Download Python source code: scatter_star_poly.py Download Jupyter notebook: scatter_star_poly.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(10)\ny = np.random.rand(10)\nz = np.sqrt(x**2 + y**2)\n\nfig, axs = plt.subplots(2, 3, sharex=True, sharey=True, layout=\"constrained\")\n\n# Matplotlib marker symbol\naxs[0, 0].scatter(x, y, s=80, c=z, marker=\">\")\naxs[0, 0].set_title(\"marker=\\'>\\'\")\n\n# marker from TeX: passing a TeX symbol name enclosed in $-signs\naxs[0, 1].scatter(x, y, s=80, c=z, marker=r\"$\\\\clubsuit$\")\naxs[0, 1].set_title(r\"marker=r\\'\\\\$\\\\clubsuit\\\\$\\'\")\n\n# marker from path: passing a custom path of N vertices as a (N, 2) array-like\nverts = [[-1, -1], [1, -1], [1, 1], [-1, -1]]\naxs[0, 2].scatter(x, y, s=80, c=z, marker=verts)\naxs[0, 2].set_title(\"marker=verts\")\n\n# regular pentagon marker\naxs[1, 0].scatter(x, y, s=80, c=z, marker=(5, 0))\naxs[1, 0].set_title(\"marker=(5, 0)\")\n\n# regular 5-pointed star marker\naxs[1, 1].scatter(x, y, s=80, c=z, marker=(5, 1))\naxs[1, 1].set_title(\"marker=(5, 1)\")\n\n# regular 5-pointed asterisk marker\naxs[1, 2].scatter(x, y, s=80, c=z, marker=(5, 2))\naxs[1, 2].set_title(\"marker=(5, 2)\")\n\nplt.show()\n",
    "id": 37
},
{
    "title": "Scatter plots with a legend#",
    "text": "To create a scatter plot with a legend one may use a loop and create one\nscatter plot per item to appear in the legend and set the label\naccordingly. The following also demonstrates how transparency of the markers\ncan be adjusted by giving alpha a value between 0 and 1. Another option for creating a legend for a scatter is to use the\nPathCollection.legend_elements method. It will automatically try to\ndetermine a useful number of legend entries to be shown and return a tuple of\nhandles and labels. Those can be passed to the call to legend. Further arguments to the PathCollection.legend_elements method\ncan be used to steer how many legend entries are to be created and how they\nshould be labeled. The following shows how to use some of them. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.scatter / matplotlib.pyplot.scatter matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.collections.PathCollection.legend_elements Total running time of the script: (0 minutes 1.452 seconds) Download Python source code: scatter_with_legend.py Download Jupyter notebook: scatter_with_legend.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nfor color in tab:blue tab:orange tab:green:\n    n = 750\n    x, y = np.random.rand(2, n)\n    scale = 200.0 * np.random.rand(n)\n    ax.scatter(x, y, c=color, s=scale, label=color,\n               alpha=0.3, edgecolors='none')\n\nax.legend()\nax.grid(True)\n\nplt.show()\n\", 'N = 45\nx, y = np.random.rand(2, N)\nc = np.random.randint(1, 5, size=N)\ns = np.random.randint(10, 220, size=N)\n\nfig, ax = plt.subplots()\n\nscatter = ax.scatter(x, y, c=c, s=s)\n\n# produce a legend with the unique colors from the scatter\nlegend1 = ax.legend(*scatter.legend_elements(),\n                    loc=\"lower left\", title=\"Classes\")\nax.add_artist(legend1)\n\n# produce a legend with a cross-section of sizes from the scatter\nhandles, labels = scatter.legend_elements(prop=\"sizes\", alpha=0.6)\nlegend2 = ax.legend(handles, labels, loc=\"upper right\", title=\"Sizes\")\n\nplt.show()\n volume = np.random.rayleigh(27, size=40)\namount = np.random.poisson(10, size=40)\nranking = np.random.normal(size=40)\nprice = np.random.uniform(1, 10, size=40)\n\nfig, ax = plt.subplots()\n\n# Because the price is much too small when being provided as size for ``s``,\n# we normalize it to some useful point sizes, s=0.3*(price*3)**2\nscatter = ax.scatter(volume, amount, c=ranking, s=0.3*(price*3)**2,\n                     vmin=-3, vmax=3, cmap=\"Spectral\")\n\n# Produce a legend for the ranking (colors). Even though there are 40 different\n# rankings, we only want to show 5 of them in the legend.\nlegend1 = ax.legend(*scatter.legend_elements(num=5),\n                    loc=\"upper left\", title=\"Ranking\")\nax.add_artist(legend1)\n\n# Produce a legend for the price (sizes). Because we want to show the prices\n# in dollars, we use the *func* argument to supply the inverse of the function\n# used to calculate the sizes from above. The *fmt* ensures to show the price\n# in dollars. Note how we target at 5 elements here, but obtain only 4 in the\n# created legend due to the automatic round prices that are chosen for us.\nkw = dict(prop=\"sizes\", num=5, color=scatter.cmap(0.7), fmt=\"$ {x:.2f}\",\n          func=lambda s: np.sqrt(s/.3)/3)\nlegend2 = ax.legend(*scatter.legend_elements(**kw),\n                    loc=\"lower right\", title=\"Price\")\n\nplt.show()\n",
    "id": 38
},
{
    "title": "Simple Plot#",
    "text": "Create a simple plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.pyplot.subplots matplotlib.figure.Figure.savefig Download Python source code: simple_plot.py Download Jupyter notebook: simple_plot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.set(xlabel=\\'time (s)\\', ylabel=\\'voltage (mV)\\',\n       title=\\'About as simple as it gets, folks\\')\nax.grid()\n\nfig.savefig(\"test.png\")\nplt.show()\n",
    "id": 39
},
{
    "title": "Shade regions defined by a logical mask using fill_between#",
    "text": "References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.fill_between Download Python source code: span_regions.py Download Jupyter notebook: span_regions.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2, 0.01)\ns = np.sin(2*np.pi*t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s, color='black')\nax.axhline(0, color='black')\n\nax.fill_between(t, 1, where=s > 0, facecolor='green', alpha=.5)\nax.fill_between(t, -1, where=s < 0, facecolor='red', alpha=.5)\n\nplt.show()\n",
    "id": 40
},
{
    "title": "Spectrum representations#",
    "text": "The plots show different spectrum representations of a sine signal with\nadditive noise. A (frequency) spectrum of a discrete-time signal is calculated\nby utilizing the fast Fourier transform (FFT). Total running time of the script: (0 minutes 1.201 seconds) Download Python source code: spectrum_demo.py Download Jupyter notebook: spectrum_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(0)\n\ndt = 0.01  # sampling interval\nFs = 1 / dt  # sampling frequency\nt = np.arange(0, 10, dt)\n\n# generate noise:\nnse = np.random.randn(len(t))\nr = np.exp(-t / 0.05)\ncnse = np.convolve(nse, r) * dt\ncnse = cnse[:len(t)]\n\ns = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal\n\nfig = plt.figure(figsize=(7, 7), layout=\\'constrained\\')\naxs = fig.subplot_mosaic([signal\", \"signal,\n                          magnitude\", \"log_magnitude,\n                          phase\", \"angle])\n\n# plot time signal:\naxssignal.set_title(\"Signal\")\naxssignal.plot(t, s, color=\\'C0\\')\naxssignal.set_xlabel(\"Time (s)\")\naxssignal.set_ylabel(\"Amplitude\")\n\n# plot different spectrum types:\naxsmagnitude.set_title(\"Magnitude Spectrum\")\naxsmagnitude.magnitude_spectrum(s, Fs=Fs, color=\\'C1\\')\n\naxslog_magnitude.set_title(\"Log. Magnitude Spectrum\")\naxslog_magnitude.magnitude_spectrum(s, Fs=Fs, scale=\\'dB\\', color=\\'C1\\')\n\naxsphase.set_title(\"Phase Spectrum \")\naxsphase.phase_spectrum(s, Fs=Fs, color=\\'C2\\')\n\naxsangle.set_title(\"Angle Spectrum\")\naxsangle.angle_spectrum(s, Fs=Fs, color=\\'C2\\')\n\nplt.show()\n",
    "id": 41
},
{
    "title": "Stackplots and streamgraphs#",
    "text": "Stackplots draw multiple datasets as vertically stacked areas. This is\nuseful when the individual data values and additionally their cumulative\nvalue are of interest. Using the baseline parameter, you can turn an ordinary stacked area plot\nwith baseline 0 into a stream graph. Download Python source code: stackplot_demo.py Download Jupyter notebook: stackplot_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# data from United Nations World Population Prospects (Revision 2019)\n# https://population.un.org/wpp/, license: CC BY 3.0 IGO\nyear = [1950, 1960, 1970, 1980, 1990, 2000, 2010, 2018]\npopulation_by_continent = {\n    'africa': [228, 284, 365, 477, 631, 814, 1044, 1275],\n    'americas': [340, 425, 519, 619, 727, 840, 943, 1006],\n    'asia': [1394, 1686, 2120, 2625, 3202, 3714, 4169, 4560],\n    'europe': [220, 253, 276, 295, 310, 303, 294, 293],\n    'oceania': [12, 15, 19, 22, 26, 31, 36, 39],\n}\n\nfig, ax = plt.subplots()\nax.stackplot(year, population_by_continent.values(),\n             labels=population_by_continent.keys(), alpha=0.8)\nax.legend(loc='upper left', reverse=True)\nax.set_title('World population')\nax.set_xlabel('Year')\nax.set_ylabel('Number of people (millions)')\n\nplt.show()\n\", '# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef gaussian_mixture(x, n=5):\n    \"\"\"Return a random mixture of *n* Gaussians, evaluated at positions *x*.\"\"\"\n    def add_random_gaussian(a):\n        amplitude = 1 / (.1 + np.random.random())\n        dx = x[-1] - x[0]\n        x0 = (2 * np.random.random() - .5) * dx\n        z = 10 / (.1 + np.random.random()) / dx\n        a += amplitude * np.exp(-(z * (x - x0))**2)\n    a = np.zeros_like(x)\n    for j in range(n):\n        add_random_gaussian(a)\n    return a\n\n\nx = np.linspace(0, 100, 101)\nys = [gaussian_mixture(x) for _ in range(3)]\n\nfig, ax = plt.subplots()\nax.stackplot(x, ys, baseline=\\'wiggle\\')\nplt.show()\n",
    "id": 42
},
{
    "title": "Stairs Demo#",
    "text": "This example demonstrates the use of stairs for stepwise\nconstant functions. A common use case is histogram and histogram-like data\nvisualization. baseline can take an array to allow for stacked histogram plots pyplot.step defines the positions of the steps as single values. The steps\nextend left/right/both ways from these reference values depending on the\nparameter where. The number of x and y values is the same. In contrast, pyplot.stairs defines the positions of the steps via their\nbounds edges, which is one element longer than the step values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.stairs / matplotlib.pyplot.stairs matplotlib.patches.StepPatch Total running time of the script: (0 minutes 1.252 seconds) Download Python source code: stairs_demo.py Download Jupyter notebook: stairs_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import StepPatch\n\nnp.random.seed(0)\nh, edges = np.histogram(np.random.normal(5, 3, 5000),\n                        bins=np.linspace(0, 10, 20))\n\nfig, axs = plt.subplots(3, 1, figsize=(7, 15))\naxs[0].stairs(h, edges, label=\\'Simple histogram\\')\naxs[0].stairs(h, edges + 5, baseline=50, label=\\'Modified baseline\\')\naxs[0].stairs(h, edges + 10, baseline=None, label=\\'No edges\\')\naxs[0].set_title(\"Step Histograms\")\n\naxs[1].stairs(np.arange(1, 6, 1), fill=True,\n              label=\\'Filled histogram\\\nw/ automatic edges\\')\naxs[1].stairs(np.arange(1, 6, 1)*0.3, np.arange(2, 8, 1),\n              orientation=\\'horizontal\\', hatch=\\'//\\',\n              label=\\'Hatched histogram\\\nw/ horizontal orientation\\')\naxs[1].set_title(\"Filled histogram\")\n\npatch = StepPatch(values=[1, 2, 3, 2, 1],\n                  edges=range(1, 7),\n                  label=(\\'Patch derived underlying object\\\n\\'\n                         \\'with default edge/facecolor behaviour\\'))\naxs[2].add_patch(patch)\naxs[2].set_xlim(0, 7)\naxs[2].set_ylim(-1, 5)\naxs[2].set_title(\"StepPatch artist\")\n\nfor ax in axs:\n    ax.legend()\nplt.show()\n A = [[0, 0, 0],\n     [1, 2, 3],\n     [2, 4, 6],\n     [3, 6, 9]]\n\nfor i in range(len(A) - 1):\n    plt.stairs(A[i+1], baseline=A[i], fill=True)\n bins = np.arange(14)\ncenters = bins[:-1] + np.diff(bins) / 2\ny = np.sin(centers / 2)\n\nplt.step(bins[:-1], y, where=\\'post\\', label=\\'step(where=\"post\")\\')\nplt.plot(bins[:-1], y, \\'o--\\', color=\\'grey\\', alpha=0.3)\n\nplt.stairs(y - 1, bins, baseline=None, label=\\'stairs()\\')\nplt.plot(centers, y - 1, \\'o--\\', color=\\'grey\\', alpha=0.3)\nplt.plot(np.repeat(bins, 2), np.hstack([y[0], np.repeat(y, 2), y[-1]]) - 1,\n         \\'o\\', color=\\'red\\', alpha=0.2)\n\nplt.legend()\nplt.title(\\'step() vs. stairs()\\')\nplt.show()\n",
    "id": 43
},
{
    "title": "Stem Plot#",
    "text": "stem plots vertical lines from a baseline to the y-coordinate and\nplaces a marker at the tip. The position of the baseline can be adapted using bottom.\nThe parameters linefmt, markerfmt, and basefmt control basic format\nproperties of the plot. However, in contrast to plot not all\nproperties are configurable via keyword arguments. For more advanced\ncontrol adapt the line objects returned by pyplot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.stem / matplotlib.pyplot.stem Download Python source code: stem_plot.py Download Jupyter notebook: stem_plot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0.1, 2 * np.pi, 41)\ny = np.exp(np.sin(x))\n\nplt.stem(x, y)\nplt.show()\n', \"markerline, stemlines, baseline = plt.stem(\n    x, y, linefmt='grey', markerfmt='D', bottom=1.1)\nmarkerline.set_markerfacecolor('none')\nplt.show()\n",
    "id": 44
},
{
    "title": "Step Demo#",
    "text": "This example demonstrates the use of pyplot.step for piece-wise constant\ncurves. In particular, it illustrates the effect of the parameter where\non the step position. Note For the common case that you know the edge positions, use pyplot.stairs\ninstead.', \"The circular markers created with pyplot.plot show the actual data\npositions so that it's easier to see the effect of where.\", 'The same behavior can be achieved by using the drawstyle parameter of\npyplot.plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.step / matplotlib.pyplot.step matplotlib.axes.Axes.plot / matplotlib.pyplot.plot Download Python source code: step_demo.py Download Jupyter notebook: step_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(14)\ny = np.sin(x / 2)\n\nplt.step(x, y + 2, label='pre (default)')\nplt.plot(x, y + 2, 'o--', color='grey', alpha=0.3)\n\nplt.step(x, y + 1, where='mid', label='mid')\nplt.plot(x, y + 1, 'o--', color='grey', alpha=0.3)\n\nplt.step(x, y, where='post', label='post')\nplt.plot(x, y, 'o--', color='grey', alpha=0.3)\n\nplt.grid(axis='x', color='0.95')\nplt.legend(title='Parameter where:')\nplt.title('plt.step(where=...)')\nplt.show()\n\", \"plt.plot(x, y + 2, drawstyle='steps', label='steps (=steps-pre)')\nplt.plot(x, y + 2, 'o--', color='grey', alpha=0.3)\n\nplt.plot(x, y + 1, drawstyle='steps-mid', label='steps-mid')\nplt.plot(x, y + 1, 'o--', color='grey', alpha=0.3)\n\nplt.plot(x, y, drawstyle='steps-post', label='steps-post')\nplt.plot(x, y, 'o--', color='grey', alpha=0.3)\n\nplt.grid(axis='x', color='0.95')\nplt.legend(title='Parameter drawstyle:')\nplt.title('plt.plot(drawstyle=...)')\nplt.show()\n",
    "id": 45
},
{
    "title": "Creating a timeline with lines, dates, and text#",
    "text": "How to create a simple timeline using Matplotlib release dates.', \"Timelines can be created with a collection of dates and text. In this example,\nwe show how to create a simple timeline using the dates for recent releases\nof Matplotlib. First, we'll pull the data from GitHub.\", \"Next, we'll create a stem plot with some variation in levels as to\ndistinguish even close-by events. We add markers on the baseline for visual\nemphasis on the one-dimensional nature of the timeline.\", 'For each event, we add a text label via annotate, which is offset\nin units of points from the tip of the event line. Note that Matplotlib will automatically plot datetime inputs. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.annotate matplotlib.axes.Axes.vlines matplotlib.axis.Axis.set_major_locator matplotlib.axis.Axis.set_major_formatter matplotlib.dates.MonthLocator matplotlib.dates.DateFormatter Total running time of the script: (0 minutes 2.766 seconds) Download Python source code: timeline.py Download Jupyter notebook: timeline.ipynb ",
    "code": "from datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\ntry:\n    # Try to fetch a list of Matplotlib releases and their dates\n    # from https://api.github.com/repos/matplotlib/matplotlib/releases\n    import json\n    import urllib.request\n\n    url = \\'https://api.github.com/repos/matplotlib/matplotlib/releases\\'\n    url += \\'?per_page=100\\'\n    data = json.loads(urllib.request.urlopen(url, timeout=1).read().decode())\n\n    dates = []\n    names = []\n    for item in data:\n        if \\'rc\\' not in item[\\'tag_name\\ and \\'b\\' not in item[\\'tag_name\\:\n            dates.append(item[\\'published_at\\.split(\"T\")[0])\n            names.append(item[\\'tag_name\\)\n    # Convert date strings (e.g. 2014-10-18) to datetime\n    dates = [datetime.strptime(d, \"%Y-%m-%d\") for d in dates]\n\nexcept Exception:\n    # In case the above fails, e.g. because of missing internet connection\n    # use the following lists as fallback.\n    names = [\\'v2.2.4\\', \\'v3.0.3\\', \\'v3.0.2\\', \\'v3.0.1\\', \\'v3.0.0\\', \\'v2.2.3\\',\n             \\'v2.2.2\\', \\'v2.2.1\\', \\'v2.2.0\\', \\'v2.1.2\\', \\'v2.1.1\\', \\'v2.1.0\\',\n             \\'v2.0.2\\', \\'v2.0.1\\', \\'v2.0.0\\', \\'v1.5.3\\', \\'v1.5.2\\', \\'v1.5.1\\',\n             \\'v1.5.0\\', \\'v1.4.3\\', \\'v1.4.2\\', \\'v1.4.1\\', \\'v1.4.0\\\n\n    dates = [\\'2019-02-26\\', \\'2019-02-26\\', \\'2018-11-10\\', \\'2018-11-10\\',\n             \\'2018-09-18\\', \\'2018-08-10\\', \\'2018-03-17\\', \\'2018-03-16\\',\n             \\'2018-03-06\\', \\'2018-01-18\\', \\'2017-12-10\\', \\'2017-10-07\\',\n             \\'2017-05-10\\', \\'2017-05-02\\', \\'2017-01-17\\', \\'2016-09-09\\',\n             \\'2016-07-03\\', \\'2016-01-10\\', \\'2015-10-29\\', \\'2015-02-16\\',\n             \\'2014-10-26\\', \\'2014-10-18\\', \\'2014-08-26\\\n\n    # Convert date strings (e.g. 2014-10-18) to datetime\n    dates = [datetime.strptime(d, \"%Y-%m-%d\") for d in dates]\n # Choose some nice levels\nlevels = np.tile([-5, 5, -3, 3, -1, 1],\n                 int(np.ceil(len(dates)/6)))[:len(dates)]\n\n# Create figure and plot a stem plot with the date\nfig, ax = plt.subplots(figsize=(8.8, 4), layout=\"constrained\")\nax.set(title=\"Matplotlib release dates\")\n\nax.vlines(dates, 0, levels, color=\"tab:red\")  # The vertical stems.\nax.plot(dates, np.zeros_like(dates), \"-o\",\n        color=\"k\", markerfacecolor=\"w\")  # Baseline and markers on it.\n\n# annotate lines\nfor d, l, r in zip(dates, levels, names):\n    ax.annotate(r, xy=(d, l),\n                xytext=(-3, np.sign(l)*3), textcoords=\"offset points\",\n                horizontalalignment=\"right\",\n                verticalalignment=\"bottom\" if l > 0 else \"top\")\n\n# format x-axis with 4-month intervals\nax.xaxis.set_major_locator(mdates.MonthLocator(interval=4))\nax.xaxis.set_major_formatter(mdates.DateFormatter(\"%b %Y\"))\nplt.setp(ax.get_xticklabels(), rotation=30, ha=\"right\")\n\n# remove y-axis and spines\nax.yaxis.set_visible(False)\nax.spines[left\", \"top\", \"right].set_visible(False)\n\nax.margins(y=0.1)\nplt.show()\n",
    "id": 46
},
{
    "title": "hlines and vlines#",
    "text": "This example showcases the functions hlines and vlines. Download Python source code: vline_hline_demo.py Download Jupyter notebook: vline_hline_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nt = np.arange(0.0, 5.0, 0.1)\ns = np.exp(-t) + np.sin(2 * np.pi * t) + 1\nnse = np.random.normal(0.0, 0.3, t.shape) * s\n\nfig, (vax, hax) = plt.subplots(1, 2, figsize=(12, 6))\n\nvax.plot(t, s + nse, '^')\nvax.vlines(t, [0], s)\n# By using ``transform=vax.get_xaxis_transform()`` the y coordinates are scaled\n# such that 0 maps to the bottom of the axes and 1 to the top.\nvax.vlines([1, 2], 0, 1, transform=vax.get_xaxis_transform(), colors='r')\nvax.set_xlabel('time (s)')\nvax.set_title('Vertical lines demo')\n\nhax.plot(s + nse, t, '^')\nhax.hlines(t, [0], s, lw=2)\nhax.set_xlabel('time (s)')\nhax.set_title('Horizontal lines demo')\n\nplt.show()\n",
    "id": 47
},
{
    "title": "Cross- and auto-correlation#",
    "text": "Example use of cross-correlation (xcorr) and auto-correlation\n(acorr) plots. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.acorr / matplotlib.pyplot.acorr matplotlib.axes.Axes.xcorr / matplotlib.pyplot.xcorr Download Python source code: xcorr_acorr_demo.py Download Jupyter notebook: xcorr_acorr_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nx, y = np.random.randn(2, 100)\nfig, [ax1, ax2] = plt.subplots(2, 1, sharex=True)\nax1.xcorr(x, y, usevlines=True, maxlags=50, normed=True, lw=2)\nax1.grid(True)\nax1.set_title('Cross-correlation (xcorr)')\n\nax2.acorr(x, usevlines=True, normed=True, maxlags=50, lw=2)\nax2.grid(True)\nax2.set_title('Auto-correlation (acorr)')\n\nplt.show()\n",
    "id": 48
},
{
    "title": "Affine transform of an image#",
    "text": "Prepending an affine transformation (Affine2D) to the data\ntransform of an image allows to manipulate the image's shape and\norientation. This is an example of the concept of transform chaining.\", 'The image of the output should have its boundary match the dashed yellow\nrectangle. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.transforms.Affine2D Download Python source code: affine_image.py Download Jupyter notebook: affine_image.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\n\ndef get_image():\n    delta = 0.25\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2)\n    return Z\n\n\ndef do_plot(ax, Z, transform):\n    im = ax.imshow(Z, interpolation=\\'none\\',\n                   origin=\\'lower\\',\n                   extent=[-2, 4, -3, 2], clip_on=True)\n\n    trans_data = transform + ax.transData\n    im.set_transform(trans_data)\n\n    # display intended extent of the image\n    x1, x2, y1, y2 = im.get_extent()\n    ax.plot([x1, x2, x2, x1, x1], [y1, y1, y2, y2, y1], \"y--\",\n            transform=trans_data)\n    ax.set_xlim(-5, 5)\n    ax.set_ylim(-4, 4)\n\n\n# prepare image and figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nZ = get_image()\n\n# image rotation\ndo_plot(ax1, Z, mtransforms.Affine2D().rotate_deg(30))\n\n# image skew\ndo_plot(ax2, Z, mtransforms.Affine2D().skew_deg(30, 15))\n\n# scale and reflection\ndo_plot(ax3, Z, mtransforms.Affine2D().scale(-1, .5))\n\n# everything and a translation\ndo_plot(ax4, Z, mtransforms.Affine2D().\n        rotate_deg(30).skew_deg(30, 15).scale(-1, .5).translate(.5, -1))\n\nplt.show()\n",
    "id": 50
},
{
    "title": "Wind Barbs#",
    "text": "Demonstration of wind barb plots. Identical plot to panel 2 in the first figure, but with the point at\n(0.5, 0.25) missing (masked) References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.barbs / matplotlib.pyplot.barbs Download Python source code: barb_demo.py Download Jupyter notebook: barb_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-5, 5, 5)\nX, Y = np.meshgrid(x, x)\nU, V = 12 * X, 12 * Y\n\ndata = [(-1.5, .5, -6, -6),\n        (1, -1, -46, 46),\n        (-3, -1, 11, -11),\n        (1, 1.5, 80, 80),\n        (0.5, 0.25, 25, 15),\n        (-1.5, -0.5, -5, 40)]\n\ndata = np.array(data, dtype=[('x', np.float32), ('y', np.float32),\n                             ('u', np.float32), ('v', np.float32)])\n\nfig1, axs1 = plt.subplots(nrows=2, ncols=2)\n# Default parameters, uniform grid\naxs1[0, 0].barbs(X, Y, U, V)\n\n# Arbitrary set of vectors, make them longer and change the pivot point\n# (point around which they're rotated) to be the middle\naxs1[0, 1].barbs(\n    datax, datay, datau, datav, length=8, pivot='middle')\n\n# Showing colormapping with uniform grid.  Fill the circle for an empty barb,\n# don't round the values, and change some of the size parameters\naxs1[1, 0].barbs(\n    X, Y, U, V, np.sqrt(U ** 2 + V ** 2), fill_empty=True, rounding=False,\n    sizes=dict(emptybarb=0.25, spacing=0.2, height=0.3))\n\n# Change colors as well as the increments for parts of the barbs\naxs1[1, 1].barbs(datax, datay, datau, datav, flagcolor='r',\n                 barbcolor=b g, flip_barb=True,\n                 barb_increments=dict(half=10, full=20, flag=100))\n\n# Masked arrays are also supported\nmasked_u = np.ma.masked_array(datau)\nmasked_u[4] = 1000  # Bad value that should not be plotted when masked\nmasked_u[4] = np.ma.masked\n\", \"fig2, ax2 = plt.subplots()\nax2.barbs(datax, datay, masked_u, datav, length=8, pivot='middle')\n\nplt.show()\n",
    "id": 51
},
{
    "title": "Barcode#",
    "text": "This demo shows how to produce a bar code. The figure size is calculated so that the width in pixels is a multiple of the\nnumber of data points to prevent interpolation artifacts. Additionally, the\nAxes is defined to span the whole figure and all Axis are turned off. The data itself is rendered with imshow using code.reshape(1, -1) to turn the data into a 2D array with one row.', \"imshow(..., aspect='auto') to allow for non-square pixels.\", \"imshow(..., interpolation='nearest') to prevent blurred edges. This\nshould not happen anyway because we fine-tuned the figure width in pixels,\nbut just to be safe.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.add_axes Download Python source code: barcode_demo.py Download Jupyter notebook: barcode_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ncode = np.array([\n    1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1,\n    0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0,\n    1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,\n    1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1])\n\npixel_per_bar = 4\ndpi = 100\n\nfig = plt.figure(figsize=(len(code) * pixel_per_bar / dpi, 2), dpi=dpi)\nax = fig.add_axes([0, 0, 1, 1])  # span the whole figure\nax.set_axis_off()\nax.imshow(code.reshape(1, -1), cmap='binary', aspect='auto',\n          interpolation='nearest')\nplt.show()\n",
    "id": 52
},
{
    "title": "Interactive Adjustment of Colormap Range#",
    "text": "Demonstration of how a colorbar can be used to interactively adjust the\nrange of colormapping on an image. To use the interactive feature, you must\nbe in either zoom mode (magnifying glass toolbar button) or\npan mode (4-way arrow toolbar button) and click inside the colorbar. When zooming, the bounding box of the zoom region defines the new vmin and\nvmax of the norm. Zooming using the right mouse button will expand the\nvmin and vmax proportionally to the selected region, in the same manner that\none can zoom out on an axis. When panning, the vmin and vmax of the norm are\nboth shifted according to the direction of movement. The\nHome/Back/Forward buttons can also be used to get back to a previous state. Download Python source code: colormap_interactive_adjustment.py Download Jupyter notebook: colormap_interactive_adjustment.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 2 * np.pi, 1024)\ndata2d = np.sin(t)[:, np.newaxis] * np.cos(t)[np.newaxis, :]\n\nfig, ax = plt.subplots()\nim = ax.imshow(data2d)\nax.set_title('Pan on the colorbar to shift the color mapping\\\n'\n             'Zoom on the colorbar to scale the color mapping')\n\nfig.colorbar(im, ax=ax, label='Interactive colorbar')\n\nplt.show()\n",
    "id": 53
},
{
    "title": "Colormap normalizations#",
    "text": "Demonstration of using norm to map colormaps onto data in non-linear ways. Lognorm: Instead of pcolor log10(Z1) you can have colorbars that have\nthe exponential labels using a norm. PowerNorm: Here a power-law trend in X partially obscures a rectified\nsine wave in Y. We can remove the power law using a PowerNorm. SymLogNorm: two humps, one negative and one positive, The positive\nwith 5-times the amplitude. Linearly, you cannot see detail in the\nnegative hump. Here we logarithmically scale the positive and\nnegative data separately. Note that colorbar labels do not come out looking very good. Custom Norm: An example with a customized normalization. This one\nuses the example above, and normalizes the negative data differently\nfrom the positive. BoundaryNorm: For this one you provide the boundaries for your colors,\nand the Norm puts the first color in between the first pair, the\nsecond color between the second pair, etc. Total running time of the script: (0 minutes 2.627 seconds) Download Python source code: colormap_normalizations.py Download Jupyter notebook: colormap_normalizations.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n', \"N = 100\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\n\n# A low hump with a spike coming out of the top.  Needs to have\n# z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\n\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolor(X, Y, Z,\n                   norm=colors.LogNorm(vmin=Z.min(), vmax=Z.max()),\n                   cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='max')\n\npcm = ax[1].pcolor(X, Y, Z, cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='max')\n\", \"X, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]\nZ1 = (1 + np.sin(Y * 10.)) * X**2\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z1, norm=colors.PowerNorm(gamma=1. / 2.),\n                       cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='max')\n\npcm = ax[1].pcolormesh(X, Y, Z1, cmap='PuBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='max')\n\", \"X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ = 5 * np.exp(-X**2 - Y**2)\n\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=0.03, linscale=0.03,\n                                              vmin=-1.0, vmax=1.0, base=10),\n                       cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='both')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z),\n                       shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='both')\n\", \"X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Example of making your own norm.  Also see matplotlib.colors.\n# From Joe Kington: This one gives two different linear ramps:\n\n\nclass MidpointNormalize(colors.Normalize):\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        self.midpoint = midpoint\n        super().__init__(vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n        return np.ma.masked_array(np.interp(value, x, y))\n\", \"fig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=MidpointNormalize(midpoint=0.),\n                       cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='both')\n\npcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z),\n                       shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='both')\n\", \"fig, ax = plt.subplots(3, 1, figsize=(8, 8))\nax = ax.flatten()\n# even bounds gives a contour-like effect\nbounds = np.linspace(-1, 1, 10)\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=norm,\n                       cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[0], extend='both', orientation='vertical')\n\n# uneven bounds changes the colormapping:\nbounds = np.array([-0.25, -0.125, 0, 0.5, 1])\nnorm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\npcm = ax[1].pcolormesh(X, Y, Z, norm=norm, cmap='RdBu_r', shading='nearest')\nfig.colorbar(pcm, ax=ax[1], extend='both', orientation='vertical')\n\npcm = ax[2].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z1),\n                       shading='nearest')\nfig.colorbar(pcm, ax=ax[2], extend='both', orientation='vertical')\n\nplt.show()\n",
    "id": 54
},
{
    "title": "Colormap normalizations SymLogNorm#",
    "text": "Demonstration of using norm to map colormaps onto data in non-linear ways. Synthetic dataset consisting of two humps, one negative and one positive,\nthe positive with 8-times the amplitude.\nLinearly, the negative hump is almost invisible,\nand it is very difficult to see any detail of its profile.\nWith the logarithmic scaling applied to both positive and negative values,\nit is much easier to see the shape of each hump. See SymLogNorm. In order to find the best visualization for any particular dataset,\nit may be necessary to experiment with multiple different color scales.\nAs well as the SymLogNorm scaling, there is also\nthe option of using AsinhNorm (experimental), which has a smoother\ntransition between the linear and logarithmic regions of the transformation\napplied to the data values, \"Z\".\nIn the plots below, it may be possible to see contour-like artifacts\naround each hump despite there being no sharp features\nin the dataset itself. The asinh scaling shows a smoother shading\nof each hump. Total running time of the script: (0 minutes 2.338 seconds) Download Python source code: colormap_normalizations_symlognorm.py Download Jupyter notebook: colormap_normalizations_symlognorm.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n\ndef rbf(x, y):\n    return 1.0 / (1 + 5 * ((x ** 2) + (y ** 2)))\n\nN = 200\ngain = 8\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = rbf(X + 0.5, Y + 0.5)\nZ2 = rbf(X - 0.5, Y - 0.5)\nZ = gain * Z1 - Z2\n\nshadeopts = {'cmap': 'PRGn shading': 'gouraud'}\ncolormap = 'PRGn'\nlnrwidth = 0.5\n\nfig, ax = plt.subplots(2, 1, sharex=True, sharey=True)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=lnrwidth, linscale=1,\n                                              vmin=-gain, vmax=gain, base=10),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[0], extend='both')\nax[0].text(-2.5, 1.5, 'symlog')\n\npcm = ax[1].pcolormesh(X, Y, Z, vmin=-gain, vmax=gain,\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[1], extend='both')\nax[1].text(-2.5, 1.5, 'linear')\n\", \"fig, ax = plt.subplots(2, 1, sharex=True, sharey=True)\n\npcm = ax[0].pcolormesh(X, Y, Z,\n                       norm=colors.SymLogNorm(linthresh=lnrwidth, linscale=1,\n                                              vmin=-gain, vmax=gain, base=10),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[0], extend='both')\nax[0].text(-2.5, 1.5, 'symlog')\n\npcm = ax[1].pcolormesh(X, Y, Z,\n                       norm=colors.AsinhNorm(linear_width=lnrwidth,\n                                             vmin=-gain, vmax=gain),\n                       **shadeopts)\nfig.colorbar(pcm, ax=ax[1], extend='both')\nax[1].text(-2.5, 1.5, 'asinh')\n\n\nplt.show()\n",
    "id": 55
},
{
    "title": "Contour Corner Mask#",
    "text": "Illustrate the difference between corner_mask=False and\ncorner_mask=True for masked contour plots. The default is controlled by\nrcParamscontour.corner_mask (default: True). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf Download Python source code: contour_corner_mask.py Download Jupyter notebook: contour_corner_mask.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Data to plot.\nx, y = np.meshgrid(np.arange(7), np.arange(10))\nz = np.sin(0.5 * x) * np.cos(0.52 * y)\n\n# Mask various z values.\nmask = np.zeros_like(z, dtype=bool)\nmask[2, 3:5] = True\nmask[3:5, 4] = True\nmask[7, 2] = True\nmask[5, 0] = True\nmask[0, 6] = True\nz = np.ma.array(z, mask=mask)\n\ncorner_masks = [False, True]\nfig, axs = plt.subplots(ncols=2)\nfor ax, corner_mask in zip(axs, corner_masks):\n    cs = ax.contourf(x, y, z, corner_mask=corner_mask)\n    ax.contour(cs, colors='k')\n    ax.set_title(f'{corner_mask=}')\n\n    # Plot grid.\n    ax.grid(c='k', ls='-', alpha=0.3)\n\n    # Indicate masked points with red circles.\n    ax.plot(np.ma.array(x, mask=~mask), y, 'ro')\n\nplt.show()\n",
    "id": 56
},
{
    "title": "Contour Demo#",
    "text": "Illustrate simple contour plotting, contours on an image with\na colorbar for the contours, and labelled contours. See also the contour image example. Create a simple contour plot with labels using default colors. The inline\nargument to clabel will control whether the labels are draw over the line\nsegments of the contour, removing the lines beneath the label. Contour labels can be placed manually by providing list of positions (in data\ncoordinate). See Interactive functions\nfor interactive placement. You can force all the contours to be the same color. You can set negative contours to be solid instead of dashed: And you can manually specify the colors of the contour Or you can use a colormap to specify the colors; the default\ncolormap will be used for the contour lines References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.axes.Axes.clabel / matplotlib.pyplot.clabel matplotlib.axes.Axes.get_position matplotlib.axes.Axes.set_position Total running time of the script: (0 minutes 2.115 seconds) Download Python source code: contour_demo.py Download Jupyter notebook: contour_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\n\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n', \"fig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\nax.clabel(CS, inline=True, fontsize=10)\nax.set_title('Simplest default with labels')\n\", \"fig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\nmanual_locations = [\n    (-1, -1.4), (-0.62, -0.7), (-2, 0.5), (1.7, 1.2), (2.0, 1.4), (2.4, 1.7)]\nax.clabel(CS, inline=True, fontsize=10, manual=manual_locations)\nax.set_title('labels at selected locations')\n\", \"fig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6, colors='k')  # Negative contours default to dashed.\nax.clabel(CS, fontsize=9, inline=True)\nax.set_title('Single color - negative contours dashed')\n\", \"plt.rcParamscontour.negative_linestyle = 'solid'\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6, colors='k')  # Negative contours default to dashed.\nax.clabel(CS, fontsize=9, inline=True)\nax.set_title('Single color - negative contours solid')\n\", \"fig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z, 6,\n                linewidths=np.arange(.5, 4, .5),\n                colors=('r green blue', (1, 1, 0), '#afeeee 0.5'),\n                )\nax.clabel(CS, fontsize=9, inline=True)\nax.set_title('Crazy lines')\n\", \"fig, ax = plt.subplots()\nim = ax.imshow(Z, interpolation='bilinear', origin='lower',\n               cmap=cm.gray, extent=(-3, 3, -2, 2))\nlevels = np.arange(-1.2, 1.6, 0.2)\nCS = ax.contour(Z, levels, origin='lower', cmap='flag', extend='both',\n                linewidths=2, extent=(-3, 3, -2, 2))\n\n# Thicken the zero contour.\nlws = np.resize(CS.get_linewidth(), len(levels))\nlws[6] = 4\nCS.set_linewidth(lws)\n\nax.clabel(CS, levels[1::2],  # label every second level\n          inline=True, fmt='%1.1f', fontsize=14)\n\n# make a colorbar for the contour lines\nCB = fig.colorbar(CS, shrink=0.8)\n\nax.set_title('Lines with colorbar')\n\n# We can still add a colorbar for the image, too.\nCBI = fig.colorbar(im, orientation='horizontal', shrink=0.8)\n\n# This makes the original colorbar look a bit out of place,\n# so let's improve its position.\n\nl, b, w, h = ax.get_position().bounds\nll, bb, ww, hh = CB.ax.get_position().bounds\nCB.ax.set_position([ll, b + 0.1*h, ww, h*0.8])\n\nplt.show()\n",
    "id": 57
},
{
    "title": "Contour Image#",
    "text": "Test combinations of contouring, filled contouring, and image plotting.\nFor contour labelling, see also the contour demo example. The emphasis in this demo is on showing how to make contours register\ncorrectly on images, and on how to get both of them oriented as desired.\nIn particular, note the usage of the \"origin\" and \"extent\" keyword arguments to imshow and\ncontour. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.Normalize Download Python source code: contour_image.py Download Jupyter notebook: contour_image.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\n\n# Default delta is large because that makes it fast, and it illustrates\n# the correct registration between image and contours.\ndelta = 0.5\n\nextent = (-3, 4, -4, 3)\n\nx = np.arange(-3.0, 4.001, delta)\ny = np.arange(-4.0, 3.001, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Boost the upper limit to avoid truncation errors.\nlevels = np.arange(-2.0, 1.601, 0.4)\n\nnorm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max())\ncmap = cm.PRGn\n\nfig, _axs = plt.subplots(nrows=2, ncols=2)\nfig.subplots_adjust(hspace=0.3)\naxs = _axs.flatten()\n\ncset1 = axs[0].contourf(X, Y, Z, levels, norm=norm,\n                        cmap=cmap.resampled(len(levels) - 1))\n# It is not necessary, but for the colormap, we need only the\n# number of levels minus 1.  To avoid discretization error, use\n# either this number or a large number such as the default (256).\n\n# If we want lines as well as filled regions, we need to call\n# contour separately; don\\'t try to change the edgecolor or edgewidth\n# of the polygons in the collections returned by contourf.\n# Use levels output from previous call to guarantee they are the same.\n\ncset2 = axs[0].contour(X, Y, Z, cset1.levels, colors=\\'k\\')\n\n# We don\\'t really need dashed contour lines to indicate negative\n# regions, so let\\'s turn them off.\ncset2.set_linestyle(\\'solid\\')\n\n# It is easier here to make a separate call to contour than\n# to set up an array of colors and linewidths.\n# We are making a thick green line as a zero contour.\n# Specify the zero level as a tuple with only 0 in it.\n\ncset3 = axs[0].contour(X, Y, Z, (0,), colors=\\'g\\', linewidths=2)\naxs[0].set_title(\\'Filled contours\\')\nfig.colorbar(cset1, ax=axs[0])\n\n\naxs[1].imshow(Z, extent=extent, cmap=cmap, norm=norm)\naxs[1].contour(Z, levels, colors=\\'k\\', origin=\\'upper\\', extent=extent)\naxs[1].set_title(\"Image, origin \\'upper\\'\")\n\naxs[2].imshow(Z, origin=\\'lower\\', extent=extent, cmap=cmap, norm=norm)\naxs[2].contour(Z, levels, colors=\\'k\\', origin=\\'lower\\', extent=extent)\naxs[2].set_title(\"Image, origin \\'lower\\'\")\n\n# We will use the interpolation \"nearest\" here to show the actual\n# image pixels.\n# Note that the contour lines don\\'t extend to the edge of the box.\n# This is intentional. The Z values are defined at the center of each\n# image pixel (each color block on the following subplot), so the\n# domain that is contoured does not extend beyond these pixel centers.\nim = axs[3].imshow(Z, interpolation=\\'nearest\\', extent=extent,\n                   cmap=cmap, norm=norm)\naxs[3].contour(Z, levels, colors=\\'k\\', origin=\\'image\\', extent=extent)\nylim = axs[3].get_ylim()\naxs[3].set_ylim(ylim[::-1])\naxs[3].set_title(\"Origin from rc, reversed y-axis\")\nfig.colorbar(im, ax=axs[3])\n\nfig.tight_layout()\nplt.show()\n",
    "id": 58
},
{
    "title": "Contour Label Demo#",
    "text": "Illustrate some of the more advanced things that one can do with\ncontour labels. See also the contour demo example. Define our surface Make contour labels with custom level formatters Label contours with arbitrary strings using a dictionary Use a Formatter References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.clabel / matplotlib.pyplot.clabel matplotlib.ticker.LogFormatterMathtext matplotlib.ticker.TickHelper.create_dummy_axis Total running time of the script: (0 minutes 1.145 seconds) Download Python source code: contour_label_demo.py Download Jupyter notebook: contour_label_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n delta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n # This custom formatter removes trailing zeros, e.g. \"1.0\" becomes \"1\", and\n# then adds a percent sign.\ndef fmt(x):\n    s = f\"{x:.1f}\"\n    if s.endswith(\"0\"):\n        s = f\"{x:.0f}\"\n    return rf\"{s} \\\\%\" if plt.rcParamstext.usetex else f\"{s} %\"\n\n\n# Basic contour plot\nfig, ax = plt.subplots()\nCS = ax.contour(X, Y, Z)\n\nax.clabel(CS, CS.levels, inline=True, fmt=fmt, fontsize=10)\n', \"fig1, ax1 = plt.subplots()\n\n# Basic contour plot\nCS1 = ax1.contour(X, Y, Z)\n\nfmt = {}\nstrs = first second third fourth fifth sixth seventh\nfor l, s in zip(CS1.levels, strs):\n    fmt[l] = s\n\n# Label every other level using strings\nax1.clabel(CS1, CS1.levels[::2], inline=True, fmt=fmt, fontsize=10)\n\", 'fig2, ax2 = plt.subplots()\n\nCS2 = ax2.contour(X, Y, 100**Z, locator=plt.LogLocator())\nfmt = ticker.LogFormatterMathtext()\nfmt.create_dummy_axis()\nax2.clabel(CS2, CS2.levels, fmt=fmt)\nax2.set_title(\"$100^Z$\")\n\nplt.show()\n",
    "id": 59
},
{
    "title": "Contourf demo#",
    "text": "How to use the axes.Axes.contourf method to create filled contour plots.', \"We are using automatic selection of contour levels; this is usually not such\na good idea, because they don't occur on nice boundaries, but we do it here\nfor purposes of illustration.\", 'Now make a contour plot with the levels specified, and with the colormap\ngenerated automatically from a list of colors. Illustrate all 4 possible \"extend\" settings: This code demonstrates orienting contour plot data using the \"origin\" keyword References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.axes.Axes.clabel / matplotlib.pyplot.clabel matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.Colormap matplotlib.colors.Colormap.set_bad matplotlib.colors.Colormap.set_under matplotlib.colors.Colormap.set_over Total running time of the script: (0 minutes 2.348 seconds) Download Python source code: contourf_demo.py Download Jupyter notebook: contourf_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndelta = 0.025\n\nx = y = np.arange(-3.0, 3.01, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nnr, nc = Z.shape\n\n# put NaNs in one corner:\nZ[-nr // 6:, -nc // 6:] = np.nan\n# contourf will convert these to masked\n\n\nZ = np.ma.array(Z)\n# mask another corner:\nZ[:nr // 6, :nc // 6] = np.ma.masked\n\n# mask a circle in the middle:\ninterior = np.sqrt(X**2 + Y**2) < 0.5\nZ[interior] = np.ma.masked\n', \"fig1, ax2 = plt.subplots(layout='constrained')\nCS = ax2.contourf(X, Y, Z, 10, cmap=plt.cm.bone)\n\n# Note that in the following, we explicitly pass in a subset of the contour\n# levels used for the filled contours.  Alternatively, we could pass in\n# additional levels to provide extra resolution, or leave out the *levels*\n# keyword argument to use all of the original levels.\n\nCS2 = ax2.contour(CS, levels=CS.levels[::2], colors='r')\n\nax2.set_title('Nonsense (3 masked regions)')\nax2.set_xlabel('word length anomaly')\nax2.set_ylabel('sentence length anomaly')\n\n# Make a colorbar for the ContourSet returned by the contourf call.\ncbar = fig1.colorbar(CS)\ncbar.ax.set_ylabel('verbosity coefficient')\n# Add the contour line levels to the colorbar\ncbar.add_lines(CS2)\n\", \"fig2, ax2 = plt.subplots(layout='constrained')\nlevels = [-1.5, -1, -0.5, 0, 0.5, 1]\nCS3 = ax2.contourf(X, Y, Z, levels, colors=('r g b'), extend='both')\n# Our data range extends outside the range of levels; make\n# data below the lowest contour level yellow, and above the\n# highest level cyan:\nCS3.cmap.set_under('yellow')\nCS3.cmap.set_over('cyan')\n\nCS4 = ax2.contour(X, Y, Z, levels, colors=('k',), linewidths=(3,))\nax2.set_title('Listed colors (3 masked regions)')\nax2.clabel(CS4, fmt='%2.1f', colors='w', fontsize=14)\n\n# Notice that the colorbar gets all the information it\n# needs from the ContourSet object, CS3.\nfig2.colorbar(CS3)\n\", 'extends = neither\", \"both\", \"min\", \"max\ncmap = plt.colormapswinter.with_extremes(under=\"magenta\", over=\"yellow\")\n# Note: contouring simply excludes masked or nan regions, so\n# instead of using the \"bad\" colormap value for them, it draws\n# nothing at all in them.  Therefore, the following would have\n# no effect:\n# cmap.set_bad(\"red\")\n\nfig, axs = plt.subplots(2, 2, layout=\"constrained\")\n\nfor ax, extend in zip(axs.flat, extends):\n    cs = ax.contourf(X, Y, Z, levels, cmap=cmap, extend=extend)\n    fig.colorbar(cs, ax=ax, shrink=0.9)\n    ax.set_title(\"extend = %s\" % extend)\n    ax.locator_params(nbins=4)\n\nplt.show()\n x = np.arange(1, 10)\ny = x.reshape(-1, 1)\nh = x * y\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\nax1.set_title(\"origin=\\'upper\\'\")\nax2.set_title(\"origin=\\'lower\\'\")\nax1.contourf(h, levels=np.arange(5, 70, 5), extend=\\'both\\', origin=\"upper\")\nax2.contourf(h, levels=np.arange(5, 70, 5), extend=\\'both\\', origin=\"lower\")\n\nplt.show()\n",
    "id": 60
},
{
    "title": "Contourf Hatching#",
    "text": "Demo filled contour plots with hatched patterns. Plot 1: the simplest hatched plot with a colorbar Plot 2: a plot of hatches without color with a legend References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.contour.ContourSet matplotlib.contour.ContourSet.legend_elements Download Python source code: contourf_hatching.py Download Jupyter notebook: contourf_hatching.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# invent some numbers, turning the x and y arrays into simple\n# 2d arrays, which make combining them together easier.\nx = np.linspace(-3, 5, 150).reshape(1, -1)\ny = np.linspace(-3, 5, 120).reshape(-1, 1)\nz = np.cos(x) + np.sin(y)\n\n# we no longer need x and y to be 2 dimensional, so flatten them.\nx, y = x.flatten(), y.flatten()\n', \"fig1, ax1 = plt.subplots()\ncs = ax1.contourf(x, y, z, hatches=- / \\\\\\\\ //,\n                  cmap='gray', extend='both', alpha=0.5)\nfig1.colorbar(cs)\n\", \"fig2, ax2 = plt.subplots()\nn_levels = 6\nax2.contour(x, y, z, n_levels, colors='black', linestyles='-')\ncs = ax2.contourf(x, y, z, n_levels, colors='none',\n                  hatches=. / \\\\\\\\', None, '\\\\\\\\\\\\\\\\ *,\n                  extend='lower')\n\n# create a legend for the contour set\nartists, labels = cs.legend_elements(str_format='{:2.1f}'.format)\nax2.legend(artists, labels, handleheight=2, framealpha=1)\nplt.show()\n",
    "id": 61
},
{
    "title": "Contourf and log color scale#",
    "text": "Demonstrate use of a log color scale in contourf References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.ticker.LogLocator Download Python source code: contourf_log.py Download Jupyter notebook: contourf_log.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import ma\n\nfrom matplotlib import cm, ticker\n\nN = 100\nx = np.linspace(-3.0, 3.0, N)\ny = np.linspace(-2.0, 2.0, N)\n\nX, Y = np.meshgrid(x, y)\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nz = Z1 + 50 * Z2\n\n# Put in some negative values (lower left corner) to cause trouble with logs:\nz[:5, :5] = -1\n\n# The following is not strictly essential, but it will eliminate\n# a warning.  Comment it out to see the warning.\nz = ma.masked_where(z <= 0, z)\n\n\n# Automatic selection of levels works; setting the\n# log locator tells contourf to use a log scale:\nfig, ax = plt.subplots()\ncs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cm.PuBu_r)\n\n# Alternatively, you can manually set the levels\n# and the norm:\n# lev_exp = np.arange(np.floor(np.log10(z.min())-1),\n#                    np.ceil(np.log10(z.max())+1))\n# levs = np.power(10, lev_exp)\n# cs = ax.contourf(X, Y, z, levs, norm=colors.LogNorm())\n\ncbar = fig.colorbar(cs)\n\nplt.show()\n",
    "id": 62
},
{
    "title": "Contouring the solution space of optimizations#",
    "text": "Contour plotting is particularly handy when illustrating the solution\nspace of optimization problems. Not only can axes.Axes.contour be\nused to represent the topography of the objective function, it can be\nused to generate boundary curves of the constraint functions. The\nconstraint lines can be drawn with\nTickedStroke to distinguish the valid and\ninvalid sides of the constraint boundaries. axes.Axes.contour generates curves with larger values to the left\nof the contour. The angle parameter is measured zero ahead with\nincreasing values to the left. Consequently, when using\nTickedStroke to illustrate a constraint in\na typical optimization problem, the angle should be set between\nzero and 180 degrees. Download Python source code: contours_in_optimization_demo.py Download Jupyter notebook: contours_in_optimization_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\nnx = 101\nny = 105\n\n# Set up survey vectors\nxvec = np.linspace(0.001, 4.0, nx)\nyvec = np.linspace(0.001, 4.0, ny)\n\n# Set up survey matrices.  Design disk loading and gear ratio.\nx1, x2 = np.meshgrid(xvec, yvec)\n\n# Evaluate some stuff to plot\nobj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2\ng1 = -(3*x1 + x2 - 5.5)\ng2 = -(x1 + 2*x2 - 4.5)\ng3 = 0.8 + x1**-3 - x2\n\ncntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],\n                  colors=\\'black\\')\nax.clabel(cntr, fmt=\"%2.1f\", use_clabeltext=True)\n\ncg1 = ax.contour(x1, x2, g1, [0], colors=\\'sandybrown\\')\ncg1.set(path_effects=[patheffects.withTickedStroke(angle=135)])\n\ncg2 = ax.contour(x1, x2, g2, [0], colors=\\'orangered\\')\ncg2.set(path_effects=[patheffects.withTickedStroke(angle=60, length=2)])\n\ncg3 = ax.contour(x1, x2, g3, [0], colors=\\'mediumblue\\')\ncg3.set(path_effects=[patheffects.withTickedStroke(spacing=7)])\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nplt.show()\n",
    "id": 63
},
{
    "title": "BboxImage Demo#",
    "text": "A BboxImage can be used to position an image according to\na bounding box. This demo shows how to show an image inside a text.Text's\nbounding box as well as how to manually create a bounding box for the image.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.image.BboxImage matplotlib.transforms.Bbox matplotlib.transforms.TransformedBbox matplotlib.text.Text Download Python source code: demo_bboximage.py Download Jupyter notebook: demo_bboximage.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.image import BboxImage\nfrom matplotlib.transforms import Bbox, TransformedBbox\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# ----------------------------\n# Create a BboxImage with Text\n# ----------------------------\ntxt = ax1.text(0.5, 0.5, \"test\", size=30, ha=\"center\", color=\"w\")\nax1.add_artist(\n    BboxImage(txt.get_window_extent, data=np.arange(256).reshape((1, -1))))\n\n# ------------------------------------\n# Create a BboxImage for each colormap\n# ------------------------------------\n# List of all colormaps; skip reversed colormaps.\ncmap_names = sorted(m for m in plt.colormaps if not m.endswith(\"_r\"))\n\nncol = 2\nnrow = len(cmap_names) // ncol + 1\n\nxpad_fraction = 0.3\ndx = 1 / (ncol + xpad_fraction * (ncol - 1))\n\nypad_fraction = 0.3\ndy = 1 / (nrow + ypad_fraction * (nrow - 1))\n\nfor i, cmap_name in enumerate(cmap_names):\n    ix, iy = divmod(i, nrow)\n    bbox0 = Bbox.from_bounds(ix*dx*(1+xpad_fraction),\n                             1 - iy*dy*(1+ypad_fraction) - dy,\n                             dx, dy)\n    bbox = TransformedBbox(bbox0, ax2.transAxes)\n    ax2.add_artist(\n        BboxImage(bbox, cmap=cmap_name, data=np.arange(256).reshape((1, -1))))\n\nplt.show()\n",
    "id": 64
},
{
    "title": "Figimage Demo#",
    "text": "This illustrates placing images directly in the figure, with no Axes objects. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure matplotlib.figure.Figure.figimage / matplotlib.pyplot.figimage Download Python source code: figimage_demo.py Download Jupyter notebook: figimage_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nZ = np.arange(10000).reshape((100, 100))\nZ[:, 50:] = 1\n\nim1 = fig.figimage(Z, xo=50, yo=0, origin='lower')\nim2 = fig.figimage(Z, xo=100, yo=100, alpha=.8, origin='lower')\n\nplt.show()\n",
    "id": 65
},
{
    "title": "Creating annotated heatmaps#",
    "text": "It is often desirable to show data which depends on two independent\nvariables as a color coded image plot. This is often referred to as a\nheatmap. If the data is categorical, this would be called a categorical\nheatmap.', \"Matplotlib's imshow function makes\nproduction of such plots particularly easy.\", 'The following examples show how to create a heatmap with annotations.\nWe will start with an easy example and expand it to be usable as a\nuniversal function. We may start by defining some data. What we need is a 2D list or array\nwhich defines the data to color code. We then also need two lists or arrays\nof categories; of course the number of elements in those lists\nneed to match the data along the respective axes.\nThe heatmap itself is an imshow plot\nwith the labels set to the categories we have.\nNote that it is important to set both, the tick locations\n(set_xticks) as well as the\ntick labels (set_xticklabels),\notherwise they would become out of sync. The locations are just\nthe ascending integer numbers, while the ticklabels are the labels to show.\nFinally, we can label the data itself by creating a Text\nwithin each cell showing the value of that cell. As discussed in the Coding styles\none might want to reuse such code to create some kind of heatmap\nfor different input data and/or on different axes.\nWe create a function that takes the data and the row and column labels as\ninput, and allows arguments that are used to customize the plot Here, in addition to the above we also want to create a colorbar and\nposition the labels above of the heatmap instead of below it.\nThe annotations shall get different colors depending on a threshold\nfor better contrast against the pixel color.\nFinally, we turn the surrounding axes spines off and create\na grid of white lines to separate the cells. The above now allows us to keep the actual plot creation pretty compact. In the following we show the versatility of the previously created\nfunctions by applying it in different cases and using different arguments. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar Total running time of the script: (0 minutes 2.528 seconds) Download Python source code: image_annotated_heatmap.py Download Jupyter notebook: image_annotated_heatmap.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib\nimport matplotlib as mpl\n\n\nvegetables = cucumber\", \"tomato\", \"lettuce\", \"asparagus\",\n              \"potato\", \"wheat\", \"barley\nfarmers = Farmer Joe\", \"Upland Bros.\", \"Smith Gardening\",\n           \"Agrifun\", \"Organiculture\", \"BioGoods Ltd.\", \"Cornylee Corp.\n\nharvest = np.array([[0.8, 2.4, 2.5, 3.9, 0.0, 4.0, 0.0],\n                    [2.4, 0.0, 4.0, 1.0, 2.7, 0.0, 0.0],\n                    [1.1, 2.4, 0.8, 4.3, 1.9, 4.4, 0.0],\n                    [0.6, 0.0, 0.3, 0.0, 3.1, 0.0, 0.0],\n                    [0.7, 1.7, 0.6, 2.6, 2.2, 6.2, 0.0],\n                    [1.3, 1.2, 0.0, 0.0, 0.0, 3.2, 5.1],\n                    [0.1, 2.0, 0.0, 1.4, 0.0, 1.9, 6.3]])\n\n\nfig, ax = plt.subplots()\nim = ax.imshow(harvest)\n\n# Show all ticks and label them with the respective list entries\nax.set_xticks(np.arange(len(farmers)), labels=farmers)\nax.set_yticks(np.arange(len(vegetables)), labels=vegetables)\n\n# Rotate the tick labels and set their alignment.\nplt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n         rotation_mode=\"anchor\")\n\n# Loop over data dimensions and create text annotations.\nfor i in range(len(vegetables)):\n    for j in range(len(farmers)):\n        text = ax.text(j, i, harvest[i, j],\n                       ha=\"center\", va=\"center\", color=\"w\")\n\nax.set_title(\"Harvest of local farmers (in tons/year)\")\nfig.tight_layout()\nplt.show()\n def heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw=None, cbarlabel=\"\", **kwargs):\n    \"\"\"\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (M, N).\n    row_labels\n        A list or array of length M with the labels for the rows.\n    col_labels\n        A list or array of length N with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    \"\"\"\n\n    if ax is None:\n        ax = plt.gca()\n\n    if cbar_kw is None:\n        cbar_kw = {}\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va=\"bottom\")\n\n    # Show all ticks and label them with the respective list entries.\n    ax.set_xticks(np.arange(data.shape[1]), labels=col_labels)\n    ax.set_yticks(np.arange(data.shape[0]), labels=row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=-30, ha=\"right\",\n             rotation_mode=\"anchor\")\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which=\"minor\", color=\"w\", linestyle=\\'-\\', linewidth=3)\n    ax.tick_params(which=\"minor\", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt=\"{x:.2f}\",\n                     textcolors=(\"black\", \"white\"),\n                     threshold=None, **textkw):\n    \"\"\"\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image\\'s data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. \"$ {x:.2f}\", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    \"\"\"\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment=\"center\",\n              verticalalignment=\"center\")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each \"pixel\".\n    # Change the text\\'s color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) > threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n fig, ax = plt.subplots()\n\nim, cbar = heatmap(harvest, vegetables, farmers, ax=ax,\n                   cmap=\"YlGn\", cbarlabel=\"harvest [t/year]\")\ntexts = annotate_heatmap(im, valfmt=\"{x:.1f} t\")\n\nfig.tight_layout()\nplt.show()\n np.random.seed(19680801)\n\nfig, ((ax, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8, 6))\n\n# Replicate the above example with a different font size and colormap.\n\nim, _ = heatmap(harvest, vegetables, farmers, ax=ax,\n                cmap=\"Wistia\", cbarlabel=\"harvest [t/year]\")\nannotate_heatmap(im, valfmt=\"{x:.1f}\", size=7)\n\n# Create some new data, give further arguments to imshow (vmin),\n# use an integer format on the annotations and provide some colors.\n\ndata = np.random.randint(2, 100, size=(7, 7))\ny = [f\"Book {i}\" for i in range(1, 8)]\nx = [f\"Store {i}\" for i in list(\"ABCDEFG\")]\nim, _ = heatmap(data, y, x, ax=ax2, vmin=0,\n                cmap=\"magma_r\", cbarlabel=\"weekly sold copies\")\nannotate_heatmap(im, valfmt=\"{x:d}\", size=7, threshold=20,\n                 textcolors=(\"red\", \"white\"))\n\n# Sometimes even the data itself is categorical. Here we use a\n# `matplotlib.colors.BoundaryNorm` to get the data into classes\n# and use this to colorize the plot, but also to obtain the class\n# labels from an array of classes.\n\ndata = np.random.randn(6, 6)\ny = [f\"Prod. {i}\" for i in range(10, 70, 10)]\nx = [f\"Cycle {i}\" for i in range(1, 7)]\n\nqrates = list(\"ABCDEFG\")\nnorm = matplotlib.colors.BoundaryNorm(np.linspace(-3.5, 3.5, 8), 7)\nfmt = matplotlib.ticker.FuncFormatter(lambda x, pos: qrates[::-1][norm(x)])\n\nim, _ = heatmap(data, y, x, ax=ax3,\n                cmap=mpl.colormapsPiYG.resampled(7), norm=norm,\n                cbar_kw=dict(ticks=np.arange(-3, 4), format=fmt),\n                cbarlabel=\"Quality Rating\")\n\nannotate_heatmap(im, valfmt=fmt, size=9, fontweight=\"bold\", threshold=-1,\n                 textcolors=(\"red\", \"black\"))\n\n# We can nicely plot a correlation matrix. Since this is bound by -1 and 1,\n# we use those as vmin and vmax. We may also remove leading zeros and hide\n# the diagonal elements (which are all 1) by using a\n# `matplotlib.ticker.FuncFormatter`.\n\ncorr_matrix = np.corrcoef(harvest)\nim, _ = heatmap(corr_matrix, vegetables, vegetables, ax=ax4,\n                cmap=\"PuOr\", vmin=-1, vmax=1,\n                cbarlabel=\"correlation coeff.\")\n\n\ndef func(x, pos):\n    return f\"{x:.2f}\".replace(\"0.\", \".\").replace(\"1.00\", \"\")\n\nannotate_heatmap(im, valfmt=matplotlib.ticker.FuncFormatter(func), size=7)\n\n\nplt.tight_layout()\nplt.show()\n",
    "id": 66
},
{
    "title": "Image antialiasing#",
    "text": "Images are represented by discrete pixels, either on the screen or in an\nimage file. When data that makes up the image has a different resolution\nthan its representation on the screen we will see aliasing effects. How\nnoticeable these are depends on how much down-sampling takes place in\nthe change of resolution (if any). When subsampling data, aliasing is reduced by smoothing first and then\nsubsampling the smoothed data. In Matplotlib, we can do that\nsmoothing before mapping the data to colors, or we can do the smoothing\non the RGB(A) data in the final image. The differences between these are\nshown below, and controlled with the interpolation_stage keyword argument.', \"The default image interpolation in Matplotlib is 'antialiased', and\nit is applied to the data. This uses a\nhanning interpolation on the data provided by the user for reduced aliasing\nin most situations. Only when there is upsampling by a factor of 1, 2 or\n>=3 is 'nearest' neighbor interpolation used.\", 'Other anti-aliasing filters can be specified in Axes.imshow using the\ninterpolation keyword argument. First we generate a 450x450 pixel image with varying frequency content:', \"The following images are subsampled from 450 data pixels to either\n125 pixels or 250 pixels (depending on your display).\nThe Moir\u00e9 patterns in the 'nearest' interpolation are caused by the\nhigh-frequency data being subsampled. The 'antialiased' imaged\nstill has some Moir\u00e9 patterns as well, but they are greatly reduced.\", \"There are substantial differences between the 'data' interpolation and\nthe 'rgba' interpolation. The alternating bands of red and blue on the\nleft third of the image are subsampled. By interpolating in 'data' space\n(the default) the antialiasing filter makes the stripes close to white,\nbecause the average of -1 and +1 is zero, and zero is white in this\ncolormap.\", \"Conversely, when the anti-aliasing occurs in 'rgba' space, the red and\nblue are combined visually to make purple. This behaviour is more like a\ntypical image processing package, but note that purple is not in the\noriginal colormap, so it is no longer possible to invert individual\npixels back to their data value.\", \"Even up-sampling an image with 'nearest' interpolation will lead to Moir\u00e9\npatterns when the upsampling factor is not integer. The following image\nupsamples 500 data pixels to 530 rendered pixels. You may note a grid of\n30 line-like artifacts which stem from the 524 - 500 = 24 extra pixels that\nhad to be made up. Since interpolation is 'nearest' they are the same as a\nneighboring line of pixels and thus stretch the image locally so that it\nlooks distorted.\", 'Better antialiasing algorithms can reduce this effect:', \"Apart from the default 'hanning' antialiasing, imshow supports a\nnumber of different interpolation algorithms, which may work better or\nworse depending on the pattern.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow Total running time of the script: (0 minutes 2.792 seconds) Download Python source code: image_antialiasing.py Download Jupyter notebook: image_antialiasing.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n N = 450\nx = np.arange(N) / N - 0.5\ny = np.arange(N) / N - 0.5\naa = np.ones((N, N))\naa[::2, :] = -1\n\nX, Y = np.meshgrid(x, y)\nR = np.sqrt(X**2 + Y**2)\nf0 = 5\nk = 100\na = np.sin(np.pi * 2 * (f0 * R + k * R**2 / 2))\n# make the left hand side of this\na[:int(N / 2), :][R[:int(N / 2), :] < 0.4] = -1\na[:int(N / 2), :][R[:int(N / 2), :] < 0.3] = 1\naa[:, int(N / 3):] = a[:, int(N / 3):]\na = aa\n fig, axs = plt.subplots(2, 2, figsize=(5, 6), layout=\\'constrained\\')\naxs[0, 0].imshow(a, interpolation=\\'nearest\\', cmap=\\'RdBu_r\\')\naxs[0, 0].set_xlim(100, 200)\naxs[0, 0].set_ylim(275, 175)\naxs[0, 0].set_title(\\'Zoom\\')\n\nfor ax, interp, space in zip(axs.flat[1:],\n                             [\\'nearest\\', \\'antialiased\\', \\'antialiased\\,\n                             [\\'data\\', \\'data\\', \\'rgba\\):\n    ax.imshow(a, interpolation=interp, interpolation_stage=space,\n              cmap=\\'RdBu_r\\')\n    ax.set_title(f\"interpolation=\\'{interp}\\'\\\nspace=\\'{space}\\'\")\nplt.show()\n fig, ax = plt.subplots(figsize=(6.8, 6.8))\nax.imshow(a, interpolation=\\'nearest\\', cmap=\\'gray\\')\nax.set_title(\"upsampled by factor a 1.048, interpolation=\\'nearest\\'\")\nplt.show()\n fig, ax = plt.subplots(figsize=(6.8, 6.8))\nax.imshow(a, interpolation=\\'antialiased\\', cmap=\\'gray\\')\nax.set_title(\"upsampled by factor a 1.048, interpolation=\\'antialiased\\'\")\nplt.show()\n fig, axs = plt.subplots(1, 2, figsize=(7, 4), layout=\\'constrained\\')\nfor ax, interp in zip(axs, [\\'hanning\\', \\'lanczos\\):\n    ax.imshow(a, interpolation=interp, cmap=\\'gray\\')\n    ax.set_title(f\"interpolation=\\'{interp}\\'\")\nplt.show()\n",
    "id": 67
},
{
    "title": "Clipping images with patches#",
    "text": "Demo of image that's been clipped by a circular patch.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.artist.Artist.set_clip_path Download Python source code: image_clip_path.py Download Jupyter notebook: image_clip_path.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.patches as patches\n\nwith cbook.get_sample_data('grace_hopper.jpg') as image_file:\n    image = plt.imread(image_file)\n\nfig, ax = plt.subplots()\nim = ax.imshow(image)\npatch = patches.Circle((260, 200), radius=200, transform=ax.transData)\nim.set_clip_path(patch)\n\nax.axis('off')\nplt.show()\n",
    "id": 68
},
{
    "title": "Image demo#",
    "text": "Many ways to plot images in Matplotlib. The most common way to plot images in Matplotlib is with\nimshow. The following examples demonstrate much of the\nfunctionality of imshow and the many images you can create.', \"First we'll generate a simple bivariate normal distribution.\", 'It is also possible to show images of pictures.', \"It is also possible to interpolate images before displaying them. Be careful,\nas this may manipulate the way your data looks, but it can be helpful for\nachieving the look you want. Below we'll display the same (small) array,\ninterpolated with three different interpolation methods.\", \"The center of the pixel at A[i, j] is plotted at (i+0.5, i+0.5). If you\nare using interpolation='nearest', the region bounded by (i, j) and\n(i+1, j+1) will have the same color. If you are using interpolation,\nthe pixel center will have the same color as it does with nearest, but\nother pixels will be interpolated between the neighboring pixels.\", 'To prevent edge effects when doing interpolation, Matplotlib pads the input\narray with identical pixels around the edge: if you have a 5x5 array with\ncolors a-y as below: Matplotlib computes the interpolation and resizing on the padded array and then extracts the central region of the result. (Extremely old versions\nof Matplotlib (<0.63) did not pad the array, but instead adjusted the view\nlimits to hide the affected edge areas.)', \"This approach allows plotting the full extent of an array without\nedge effects, and for example to layer multiple images of different\nsizes over one another with different interpolation methods -- see\nLayer Images. It also implies\na performance hit, as this new temporary, padded array must be created.\nSophisticated interpolation also implies a performance hit; for maximal\nperformance or very large images, interpolation='nearest' is suggested.\", 'You can specify whether images should be plotted with the array origin\nx[0, 0] in the upper left or lower right by using the origin parameter.\nYou can also control the default setting image.origin in your\nmatplotlibrc file. For more on\nthis topic see the complete guide on origin and extent.', \"Finally, we'll show an image using a clip path.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.artist.Artist.set_clip_path matplotlib.patches.PathPatch Total running time of the script: (0 minutes 2.131 seconds) Download Python source code: image_demo.py Download Jupyter notebook: image_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nimport matplotlib.cm as cm\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n', \"delta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nfig, ax = plt.subplots()\nim = ax.imshow(Z, interpolation='bilinear', cmap=cm.RdYlGn,\n               origin='lower', extent=[-3, 3, -3, 3],\n               vmax=abs(Z).max(), vmin=-abs(Z).max())\n\nplt.show()\n\", \"# A sample image\nwith cbook.get_sample_data('grace_hopper.jpg') as image_file:\n    image = plt.imread(image_file)\n\n# And another image, using 256x256 16-bit integers.\nw, h = 256, 256\nwith cbook.get_sample_data('s1045.ima.gz') as datafile:\n    s = datafile.read()\nA = np.frombuffer(s, np.uint16).astype(float).reshape((w, h))\nextent = (0, 25, 0, 25)\n\nfig, ax = plt.subplot_mosaic([\n    hopper mri\n], figsize=(7, 3.5))\n\naxhopper.imshow(image)\naxhopper.axis('off')  # clear x-axis and y-axis\n\nim = axmri.imshow(A, cmap=plt.cm.hot, origin='upper', extent=extent)\n\nmarkers = [(15.9, 14.5), (16.8, 15)]\nx, y = zip(*markers)\naxmri.plot(x, y, 'o')\n\naxmri.set_title('MRI')\n\nplt.show()\n\", 'a b c d e\nf g h i j\nk l m n o\np q r s t\nu v w x y\n a a b c d e e\na a b c d e e\nf f g h i j j\nk k l m n o o\np p q r s t t\no u v w x y y\no u v w x y y\n', \"A = np.random.rand(5, 5)\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 3))\nfor ax, interp in zip(axs, nearest bilinear bicubic):\n    ax.imshow(A, interpolation=interp)\n    ax.set_title(interp.capitalize())\n    ax.grid(True)\n\nplt.show()\n\", \"x = np.arange(120).reshape((10, 12))\n\ninterp = 'bilinear'\nfig, axs = plt.subplots(nrows=2, sharex=True, figsize=(3, 5))\naxs[0].set_title('blue should be up')\naxs[0].imshow(x, origin='upper', interpolation=interp)\n\naxs[1].set_title('blue should be down')\naxs[1].imshow(x, origin='lower', interpolation=interp)\nplt.show()\n\", \"delta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\npath = Path([[0, 1], [1, 0], [0, -1], [-1, 0], [0, 1]])\npatch = PathPatch(path, facecolor='none')\n\nfig, ax = plt.subplots()\nax.add_patch(patch)\n\nim = ax.imshow(Z, interpolation='bilinear', cmap=cm.gray,\n               origin='lower', extent=[-3, 3, -3, 3],\n               clip_path=patch, clip_on=True)\nim.set_clip_path(patch)\n\nplt.show()\n",
    "id": 69
},
{
    "title": "Image Masked#",
    "text": "imshow with masked array input and out-of-range colors. The second subplot illustrates the use of BoundaryNorm to\nget a filled contour effect. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.BoundaryNorm matplotlib.colorbar.Colorbar.set_label Download Python source code: image_masked.py Download Jupyter notebook: image_masked.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as colors\n\n# compute some interesting data\nx0, x1 = -5, 5\ny0, y1 = -3, 3\nx = np.linspace(x0, x1, 500)\ny = np.linspace(y0, y1, 500)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\n# Set up a colormap:\npalette = plt.cm.gray.with_extremes(over='r', under='g', bad='b')\n# Alternatively, we could use\n# palette.set_bad(alpha = 0.0)\n# to make the bad region transparent.  This is the default.\n# If you comment out all the palette.set* lines, you will see\n# all the defaults; under and over will be colored with the\n# first and last colors in the palette, respectively.\nZm = np.ma.masked_where(Z > 1.2, Z)\n\n# By setting vmin and vmax in the norm, we establish the\n# range to which the regular palette color scale is applied.\n# Anything above that range is colored based on palette.set_over, etc.\n\n# set up the Axes objects\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 5.4))\n\n# plot using 'continuous' colormap\nim = ax1.imshow(Zm, interpolation='bilinear',\n                cmap=palette,\n                norm=colors.Normalize(vmin=-1.0, vmax=1.0),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax1.set_title('Green=low, Red=high, Blue=masked')\ncbar = fig.colorbar(im, extend='both', shrink=0.9, ax=ax1)\ncbar.set_label('uniform')\nax1.tick_params(axis='x', labelbottom=False)\n\n# Plot using a small number of colors, with unevenly spaced boundaries.\nim = ax2.imshow(Zm, interpolation='nearest',\n                cmap=palette,\n                norm=colors.BoundaryNorm([-1, -0.5, -0.2, 0, 0.2, 0.5, 1],\n                                         ncolors=palette.N),\n                aspect='auto',\n                origin='lower',\n                extent=[x0, x1, y0, y1])\nax2.set_title('With BoundaryNorm')\ncbar = fig.colorbar(im, extend='both', spacing='proportional',\n                    shrink=0.9, ax=ax2)\ncbar.set_label('proportional')\n\nfig.suptitle('imshow, with out-of-range and masked data')\nplt.show()\n",
    "id": 70
},
{
    "title": "Image nonuniform#",
    "text": "This illustrates the NonUniformImage class. It is not\navailable via an Axes method, but it is easily added to an\nAxes instance as shown here. Total running time of the script: (0 minutes 1.293 seconds) Download Python source code: image_nonuniform.py Download Jupyter notebook: image_nonuniform.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.image import NonUniformImage\n\ninterp = 'nearest'\n\n# Linear x array for cell centers:\nx = np.linspace(-4, 4, 9)\n\n# Highly nonlinear x array:\nx2 = x**3\n\ny = np.linspace(-4, 4, 9)\n\nz = np.sqrt(x[np.newaxis, :]**2 + y[:, np.newaxis]**2)\n\nfig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\nfig.suptitle('NonUniformImage class', fontsize='large')\nax = axs[0, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[0, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\ninterp = 'bilinear'\n\nax = axs[1, 0]\nim = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x, y, z)\nax.add_image(im)\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nax = axs[1, 1]\nim = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),\n                     cmap=cm.Purples)\nim.set_data(x2, y, z)\nax.add_image(im)\nax.set_xlim(-64, 64)\nax.set_ylim(-4, 4)\nax.set_title(interp)\n\nplt.show()\n",
    "id": 71
},
{
    "title": "Blend transparency with color in 2D images#",
    "text": "Blend transparency with color to highlight parts of data with imshow. A common use for matplotlib.pyplot.imshow is to plot a 2D statistical\nmap. The function makes it easy to visualize a 2D matrix as an image and add\ntransparency to the output. For example, one can plot a statistic (such as a\nt-statistic) and color the transparency of each pixel according to its p-value.\nThis example demonstrates how you can achieve this effect. First we will generate some data, in this case, we\\'ll create two 2D \"blobs\"\nin a 2D grid. One blob will be positive, and the other negative.', \"The simplest way to include transparency when plotting data with\nmatplotlib.pyplot.imshow is to pass an array matching the shape of\nthe data to the alpha argument. For example, we'll create a gradient\nmoving from left to right below.\", \"Finally, we'll recreate the same plot, but this time we'll use transparency\nto highlight the extreme values in the data. This is often used to highlight\ndata points with smaller p-values. We'll also add in contour lines to\nhighlight the image values.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.colors.Normalize matplotlib.axes.Axes.set_axis_off Download Python source code: image_transparency_blend.py Download Jupyter notebook: image_transparency_blend.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import Normalize\n\n\ndef normal_pdf(x, mean, var):\n    return np.exp(-(x - mean)**2 / (2*var))\n\n\n# Generate the space in which the blobs will live\nxmin, xmax, ymin, ymax = (0, 100, 0, 100)\nn_bins = 100\nxx = np.linspace(xmin, xmax, n_bins)\nyy = np.linspace(ymin, ymax, n_bins)\n\n# Generate the blobs. The range of the values is roughly -.0002 to .0002\nmeans_high = [20, 50]\nmeans_low = [50, 60]\nvar = [150, 200]\n\ngauss_x_high = normal_pdf(xx, means_high[0], var[0])\ngauss_y_high = normal_pdf(yy, means_high[1], var[0])\n\ngauss_x_low = normal_pdf(xx, means_low[0], var[1])\ngauss_y_low = normal_pdf(yy, means_low[1], var[1])\n\nweights = (np.outer(gauss_y_high, gauss_x_high)\n           - np.outer(gauss_y_low, gauss_x_low))\n\n# We'll also create a grey background into which the pixels will fade\ngreys = np.full((*weights.shape, 3), 70, dtype=np.uint8)\n\n# First we'll plot these blobs using ``imshow`` without transparency.\nvmax = np.abs(weights).max()\nimshow_kwargs = {\n    'vmax': vmax,\n    'vmin': -vmax,\n    'cmap': 'RdYlBu',\n    'extent': (xmin, xmax, ymin, ymax),\n}\n\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, **imshow_kwargs)\nax.set_axis_off()\n\", '# Create an alpha channel of linearly increasing values moving to the right.\nalphas = np.ones(weights.shape)\nalphas[:, 30:] = np.linspace(1, 0, 70)\n\n# Create the figure and image\n# Note that the absolute values may be slightly different\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, alpha=alphas, **imshow_kwargs)\nax.set_axis_off()\n', \"# Create an alpha channel based on weight values\n# Any value whose absolute value is > .0001 will have zero transparency\nalphas = Normalize(0, .3, clip=True)(np.abs(weights))\nalphas = np.clip(alphas, .4, 1)  # alpha value clipped at the bottom at .4\n\n# Create the figure and image\n# Note that the absolute values may be slightly different\nfig, ax = plt.subplots()\nax.imshow(greys)\nax.imshow(weights, alpha=alphas, **imshow_kwargs)\n\n# Add contour lines to further highlight different levels.\nax.contour(weights[::-1], levels=[-.1, .1], colors='k', linestyles='-')\nax.set_axis_off()\nplt.show()\n\nax.contour(weights[::-1], levels=[-.0001, .0001], colors='k', linestyles='-')\nax.set_axis_off()\nplt.show()\n",
    "id": 72
},
{
    "title": "Modifying the coordinate formatter#",
    "text": "Modify the coordinate formatter to report the image \"z\" value of the nearest\npixel given x and y. This functionality is built in by default; this example\njust showcases how to customize the format_coord function. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.format_coord matplotlib.axes.Axes.imshow Download Python source code: image_zcoord.py Download Jupyter notebook: image_zcoord.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nX = 10*np.random.rand(5, 3)\n\nfig, ax = plt.subplots()\nax.imshow(X)\n\n\ndef format_coord(x, y):\n    col = round(x)\n    row = round(y)\n    nrows, ncols = X.shape\n    if 0 <= col < ncols and 0 <= row < nrows:\n        z = X[row, col]\n        return f'x={x:1.4f}, y={y:1.4f}, z={z:1.4f}'\n    else:\n        return f'x={x:1.4f}, y={y:1.4f}'\n\n\nax.format_coord = format_coord\nplt.show()\n",
    "id": 73
},
{
    "title": "Interpolations for imshow#",
    "text": "This example displays the difference between interpolation methods for\nimshow. If interpolation is None, it defaults to the rcParamsimage.interpolation (default: \\'antialiased\\').\nIf the interpolation is \\'none\\', then no interpolation is performed for the\nAgg, ps and pdf backends. Other backends will default to \\'antialiased\\'.', \"For the Agg, ps and pdf backends, interpolation='none' works well when a\nbig image is scaled down, while interpolation='nearest' works well when\na small image is scaled up.\", \"See Image antialiasing for a\ndiscussion on the default interpolation='antialiased' option.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow Total running time of the script: (0 minutes 1.438 seconds) Download Python source code: interpolation_methods.py Download Jupyter notebook: interpolation_methods.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nmethods = [None, 'none nearest bilinear bicubic spline16',\n           'spline36 hanning hamming hermite kaiser quadric',\n           'catrom gaussian bessel mitchell sinc lanczos\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ngrid = np.random.rand(4, 4)\n\nfig, axs = plt.subplots(nrows=3, ncols=6, figsize=(9, 6),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\nfor ax, interp_method in zip(axs.flat, methods):\n    ax.imshow(grid, interpolation=interp_method, cmap='viridis')\n    ax.set_title(str(interp_method))\n\nplt.tight_layout()\nplt.show()\n",
    "id": 74
},
{
    "title": "Contour plot of irregularly spaced data#",
    "text": "Comparison of a contour plot of irregularly spaced data interpolated\non a regular grid versus a tricontour plot for an unstructured triangular grid. Since contour and contourf expect the data to live\non a regular grid, plotting a contour plot of irregularly spaced data requires\ndifferent methods. The two options are: Interpolate the data to a regular grid first. This can be done with on-board\nmeans, e.g. via LinearTriInterpolator or using external functionality\ne.g. via scipy.interpolate.griddata. Then plot the interpolated data with\nthe usual contour. Directly use tricontour or tricontourf which will\nperform a triangulation internally. This example shows both methods in action. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.contour / matplotlib.pyplot.contour matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf Download Python source code: irregulardatagrid.py Download Jupyter notebook: irregulardatagrid.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nnp.random.seed(19680801)\nnpts = 200\nngridx = 100\nngridy = 200\nx = np.random.uniform(-2, 2, npts)\ny = np.random.uniform(-2, 2, npts)\nz = x * np.exp(-x**2 - y**2)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2)\n\n# -----------------------\n# Interpolation on a grid\n# -----------------------\n# A contour plot of irregularly spaced data coordinates\n# via interpolation on a grid.\n\n# Create grid values first.\nxi = np.linspace(-2.1, 2.1, ngridx)\nyi = np.linspace(-2.1, 2.1, ngridy)\n\n# Linearly interpolate the data (x, y) on a grid defined by (xi, yi).\ntriang = tri.Triangulation(x, y)\ninterpolator = tri.LinearTriInterpolator(triang, z)\nXi, Yi = np.meshgrid(xi, yi)\nzi = interpolator(Xi, Yi)\n\n# Note that scipy.interpolate provides means to interpolate data on a grid\n# as well. The following would be an alternative to the four lines above:\n# from scipy.interpolate import griddata\n# zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method=\\'linear\\')\n\nax1.contour(xi, yi, zi, levels=14, linewidths=0.5, colors=\\'k\\')\ncntr1 = ax1.contourf(xi, yi, zi, levels=14, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr1, ax=ax1)\nax1.plot(x, y, \\'ko\\', ms=3)\nax1.set(xlim=(-2, 2), ylim=(-2, 2))\nax1.set_title(\\'grid and contour (%d points, %d grid points)\\' %\n              (npts, ngridx * ngridy))\n\n# ----------\n# Tricontour\n# ----------\n# Directly supply the unordered, irregularly spaced coordinates\n# to tricontour.\n\nax2.tricontour(x, y, z, levels=14, linewidths=0.5, colors=\\'k\\')\ncntr2 = ax2.tricontourf(x, y, z, levels=14, cmap=\"RdBu_r\")\n\nfig.colorbar(cntr2, ax=ax2)\nax2.plot(x, y, \\'ko\\', ms=3)\nax2.set(xlim=(-2, 2), ylim=(-2, 2))\nax2.set_title(\\'tricontour (%d points)\\' % npts)\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n",
    "id": 75
},
{
    "title": "Layer Images#",
    "text": "Layer images above one another using alpha blending References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow Download Python source code: layer_images.py Download Jupyter notebook: layer_images.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef func3(x, y):\n    return (1 - x / 2 + x**5 + y**3) * np.exp(-(x**2 + y**2))\n\n\n# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\nx = np.arange(-3.0, 3.0, dx)\ny = np.arange(-3.0, 3.0, dy)\nX, Y = np.meshgrid(x, y)\n\n# when layering multiple images, the images need to have the same\n# extent.  This does not mean they need to have the same shape, but\n# they both need to render to the same coordinate system determined by\n# xmin, xmax, ymin, ymax.  Note if you use different interpolations\n# for the images their apparent extent could be different due to\n# interpolation edge effects\n\nextent = np.min(x), np.max(x), np.min(y), np.max(y)\nfig = plt.figure(frameon=False)\n\nZ1 = np.add.outer(range(8), range(8)) % 2  # chessboard\nim1 = plt.imshow(Z1, cmap=plt.cm.gray, interpolation='nearest',\n                 extent=extent)\n\nZ2 = func3(X, Y)\n\nim2 = plt.imshow(Z2, cmap=plt.cm.viridis, alpha=.9, interpolation='bilinear',\n                 extent=extent)\n\nplt.show()\n",
    "id": 76
},
{
    "title": "Visualize matrices with matshow#",
    "text": "matshow visualizes a 2D matrix or array as color-coded image. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow Download Python source code: matshow.py Download Jupyter notebook: matshow.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# a 2D array with linearly increasing values on the diagonal\na = np.diag(range(15))\n\nplt.matshow(a)\n\nplt.show()\n",
    "id": 77
},
{
    "title": "Multiple images#",
    "text": "Make a set of images with a single colormap, norm, and colorbar. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.Normalize matplotlib.cm.ScalarMappable.set_cmap matplotlib.cm.ScalarMappable.set_norm matplotlib.cm.ScalarMappable.set_clim matplotlib.cbook.CallbackRegistry.connect Download Python source code: multi_image.py Download Jupyter notebook: multi_image.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\n\nnp.random.seed(19680801)\nNr = 3\nNc = 2\n\nfig, axs = plt.subplots(Nr, Nc)\nfig.suptitle(\\'Multiple images\\')\n\nimages = []\nfor i in range(Nr):\n    for j in range(Nc):\n        # Generate data with a range that varies from one plot to the next.\n        data = ((1 + i + j) / 10) * np.random.rand(10, 20)\n        images.append(axs[i, j].imshow(data))\n        axs[i, j].label_outer()\n\n# Find the min and max of all colors for use in setting the color scale.\nvmin = min(image.get_array().min() for image in images)\nvmax = max(image.get_array().max() for image in images)\nnorm = colors.Normalize(vmin=vmin, vmax=vmax)\nfor im in images:\n    im.set_norm(norm)\n\nfig.colorbar(images[0], ax=axs, orientation=\\'horizontal\\', fraction=.1)\n\n\n# Make images respond to changes in the norm of other images (e.g. via the\n# \"edit axis, curves and images parameters\" GUI on Qt), but be careful not to\n# recurse infinitely!\ndef update(changed_image):\n    for im in images:\n        if (changed_image.get_cmap() != im.get_cmap()\n                or changed_image.get_clim() != im.get_clim()):\n            im.set_cmap(changed_image.get_cmap())\n            im.set_clim(changed_image.get_clim())\n\n\nfor im in images:\n    im.callbacks.connect(\\'changed\\', update)\n\nplt.show()\n",
    "id": 78
},
{
    "title": "Pcolor demo#",
    "text": "Generating images with pcolor. Pcolor allows you to generate 2D image-style plots. Below we will show how\nto do so in Matplotlib. Demonstrates similarities between pcolor,\npcolormesh, imshow and\npcolorfast for drawing quadrilateral grids.\nNote that we call imshow with aspect=\"auto\" so that it doesn\\'t force\nthe data pixels to be square (the default is aspect=\"equal\"). The following shows pcolor plots with a log scale. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pcolor / matplotlib.pyplot.pcolor matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh matplotlib.axes.Axes.pcolorfast matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.LogNorm Total running time of the script: (0 minutes 1.645 seconds) Download Python source code: pcolor_demo.py Download Jupyter notebook: pcolor_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LogNorm\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n', \"Z = np.random.rand(6, 10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\nc = ax0.pcolor(Z)\nax0.set_title('default: no edges')\n\nc = ax1.pcolor(Z, edgecolors='k', linewidths=4)\nax1.set_title('thick edges')\n\nfig.tight_layout()\nplt.show()\n\", '# make these smaller to increase the resolution\ndx, dy = 0.15, 0.05\n\n# generate 2 2d grids for the x & y bounds\ny, x = np.mgrid[-3:3+dy:dy, -3:3+dx:dx]\nz = (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)\n# x and y are bounds, so z should be the value *inside* those bounds.\n# Therefore, remove the last value from the z array.\nz = z[:-1, :-1]\nz_min, z_max = -abs(z).max(), abs(z).max()\n\nfig, axs = plt.subplots(2, 2)\n\nax = axs[0, 0]\nc = ax.pcolor(x, y, z, cmap=\\'RdBu\\', vmin=z_min, vmax=z_max)\nax.set_title(\\'pcolor\\')\nfig.colorbar(c, ax=ax)\n\nax = axs[0, 1]\nc = ax.pcolormesh(x, y, z, cmap=\\'RdBu\\', vmin=z_min, vmax=z_max)\nax.set_title(\\'pcolormesh\\')\nfig.colorbar(c, ax=ax)\n\nax = axs[1, 0]\nc = ax.imshow(z, cmap=\\'RdBu\\', vmin=z_min, vmax=z_max,\n              extent=[x.min(), x.max(), y.min(), y.max()],\n              interpolation=\\'nearest\\', origin=\\'lower\\', aspect=\\'auto\\')\nax.set_title(\\'image (nearest, aspect=\"auto\")\\')\nfig.colorbar(c, ax=ax)\n\nax = axs[1, 1]\nc = ax.pcolorfast(x, y, z, cmap=\\'RdBu\\', vmin=z_min, vmax=z_max)\nax.set_title(\\'pcolorfast\\')\nfig.colorbar(c, ax=ax)\n\nfig.tight_layout()\nplt.show()\n', \"N = 100\nX, Y = np.meshgrid(np.linspace(-3, 3, N), np.linspace(-2, 2, N))\n\n# A low hump with a spike coming out.\n# Needs to have z/colour axis on a log scale, so we see both hump and spike.\n# A linear scale only shows the spike.\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X * 10)**2 - (Y * 10)**2)\nZ = Z1 + 50 * Z2\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\nc = ax0.pcolor(X, Y, Z, shading='auto',\n               norm=LogNorm(vmin=Z.min(), vmax=Z.max()), cmap='PuBu_r')\nfig.colorbar(c, ax=ax0)\n\nc = ax1.pcolor(X, Y, Z, cmap='PuBu_r', shading='auto')\nfig.colorbar(c, ax=ax1)\n\nplt.show()\n",
    "id": 79
},
{
    "title": "pcolormesh grids and shading#",
    "text": "axes.Axes.pcolormesh and pcolor have a few options for\nhow grids are laid out and the shading between the grid points. Generally, if Z has shape (M, N) then the grid X and Y can be\nspecified with either shape (M+1, N+1) or (M, N), depending on the\nargument for the shading keyword argument. Note that below we specify\nvectors x as either length N or N+1 and y as length M or M+1, and\npcolormesh internally makes the mesh matrices X and Y from\nthe input vectors.', \"The grid specification with the least assumptions is shading='flat'\nand if the grid is one larger than the data in each dimension, i.e. has shape\n(M+1, N+1). In that case X and Y specify the corners of quadrilaterals\nthat are colored with the values in Z. Here we specify the edges of the\n(3, 5) quadrilaterals with X and Y that are (4, 6).\", \"Often, however, data is provided where X and Y match the shape of Z.\nWhile this makes sense for other shading types, it is not permitted\nwhen shading='flat'. Historically, Matplotlib silently dropped the last\nrow and column of Z in this case, to match Matlab's behavior. If this\nbehavior is still desired, simply drop the last row and column manually:\", \"Usually, dropping a row and column of data is not what the user means when\nthey make X, Y and Z all the same shape. For this case, Matplotlib\nallows shading='nearest' and centers the colored quadrilaterals on the\ngrid points.\", \"If a grid that is not the correct shape is passed with shading='nearest'\nan error is raised.\", \"It's possible that the user would like the code to automatically choose which\nto use, in this case shading='auto' will decide whether to use 'flat' or\n'nearest' shading based on the shapes of X, Y and Z.\", 'Gouraud shading can also\nbe specified, where the color in the quadrilaterals is linearly interpolated\nbetween the grid points. The shapes of X, Y, Z must be the same. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh Total running time of the script: (0 minutes 1.792 seconds) Download Python source code: pcolormesh_grids.py Download Jupyter notebook: pcolormesh_grids.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n nrows = 3\nncols = 5\nZ = np.arange(nrows * ncols).reshape(nrows, ncols)\nx = np.arange(ncols + 1)\ny = np.arange(nrows + 1)\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z, shading=\\'flat\\', vmin=Z.min(), vmax=Z.max())\n\n\ndef _annotate(ax, x, y, title):\n    # this all gets repeated below:\n    X, Y = np.meshgrid(x, y)\n    ax.plot(X.flat, Y.flat, \\'o\\', color=\\'m\\')\n    ax.set_xlim(-0.7, 5.2)\n    ax.set_ylim(-0.7, 3.2)\n    ax.set_title(title)\n\n_annotate(ax, x, y, \"shading=\\'flat\\'\")\n x = np.arange(ncols)  # note *not* ncols + 1 as before\ny = np.arange(nrows)\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z[:-1, :-1], shading=\\'flat\\', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading=\\'flat\\': X, Y, C same shape\")\n fig, ax = plt.subplots()\nax.pcolormesh(x, y, Z, shading=\\'nearest\\', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading=\\'nearest\\'\")\n fig, axs = plt.subplots(2, 1, layout=\\'constrained\\')\nax = axs[0]\nx = np.arange(ncols)\ny = np.arange(nrows)\nax.pcolormesh(x, y, Z, shading=\\'auto\\', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading=\\'auto\\'; X, Y, Z: same shape (nearest)\")\n\nax = axs[1]\nx = np.arange(ncols + 1)\ny = np.arange(nrows + 1)\nax.pcolormesh(x, y, Z, shading=\\'auto\\', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading=\\'auto\\'; X, Y one larger than Z (flat)\")\n fig, ax = plt.subplots(layout=\\'constrained\\')\nx = np.arange(ncols)\ny = np.arange(nrows)\nax.pcolormesh(x, y, Z, shading=\\'gouraud\\', vmin=Z.min(), vmax=Z.max())\n_annotate(ax, x, y, \"shading=\\'gouraud\\'; X, Y same shape as Z\")\n\nplt.show()\n",
    "id": 80
},
{
    "title": "pcolormesh#",
    "text": "axes.Axes.pcolormesh allows you to generate 2D image-style plots.\nNote that it is faster than the similar pcolor. We usually specify a pcolormesh by defining the edge of quadrilaterals and\nthe value of the quadrilateral. Note that here x and y each have one\nextra element than Z in the respective dimension. Note that we can also specify matrices for X and Y and have\nnon-rectilinear quadrilaterals. Often a user wants to pass X and Y with the same sizes as Z to\naxes.Axes.pcolormesh. This is also allowed if shading=\\'auto\\' is\npassed (default set by rcParamspcolor.shading (default: \\'auto\\')). Pre Matplotlib 3.3,\nshading=\\'flat\\' would drop the last column and row of Z, but now gives\nan error. If this is really what you want, then simply drop the last row and\ncolumn of Z manually: Shows how to combine Normalization and Colormap instances to draw\n\"levels\" in axes.Axes.pcolor, axes.Axes.pcolormesh\nand axes.Axes.imshow type plots in a similar\nway to the levels keyword argument to contour/contourf. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors.BoundaryNorm matplotlib.ticker.MaxNLocator Total running time of the script: (0 minutes 1.224 seconds) Download Python source code: pcolormesh_levels.py Download Jupyter notebook: pcolormesh_levels.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import BoundaryNorm\nfrom matplotlib.ticker import MaxNLocator\n np.random.seed(19680801)\nZ = np.random.rand(6, 10)\nx = np.arange(-0.5, 10, 1)  # len = 11\ny = np.arange(4.5, 11, 1)  # len = 7\n\nfig, ax = plt.subplots()\nax.pcolormesh(x, y, Z)\n x = np.arange(-0.5, 10, 1)  # len = 11\ny = np.arange(4.5, 11, 1)  # len = 7\nX, Y = np.meshgrid(x, y)\nX = X + 0.2 * Y  # tilt the coordinates.\nY = Y + 0.3 * X\n\nfig, ax = plt.subplots()\nax.pcolormesh(X, Y, Z)\n x = np.arange(10)  # len = 10\ny = np.arange(6)  # len = 6\nX, Y = np.meshgrid(x, y)\n\nfig, axs = plt.subplots(2, 1, sharex=True, sharey=True)\naxs[0].pcolormesh(X, Y, Z, vmin=np.min(Z), vmax=np.max(Z), shading=\\'auto\\')\naxs[0].set_title(\"shading=\\'auto\\' = \\'nearest\\'\")\naxs[1].pcolormesh(X, Y, Z[:-1, :-1], vmin=np.min(Z), vmax=np.max(Z),\n                  shading=\\'flat\\')\naxs[1].set_title(\"shading=\\'flat\\'\")\n', \"# make these smaller to increase the resolution\ndx, dy = 0.05, 0.05\n\n# generate 2 2d grids for the x & y bounds\ny, x = np.mgrid[slice(1, 5 + dy, dy),\n                slice(1, 5 + dx, dx)]\n\nz = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)\n\n# x and y are bounds, so z should be the value *inside* those bounds.\n# Therefore, remove the last value from the z array.\nz = z[:-1, :-1]\nlevels = MaxNLocator(nbins=15).tick_values(z.min(), z.max())\n\n\n# pick the desired colormap, sensible levels, and define a normalization\n# instance which takes data values and translates those into levels.\ncmap = plt.colormapsPiYG\nnorm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)\n\nfig, (ax0, ax1) = plt.subplots(nrows=2)\n\nim = ax0.pcolormesh(x, y, z, cmap=cmap, norm=norm)\nfig.colorbar(im, ax=ax0)\nax0.set_title('pcolormesh with levels')\n\n\n# contours are *point* based plots, so convert our bound into point\n# centers\ncf = ax1.contourf(x[:-1, :-1] + dx/2.,\n                  y[:-1, :-1] + dy/2., z, levels=levels,\n                  cmap=cmap)\nfig.colorbar(cf, ax=ax1)\nax1.set_title('contourf with levels')\n\n# adjust spacing between subplots so `ax1` title and `ax0` tick labels\n# don't overlap\nfig.tight_layout()\n\nplt.show()\n",
    "id": 81
},
{
    "title": "Streamplot#",
    "text": "A stream plot, or streamline plot, is used to display 2D vector fields. This\nexample shows a few features of the streamplot function: Varying the color along a streamline. Varying the density of streamlines. Varying the line width along a streamline. Controlling the starting points of streamlines. Streamlines skipping masked regions and NaN values. Unbroken streamlines even when exceeding the limit of lines within a single\ngrid cell. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.streamplot / matplotlib.pyplot.streamplot matplotlib.gridspec.GridSpec Total running time of the script: (0 minutes 3.501 seconds) Download Python source code: plot_streamplot.py Download Jupyter notebook: plot_streamplot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nw = 3\nY, X = np.mgrid[-w:w:100j, -w:w:100j]\nU = -1 - X**2 + Y\nV = 1 + X - Y**2\nspeed = np.sqrt(U**2 + V**2)\n\nfig, axs = plt.subplots(3, 2, figsize=(7, 9), height_ratios=[1, 1, 2])\naxs = axs.flat\n\n#  Varying density along a streamline\naxs[0].streamplot(X, Y, U, V, density=[0.5, 1])\naxs[0].set_title('Varying Density')\n\n# Varying color along a streamline\nstrm = axs[1].streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')\nfig.colorbar(strm.lines)\naxs[1].set_title('Varying Color')\n\n#  Varying line width along a streamline\nlw = 5*speed / speed.max()\naxs[2].streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)\naxs[2].set_title('Varying Line Width')\n\n# Controlling the starting points of the streamlines\nseed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])\n\nstrm = axs[3].streamplot(X, Y, U, V, color=U, linewidth=2,\n                         cmap='autumn', start_points=seed_points.T)\nfig.colorbar(strm.lines)\naxs[3].set_title('Controlling Starting Points')\n\n# Displaying the starting points with blue symbols.\naxs[3].plot(seed_points[0], seed_points[1], 'bo')\naxs[3].set(xlim=(-w, w), ylim=(-w, w))\n\n# Create a mask\nmask = np.zeros(U.shape, dtype=bool)\nmask[40:60, 40:60] = True\nU[:20, :20] = np.nan\nU = np.ma.array(U, mask=mask)\n\naxs[4].streamplot(X, Y, U, V, color='r')\naxs[4].set_title('Streamplot with Masking')\n\naxs[4].imshow(~mask, extent=(-w, w, -w, w), alpha=0.5, cmap='gray',\n              aspect='auto')\naxs[4].set_aspect('equal')\n\naxs[5].streamplot(X, Y, U, V, broken_streamlines=False)\naxs[5].set_title('Streamplot with unbroken streamlines')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 82
},
{
    "title": "QuadMesh Demo#",
    "text": "pcolormesh uses a QuadMesh,\na faster generalization of pcolor, but with some restrictions. This demo illustrates a bug in quadmesh with masked data. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh Download Python source code: quadmesh_demo.py Download Jupyter notebook: quadmesh_demo.ipynb ",
    "code": "import numpy as np\n\nfrom matplotlib import pyplot as plt\n\nn = 12\nx = np.linspace(-1.5, 1.5, n)\ny = np.linspace(-1.5, 1.5, n * 2)\nX, Y = np.meshgrid(x, y)\nQx = np.cos(Y) - np.cos(X)\nQz = np.sin(Y) + np.sin(X)\nZ = np.sqrt(X**2 + Y**2) / 5\nZ = (Z - Z.min()) / (Z.max() - Z.min())\n\n# The color array can include masked values.\nZm = np.ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\nfig, axs = plt.subplots(nrows=1, ncols=3)\naxs[0].pcolormesh(Qx, Qz, Z, shading='gouraud')\naxs[0].set_title('Without masked values')\n\n# You can control the color of the masked region.\ncmap = plt.colormaps[plt.rcParamsimage.cmap].with_extremes(bad='y')\naxs[1].pcolormesh(Qx, Qz, Zm, shading='gouraud', cmap=cmap)\naxs[1].set_title('With masked values')\n\n# Or use the default, which is transparent.\naxs[2].pcolormesh(Qx, Qz, Zm, shading='gouraud')\naxs[2].set_title('With masked values')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 83
},
{
    "title": "Advanced quiver and quiverkey functions#",
    "text": "Demonstrates some more advanced options for quiver. For a simple\nexample refer to Quiver Simple Demo. Note: The plot autoscaling does not take into account the arrows, so\nthose on the boundaries may reach out of the picture. This is not an easy\nproblem to solve in a perfectly general way. The recommended workaround is to\nmanually set the Axes limits in such a case. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.quiver / matplotlib.pyplot.quiver matplotlib.axes.Axes.quiverkey / matplotlib.pyplot.quiverkey Total running time of the script: (0 minutes 1.496 seconds) Download Python source code: quiver_demo.py Download Jupyter notebook: quiver_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nX, Y = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))\nU = np.cos(X)\nV = np.sin(Y)\n', \"fig1, ax1 = plt.subplots()\nax1.set_title('Arrows scale with plot width, not view')\nQ = ax1.quiver(X, Y, U, V, units='width')\nqk = ax1.quiverkey(Q, 0.9, 0.9, 2, r'$2 \\\\frac{m}{s}$', labelpos='E',\n                   coordinates='figure')\n\", 'fig2, ax2 = plt.subplots()\nax2.set_title(\"pivot=\\'mid\\'; every third arrow; units=\\'inches\\'\")\nQ = ax2.quiver(X[::3, ::3], Y[::3, ::3], U[::3, ::3], V[::3, ::3],\n               pivot=\\'mid\\', units=\\'inches\\')\nqk = ax2.quiverkey(Q, 0.9, 0.9, 1, r\\'$1 \\\\frac{m}{s}$\\', labelpos=\\'E\\',\n                   coordinates=\\'figure\\')\nax2.scatter(X[::3, ::3], Y[::3, ::3], color=\\'r\\', s=5)\n fig3, ax3 = plt.subplots()\nax3.set_title(\"pivot=\\'tip\\'; scales with x view\")\nM = np.hypot(U, V)\nQ = ax3.quiver(X, Y, U, V, M, units=\\'x\\', pivot=\\'tip\\', width=0.022,\n               scale=1 / 0.15)\nqk = ax3.quiverkey(Q, 0.9, 0.9, 1, r\\'$1 \\\\frac{m}{s}$\\', labelpos=\\'E\\',\n                   coordinates=\\'figure\\')\nax3.scatter(X, Y, color=\\'0.5\\', s=1)\n\nplt.show()\n",
    "id": 84
},
{
    "title": "Quiver Simple Demo#",
    "text": "A simple example of a quiver plot with a quiverkey. For more advanced options refer to\nAdvanced quiver and quiverkey functions. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.quiver / matplotlib.pyplot.quiver matplotlib.axes.Axes.quiverkey / matplotlib.pyplot.quiverkey Download Python source code: quiver_simple_demo.py Download Jupyter notebook: quiver_simple_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nX = np.arange(-10, 10, 1)\nY = np.arange(-10, 10, 1)\nU, V = np.meshgrid(X, Y)\n\nfig, ax = plt.subplots()\nq = ax.quiver(X, Y, U, V)\nax.quiverkey(q, X=0.3, Y=1.1, U=10,\n             label='Quiver key, length = 10', labelpos='E')\n\nplt.show()\n",
    "id": 85
},
{
    "title": "Shading example#",
    "text": "Example showing how to make shaded relief plots like Mathematica or\nGeneric Mapping Tools. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors.LightSource matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow Total running time of the script: (0 minutes 1.190 seconds) Download Python source code: shading_example.py Download Jupyter notebook: shading_example.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib.colors import LightSource\n\n\ndef main():\n    # Test data\n    x, y = np.mgrid[-5:5:0.05, -5:5:0.05]\n    z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2))\n\n    dem = cbook.get_sample_data(\\'jacksboro_fault_dem.npz\\')\n    elev = dem[\\'elevation\\\n\n    fig = compare(z, plt.cm.copper)\n    fig.suptitle(\\'HSV Blending Looks Best with Smooth Surfaces\\', y=0.95)\n\n    fig = compare(elev, plt.cm.gist_earth, ve=0.05)\n    fig.suptitle(\\'Overlay Blending Looks Best with Rough Surfaces\\', y=0.95)\n\n    plt.show()\n\n\ndef compare(z, cmap, ve=1):\n    # Create subplots and hide ticks\n    fig, axs = plt.subplots(ncols=2, nrows=2)\n    for ax in axs.flat:\n        ax.set(xticks=[], yticks=[])\n\n    # Illuminate the scene from the northwest\n    ls = LightSource(azdeg=315, altdeg=45)\n\n    axs[0, 0].imshow(z, cmap=cmap)\n    axs[0, 0].set(xlabel=\\'Colormapped Data\\')\n\n    axs[0, 1].imshow(ls.hillshade(z, vert_exag=ve), cmap=\\'gray\\')\n    axs[0, 1].set(xlabel=\\'Illumination Intensity\\')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode=\\'hsv\\')\n    axs[1, 0].imshow(rgb)\n    axs[1, 0].set(xlabel=\\'Blend Mode: \"hsv\" (default)\\')\n\n    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode=\\'overlay\\')\n    axs[1, 1].imshow(rgb)\n    axs[1, 1].set(xlabel=\\'Blend Mode: \"overlay\"\\')\n\n    return fig\n\n\nif __name__ == \\'__main__\\':\n    main()\n",
    "id": 86
},
{
    "title": "Spectrogram#",
    "text": "Plotting a spectrogram using specgram. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.specgram / matplotlib.pyplot.specgram Download Python source code: specgram_demo.py Download Jupyter notebook: specgram_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\ndt = 0.0005\nt = np.arange(0.0, 20.5, dt)\ns1 = np.sin(2 * np.pi * 100 * t)\ns2 = 2 * np.sin(2 * np.pi * 400 * t)\n\n# create a transient \"chirp\"\ns2[t <= 10] = s2[12 <= t] = 0\n\n# add some noise into the mix\nnse = 0.01 * np.random.random(size=len(t))\n\nx = s1 + s2 + nse  # the signal\nNFFT = 1024  # the length of the windowing segments\nFs = 1/dt  # the sampling frequency\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)\nax1.plot(t, x)\nax1.set_ylabel(\\'Signal\\')\n\nPxx, freqs, bins, im = ax2.specgram(x, NFFT=NFFT, Fs=Fs)\n# The `specgram` method returns 4 objects. They are:\n# - Pxx: the periodogram\n# - freqs: the frequency vector\n# - bins: the centers of the time bins\n# - im: the .image.AxesImage instance representing the data in the plot\nax2.set_xlabel(\\'Time (s)\\')\nax2.set_ylabel(\\'Frequency (Hz)\\')\nax2.set_xlim(0, 20)\n\nplt.show()\n",
    "id": 87
},
{
    "title": "Spy Demos#",
    "text": "Plot the sparsity pattern of arrays. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.spy / matplotlib.pyplot.spy Download Python source code: spy_demos.py Download Jupyter notebook: spy_demos.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(2, 2)\nax1 = axs[0, 0]\nax2 = axs[0, 1]\nax3 = axs[1, 0]\nax4 = axs[1, 1]\n\nx = np.random.randn(20, 20)\nx[5, :] = 0.\nx[:, 12] = 0.\n\nax1.spy(x, markersize=5)\nax2.spy(x, precision=0.1, markersize=5)\n\nax3.spy(x)\nax4.spy(x, precision=0.1)\n\nplt.show()\n",
    "id": 88
},
{
    "title": "Tricontour Demo#",
    "text": "Contour plots of unstructured triangular grids. Creating a Triangulation without specifying the triangles results in the\nDelaunay triangulation of the points. pcolor plot. You could also specify hatching patterns along with different cmaps. You could also generate hatching patterns labeled with no color. You can specify your own triangulation rather than perform a Delaunay\ntriangulation of the points, where each triangle is given by the indices of\nthe three points that make up the triangle, ordered in either a clockwise or\nanticlockwise manner. Rather than create a Triangulation object, can simply pass x, y and triangles\narrays to tripcolor directly. It would be better to use a Triangulation\nobject if the same triangulation was to be used more than once to save\nduplicated calculations. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.tri.Triangulation matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.contour.ContourSet.legend_elements Total running time of the script: (0 minutes 1.712 seconds) Download Python source code: tricontour_demo.py Download Jupyter notebook: tricontour_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n # First create the x and y coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = (np.cos(radii) * np.cos(3 * angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n', \"fig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\ntcf = ax1.tricontourf(triang, z)\nfig1.colorbar(tcf)\nax1.tricontour(triang, z, colors='k')\nax1.set_title('Contour plot of Delaunay triangulation')\n\", 'fig2, ax2 = plt.subplots()\nax2.set_aspect(\"equal\")\ntcf = ax2.tricontourf(\n    triang,\n    z,\n    hatches=*\", \"-\", \"/\", \"//\", \"\\\\\\\\\", None],\n    cmap=\"cividis\"\n)\nfig2.colorbar(tcf)\nax2.tricontour(triang, z, linestyles=\"solid\", colors=\"k\", linewidths=2.0)\nax2.set_title(\"Hatched Contour plot of Delaunay triangulation\")\n fig3, ax3 = plt.subplots()\nn_levels = 7\ntcf = ax3.tricontourf(\n    triang,\n    z,\n    n_levels,\n    colors=\"none\",\n    hatches=.\", \"/\", \"\\\\\\\\\", None, \"\\\\\\\\\\\\\\\\\", \"*,\n)\nax3.tricontour(triang, z, n_levels, colors=\"black\", linestyles=\"-\")\n\n\n# create a legend for the contour set\nartists, labels = tcf.legend_elements(str_format=\"{:2.1f}\".format)\nax3.legend(artists, labels, handleheight=2, framealpha=1)\n xy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx = np.degrees(xy[:, 0])\ny = np.degrees(xy[:, 1])\nx0 = -5\ny0 = 52\nz = np.exp(-0.01 * ((x - x0) ** 2 + (y - y0) ** 2))\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n', \"fig4, ax4 = plt.subplots()\nax4.set_aspect('equal')\ntcf = ax4.tricontourf(x, y, triangles, z)\nfig4.colorbar(tcf)\nax4.set_title('Contour plot of user-specified triangulation')\nax4.set_xlabel('Longitude (degrees)')\nax4.set_ylabel('Latitude (degrees)')\n\nplt.show()\n",
    "id": 89
},
{
    "title": "Tricontour Smooth Delaunay#",
    "text": "Demonstrates high-resolution tricontouring of a random set of points;\na matplotlib.tri.TriAnalyzer is used to improve the plot quality. The initial data points and triangular grid for this demo are: a set of random points is instantiated, inside [-1, 1] x [-1, 1] square A Delaunay triangulation of these points is then computed, of which a\nrandom subset of triangles is masked out by the user (based on\ninit_mask_frac parameter). This simulates invalidated data. The proposed generic procedure to obtain a high resolution contouring of such\na data set is the following: Compute an extended mask with a matplotlib.tri.TriAnalyzer, which will\nexclude badly shaped (flat) triangles from the border of the\ntriangulation. Apply the mask to the triangulation (using set_mask). Refine and interpolate the data using a matplotlib.tri.UniformTriRefiner. Plot the refined data with tricontour. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.tri matplotlib.tri.Triangulation matplotlib.tri.TriAnalyzer matplotlib.tri.UniformTriRefiner Download Python source code: tricontour_smooth_delaunay.py Download Jupyter notebook: tricontour_smooth_delaunay.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import TriAnalyzer, Triangulation, UniformTriRefiner\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef experiment_res(x, y):\n    \"\"\"An analytic function representing experiment results.\"\"\"\n    x = 2 * x\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = (4 * (np.exp((r1/10)**2) - 1) * 30 * np.cos(3 * theta1) +\n         (np.exp((r2/10)**2) - 1) * 30 * np.cos(5 * theta2) +\n         2 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Generating the initial data test points and triangulation for the demo\n# ----------------------------------------------------------------------------\n# User parameters for data test points\n\n# Number of test data points, tested from 3 to 5000 for subdiv=3\nn_test = 200\n\n# Number of recursive subdivisions of the initial mesh for smooth plots.\n# Values >3 might result in a very high number of triangles for the refine\n# mesh: new triangles numbering = (4**subdiv)*ntri\nsubdiv = 3\n\n# Float > 0. adjusting the proportion of (invalid) initial triangles which will\n# be masked out. Enter 0 for no mask.\ninit_mask_frac = 0.0\n\n# Minimum circle ratio - border triangles with circle ratio below this will be\n# masked if they touch a border. Suggested value 0.01; use -1 to keep all\n# triangles.\nmin_circle_ratio = .01\n\n# Random points\nrandom_gen = np.random.RandomState(seed=19680801)\nx_test = random_gen.uniform(-1., 1., size=n_test)\ny_test = random_gen.uniform(-1., 1., size=n_test)\nz_test = experiment_res(x_test, y_test)\n\n# meshing with Delaunay triangulation\ntri = Triangulation(x_test, y_test)\nntri = tri.triangles.shape[0]\n\n# Some invalid data are masked out\nmask_init = np.zeros(ntri, dtype=bool)\nmasked_tri = random_gen.randint(0, ntri, int(ntri * init_mask_frac))\nmask_init[masked_tri] = True\ntri.set_mask(mask_init)\n\n\n# ----------------------------------------------------------------------------\n# Improving the triangulation before high-res plots: removing flat triangles\n# ----------------------------------------------------------------------------\n# masking badly shaped triangles at the border of the triangular mesh.\nmask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio)\ntri.set_mask(mask)\n\n# refining the data\nrefiner = UniformTriRefiner(tri)\ntri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv)\n\n# analytical \\'results\\' for comparison\nz_expected = experiment_res(tri_refi.x, tri_refi.y)\n\n# for the demo: loading the \\'flat\\' triangles for plot\nflat_tri = Triangulation(x_test, y_test)\nflat_tri.set_mask(~mask)\n\n\n# ----------------------------------------------------------------------------\n# Now the plots\n# ----------------------------------------------------------------------------\n# User options for plots\nplot_tri = True          # plot of base triangulation\nplot_masked_tri = True   # plot of excessively flat excluded triangles\nplot_refi_tri = False    # plot of refined triangulation\nplot_expected = False    # plot of analytical function values for comparison\n\n\n# Graphical options for tricontouring\nlevels = np.arange(0., 1., 0.025)\n\nfig, ax = plt.subplots()\nax.set_aspect(\\'equal\\')\nax.set_title(\"Filtering a Delaunay mesh\\\n\"\n             \"(application to high-resolution tricontouring)\")\n\n# 1) plot of the refined (computed) data contours:\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap=\\'Blues\\',\n              linewidths=[2.0, 0.5, 1.0, 0.5])\n# 2) plot of the expected (analytical) data contours (dashed):\nif plot_expected:\n    ax.tricontour(tri_refi, z_expected, levels=levels, cmap=\\'Blues\\',\n                  linestyles=\\'--\\')\n# 3) plot of the fine mesh on which interpolation was done:\nif plot_refi_tri:\n    ax.triplot(tri_refi, color=\\'0.97\\')\n# 4) plot of the initial \\'coarse\\' mesh:\nif plot_tri:\n    ax.triplot(tri, color=\\'0.7\\')\n# 4) plot of the unvalidated triangles from naive Delaunay Triangulation:\nif plot_masked_tri:\n    ax.triplot(flat_tri, color=\\'red\\')\n\nplt.show()\n",
    "id": 90
},
{
    "title": "Tricontour Smooth User#",
    "text": "Demonstrates high-resolution tricontouring on user-defined triangular grids\nwith matplotlib.tri.UniformTriRefiner. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.tri matplotlib.tri.Triangulation matplotlib.tri.UniformTriRefiner Download Python source code: tricontour_smooth_user.py Download Jupyter notebook: tricontour_smooth_user.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n\n# ----------------------------------------------------------------------------\n# Analytical test function\n# ----------------------------------------------------------------------------\ndef function_z(x, y):\n    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)\n    theta1 = np.arctan2(0.5 - x, 0.5 - y)\n    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)\n    theta2 = np.arctan2(-x - 0.2, -y - 0.2)\n    z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +\n          (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +\n          0.7 * (x**2 + y**2))\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 20\nn_radii = 10\nmin_radius = 0.15\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = function_z(x, y)\n\n# Now create the Triangulation.\n# (Creating a Triangulation without specifying the triangles results in the\n# Delaunay triangulation of the points.)\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data\n# ----------------------------------------------------------------------------\nrefiner = tri.UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(z, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation and the high-res iso-contours\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect(\\'equal\\')\nax.triplot(triang, lw=0.5, color=\\'white\\')\n\nlevels = np.arange(0., 1., 0.025)\nax.tricontourf(tri_refi, z_test_refi, levels=levels, cmap=\\'terrain\\')\nax.tricontour(tri_refi, z_test_refi, levels=levels,\n              colors=[\\'0.25\\', \\'0.5\\', \\'0.5\\', \\'0.5\\', \\'0.5\\,\n              linewidths=[1.0, 0.5, 0.5, 0.5, 0.5])\n\nax.set_title(\"High-resolution tricontouring\")\n\nplt.show()\n",
    "id": 91
},
{
    "title": "Trigradient Demo#",
    "text": "Demonstrates computation of gradient with\nmatplotlib.tri.CubicTriInterpolator. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontour / matplotlib.pyplot.tricontour matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.tri matplotlib.tri.Triangulation matplotlib.tri.CubicTriInterpolator matplotlib.tri.CubicTriInterpolator.gradient matplotlib.tri.UniformTriRefiner matplotlib.axes.Axes.quiver / matplotlib.pyplot.quiver Download Python source code: trigradient_demo.py Download Jupyter notebook: trigradient_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.tri import (CubicTriInterpolator, Triangulation,\n                            UniformTriRefiner)\n\n\n# ----------------------------------------------------------------------------\n# Electrical potential of a dipole\n# ----------------------------------------------------------------------------\ndef dipole_potential(x, y):\n    \"\"\"The electric dipole potential V, at position *x*, *y*.\"\"\"\n    r_sq = x**2 + y**2\n    theta = np.arctan2(y, x)\n    z = np.cos(theta)/r_sq\n    return (np.max(z) - z) / (np.max(z) - np.min(z))\n\n\n# ----------------------------------------------------------------------------\n# Creating a Triangulation\n# ----------------------------------------------------------------------------\n# First create the x and y coordinates of the points.\nn_angles = 30\nn_radii = 10\nmin_radius = 0.2\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nV = dipole_potential(x, y)\n\n# Create the Triangulation; no triangles specified so Delaunay triangulation\n# created.\ntriang = Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# ----------------------------------------------------------------------------\n# Refine data - interpolates the electrical potential V\n# ----------------------------------------------------------------------------\nrefiner = UniformTriRefiner(triang)\ntri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)\n\n# ----------------------------------------------------------------------------\n# Computes the electrical field (Ex, Ey) as gradient of electrical potential\n# ----------------------------------------------------------------------------\ntci = CubicTriInterpolator(triang, -V)\n# Gradient requested here at the mesh nodes but could be anywhere else:\n(Ex, Ey) = tci.gradient(triang.x, triang.y)\nE_norm = np.sqrt(Ex**2 + Ey**2)\n\n# ----------------------------------------------------------------------------\n# Plot the triangulation, the potential iso-contours and the vector field\n# ----------------------------------------------------------------------------\nfig, ax = plt.subplots()\nax.set_aspect(\\'equal\\')\n# Enforce the margins, and enlarge them to give room for the vectors.\nax.use_sticky_edges = False\nax.margins(0.07)\n\nax.triplot(triang, color=\\'0.8\\')\n\nlevels = np.arange(0., 1., 0.01)\nax.tricontour(tri_refi, z_test_refi, levels=levels, cmap=\\'hot\\',\n              linewidths=[2.0, 1.0, 1.0, 1.0])\n# Plots direction of the electrical vector field\nax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,\n          units=\\'xy\\', scale=10., zorder=3, color=\\'blue\\',\n          width=0.007, headwidth=3., headlength=4.)\n\nax.set_title(\\'Gradient plot: an electrical dipole\\')\nplt.show()\n",
    "id": 92
},
{
    "title": "Triinterp Demo#",
    "text": "Interpolation from triangular grid to quad grid. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tricontourf / matplotlib.pyplot.tricontourf matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.axes.Axes.contourf / matplotlib.pyplot.contourf matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.tri matplotlib.tri.LinearTriInterpolator matplotlib.tri.CubicTriInterpolator matplotlib.tri.Triangulation Download Python source code: triinterp_demo.py Download Jupyter notebook: triinterp_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\n# Create triangulation.\nx = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5])\ny = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0])\ntriangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7],\n             [5, 6, 8], [5, 8, 7], [7, 8, 9]]\ntriang = mtri.Triangulation(x, y, triangles)\n\n# Interpolate to regularly-spaced quad grid.\nz = np.cos(1.5 * x) * np.cos(1.5 * y)\nxi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20))\n\ninterp_lin = mtri.LinearTriInterpolator(triang, z)\nzi_lin = interp_lin(xi, yi)\n\ninterp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind=\\'geom\\')\nzi_cubic_geom = interp_cubic_geom(xi, yi)\n\ninterp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind=\\'min_E\\')\nzi_cubic_min_E = interp_cubic_min_E(xi, yi)\n\n# Set up the figure\nfig, axs = plt.subplots(nrows=2, ncols=2)\naxs = axs.flatten()\n\n# Plot the triangulation.\naxs[0].tricontourf(triang, z)\naxs[0].triplot(triang, \\'ko-\\')\naxs[0].set_title(\\'Triangular grid\\')\n\n# Plot linear interpolation to quad grid.\naxs[1].contourf(xi, yi, zi_lin)\naxs[1].plot(xi, yi, \\'k-\\', lw=0.5, alpha=0.5)\naxs[1].plot(xi.T, yi.T, \\'k-\\', lw=0.5, alpha=0.5)\naxs[1].set_title(\"Linear interpolation\")\n\n# Plot cubic interpolation to quad grid, kind=geom\naxs[2].contourf(xi, yi, zi_cubic_geom)\naxs[2].plot(xi, yi, \\'k-\\', lw=0.5, alpha=0.5)\naxs[2].plot(xi.T, yi.T, \\'k-\\', lw=0.5, alpha=0.5)\naxs[2].set_title(\"Cubic interpolation,\\\nkind=\\'geom\\'\")\n\n# Plot cubic interpolation to quad grid, kind=min_E\naxs[3].contourf(xi, yi, zi_cubic_min_E)\naxs[3].plot(xi, yi, \\'k-\\', lw=0.5, alpha=0.5)\naxs[3].plot(xi.T, yi.T, \\'k-\\', lw=0.5, alpha=0.5)\naxs[3].set_title(\"Cubic interpolation,\\\nkind=\\'min_E\\'\")\n\nfig.tight_layout()\nplt.show()\n",
    "id": 93
},
{
    "title": "Tripcolor Demo#",
    "text": "Pseudocolor plots of unstructured triangular grids. Creating a Triangulation without specifying the triangles results in the\nDelaunay triangulation of the points. tripcolor plot. Illustrate Gouraud shading. You can specify your own triangulation rather than perform a Delaunay\ntriangulation of the points, where each triangle is given by the indices of\nthe three points that make up the triangle, ordered in either a clockwise or\nanticlockwise manner. Rather than create a Triangulation object, can simply pass x, y and triangles\narrays to tripcolor directly. It would be better to use a Triangulation\nobject if the same triangulation was to be used more than once to save\nduplicated calculations.\nCan specify one color value per face rather than one per point by using the\nfacecolors keyword argument. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.tripcolor / matplotlib.pyplot.tripcolor matplotlib.tri matplotlib.tri.Triangulation Total running time of the script: (0 minutes 1.410 seconds) Download Python source code: tripcolor_demo.py Download Jupyter notebook: tripcolor_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n # First create the x and y coordinates of the points.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\nz = (np.cos(radii) * np.cos(3 * angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n', \"fig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\ntpc = ax1.tripcolor(triang, z, shading='flat')\nfig1.colorbar(tpc)\nax1.set_title('tripcolor of Delaunay triangulation, flat shading')\n\", \"fig2, ax2 = plt.subplots()\nax2.set_aspect('equal')\ntpc = ax2.tripcolor(triang, z, shading='gouraud')\nfig2.colorbar(tpc)\nax2.set_title('tripcolor of Delaunay triangulation, gouraud shading')\n\", 'xy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx, y = np.rad2deg(xy).T\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n\nxmid = x[triangles].mean(axis=1)\nymid = y[triangles].mean(axis=1)\nx0 = -5\ny0 = 52\nzfaces = np.exp(-0.01 * ((xmid - x0) * (xmid - x0) +\n                         (ymid - y0) * (ymid - y0)))\n', \"fig3, ax3 = plt.subplots()\nax3.set_aspect('equal')\ntpc = ax3.tripcolor(x, y, triangles, facecolors=zfaces, edgecolors='k')\nfig3.colorbar(tpc)\nax3.set_title('tripcolor of user-specified triangulation')\nax3.set_xlabel('Longitude (degrees)')\nax3.set_ylabel('Latitude (degrees)')\n\nplt.show()\n",
    "id": 94
},
{
    "title": "Triplot Demo#",
    "text": "Creating and plotting unstructured triangular grids. Creating a Triangulation without specifying the triangles results in the\nDelaunay triangulation of the points. Plot the triangulation. You can specify your own triangulation rather than perform a Delaunay\ntriangulation of the points, where each triangle is given by the indices of\nthe three points that make up the triangle, ordered in either a clockwise or\nanticlockwise manner. Rather than create a Triangulation object, can simply pass x, y and triangles\narrays to triplot directly. It would be better to use a Triangulation object\nif the same triangulation was to be used more than once to save duplicated\ncalculations. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.triplot / matplotlib.pyplot.triplot matplotlib.tri matplotlib.tri.Triangulation Download Python source code: triplot_demo.py Download Jupyter notebook: triplot_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n # First create the x and y coordinates of the points.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\n\nx = (radii * np.cos(angles)).flatten()\ny = (radii * np.sin(angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n', \"fig1, ax1 = plt.subplots()\nax1.set_aspect('equal')\nax1.triplot(triang, 'bo-', lw=1)\nax1.set_title('triplot of Delaunay triangulation')\n\", 'xy = np.asarray([\n    [-0.101, 0.872], [-0.080, 0.883], [-0.069, 0.888], [-0.054, 0.890],\n    [-0.045, 0.897], [-0.057, 0.895], [-0.073, 0.900], [-0.087, 0.898],\n    [-0.090, 0.904], [-0.069, 0.907], [-0.069, 0.921], [-0.080, 0.919],\n    [-0.073, 0.928], [-0.052, 0.930], [-0.048, 0.942], [-0.062, 0.949],\n    [-0.054, 0.958], [-0.069, 0.954], [-0.087, 0.952], [-0.087, 0.959],\n    [-0.080, 0.966], [-0.085, 0.973], [-0.087, 0.965], [-0.097, 0.965],\n    [-0.097, 0.975], [-0.092, 0.984], [-0.101, 0.980], [-0.108, 0.980],\n    [-0.104, 0.987], [-0.102, 0.993], [-0.115, 1.001], [-0.099, 0.996],\n    [-0.101, 1.007], [-0.090, 1.010], [-0.087, 1.021], [-0.069, 1.021],\n    [-0.052, 1.022], [-0.052, 1.017], [-0.069, 1.010], [-0.064, 1.005],\n    [-0.048, 1.005], [-0.031, 1.005], [-0.031, 0.996], [-0.040, 0.987],\n    [-0.045, 0.980], [-0.052, 0.975], [-0.040, 0.973], [-0.026, 0.968],\n    [-0.020, 0.954], [-0.006, 0.947], [ 0.003, 0.935], [ 0.006, 0.926],\n    [ 0.005, 0.921], [ 0.022, 0.923], [ 0.033, 0.912], [ 0.029, 0.905],\n    [ 0.017, 0.900], [ 0.012, 0.895], [ 0.027, 0.893], [ 0.019, 0.886],\n    [ 0.001, 0.883], [-0.012, 0.884], [-0.029, 0.883], [-0.038, 0.879],\n    [-0.057, 0.881], [-0.062, 0.876], [-0.078, 0.876], [-0.087, 0.872],\n    [-0.030, 0.907], [-0.007, 0.905], [-0.057, 0.916], [-0.025, 0.933],\n    [-0.077, 0.990], [-0.059, 0.993]])\nx = np.degrees(xy[:, 0])\ny = np.degrees(xy[:, 1])\n\ntriangles = np.asarray([\n    [67, 66,  1], [65,  2, 66], [ 1, 66,  2], [64,  2, 65], [63,  3, 64],\n    [60, 59, 57], [ 2, 64,  3], [ 3, 63,  4], [ 0, 67,  1], [62,  4, 63],\n    [57, 59, 56], [59, 58, 56], [61, 60, 69], [57, 69, 60], [ 4, 62, 68],\n    [ 6,  5,  9], [61, 68, 62], [69, 68, 61], [ 9,  5, 70], [ 6,  8,  7],\n    [ 4, 70,  5], [ 8,  6,  9], [56, 69, 57], [69, 56, 52], [70, 10,  9],\n    [54, 53, 55], [56, 55, 53], [68, 70,  4], [52, 56, 53], [11, 10, 12],\n    [69, 71, 68], [68, 13, 70], [10, 70, 13], [51, 50, 52], [13, 68, 71],\n    [52, 71, 69], [12, 10, 13], [71, 52, 50], [71, 14, 13], [50, 49, 71],\n    [49, 48, 71], [14, 16, 15], [14, 71, 48], [17, 19, 18], [17, 20, 19],\n    [48, 16, 14], [48, 47, 16], [47, 46, 16], [16, 46, 45], [23, 22, 24],\n    [21, 24, 22], [17, 16, 45], [20, 17, 45], [21, 25, 24], [27, 26, 28],\n    [20, 72, 21], [25, 21, 72], [45, 72, 20], [25, 28, 26], [44, 73, 45],\n    [72, 45, 73], [28, 25, 29], [29, 25, 31], [43, 73, 44], [73, 43, 40],\n    [72, 73, 39], [72, 31, 25], [42, 40, 43], [31, 30, 29], [39, 73, 40],\n    [42, 41, 40], [72, 33, 31], [32, 31, 33], [39, 38, 72], [33, 72, 38],\n    [33, 38, 34], [37, 35, 38], [34, 38, 35], [35, 37, 36]])\n', \"fig2, ax2 = plt.subplots()\nax2.set_aspect('equal')\nax2.triplot(x, y, triangles, 'go-', lw=1.0)\nax2.set_title('triplot of user-specified triangulation')\nax2.set_xlabel('Longitude (degrees)')\nax2.set_ylabel('Latitude (degrees)')\n\nplt.show()\n",
    "id": 95
},
{
    "title": "Watermark image#",
    "text": "Overlay an image on a plot by moving it to the front (zorder=3) and making it\nsemi-transparent (alpha=0.7). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.image matplotlib.image.imread / matplotlib.pyplot.imread matplotlib.figure.Figure.figimage Download Python source code: watermark_image.py Download Jupyter notebook: watermark_image.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nimport matplotlib.image as image\n\nwith cbook.get_sample_data('logo2.png') as file:\n    im = image.imread(file)\n\nfig, ax = plt.subplots()\n\nnp.random.seed(19680801)\nx = np.arange(30)\ny = x + np.random.randn(30)\nax.bar(x, y, color='#6bbc6b')\nax.grid()\n\nfig.figimage(im, 25, 25, zorder=3, alpha=.7)\n\nplt.show()\n",
    "id": 96
},
{
    "title": "Aligning Labels#",
    "text": "Aligning xlabel and ylabel using Figure.align_xlabels and\nFigure.align_ylabels Figure.align_labels wraps these two functions. Note that the xlabel \"XLabel1 1\" would normally be much closer to the\nx-axis, and \"YLabel1 0\" would be much closer to the y-axis of their\nrespective axes. Download Python source code: align_labels_demo.py Download Jupyter notebook: align_labels_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.gridspec as gridspec\n\nfig = plt.figure(tight_layout=True)\ngs = gridspec.GridSpec(2, 2)\n\nax = fig.add_subplot(gs[0, :])\nax.plot(np.arange(0, 1e6, 1000))\nax.set_ylabel('YLabel0')\nax.set_xlabel('XLabel0')\n\nfor i in range(2):\n    ax = fig.add_subplot(gs[1, i])\n    ax.plot(np.arange(1., 0., -0.1) * 2000., np.arange(1., 0., -0.1))\n    ax.set_ylabel('YLabel1 %d' % i)\n    ax.set_xlabel('XLabel1 %d' % i)\n    if i == 0:\n        ax.tick_params(axis='x', rotation=55)\nfig.align_labels()  # same as fig.align_xlabels(); fig.align_ylabels()\n\nplt.show()\n",
    "id": 98
},
{
    "title": "Programmatically controlling subplot adjustment#",
    "text": "Note This example is primarily intended to show some advanced concepts in\nMatplotlib. If you are only looking for having enough space for your labels, it is\nalmost always simpler and good enough to either set the subplot parameters\nmanually using Figure.subplots_adjust, or use one of the automatic\nlayout mechanisms\n(Constrained Layout Guide or\nTight Layout guide). This example describes a user-defined way to read out Artist sizes and\nset the subplot parameters accordingly. Its main purpose is to illustrate\nsome advanced concepts like reading out text positions, working with\nbounding boxes and transforms and using\nevents. But it can also serve as a starting\npoint if you want to automate the layouting and need more flexibility than\ntight layout and constrained layout. Below, we collect the bounding boxes of all y-labels and move the left border\nof the subplot to the right so that it leaves enough room for the union of all\nthe bounding boxes.', \"There's one catch with calculating text bounding boxes:\nQuerying the text bounding boxes (Text.get_window_extent) needs a\nrenderer (RendererBase instance), to calculate the text size. This renderer\nis only available after the figure has been drawn (Figure.draw).\", 'A solution to this is putting the adjustment logic in a draw callback.\nThis function is executed after the figure has been drawn. It can now check\nif the subplot leaves enough room for the text. If not, the subplot parameters\nare updated and second draw is triggered. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.artist.Artist.get_window_extent matplotlib.transforms.Bbox matplotlib.transforms.BboxBase.transformed matplotlib.transforms.BboxBase.union matplotlib.transforms.Transform.inverted matplotlib.figure.Figure.subplots_adjust matplotlib.figure.SubplotParams matplotlib.backend_bases.FigureCanvasBase.mpl_connect Download Python source code: auto_subplots_adjust.py Download Jupyter notebook: auto_subplots_adjust.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_yticks([2, 5, 7], labels=really, really, really long labels)\n\n\ndef on_draw(event):\n    bboxes = []\n    for label in ax.get_yticklabels():\n        # Bounding box in pixels\n        bbox_px = label.get_window_extent()\n        # Transform to relative figure coordinates. This is the inverse of\n        # transFigure.\n        bbox_fig = bbox_px.transformed(fig.transFigure.inverted())\n        bboxes.append(bbox_fig)\n    # the bbox that bounds all the bboxes, again in relative figure coords\n    bbox = mtransforms.Bbox.union(bboxes)\n    if fig.subplotpars.left < bbox.width:\n        # Move the subplot left edge more to the right\n        fig.subplots_adjust(left=1.1*bbox.width)  # pad a little\n        fig.canvas.draw()\n\n\nfig.canvas.mpl_connect('draw_event', on_draw)\n\nplt.show()\n",
    "id": 99
},
{
    "title": "Axes box aspect#",
    "text": "This demo shows how to set the aspect of an Axes box directly via\nset_box_aspect. The box aspect is the ratio between axes height\nand axes width in physical units, independent of the data limits.\nThis is useful to e.g. produce a square plot, independent of the data it\ncontains, or to have a usual plot with the same axes dimensions next to\nan image plot with fixed (data-)aspect. The following lists a few use cases for set_box_aspect. Produce a square axes, no matter what the data limits are. Produce shared subplots that are squared in size. Produce a square axes, with a twin axes. The twinned axes takes over the\nbox aspect of the parent. When creating an image plot with fixed data aspect and the default\nadjustable=\"box\" next to a normal plot, the axes would be unequal in\nheight. set_box_aspect provides an easy solution to that by allowing\nto have the normal plot\\'s axes use the images dimensions as box aspect. This example also shows that constrained layout interplays nicely with\na fixed box aspect. It may be desirable to show marginal distributions next to a plot of joint\ndata. The following creates a square plot with the box aspect of the\nmarginal axes being equal to the width- and height-ratios of the gridspec.\nThis ensures that all axes align perfectly, independent on the size of the\nfigure. When setting the box aspect, one may still set the data aspect as well.\nHere we create an Axes with a box twice as long as tall and use an \"equal\"\ndata aspect for its contents, i.e. the circle actually stays circular. It is possible to pass the box aspect to an Axes at initialization. The\nfollowing creates a 2 by 3 subplot grid with all square Axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.set_box_aspect Total running time of the script: (0 minutes 2.231 seconds) Download Python source code: axes_box_aspect.py Download Jupyter notebook: axes_box_aspect.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig1, ax = plt.subplots()\n\nax.set_xlim(300, 400)\nax.set_box_aspect(1)\n\nplt.show()\n fig2, (ax, ax2) = plt.subplots(ncols=2, sharey=True)\n\nax.plot([1, 5], [0, 10])\nax2.plot([100, 500], [10, 15])\n\nax.set_box_aspect(1)\nax2.set_box_aspect(1)\n\nplt.show()\n fig3, ax = plt.subplots()\n\nax2 = ax.twinx()\n\nax.plot([0, 10])\nax2.plot([12, 10])\n\nax.set_box_aspect(1)\n\nplt.show()\n fig4, (ax, ax2) = plt.subplots(ncols=2, layout=\"constrained\")\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\nim = np.random.rand(16, 27)\nax.imshow(im)\n\nax2.plot([23, 45])\nax2.set_box_aspect(im.shape[0]/im.shape[1])\n\nplt.show()\n fig5, axs = plt.subplots(2, 2, sharex=\"col\", sharey=\"row\",\n                         gridspec_kw=dict(height_ratios=[1, 3],\n                                          width_ratios=[3, 1]))\naxs[0, 1].set_visible(False)\naxs[0, 0].set_box_aspect(1/3)\naxs[1, 0].set_box_aspect(1)\naxs[1, 1].set_box_aspect(3/1)\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\nx, y = np.random.randn(2, 400) * [[.5], [180]]\naxs[1, 0].scatter(x, y)\naxs[0, 0].hist(x)\naxs[1, 1].hist(y, orientation=\"horizontal\")\n\nplt.show()\n fig6, ax = plt.subplots()\n\nax.add_patch(plt.Circle((5, 3), 1))\nax.set_aspect(\"equal\", adjustable=\"datalim\")\nax.set_box_aspect(0.5)\nax.autoscale()\n\nplt.show()\n fig7, axs = plt.subplots(2, 3, subplot_kw=dict(box_aspect=1),\n                         sharex=True, sharey=True, layout=\"constrained\")\n\nfor i, ax in enumerate(axs.flat):\n    ax.scatter(i % 3, -((i // 3) - 0.5)*200, c=[plt.cm.hsv(i / 6)], s=300)\nplt.show()\n",
    "id": 100
},
{
    "title": "Axes Demo#",
    "text": "Example use of fig.add_axes to create inset axes within the main plot axes. Please see also the Module - axes_grid1 section, and the following three\nexamples: Zoom region inset axes Inset locator demo Inset locator demo 2 Download Python source code: axes_demo.py Download Jupyter notebook: axes_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility.\n\n# create some data to use for the plot\ndt = 0.001\nt = np.arange(0.0, 10.0, dt)\nr = np.exp(-t[:1000] / 0.05)  # impulse response\nx = np.random.randn(len(t))\ns = np.convolve(x, r)[:len(x)] * dt  # colored noise\n\nfig, main_ax = plt.subplots()\nmain_ax.plot(t, s)\nmain_ax.set_xlim(0, 1)\nmain_ax.set_ylim(1.1 * np.min(s), 2 * np.max(s))\nmain_ax.set_xlabel('time (s)')\nmain_ax.set_ylabel('current (nA)')\nmain_ax.set_title('Gaussian colored noise')\n\n# this is an inset axes over the main axes\nright_inset_ax = fig.add_axes([.65, .6, .2, .2], facecolor='k')\nright_inset_ax.hist(s, 400, density=True)\nright_inset_ax.set(title='Probability', xticks=[], yticks=[])\n\n# this is another inset axes over the main axes\nleft_inset_ax = fig.add_axes([.2, .6, .2, .2], facecolor='k')\nleft_inset_ax.plot(t[:len(r)], r)\nleft_inset_ax.set(title='Impulse response', xlim=(0, .2), xticks=[], yticks=[])\n\nplt.show()\n",
    "id": 101
},
{
    "title": "Controlling view limits using margins and sticky_edges#",
    "text": "The first figure in this example shows how to zoom in and out of a\nplot using margins instead of set_xlim and\nset_ylim. The second figure demonstrates the concept of\nedge \"stickiness\" introduced by certain methods and artists and how\nto effectively work around that. Some plotting functions make the axis limits \"sticky\" or immune to the will\nof the margins methods. For instance, imshow and\npcolor expect the user to want the limits to be tight around the\npixels shown in the plot. If this behavior is not desired, you need to set\nuse_sticky_edges to False. Consider the following example: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.margins / matplotlib.pyplot.margins matplotlib.axes.Axes.use_sticky_edges matplotlib.axes.Axes.pcolor / matplotlib.pyplot.pcolor matplotlib.patches.Polygon Download Python source code: axes_margins.py Download Jupyter notebook: axes_margins.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 3.0, 0.01)\n\nax1 = plt.subplot(212)\nax1.margins(0.05)           # Default margin is 0.05, value 0 means fit\nax1.plot(t1, f(t1))\n\nax2 = plt.subplot(221)\nax2.margins(2, 2)           # Values >0.0 zoom out\nax2.plot(t1, f(t1))\nax2.set_title('Zoomed out')\n\nax3 = plt.subplot(222)\nax3.margins(x=0, y=-0.25)   # Values in (-0.5, 0.0) zooms in to center\nax3.plot(t1, f(t1))\nax3.set_title('Zoomed in')\n\nplt.show()\n\", \"y, x = np.mgrid[:5, 1:6]\npoly_coords = [\n    (0.25, 2.75), (3.25, 2.75),\n    (2.25, 0.75), (0.25, 0.75)\n]\nfig, (ax1, ax2) = plt.subplots(ncols=2)\n\n# Here we set the stickiness of the axes object...\n# ax1 we'll leave as the default, which uses sticky edges\n# and we'll turn off stickiness for ax2\nax2.use_sticky_edges = False\n\nfor ax, status in zip((ax1, ax2), ('Is Is Not')):\n    cells = ax.pcolor(x, y, x+y, cmap='inferno', shading='auto')  # sticky\n    ax.add_patch(\n        Polygon(poly_coords, color='forestgreen', alpha=0.5)\n    )  # not sticky\n    ax.margins(x=0.1, y=0.05)\n    ax.set_aspect('equal')\n    ax.set_title(f'{status} Sticky')\n\nplt.show()\n",
    "id": 102
},
{
    "title": "Axes Props#",
    "text": "You can control the axis tick and grid properties Download Python source code: axes_props.py Download Jupyter notebook: axes_props.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.grid(True, linestyle='-.')\nax.tick_params(labelcolor='r', labelsize='medium', width=3)\n\nplt.show()\n",
    "id": 103
},
{
    "title": "Axes Zoom Effect#",
    "text": "Download Python source code: axes_zoom_effect.py Download Jupyter notebook: axes_zoom_effect.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import (Bbox, TransformedBbox,\n                                   blended_transform_factory)\nfrom mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\n                                                   BboxConnectorPatch,\n                                                   BboxPatch)\n\n\ndef connect_bbox(bbox1, bbox2,\n                 loc1a, loc2a, loc1b, loc2b,\n                 prop_lines, prop_patches=None):\n    if prop_patches is None:\n        prop_patches = {\n            **prop_lines,\n            \"alpha\": prop_lines.get(\"alpha\", 1) * 0.2,\n            \"clip_on\": False,\n        }\n\n    c1 = BboxConnector(\n        bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\n    c2 = BboxConnector(\n        bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\n\n    bbox_patch1 = BboxPatch(bbox1, **prop_patches)\n    bbox_patch2 = BboxPatch(bbox2, **prop_patches)\n\n    p = BboxConnectorPatch(bbox1, bbox2,\n                           loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\n                           clip_on=False,\n                           **prop_patches)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect01(ax1, ax2, xmin, xmax, **kwargs):\n    \"\"\"\n    Connect *ax1* and *ax2*. The *xmin*-to-*xmax* range in both axes will\n    be marked.\n\n    Parameters\n    ----------\n    ax1\n        The main axes.\n    ax2\n        The zoomed axes.\n    xmin, xmax\n        The limits of the colored area in both plot axes.\n    **kwargs\n        Arguments passed to the patch constructor.\n    \"\"\"\n\n    bbox = Bbox.from_extents(xmin, 0, xmax, 1)\n\n    mybbox1 = TransformedBbox(bbox, ax1.get_xaxis_transform())\n    mybbox2 = TransformedBbox(bbox, ax2.get_xaxis_transform())\n\n    prop_patches = {**kwargs, \"ec\": \"none\", \"alpha\": 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\ndef zoom_effect02(ax1, ax2, **kwargs):\n    \"\"\"\n    ax1 : the main axes\n    ax1 : the zoomed axes\n\n    Similar to zoom_effect01.  The xmin & xmax will be taken from the\n    ax1.viewLim.\n    \"\"\"\n\n    tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\n    trans = blended_transform_factory(ax2.transData, tt)\n\n    mybbox1 = ax1.bbox\n    mybbox2 = TransformedBbox(ax1.viewLim, trans)\n\n    prop_patches = {**kwargs, \"ec\": \"none\", \"alpha\": 0.2}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=3, loc2a=2, loc1b=4, loc2b=1,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\naxs = plt.figure().subplot_mosaic([\n    zoom1\", \"zoom2,\n    main\", \"main,\n])\n\naxsmain.set(xlim=(0, 5))\nzoom_effect01(axszoom1, axsmain, 0.2, 0.8)\naxszoom2.set(xlim=(2, 3))\nzoom_effect02(axszoom2, axsmain)\n\nplt.show()\n",
    "id": 104
},
{
    "title": "axhspan Demo#",
    "text": "Create lines or rectangles that span the axes in either the horizontal or\nvertical direction, and lines than span the axes with an arbitrary orientation. Download Python source code: axhspan_demo.py Download Jupyter notebook: axhspan_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(-1, 2, .01)\ns = np.sin(2 * np.pi * t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s)\n# Thick red horizontal line at y=0 that spans the xrange.\nax.axhline(linewidth=8, color='#d62728')\n# Horizontal line at y=1 that spans the xrange.\nax.axhline(y=1)\n# Vertical line at x=1 that spans the yrange.\nax.axvline(x=1)\n# Thick blue vertical line at x=0 that spans the upper quadrant of the yrange.\nax.axvline(x=0, ymin=0.75, linewidth=8, color='#1f77b4')\n# Default hline at y=.5 that spans the middle half of the axes.\nax.axhline(y=.5, xmin=0.25, xmax=0.75)\n# Infinite black line going through (0, 0) to (1, 1).\nax.axline((0, 0), (1, 1), color='k')\n# 50%-gray rectangle spanning the axes' width from y=0.25 to y=0.75.\nax.axhspan(0.25, 0.75, facecolor='0.5')\n# Green rectangle spanning the axes' height from x=1.25 to x=1.55.\nax.axvspan(1.25, 1.55, facecolor='#2ca02c')\n\nplt.show()\n",
    "id": 105
},
{
    "title": "Equal axis aspect ratio#",
    "text": "How to set and adjust plots with equal axis aspect ratios. Download Python source code: axis_equal_demo.py Download Jupyter notebook: axis_equal_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Plot circle of radius 3.\n\nan = np.linspace(0, 2 * np.pi, 100)\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 0].set_title('not equal, looks like ellipse', fontsize=10)\n\naxs[0, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[0, 1].axis('equal')\naxs[0, 1].set_title('equal, looks like circle', fontsize=10)\n\naxs[1, 0].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 0].axis('equal')\naxs[1, 0].set(xlim=(-3, 3), ylim=(-3, 3))\naxs[1, 0].set_title('still a circle, even after changing limits', fontsize=10)\n\naxs[1, 1].plot(3 * np.cos(an), 3 * np.sin(an))\naxs[1, 1].set_aspect('equal box')\naxs[1, 1].set_title('still a circle, auto-adjusted data limits', fontsize=10)\n\nfig.tight_layout()\n\nplt.show()\n",
    "id": 106
},
{
    "title": "Axis Label Position#",
    "text": "Choose axis label position when calling set_xlabel and\nset_ylabel as well as for colorbar. Download Python source code: axis_labels_demo.py Download Jupyter notebook: axis_labels_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nsc = ax.scatter([1, 2], [1, 2], c=[1, 2])\nax.set_ylabel(\\'YLabel\\', loc=\\'top\\')\nax.set_xlabel(\\'XLabel\\', loc=\\'left\\')\ncbar = fig.colorbar(sc)\ncbar.set_label(\"ZLabel\", loc=\\'top\\')\n\nplt.show()\n",
    "id": 107
},
{
    "title": "Broken Axis#",
    "text": "Broken axis example, where the y-axis will have a portion cut out. Download Python source code: broken_axis.py Download Jupyter notebook: broken_axis.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\npts = np.random.rand(30)*.2\n# Now let\\'s make two outlier points which are far away from everything.\npts[[3, 14]] += .8\n\n# If we were to simply plot pts, we\\'d lose most of the interesting\n# details due to the outliers. So let\\'s \\'break\\' or \\'cut-out\\' the y-axis\n# into two portions - use the top (ax1) for the outliers, and the bottom\n# (ax2) for the details of the majority of our data\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\nfig.subplots_adjust(hspace=0.05)  # adjust space between axes\n\n# plot the same data on both axes\nax1.plot(pts)\nax2.plot(pts)\n\n# zoom-in / limit the view to different portions of the data\nax1.set_ylim(.78, 1.)  # outliers only\nax2.set_ylim(0, .22)  # most of the data\n\n# hide the spines between ax and ax2\nax1.spines.bottom.set_visible(False)\nax2.spines.top.set_visible(False)\nax1.xaxis.tick_top()\nax1.tick_params(labeltop=False)  # don\\'t put tick labels at the top\nax2.xaxis.tick_bottom()\n\n# Now, let\\'s turn towards the cut-out slanted lines.\n# We create line objects in axes coordinates, in which (0,0), (0,1),\n# (1,0), and (1,1) are the four corners of the axes.\n# The slanted lines themselves are markers at those locations, such that the\n# lines keep their angle and position, independent of the axes size or scale\n# Finally, we need to disable clipping.\n\nd = .5  # proportion of vertical to horizontal extent of the slanted line\nkwargs = dict(marker=[(-1, -d), (1, d)], markersize=12,\n              linestyle=\"none\", color=\\'k\\', mec=\\'k\\', mew=1, clip_on=False)\nax1.plot([0, 1], [0, 0], transform=ax1.transAxes, **kwargs)\nax2.plot([0, 1], [1, 1], transform=ax2.transAxes, **kwargs)\n\n\nplt.show()\n",
    "id": 108
},
{
    "title": "Custom Figure subclasses#",
    "text": "You can pass a Figure subclass to pyplot.figure if you want to change\nthe default behavior of the figure. This example defines a Figure subclass WatermarkFigure that accepts an\nadditional parameter watermark to display a custom watermark text. The\nfigure is created using the FigureClass parameter of pyplot.figure.\nThe additional watermark parameter is passed on to the subclass\nconstructor. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.figure.Figure matplotlib.figure.Figure.text Download Python source code: custom_figure_class.py Download Jupyter notebook: custom_figure_class.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.figure import Figure\n\n\nclass WatermarkFigure(Figure):\n    \"\"\"A figure with a text watermark.\"\"\"\n\n    def __init__(self, *args, watermark=None, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if watermark is not None:\n            bbox = dict(boxstyle=\\'square\\', lw=3, ec=\\'gray\\',\n                        fc=(0.9, 0.9, .9, .5), alpha=0.5)\n            self.text(0.5, 0.5, watermark,\n                      ha=\\'center\\', va=\\'center\\', rotation=30,\n                      fontsize=40, color=\\'gray\\', alpha=0.5, bbox=bbox)\n\n\nx = np.linspace(-3, 3, 201)\ny = np.tanh(x) + 0.1 * np.cos(5 * x)\n\nplt.figure(FigureClass=WatermarkFigure, watermark=\\'draft\\')\nplt.plot(x, y)\n",
    "id": 109
},
{
    "title": "Resizing axes with constrained layout#",
    "text": "Constrained layout attempts to resize subplots in\na figure so that there are no overlaps between axes objects and labels\non the axes. See Constrained Layout Guide for more details and\nTight Layout guide for an alternative.', \"If we don't use constrained layout, then labels overlap the axes\", \"adding layout='constrained' automatically adjusts.\", 'Below is a more complicated example using nested gridspecs. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.gridspec.GridSpec matplotlib.gridspec.GridSpecFromSubplotSpec Total running time of the script: (0 minutes 1.941 seconds) Download Python source code: demo_constrained_layout.py Download Jupyter notebook: demo_constrained_layout.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef example_plot(ax):\n    ax.plot([1, 2])\n    ax.set_xlabel('x-label', fontsize=12)\n    ax.set_ylabel('y-label', fontsize=12)\n    ax.set_title('Title', fontsize=14)\n\", 'fig, axs = plt.subplots(nrows=2, ncols=2, layout=None)\n\nfor ax in axs.flat:\n    example_plot(ax)\n', \"fig, axs = plt.subplots(nrows=2, ncols=2, layout='constrained')\n\nfor ax in axs.flat:\n    example_plot(ax)\n\", \"fig = plt.figure(layout='constrained')\n\nimport matplotlib.gridspec as gridspec\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs1 = gridspec.GridSpecFromSubplotSpec(3, 1, subplot_spec=gs0[0])\nfor n in range(3):\n    ax = fig.add_subplot(gs1[n])\n    example_plot(ax)\n\n\ngs2 = gridspec.GridSpecFromSubplotSpec(2, 1, subplot_spec=gs0[1])\nfor n in range(2):\n    ax = fig.add_subplot(gs2[n])\n    example_plot(ax)\n\nplt.show()\n",
    "id": 110
},
{
    "title": "Resizing axes with tight layout#",
    "text": "tight_layout attempts to resize subplots in a figure so that there\nare no overlaps between axes objects and labels on the axes. See Tight Layout guide for more details and\nConstrained Layout Guide for an alternative. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.tight_layout /\nmatplotlib.pyplot.tight_layout matplotlib.figure.Figure.add_gridspec matplotlib.figure.Figure.add_subplot matplotlib.pyplot.subplot2grid Total running time of the script: (0 minutes 4.428 seconds) Download Python source code: demo_tight_layout.py Download Jupyter notebook: demo_tight_layout.ipynb ",
    "code": "import itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\n\nfontsizes = itertools.cycle([8, 16, 24, 32])\n\n\ndef example_plot(ax):\n    ax.plot([1, 2])\n    ax.set_xlabel('x-label', fontsize=next(fontsizes))\n    ax.set_ylabel('y-label', fontsize=next(fontsizes))\n    ax.set_title('Title', fontsize=next(fontsizes))\n\", 'fig, ax = plt.subplots()\nexample_plot(ax)\nfig.tight_layout()\n fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nfig.tight_layout()\n fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1)\nexample_plot(ax1)\nexample_plot(ax2)\nfig.tight_layout()\n fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2)\nexample_plot(ax1)\nexample_plot(ax2)\nfig.tight_layout()\n fig, axs = plt.subplots(nrows=3, ncols=3)\nfor ax in axs.flat:\n    example_plot(ax)\nfig.tight_layout()\n plt.figure()\nax1 = plt.subplot(221)\nax2 = plt.subplot(223)\nax3 = plt.subplot(122)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nplt.tight_layout()\n plt.figure()\nax1 = plt.subplot2grid((3, 3), (0, 0))\nax2 = plt.subplot2grid((3, 3), (0, 1), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 0), colspan=2, rowspan=2)\nax4 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\nexample_plot(ax4)\nplt.tight_layout()\n fig = plt.figure()\n\ngs1 = fig.add_gridspec(3, 1)\nax1 = fig.add_subplot(gs1[0])\nax2 = fig.add_subplot(gs1[1])\nax3 = fig.add_subplot(gs1[2])\nexample_plot(ax1)\nexample_plot(ax2)\nexample_plot(ax3)\ngs1.tight_layout(fig, rect=[None, None, 0.45, None])\n\ngs2 = fig.add_gridspec(2, 1)\nax4 = fig.add_subplot(gs2[0])\nax5 = fig.add_subplot(gs2[1])\nexample_plot(ax4)\nexample_plot(ax5)\nwith warnings.catch_warnings():\n    # gs2.tight_layout cannot handle the subplots from the first gridspec\n    # (gs1), so it will raise a warning. We are going to match the gridspecs\n    # manually so we can filter the warning away.\n    warnings.simplefilter(\"ignore\", UserWarning)\n    gs2.tight_layout(fig, rect=[0.45, None, None, None])\n\n# now match the top and bottom of two gridspecs.\ntop = min(gs1.top, gs2.top)\nbottom = max(gs1.bottom, gs2.bottom)\n\ngs1.update(top=top, bottom=bottom)\ngs2.update(top=top, bottom=bottom)\n\nplt.show()\n",
    "id": 111
},
{
    "title": "Different scales on the same axes#",
    "text": "Demo of how to display two scales on the left and right y-axis. This example uses the Fahrenheit and Celsius scales. Download Python source code: fahrenheit_celsius_scales.py Download Jupyter notebook: fahrenheit_celsius_scales.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef fahrenheit2celsius(temp):\n    \"\"\"\n    Returns temperature in Celsius given Fahrenheit temperature.\n    \"\"\"\n    return (5. / 9.) * (temp - 32)\n\n\ndef make_plot():\n\n    # Define a closure function to register as a callback\n    def convert_ax_c_to_celsius(ax_f):\n        \"\"\"\n        Update second axis according to first axis.\n        \"\"\"\n        y1, y2 = ax_f.get_ylim()\n        ax_c.set_ylim(fahrenheit2celsius(y1), fahrenheit2celsius(y2))\n        ax_c.figure.canvas.draw()\n\n    fig, ax_f = plt.subplots()\n    ax_c = ax_f.twinx()\n\n    # automatically update ylim of ax2 when ylim of ax1 changes.\n    ax_f.callbacks.connect(\"ylim_changed\", convert_ax_c_to_celsius)\n    ax_f.plot(np.linspace(-40, 120, 100))\n    ax_f.set_xlim(0, 100)\n\n    ax_f.set_title(\\'Two scales: Fahrenheit and Celsius\\')\n    ax_f.set_ylabel(\\'Fahrenheit\\')\n    ax_c.set_ylabel(\\'Celsius\\')\n\n    plt.show()\n\nmake_plot()\n",
    "id": 112
},
{
    "title": "Figure size in different units#",
    "text": "The native figure size unit in Matplotlib is inches, deriving from print\nindustry standards. However, users may need to specify their figures in other\nunits like centimeters or pixels. This example illustrates how to do this\nefficiently. Multiplying centimeter-based numbers with a conversion factor from cm to\ninches, gives the right numbers. Naming the conversion factor cm makes\nthe conversion almost look like appending a unit to the number, which is\nnicely readable. Similarly, one can use a conversion from pixels. Note that you could break this if you use savefig with a\ndifferent explicit dpi value. Quick interactive work is usually rendered to the screen, making pixels a\ngood size of unit. But defining the conversion factor may feel a little\ntedious for quick iterations.', \"Because of the default rcParamsfigure.dpi = 100, one can mentally\ndivide the needed pixel value by 100 [1]:\", \"Unfortunately, this does not work well for the matplotlib inline\nbackend in Jupyter because that backend uses a different default of\nrcParamsfigure.dpi = 72. Additionally, it saves the figure\nwith bbox_inches='tight', which crops the figure and makes the\nactual size unpredictable.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.pyplot.subplots matplotlib.pyplot.subplot_mosaic Download Python source code: figure_size_units.py Download Jupyter notebook: figure_size_units.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\ntext_kwargs = dict(ha='center', va='center', fontsize=28, color='C1')\n\", \"plt.subplots(figsize=(6, 2))\nplt.text(0.5, 0.5, '6 inches x 2 inches', **text_kwargs)\nplt.show()\n\", \"cm = 1/2.54  # centimeters in inches\nplt.subplots(figsize=(15*cm, 5*cm))\nplt.text(0.5, 0.5, '15cm x 5cm', **text_kwargs)\nplt.show()\n\", \"px = 1/plt.rcParamsfigure.dpi  # pixel in inches\nplt.subplots(figsize=(600*px, 200*px))\nplt.text(0.5, 0.5, '600px x 200px', **text_kwargs)\nplt.show()\n\", \"plt.subplots(figsize=(6, 2))\nplt.text(0.5, 0.5, '600px x 200px', **text_kwargs)\nplt.show()\n",
    "id": 113
},
{
    "title": "Figure labels: suptitle, supxlabel, supylabel#",
    "text": "Each axes can have a title (or actually three - one each with loc \"left\",\n\"center\", and \"right\"), but is sometimes desirable to give a whole figure\n(or SubFigure) an overall title, using FigureBase.suptitle. We can also add figure-level x- and y-labels using FigureBase.supxlabel and\nFigureBase.supylabel. A global x- or y-label can be set using the FigureBase.supxlabel and\nFigureBase.supylabel methods. Total running time of the script: (0 minutes 2.886 seconds) Download Python source code: figure_title.py Download Jupyter notebook: figure_title.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\n\nx = np.linspace(0.0, 5.0, 501)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, layout='constrained', sharey=True)\nax1.plot(x, np.cos(6*x) * np.exp(-x))\nax1.set_title('damped')\nax1.set_xlabel('time (s)')\nax1.set_ylabel('amplitude')\n\nax2.plot(x, np.cos(6*x))\nax2.set_xlabel('time (s)')\nax2.set_title('undamped')\n\nfig.suptitle('Different types of oscillations', fontsize=16)\n\", \"with get_sample_data('Stocks.csv') as file:\n    stocks = np.genfromtxt(\n        file, delimiter=',', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, 'D')}, skip_header=1)\n\nfig, axs = plt.subplots(4, 2, figsize=(9, 5), layout='constrained',\n                        sharex=True, sharey=True)\nfor nn, ax in enumerate(axs.flat):\n    column_name = stocks.dtype.names[1+nn]\n    y = stocks[column_name]\n    line, = ax.plot(stocksDate, y / np.nanmax(y), lw=2.5)\n    ax.set_title(column_name, fontsize='small', loc='left')\nfig.supxlabel('Year')\nfig.supylabel('Stock price relative to max')\n\nplt.show()\n",
    "id": 114
},
{
    "title": "Creating adjacent subplots#",
    "text": "To create plots that share a common axis (visually) you can set the hspace\nbetween the subplots to zero. Passing sharex=True when creating the subplots\nwill automatically turn off all x ticks and labels except those on the bottom\naxis. In this example the plots share a common x-axis, but you can follow the same\nlogic to supply a common y-axis. Download Python source code: ganged_plots.py Download Jupyter notebook: ganged_plots.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\n\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = s1 * s2\n\nfig, axs = plt.subplots(3, 1, sharex=True)\n# Remove vertical space between axes\nfig.subplots_adjust(hspace=0)\n\n# Plot each graph, and manually set the y tick values\naxs[0].plot(t, s1)\naxs[0].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[0].set_ylim(-1, 1)\n\naxs[1].plot(t, s2)\naxs[1].set_yticks(np.arange(0.1, 1.0, 0.2))\naxs[1].set_ylim(0, 1)\n\naxs[2].plot(t, s3)\naxs[2].set_yticks(np.arange(-0.9, 1.0, 0.4))\naxs[2].set_ylim(-1, 1)\n\nplt.show()\n",
    "id": 115
},
{
    "title": "Geographic Projections#",
    "text": "This shows 4 possible geographic projections. Cartopy supports more\nprojections. Total running time of the script: (0 minutes 1.208 seconds) Download Python source code: geo_demo.py Download Jupyter notebook: geo_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n plt.figure()\nplt.subplot(projection=\"aitoff\")\nplt.title(\"Aitoff\")\nplt.grid(True)\n plt.figure()\nplt.subplot(projection=\"hammer\")\nplt.title(\"Hammer\")\nplt.grid(True)\n plt.figure()\nplt.subplot(projection=\"lambert\")\nplt.title(\"Lambert\")\nplt.grid(True)\n plt.figure()\nplt.subplot(projection=\"mollweide\")\nplt.title(\"Mollweide\")\nplt.grid(True)\n\nplt.show()\n",
    "id": 116
},
{
    "title": "Combining two subplots using subplots and GridSpec#",
    "text": "Sometimes we want to combine two subplots in an axes layout created with\nsubplots. We can get the GridSpec from the axes\nand then remove the covered axes and fill the gap with a new bigger axes.\nHere we create a layout with the bottom two axes in the last column combined. To start with this layout (rather than removing the overlapping axes) use\nsubplot_mosaic. See also Arranging multiple Axes in a Figure. Download Python source code: gridspec_and_subplots.py Download Jupyter notebook: gridspec_and_subplots.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(ncols=3, nrows=3)\ngs = axs[1, 2].get_gridspec()\n# remove the underlying axes\nfor ax in axs[1:, -1]:\n    ax.remove()\naxbig = fig.add_subplot(gs[1:, -1])\naxbig.annotate('Big Axes \\\nGridSpec[1:, -1]', (0.1, 0.5),\n               xycoords='axes fraction', va='center')\n\nfig.tight_layout()\n\nplt.show()\n",
    "id": 117
},
{
    "title": "Using Gridspec to make multi-column/row subplot layouts#",
    "text": "GridSpec is a flexible way to layout\nsubplot grids. Here is an example with a 3x3 grid, and\naxes spanning all three columns, two columns, and two rows. Download Python source code: gridspec_multicolumn.py Download Jupyter notebook: gridspec_multicolumn.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\nfig = plt.figure(layout=\"constrained\")\n\ngs = GridSpec(3, 3, figure=fig)\nax1 = fig.add_subplot(gs[0, :])\n# identical to ax1 = plt.subplot(gs.new_subplotspec((0, 0), colspan=3))\nax2 = fig.add_subplot(gs[1, :-1])\nax3 = fig.add_subplot(gs[1:, -1])\nax4 = fig.add_subplot(gs[-1, 0])\nax5 = fig.add_subplot(gs[-1, -2])\n\nfig.suptitle(\"GridSpec\")\nformat_axes(fig)\n\nplt.show()\n",
    "id": 118
},
{
    "title": "Nested Gridspecs#",
    "text": "GridSpecs can be nested, so that a subplot from a parent GridSpec can\nset the position for a nested grid of subplots. Note that the same functionality can be achieved more directly with\nsubfigures; see\nFigure subfigures. Download Python source code: gridspec_nested.py Download Jupyter notebook: gridspec_nested.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.gridspec as gridspec\n\n\ndef format_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\n# gridspec inside gridspec\nfig = plt.figure()\n\ngs0 = gridspec.GridSpec(1, 2, figure=fig)\n\ngs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0])\n\nax1 = fig.add_subplot(gs00[:-1, :])\nax2 = fig.add_subplot(gs00[-1, :-1])\nax3 = fig.add_subplot(gs00[-1, -1])\n\n# the following syntax does the same as the GridSpecFromSubplotSpec call above:\ngs01 = gs0[1].subgridspec(3, 3)\n\nax4 = fig.add_subplot(gs01[:, :-1])\nax5 = fig.add_subplot(gs01[:-1, -1])\nax6 = fig.add_subplot(gs01[-1, -1])\n\nplt.suptitle(\"GridSpec Inside GridSpec\")\nformat_axes(fig)\n\nplt.show()\n",
    "id": 119
},
{
    "title": "Invert Axes#",
    "text": "You can use decreasing axes by flipping the normal order of the axis\nlimits Download Python source code: invert_axes.py Download Jupyter notebook: invert_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns = np.exp(-t)\n\nfig, ax = plt.subplots()\n\nax.plot(t, s)\nax.set_xlim(5, 0)  # decreasing time\nax.set_xlabel('decreasing time (s)')\nax.set_ylabel('voltage (mV)')\nax.set_title('Should be growing...')\nax.grid(True)\n\nplt.show()\n",
    "id": 120
},
{
    "title": "Managing multiple figures in pyplot#",
    "text": "matplotlib.pyplot uses the concept of a current figure and current axes.\nFigures are identified via a figure number that is passed to figure.\nThe figure with the given number is set as current figure. Additionally, if\nno figure with the number exists, a new one is created. Note We discourage working with multiple figures through the implicit pyplot\ninterface because managing the current figure is cumbersome and\nerror-prone. Instead, we recommend using the explicit approach and call\nmethods on Figure and Axes instances. See Matplotlib Application Interfaces (APIs) for an\nexplanation of the trade-offs between the implicit and explicit interfaces. Create figure 1 Create figure 2 Now switch back to figure 1 and make some changes Download Python source code: multiple_figs_demo.py Download Jupyter notebook: multiple_figs_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(4*np.pi*t)\n plt.figure(1)\nplt.subplot(211)\nplt.plot(t, s1)\nplt.subplot(212)\nplt.plot(t, 2*s1)\n plt.figure(2)\nplt.plot(t, s2)\n', \"plt.figure(1)\nplt.subplot(211)\nplt.plot(t, s2, 's')\nax = plt.gca()\nax.set_xticklabels([])\n\nplt.show()\n",
    "id": 121
},
{
    "title": "Secondary Axis#",
    "text": "Sometimes we want a secondary axis on a plot, for instance to convert\nradians to degrees on the same plot. We can do this by making a child\naxes with only one axis visible via axes.Axes.secondary_xaxis and\naxes.Axes.secondary_yaxis. This secondary axis can have a different scale\nthan the main axis by providing both a forward and an inverse conversion\nfunction in a tuple to the functions keyword argument: Here is the case of converting from wavenumber to wavelength in a\nlog-log scale. Note In this case, the xscale of the parent is logarithmic, so the child is\nmade logarithmic as well. Sometime we want to relate the axes in a transform that is ad-hoc from\nthe data, and is derived empirically. In that case we can set the\nforward and inverse transforms functions to be linear interpolations from the\none data set to the other. Note In order to properly handle the data margins, the mapping functions\n(forward and inverse in this example) need to be defined beyond the\nnominal plot limits. In the specific case of the numpy linear interpolation, numpy.interp,\nthis condition can be arbitrarily enforced by providing optional keyword\narguments left, right such that values outside the data range are\nmapped well outside the plot limits. A final example translates np.datetime64 to yearday on the x axis and\nfrom Celsius to Fahrenheit on the y axis. Note the addition of a\nthird y axis, and that it can be placed using a float for the\nlocation argument References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.secondary_xaxis matplotlib.axes.Axes.secondary_yaxis Total running time of the script: (0 minutes 4.213 seconds) Download Python source code: secondary_axis.py Download Jupyter notebook: secondary_axis.ipynb ",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\nfrom matplotlib.ticker import AutoMinorLocator\n\nfig, ax = plt.subplots(layout='constrained')\nx = np.arange(0, 360, 1)\ny = np.sin(2 * x * np.pi / 180)\nax.plot(x, y)\nax.set_xlabel('angle [degrees]')\nax.set_ylabel('signal')\nax.set_title('Sine wave')\n\n\ndef deg2rad(x):\n    return x * np.pi / 180\n\n\ndef rad2deg(x):\n    return x * 180 / np.pi\n\n\nsecax = ax.secondary_xaxis('top', functions=(deg2rad, rad2deg))\nsecax.set_xlabel('angle [rad]')\nplt.show()\n\", 'fig, ax = plt.subplots(layout=\\'constrained\\')\nx = np.arange(0.02, 1, 0.02)\nnp.random.seed(19680801)\ny = np.random.randn(len(x)) ** 2\nax.loglog(x, y)\nax.set_xlabel(\\'f [Hz]\\')\nax.set_ylabel(\\'PSD\\')\nax.set_title(\\'Random spectrum\\')\n\n\ndef one_over(x):\n    \"\"\"Vectorized 1/x, treating x==0 manually\"\"\"\n    x = np.array(x, float)\n    near_zero = np.isclose(x, 0)\n    x[near_zero] = np.inf\n    x[~near_zero] = 1 / x[~near_zero]\n    return x\n\n\n# the function \"1/x\" is its own inverse\ninverse = one_over\n\n\nsecax = ax.secondary_xaxis(\\'top\\', functions=(one_over, inverse))\nsecax.set_xlabel(\\'period [s]\\')\nplt.show()\n', \"fig, ax = plt.subplots(layout='constrained')\nxdata = np.arange(1, 11, 0.4)\nydata = np.random.randn(len(xdata))\nax.plot(xdata, ydata, label='Plotted data')\n\nxold = np.arange(0, 11, 0.2)\n# fake data set relating x coordinate to another data-derived coordinate.\n# xnew must be monotonic, so we sort...\nxnew = np.sort(10 * np.exp(-xold / 4) + np.random.randn(len(xold)) / 3)\n\nax.plot(xold[3:], xnew[3:], label='Transform data')\nax.set_xlabel('X [m]')\nax.legend()\n\n\ndef forward(x):\n    return np.interp(x, xold, xnew)\n\n\ndef inverse(x):\n    return np.interp(x, xnew, xold)\n\n\nsecax = ax.secondary_xaxis('top', functions=(forward, inverse))\nsecax.xaxis.set_minor_locator(AutoMinorLocator())\nsecax.set_xlabel('$X_{other}$')\n\nplt.show()\n\", 'dates = [datetime.datetime(2018, 1, 1) + datetime.timedelta(hours=k * 6)\n         for k in range(240)]\ntemperature = np.random.randn(len(dates)) * 4 + 6.7\nfig, ax = plt.subplots(layout=\\'constrained\\')\n\nax.plot(dates, temperature)\nax.set_ylabel(r\\'$T\\\\ [^oC]$\\')\nplt.xticks(rotation=70)\n\n\ndef date2yday(x):\n    \"\"\"Convert matplotlib datenum to days since 2018-01-01.\"\"\"\n    y = x - mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\ndef yday2date(x):\n    \"\"\"Return a matplotlib datenum for *x* days after 2018-01-01.\"\"\"\n    y = x + mdates.date2num(datetime.datetime(2018, 1, 1))\n    return y\n\n\nsecax_x = ax.secondary_xaxis(\\'top\\', functions=(date2yday, yday2date))\nsecax_x.set_xlabel(\\'yday [2018]\\')\n\n\ndef celsius_to_fahrenheit(x):\n    return x * 1.8 + 32\n\n\ndef fahrenheit_to_celsius(x):\n    return (x - 32) / 1.8\n\n\nsecax_y = ax.secondary_yaxis(\n    \\'right\\', functions=(celsius_to_fahrenheit, fahrenheit_to_celsius))\nsecax_y.set_ylabel(r\\'$T\\\\ [^oF]$\\')\n\n\ndef celsius_to_anomaly(x):\n    return (x - np.mean(temperature))\n\n\ndef anomaly_to_celsius(x):\n    return (x + np.mean(temperature))\n\n\n# use of a float for the position:\nsecax_y2 = ax.secondary_yaxis(\n    1.2, functions=(celsius_to_anomaly, anomaly_to_celsius))\nsecax_y2.set_ylabel(r\\'$T - \\\\overline{T}\\\\ [^oC]$\\')\n\n\nplt.show()\n",
    "id": 122
},
{
    "title": "Sharing axis limits and views#",
    "text": "It's common to make two or more plots which share an axis, e.g., two subplots\nwith time as a common axis. When you pan and zoom around on one, you want the\nother to move around with you. To facilitate this, matplotlib Axes support a\nsharex and sharey attribute. When you create a subplot or\naxes, you can pass in a keyword indicating what axes you want to\nshare with.\", 'Download Python source code: share_axis_lims_views.py Download Jupyter notebook: share_axis_lims_views.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0, 10, 0.01)\n\nax1 = plt.subplot(211)\nax1.plot(t, np.sin(2*np.pi*t))\n\nax2 = plt.subplot(212, sharex=ax1)\nax2.plot(t, np.sin(4*np.pi*t))\n\nplt.show()\n",
    "id": 123
},
{
    "title": "Shared axis#",
    "text": "You can share the x- or y-axis limits for one axis with another by\npassing an Axes instance as a sharex or sharey keyword argument. Changing the axis limits on one axes will be reflected automatically\nin the other, and vice-versa, so when you navigate with the toolbar\nthe Axes will follow each other on their shared axis. Ditto for\nchanges in the axis scaling (e.g., log vs. linear). However, it is\npossible to have differences in tick labeling, e.g., you can selectively\nturn off the tick labels on one Axes. The example below shows how to customize the tick labels on the\nvarious axes. Shared axes share the tick locator, tick formatter,\nview limits, and transformation (e.g., log, linear). But the ticklabels\nthemselves do not share properties. This is a feature and not a bug,\nbecause you may want to make the tick labels smaller on the upper\naxes, e.g., in the example below. If you want to turn off the ticklabels for a given Axes (e.g., on\nsubplot(211) or subplot(212)), you cannot do the standard trick: because this changes the tick Formatter, which is shared among all\nAxes. But you can alter the visibility of the labels, which is a\nproperty: Download Python source code: shared_axis_demo.py Download Jupyter notebook: shared_axis_demo.ipynb ",
    "code": "setp(ax2, xticklabels=[])\n setp(ax2.get_xticklabels(), visible=False)\n', \"import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.01, 5.0, 0.01)\ns1 = np.sin(2 * np.pi * t)\ns2 = np.exp(-t)\ns3 = np.sin(4 * np.pi * t)\n\nax1 = plt.subplot(311)\nplt.plot(t, s1)\nplt.tick_params('x', labelsize=6)\n\n# share x only\nax2 = plt.subplot(312, sharex=ax1)\nplt.plot(t, s2)\n# make these tick labels invisible\nplt.tick_params('x', labelbottom=False)\n\n# share x and y\nax3 = plt.subplot(313, sharex=ax1, sharey=ax1)\nplt.plot(t, s3)\nplt.xlim(0.01, 5.0)\nplt.show()\n",
    "id": 124
},
{
    "title": "Figure subfigures#",
    "text": "Sometimes it is desirable to have a figure with two different layouts in it.\nThis can be achieved with\nnested gridspecs,\nbut having a virtual figure with its own artists is helpful, so\nMatplotlib also has \"subfigures\", accessed by calling\nmatplotlib.figure.Figure.add_subfigure in a way that is analogous to\nmatplotlib.figure.Figure.add_subplot, or\nmatplotlib.figure.Figure.subfigures to make an array of subfigures. Note\nthat subfigures can also have their own child subfigures. Note The subfigure concept is new in v3.4, and the API is still provisional. It is possible to mix subplots and subfigures using\nmatplotlib.figure.Figure.add_subfigure. This requires getting\nthe gridspec that the subplots are laid out on. Subfigures can have different widths and heights. This is exactly the\nsame example as the first example, but width_ratios has been changed: Subfigures can be also be nested: Total running time of the script: (0 minutes 4.607 seconds) Download Python source code: subfigures.py Download Jupyter notebook: subfigures.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef example_plot(ax, fontsize=12, hide_labels=False):\n    pc = ax.pcolormesh(np.random.randn(30, 30), vmin=-2.5, vmax=2.5)\n    if not hide_labels:\n        ax.set_xlabel('x-label', fontsize=fontsize)\n        ax.set_ylabel('y-label', fontsize=fontsize)\n        ax.set_title('Title', fontsize=fontsize)\n    return pc\n\nnp.random.seed(19680808)\n# gridspec inside gridspec\nfig = plt.figure(layout='constrained', figsize=(10, 4))\nsubfigs = fig.subfigures(1, 2, wspace=0.07)\n\naxsLeft = subfigs[0].subplots(1, 2, sharey=True)\nsubfigs[0].set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfigs[0].suptitle('Left plots', fontsize='x-large')\nsubfigs[0].colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\naxsRight = subfigs[1].subplots(3, 1, sharex=True)\nfor nn, ax in enumerate(axsRight):\n    pc = example_plot(ax, hide_labels=True)\n    if nn == 2:\n        ax.set_xlabel('xlabel')\n    if nn == 1:\n        ax.set_ylabel('ylabel')\n\nsubfigs[1].set_facecolor('0.85')\nsubfigs[1].colorbar(pc, shrink=0.6, ax=axsRight)\nsubfigs[1].suptitle('Right plots', fontsize='x-large')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\n\nplt.show()\n\", \"fig, axs = plt.subplots(2, 3, layout='constrained', figsize=(10, 4))\ngridspec = axs[0, 0].get_subplotspec().get_gridspec()\n\n# clear the left column for the subfigure:\nfor a in axs[:, 0]:\n    a.remove()\n\n# plot data in remaining axes:\nfor a in axs[:, 1:].flat:\n    a.plot(np.arange(10))\n\n# make the subfigure in the empty gridspec slots:\nsubfig = fig.add_subfigure(gridspec[:, 0])\n\naxsLeft = subfig.subplots(1, 2, sharey=True)\nsubfig.set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfig.suptitle('Left plots', fontsize='x-large')\nsubfig.colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\nplt.show()\n\", \"fig = plt.figure(layout='constrained', figsize=(10, 4))\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[2, 1])\n\naxsLeft = subfigs[0].subplots(1, 2, sharey=True)\nsubfigs[0].set_facecolor('0.75')\nfor ax in axsLeft:\n    pc = example_plot(ax)\nsubfigs[0].suptitle('Left plots', fontsize='x-large')\nsubfigs[0].colorbar(pc, shrink=0.6, ax=axsLeft, location='bottom')\n\naxsRight = subfigs[1].subplots(3, 1, sharex=True)\nfor nn, ax in enumerate(axsRight):\n    pc = example_plot(ax, hide_labels=True)\n    if nn == 2:\n        ax.set_xlabel('xlabel')\n    if nn == 1:\n        ax.set_ylabel('ylabel')\n\nsubfigs[1].set_facecolor('0.85')\nsubfigs[1].colorbar(pc, shrink=0.6, ax=axsRight)\nsubfigs[1].suptitle('Right plots', fontsize='x-large')\n\nfig.suptitle('Figure suptitle', fontsize='xx-large')\n\nplt.show()\n\", \"fig = plt.figure(layout='constrained', figsize=(10, 8))\n\nfig.suptitle('fig')\n\nsubfigs = fig.subfigures(1, 2, wspace=0.07)\n\nsubfigs[0].set_facecolor('coral')\nsubfigs[0].suptitle('subfigs[0]')\n\nsubfigs[1].set_facecolor('coral')\nsubfigs[1].suptitle('subfigs[1]')\n\nsubfigsnest = subfigs[0].subfigures(2, 1, height_ratios=[1, 1.4])\nsubfigsnest[0].suptitle('subfigsnest[0]')\nsubfigsnest[0].set_facecolor('r')\naxsnest0 = subfigsnest[0].subplots(1, 2, sharey=True)\nfor nn, ax in enumerate(axsnest0):\n    pc = example_plot(ax, hide_labels=True)\nsubfigsnest[0].colorbar(pc, ax=axsnest0)\n\nsubfigsnest[1].suptitle('subfigsnest[1]')\nsubfigsnest[1].set_facecolor('g')\naxsnest1 = subfigsnest[1].subplots(3, 1, sharex=True)\n\naxsRight = subfigs[1].subplots(2, 2)\n\nplt.show()\n",
    "id": 125
},
{
    "title": "Multiple subplots#",
    "text": "Simple demo with multiple subplots. For more options, see Creating multiple subplots using plt.subplots. subplots() is the recommended method to generate simple subplot\narrangements: Subplots can also be generated one at a time using subplot(): Download Python source code: subplot.py Download Jupyter notebook: subplot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some fake data.\nx1 = np.linspace(0.0, 5.0)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\nx2 = np.linspace(0.0, 2.0)\ny2 = np.cos(2 * np.pi * x2)\n', \"fig, (ax1, ax2) = plt.subplots(2, 1)\nfig.suptitle('A tale of 2 subplots')\n\nax1.plot(x1, y1, 'o-')\nax1.set_ylabel('Damped oscillation')\n\nax2.plot(x2, y2, '.-')\nax2.set_xlabel('time (s)')\nax2.set_ylabel('Undamped')\n\nplt.show()\n\", \"plt.subplot(2, 1, 1)\nplt.plot(x1, y1, 'o-')\nplt.title('A tale of 2 subplots')\nplt.ylabel('Damped oscillation')\n\nplt.subplot(2, 1, 2)\nplt.plot(x2, y2, '.-')\nplt.xlabel('time (s)')\nplt.ylabel('Undamped')\n\nplt.show()\n",
    "id": 126
},
{
    "title": "Subplots spacings and margins#",
    "text": "Adjusting the spacing of margins and subplots using pyplot.subplots_adjust. Note There is also a tool window to adjust the margins and spacings of displayed\nfigures interactively. It can be opened via the toolbar or by calling\npyplot.subplot_tool. Download Python source code: subplots_adjust.py Download Jupyter notebook: subplots_adjust.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.subplot(211)\nplt.imshow(np.random.random((100, 100)))\nplt.subplot(212)\nplt.imshow(np.random.random((100, 100)))\n\nplt.subplots_adjust(bottom=0.1, right=0.8, top=0.9)\ncax = plt.axes((0.85, 0.1, 0.075, 0.8))\nplt.colorbar(cax=cax)\n\nplt.show()\n",
    "id": 127
},
{
    "title": "Creating multiple subplots using plt.subplots#",
    "text": "pyplot.subplots creates a figure and a grid of subplots with a single call,\nwhile providing reasonable control over how the individual plots are created.\nFor more advanced use cases you can use GridSpec for a more general subplot\nlayout or Figure.add_subplot for adding subplots at arbitrary locations\nwithin the figure. subplots() without arguments returns a Figure and a single\nAxes. This is actually the simplest and recommended way of creating a single\nFigure and Axes. The first two optional arguments of pyplot.subplots define the number of\nrows and columns of the subplot grid. When stacking in one direction only, the returned axs is a 1D numpy array\ncontaining the list of created Axes.', \"If you are creating just a few Axes, it's handy to unpack them immediately to\ndedicated variables for each Axes. That way, we can use ax1 instead of\nthe more verbose axs[0].\", 'To obtain side-by-side subplots, pass parameters 1, 2 for one row and two\ncolumns. When stacking in two directions, the returned axs is a 2D NumPy array.', \"If you have to set parameters for each subplot it's handy to iterate over\nall subplots in a 2D grid using for ax in axs.flat:.\", 'You can use tuple-unpacking also in 2D to assign all subplots to dedicated\nvariables: By default, each Axes is scaled individually. Thus, if the ranges are\ndifferent the tick values of the subplots do not align. You can use sharex or sharey to align the horizontal or vertical axis. Setting sharex or sharey to True enables global sharing across the\nwhole grid, i.e. also the y-axes of vertically stacked subplots have the\nsame scale when using sharey=True. For subplots that are sharing axes one set of tick labels is enough. Tick\nlabels of inner Axes are automatically removed by sharex and sharey.\nStill there remains an unused empty space between the subplots. To precisely control the positioning of the subplots, one can explicitly\ncreate a GridSpec with Figure.add_gridspec, and then call its\nsubplots method. For example, we can reduce the height\nbetween vertical subplots using add_gridspec(hspace=0). label_outer is a handy method to remove labels and ticks from subplots\nthat are not at the edge of the grid.', \"Apart from True and False, both sharex and sharey accept the\nvalues 'row' and 'col' to share the values only per row or column.\", 'If you want a more complex sharing structure, you can first create the\ngrid of axes with no sharing, and then call axes.Axes.sharex or\naxes.Axes.sharey to add sharing info a posteriori. The parameter subplot_kw of pyplot.subplots controls the subplot\nproperties (see also Figure.add_subplot). In particular, this can be used\nto create a grid of polar Axes. Total running time of the script: (0 minutes 6.311 seconds) Download Python source code: subplots_demo.py Download Jupyter notebook: subplots_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Some example data to display\nx = np.linspace(0, 2 * np.pi, 400)\ny = np.sin(x ** 2)\n', \"fig, ax = plt.subplots()\nax.plot(x, y)\nax.set_title('A single plot')\n\", \"fig, axs = plt.subplots(2)\nfig.suptitle('Vertically stacked subplots')\naxs[0].plot(x, y)\naxs[1].plot(x, -y)\n\", \"fig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Vertically stacked subplots')\nax1.plot(x, y)\nax2.plot(x, -y)\n\", \"fig, (ax1, ax2) = plt.subplots(1, 2)\nfig.suptitle('Horizontally stacked subplots')\nax1.plot(x, y)\nax2.plot(x, -y)\n\", \"fig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title('Axis [0, 0]')\naxs[0, 1].plot(x, y, 'tab:orange')\naxs[0, 1].set_title('Axis [0, 1]')\naxs[1, 0].plot(x, -y, 'tab:green')\naxs[1, 0].set_title('Axis [1, 0]')\naxs[1, 1].plot(x, -y, 'tab:red')\naxs[1, 1].set_title('Axis [1, 1]')\n\nfor ax in axs.flat:\n    ax.set(xlabel='x-label', ylabel='y-label')\n\n# Hide x labels and tick labels for top plots and y ticks for right plots.\nfor ax in axs.flat:\n    ax.label_outer()\n\", \"fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x, -y, 'tab:green')\nax4.plot(x, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\", \"fig, (ax1, ax2) = plt.subplots(2)\nfig.suptitle('Axes values are scaled individually by default')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\", \"fig, (ax1, ax2) = plt.subplots(2, sharex=True)\nfig.suptitle('Aligning x-axis using sharex')\nax1.plot(x, y)\nax2.plot(x + 1, -y)\n\", \"fig, axs = plt.subplots(3, sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\", \"fig = plt.figure()\ngs = fig.add_gridspec(3, hspace=0)\naxs = gs.subplots(sharex=True, sharey=True)\nfig.suptitle('Sharing both axes')\naxs[0].plot(x, y ** 2)\naxs[1].plot(x, 0.3 * y, 'o')\naxs[2].plot(x, y, '+')\n\n# Hide x labels and tick labels for all but bottom plot.\nfor ax in axs:\n    ax.label_outer()\n\", \"fig = plt.figure()\ngs = fig.add_gridspec(2, 2, hspace=0, wspace=0)\n(ax1, ax2), (ax3, ax4) = gs.subplots(sharex='col', sharey='row')\nfig.suptitle('Sharing x per column, y per row')\nax1.plot(x, y)\nax2.plot(x, y**2, 'tab:orange')\nax3.plot(x + 1, -y, 'tab:green')\nax4.plot(x + 2, -y**2, 'tab:red')\n\nfor ax in fig.get_axes():\n    ax.label_outer()\n\", 'fig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title(\"main\")\naxs[1, 0].plot(x, y**2)\naxs[1, 0].set_title(\"shares x with main\")\naxs[1, 0].sharex(axs[0, 0])\naxs[0, 1].plot(x + 1, y + 1)\naxs[0, 1].set_title(\"unrelated\")\naxs[1, 1].plot(x + 2, y + 2)\naxs[1, 1].set_title(\"also unrelated\")\nfig.tight_layout()\n', \"fig, (ax1, ax2) = plt.subplots(1, 2, subplot_kw=dict(projection='polar'))\nax1.plot(x, y)\nax2.plot(x, y ** 2)\n\nplt.show()\n",
    "id": 128
},
{
    "title": "Plots with different scales#",
    "text": "Two plots on the same axes with different left and right scales. The trick is to use two different axes that share the same x axis.\nYou can use separate matplotlib.ticker formatters and locators as\ndesired since the two axes are independent. Such axes are generated by calling the Axes.twinx method. Likewise,\nAxes.twiny is available to generate axes that share a y axis but\nhave different top and bottom scales. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.twinx / matplotlib.pyplot.twinx matplotlib.axes.Axes.twiny / matplotlib.pyplot.twiny matplotlib.axes.Axes.tick_params / matplotlib.pyplot.tick_params Download Python source code: two_scales.py Download Jupyter notebook: two_scales.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create some mock data\nt = np.arange(0.01, 10.0, 0.01)\ndata1 = np.exp(t)\ndata2 = np.sin(2 * np.pi * t)\n\nfig, ax1 = plt.subplots()\n\ncolor = 'tab:red'\nax1.set_xlabel('time (s)')\nax1.set_ylabel('exp', color=color)\nax1.plot(t, data1, color=color)\nax1.tick_params(axis='y', labelcolor=color)\n\nax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n\ncolor = 'tab:blue'\nax2.set_ylabel('sin', color=color)  # we already handled the x-label with ax1\nax2.plot(t, data2, color=color)\nax2.tick_params(axis='y', labelcolor=color)\n\nfig.tight_layout()  # otherwise the right y-label is slightly clipped\nplt.show()\n",
    "id": 129
},
{
    "title": "Zoom region inset axes#",
    "text": "Example of an inset axes and a rectangle showing where the zoom is located. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.inset_axes matplotlib.axes.Axes.indicate_inset_zoom matplotlib.axes.Axes.imshow Download Python source code: zoom_inset_axes.py Download Jupyter notebook: zoom_inset_axes.ipynb ",
    "code": "import numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib import pyplot as plt\n\nfig, ax = plt.subplots()\n\n# make data\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\nextent = (-3, 4, -4, 3)\n\nax.imshow(Z2, extent=extent, origin=\"lower\")\n\n# inset axes....\nx1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9  # subregion of the original image\naxins = ax.inset_axes(\n    [0.5, 0.5, 0.47, 0.47],\n    xlim=(x1, x2), ylim=(y1, y2), xticklabels=[], yticklabels=[])\naxins.imshow(Z2, extent=extent, origin=\"lower\")\n\nax.indicate_inset_zoom(axins, edgecolor=\"black\")\n\nplt.show()\n",
    "id": 130
},
{
    "title": "Percentiles as horizontal bar chart#",
    "text": "Bar charts are useful for visualizing counts, or summary statistics\nwith error bars. Also see the Grouped bar chart with labels\nor the Horizontal bar chart example for simpler versions\nof those features.', \"This example comes from an application in which grade school gym\nteachers wanted to be able to show parents how their child did across\na handful of fitness tests, and importantly, relative to how other\nchildren did. To extract the plotting code for demo purposes, we'll\njust make up some data for little Johnny Doe.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.bar_label / matplotlib.pyplot.bar_label matplotlib.axes.Axes.twinx / matplotlib.pyplot.twinx Download Python source code: barchart_demo.py Download Jupyter notebook: barchart_demo.ipynb ",
    "code": "from collections import namedtuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nStudent = namedtuple(\\'Student\\', [\\'name\\', \\'grade\\', \\'gender\\)\nScore = namedtuple(\\'Score\\', [\\'value\\', \\'unit\\', \\'percentile\\)\n\n\ndef to_ordinal(num):\n    \"\"\"Convert an integer to an ordinal string, e.g. 2 -> \\'2nd\\'.\"\"\"\n    suffixes = {str(i): v\n                for i, v in enumerate([\\'th\\', \\'st\\', \\'nd\\', \\'rd\\', \\'th\\',\n                                       \\'th\\', \\'th\\', \\'th\\', \\'th\\', \\'th\\)}\n    v = str(num)\n    # special case early teens\n    if v in {\\'11\\', \\'12\\', \\'13\\'}:\n        return v + \\'th\\'\n    return v + suffixes[v[-1]]\n\n\ndef format_score(score):\n    \"\"\"\n    Create score labels for the right y-axis as the test name followed by the\n    measurement unit (if any), split over two lines.\n    \"\"\"\n    return f\\'{score.value}\\\n{score.unit}\\' if score.unit else str(score.value)\n\n\ndef plot_student_results(student, scores_by_test, cohort_size):\n    fig, ax1 = plt.subplots(figsize=(9, 7), layout=\\'constrained\\')\n    fig.canvas.manager.set_window_title(\\'Eldorado K-8 Fitness Chart\\')\n\n    ax1.set_title(student.name)\n    ax1.set_xlabel(\n        \\'Percentile Ranking Across {grade} Grade {gender}s\\\n\\'\n        \\'Cohort Size: {cohort_size}\\'.format(\n            grade=to_ordinal(student.grade),\n            gender=student.gender.title(),\n            cohort_size=cohort_size))\n\n    test_names = list(scores_by_test.keys())\n    percentiles = [score.percentile for score in scores_by_test.values()]\n\n    rects = ax1.barh(test_names, percentiles, align=\\'center\\', height=0.5)\n    # Partition the percentile values to be able to draw large numbers in\n    # white within the bar, and small numbers in black outside the bar.\n    large_percentiles = [to_ordinal(p) if p > 40 else \\'\\' for p in percentiles]\n    small_percentiles = [to_ordinal(p) if p <= 40 else \\'\\' for p in percentiles]\n    ax1.bar_label(rects, small_percentiles,\n                  padding=5, color=\\'black\\', fontweight=\\'bold\\')\n    ax1.bar_label(rects, large_percentiles,\n                  padding=-32, color=\\'white\\', fontweight=\\'bold\\')\n\n    ax1.set_xlim([0, 100])\n    ax1.set_xticks([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\n    ax1.xaxis.grid(True, linestyle=\\'--\\', which=\\'major\\',\n                   color=\\'grey\\', alpha=.25)\n    ax1.axvline(50, color=\\'grey\\', alpha=0.25)  # median position\n\n    # Set the right-hand Y-axis ticks and labels\n    ax2 = ax1.twinx()\n    # Set equal limits on both yaxis so that the ticks line up\n    ax2.set_ylim(ax1.get_ylim())\n    # Set the tick locations and labels\n    ax2.set_yticks(\n        np.arange(len(scores_by_test)),\n        labels=[format_score(score) for score in scores_by_test.values()])\n\n    ax2.set_ylabel(\\'Test Scores\\')\n\n\nstudent = Student(name=\\'Johnny Doe\\', grade=2, gender=\\'Boy\\')\nscores_by_test = {\n    \\'Pacer Test\\': Score(7, \\'laps\\', percentile=37),\n    \\'Flexed Arm\\\n Hang\\': Score(48, \\'sec\\', percentile=95),\n    \\'Mile Run\\': Score(\\'12:52\\', \\'min:sec\\', percentile=73),\n    \\'Agility\\': Score(17, \\'sec\\', percentile=60),\n    \\'Push Ups\\': Score(14, \\'\\', percentile=16),\n}\n\nplot_student_results(student, scores_by_test, cohort_size=62)\nplt.show()\n",
    "id": 132
},
{
    "title": "Artist customization in box plots#",
    "text": "This example demonstrates how to use the various keyword arguments to fully\ncustomize box plots. The first figure demonstrates how to remove and add\nindividual components (note that the mean is the only value not shown by\ndefault). The second figure demonstrates how the styles of the artists can be\ncustomized. It also demonstrates how to set the limit of the whiskers to\nspecific percentiles (lower right axes) A good general reference on boxplots and their history can be found here:\nhttps://vita.had.co.nz/papers/boxplots.pdf Demonstrate how to toggle the display of different elements: Demonstrate how to customize the display different elements: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.boxplot / matplotlib.pyplot.boxplot Total running time of the script: (0 minutes 1.926 seconds) Download Python source code: boxplot.py Download Jupyter notebook: boxplot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# fake data\nnp.random.seed(19680801)\ndata = np.random.lognormal(size=(37, 4), mean=1.5, sigma=1.75)\nlabels = list('ABCD')\nfs = 10  # fontsize\n\", \"fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].boxplot(data, labels=labels)\naxs[0, 0].set_title('Default', fontsize=fs)\n\naxs[0, 1].boxplot(data, labels=labels, showmeans=True)\naxs[0, 1].set_title('showmeans=True', fontsize=fs)\n\naxs[0, 2].boxplot(data, labels=labels, showmeans=True, meanline=True)\naxs[0, 2].set_title('showmeans=True,\\\nmeanline=True', fontsize=fs)\n\naxs[1, 0].boxplot(data, labels=labels, showbox=False, showcaps=False)\ntufte_title = 'Tufte Style \\\n(showbox=False,\\\nshowcaps=False)'\naxs[1, 0].set_title(tufte_title, fontsize=fs)\n\naxs[1, 1].boxplot(data, labels=labels, notch=True, bootstrap=10000)\naxs[1, 1].set_title('notch=True,\\\nbootstrap=10000', fontsize=fs)\n\naxs[1, 2].boxplot(data, labels=labels, showfliers=False)\naxs[1, 2].set_title('showfliers=False', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\", 'boxprops = dict(linestyle=\\'--\\', linewidth=3, color=\\'darkgoldenrod\\')\nflierprops = dict(marker=\\'o\\', markerfacecolor=\\'green\\', markersize=12,\n                  markeredgecolor=\\'none\\')\nmedianprops = dict(linestyle=\\'-.\\', linewidth=2.5, color=\\'firebrick\\')\nmeanpointprops = dict(marker=\\'D\\', markeredgecolor=\\'black\\',\n                      markerfacecolor=\\'firebrick\\')\nmeanlineprops = dict(linestyle=\\'--\\', linewidth=2.5, color=\\'purple\\')\n\nfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].boxplot(data, boxprops=boxprops)\naxs[0, 0].set_title(\\'Custom boxprops\\', fontsize=fs)\n\naxs[0, 1].boxplot(data, flierprops=flierprops, medianprops=medianprops)\naxs[0, 1].set_title(\\'Custom medianprops\\\nand flierprops\\', fontsize=fs)\n\naxs[0, 2].boxplot(data, whis=(0, 100))\naxs[0, 2].set_title(\\'whis=(0, 100)\\', fontsize=fs)\n\naxs[1, 0].boxplot(data, meanprops=meanpointprops, meanline=False,\n                  showmeans=True)\naxs[1, 0].set_title(\\'Custom mean\\\nas point\\', fontsize=fs)\n\naxs[1, 1].boxplot(data, meanprops=meanlineprops, meanline=True,\n                  showmeans=True)\naxs[1, 1].set_title(\\'Custom mean\\\nas line\\', fontsize=fs)\n\naxs[1, 2].boxplot(data, whis=[15, 85])\naxs[1, 2].set_title(\\'whis=[15, 85]\\\n#percentiles\\', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale(\\'log\\')\n    ax.set_yticklabels([])\n\nfig.suptitle(\"I never said they\\'d be pretty\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n",
    "id": 133
},
{
    "title": "Box plots with custom fill colors#",
    "text": "This plot illustrates how to create two types of box plots\n(rectangular and notched), and how to fill them with custom\ncolors by accessing the properties of the artists of the\nbox plots. Additionally, the labels parameter is used to\nprovide x-tick labels for each sample. A good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.boxplot / matplotlib.pyplot.boxplot Download Python source code: boxplot_color.py Download Jupyter notebook: boxplot_color.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Random test data\nnp.random.seed(19680801)\nall_data = [np.random.normal(0, std, size=100) for std in range(1, 4)]\nlabels = x1 x2 x3\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# rectangular box plot\nbplot1 = ax1.boxplot(all_data,\n                     vert=True,  # vertical box alignment\n                     patch_artist=True,  # fill with color\n                     labels=labels)  # will be used to label x-ticks\nax1.set_title('Rectangular box plot')\n\n# notch shape box plot\nbplot2 = ax2.boxplot(all_data,\n                     notch=True,  # notch shape\n                     vert=True,  # vertical box alignment\n                     patch_artist=True,  # fill with color\n                     labels=labels)  # will be used to label x-ticks\nax2.set_title('Notched box plot')\n\n# fill with colors\ncolors = pink lightblue lightgreen\nfor bplot in (bplot1, bplot2):\n    for patch, color in zip(bplotboxes, colors):\n        patch.set_facecolor(color)\n\n# adding horizontal grid lines\nfor ax in [ax1, ax2]:\n    ax.yaxis.grid(True)\n    ax.set_xlabel('Three separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n",
    "id": 134
},
{
    "title": "Boxplots#",
    "text": "Visualizing boxplots with matplotlib. The following examples show off how to visualize boxplots with\nMatplotlib. There are many options to control their appearance and\nthe statistics that they use to summarize the data.', \"Below we'll generate data from five different probability distributions,\neach with different characteristics. We want to play with how an IID\nbootstrap resample of the data preserves the distributional\nproperties of the original sample, and a boxplot is one visual tool\nto make this assessment\", 'Here we write a custom function to bootstrap confidence intervals.\nWe can then use the boxplot along with this function to show these intervals. Here we customize the widths of the caps . References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.boxplot / matplotlib.pyplot.boxplot matplotlib.artist.Artist.set / matplotlib.pyplot.setp Total running time of the script: (0 minutes 1.662 seconds) Download Python source code: boxplot_demo.py Download Jupyter notebook: boxplot_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# fake up some data\nspread = np.random.rand(50) * 100\ncenter = np.ones(25) * 50\nflier_high = np.random.rand(10) * 100 + 100\nflier_low = np.random.rand(10) * -100\ndata = np.concatenate((spread, center, flier_high, flier_low))\n\nfig, axs = plt.subplots(2, 3)\n\n# basic plot\naxs[0, 0].boxplot(data)\naxs[0, 0].set_title(\\'basic plot\\')\n\n# notched plot\naxs[0, 1].boxplot(data, 1)\naxs[0, 1].set_title(\\'notched plot\\')\n\n# change outlier point symbols\naxs[0, 2].boxplot(data, 0, \\'gD\\')\naxs[0, 2].set_title(\\'change outlier\\\npoint symbols\\')\n\n# don\\'t show outlier points\naxs[1, 0].boxplot(data, 0, \\'\\')\naxs[1, 0].set_title(\"don\\'t show\\\noutlier points\")\n\n# horizontal boxes\naxs[1, 1].boxplot(data, 0, \\'rs\\', 0)\naxs[1, 1].set_title(\\'horizontal boxes\\')\n\n# change whisker length\naxs[1, 2].boxplot(data, 0, \\'rs\\', 0, 0.75)\naxs[1, 2].set_title(\\'change whisker length\\')\n\nfig.subplots_adjust(left=0.08, right=0.98, bottom=0.05, top=0.9,\n                    hspace=0.4, wspace=0.3)\n\n# fake up some more data\nspread = np.random.rand(50) * 100\ncenter = np.ones(25) * 40\nflier_high = np.random.rand(10) * 100 + 100\nflier_low = np.random.rand(10) * -100\nd2 = np.concatenate((spread, center, flier_high, flier_low))\n# Making a 2-D array only works if all the columns are the\n# same length.  If they are not, then use a list instead.\n# This is actually more efficient because boxplot converts\n# a 2-D array into a list of vectors internally anyway.\ndata = [data, d2, d2[::2]]\n\n# Multiple box plots on one Axes\nfig, ax = plt.subplots()\nax.boxplot(data)\n\nplt.show()\n', \"random_dists = Normal(1, 1) Lognormal(1, 1) Exp(1) Gumbel(6, 4)',\n                'Triangular(2, 9, 11)\nN = 500\n\nnorm = np.random.normal(1, 1, N)\nlogn = np.random.lognormal(1, 1, N)\nexpo = np.random.exponential(1, N)\ngumb = np.random.gumbel(6, 4, N)\ntria = np.random.triangular(2, 9, 11, N)\n\n# Generate some random indices that we'll use to resample the original data\n# arrays. For code brevity, just use the same random indices for each array\nbootstrap_indices = np.random.randint(0, N, N)\ndata = [\n    norm, norm[bootstrap_indices],\n    logn, logn[bootstrap_indices],\n    expo, expo[bootstrap_indices],\n    gumb, gumb[bootstrap_indices],\n    tria, tria[bootstrap_indices],\n]\n\nfig, ax1 = plt.subplots(figsize=(10, 6))\nfig.canvas.manager.set_window_title('A Boxplot Example')\nfig.subplots_adjust(left=0.075, right=0.95, top=0.9, bottom=0.25)\n\nbp = ax1.boxplot(data, notch=False, sym='+', vert=True, whis=1.5)\nplt.setp(bpboxes, color='black')\nplt.setp(bpwhiskers, color='black')\nplt.setp(bpfliers, color='red', marker='+')\n\n# Add a horizontal grid to the plot, but make it very light in color\n# so we can use it for reading data values but not be distracting\nax1.yaxis.grid(True, linestyle='-', which='major', color='lightgrey',\n               alpha=0.5)\n\nax1.set(\n    axisbelow=True,  # Hide the grid behind plot objects\n    title='Comparison of IID Bootstrap Resampling Across Five Distributions',\n    xlabel='Distribution',\n    ylabel='Value',\n)\n\n# Now fill the boxes with desired colors\nbox_colors = darkkhaki royalblue\nnum_boxes = len(data)\nmedians = np.empty(num_boxes)\nfor i in range(num_boxes):\n    box = bpboxes[i]\n    box_x = []\n    box_y = []\n    for j in range(5):\n        box_x.append(box.get_xdata()[j])\n        box_y.append(box.get_ydata()[j])\n    box_coords = np.column_stack([box_x, box_y])\n    # Alternate between Dark Khaki and Royal Blue\n    ax1.add_patch(Polygon(box_coords, facecolor=box_colors[i % 2]))\n    # Now draw the median lines back over what we just filled in\n    med = bpmedians[i]\n    median_x = []\n    median_y = []\n    for j in range(2):\n        median_x.append(med.get_xdata()[j])\n        median_y.append(med.get_ydata()[j])\n        ax1.plot(median_x, median_y, 'k')\n    medians[i] = median_y[0]\n    # Finally, overplot the sample averages, with horizontal alignment\n    # in the center of each box\n    ax1.plot(np.average(med.get_xdata()), np.average(data[i]),\n             color='w', marker='*', markeredgecolor='k')\n\n# Set the axes ranges and axes labels\nax1.set_xlim(0.5, num_boxes + 0.5)\ntop = 40\nbottom = -5\nax1.set_ylim(bottom, top)\nax1.set_xticklabels(np.repeat(random_dists, 2),\n                    rotation=45, fontsize=8)\n\n# Due to the Y-axis scale being different across samples, it can be\n# hard to compare differences in medians across the samples. Add upper\n# X-axis tick labels with the sample medians to aid in comparison\n# (just use two decimal places of precision)\npos = np.arange(num_boxes) + 1\nupper_labels = [str(round(s, 2)) for s in medians]\nweights = bold semibold\nfor tick, label in zip(range(num_boxes), ax1.get_xticklabels()):\n    k = tick % 2\n    ax1.text(pos[tick], .95, upper_labels[tick],\n             transform=ax1.get_xaxis_transform(),\n             horizontalalignment='center', size='x-small',\n             weight=weights[k], color=box_colors[k])\n\n# Finally, add a basic legend\nfig.text(0.80, 0.08, f'{N} Random Numbers',\n         backgroundcolor=box_colors[0], color='black', weight='roman',\n         size='x-small')\nfig.text(0.80, 0.045, 'IID Bootstrap Resample',\n         backgroundcolor=box_colors[1],\n         color='white', weight='roman', size='x-small')\nfig.text(0.80, 0.015, '*', color='white', backgroundcolor='silver',\n         weight='roman', size='medium')\nfig.text(0.815, 0.013, ' Average Value', color='black', weight='roman',\n         size='x-small')\n\nplt.show()\n\", 'def fake_bootstrapper(n):\n    \"\"\"\n    This is just a placeholder for the user\\'s method of\n    bootstrapping the median and its confidence intervals.\n\n    Returns an arbitrary median and confidence interval packed into a tuple.\n    \"\"\"\n    if n == 1:\n        med = 0.1\n        ci = (-0.25, 0.25)\n    else:\n        med = 0.2\n        ci = (-0.35, 0.50)\n    return med, ci\n\ninc = 0.1\ne1 = np.random.normal(0, 1, size=500)\ne2 = np.random.normal(0, 1, size=500)\ne3 = np.random.normal(0, 1 + inc, size=500)\ne4 = np.random.normal(0, 1 + 2*inc, size=500)\n\ntreatments = [e1, e2, e3, e4]\nmed1, ci1 = fake_bootstrapper(1)\nmed2, ci2 = fake_bootstrapper(2)\nmedians = [None, None, med1, med2]\nconf_intervals = [None, None, ci1, ci2]\n\nfig, ax = plt.subplots()\npos = np.arange(len(treatments)) + 1\nbp = ax.boxplot(treatments, sym=\\'k+\\', positions=pos,\n                notch=True, bootstrap=5000,\n                usermedians=medians,\n                conf_intervals=conf_intervals)\n\nax.set_xlabel(\\'treatment\\')\nax.set_ylabel(\\'response\\')\nplt.setp(bp[\\'whiskers\\, color=\\'k\\', linestyle=\\'-\\')\nplt.setp(bp[\\'fliers\\, markersize=3.0)\nplt.show()\n x = np.linspace(-7, 7, 140)\nx = np.hstack([-25, x, 25])\nfig, ax = plt.subplots()\n\nax.boxplot([x, x], notch=True, capwidths=[0.01, 0.2])\n\nplt.show()\n",
    "id": 135
},
{
    "title": "Box plot vs. violin plot comparison#",
    "text": "Note that although violin plots are closely related to Tukey's (1977)\nbox plots, they add useful information such as the distribution of the\nsample data (density trace).\", 'By default, box plots show data points outside 1.5 * the inter-quartile\nrange as outliers above or below the whiskers whereas violin plots show\nthe whole range of the data. A good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf Violin plots require matplotlib >= 1.4. For more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.boxplot / matplotlib.pyplot.boxplot matplotlib.axes.Axes.violinplot / matplotlib.pyplot.violinplot Download Python source code: boxplot_vs_violin.py Download Jupyter notebook: boxplot_vs_violin.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# generate some random test data\nall_data = [np.random.normal(0, std, 100) for std in range(6, 10)]\n\n# plot violin plot\naxs[0].violinplot(all_data,\n                  showmeans=False,\n                  showmedians=True)\naxs[0].set_title('Violin plot')\n\n# plot box plot\naxs[1].boxplot(all_data)\naxs[1].set_title('Box plot')\n\n# adding horizontal grid lines\nfor ax in axs:\n    ax.yaxis.grid(True)\n    ax.set_xticks([y + 1 for y in range(len(all_data))],\n                  labels=x1 x2 x3 x4)\n    ax.set_xlabel('Four separate samples')\n    ax.set_ylabel('Observed values')\n\nplt.show()\n",
    "id": 136
},
{
    "title": "Boxplot drawer function#",
    "text": "This example demonstrates how to pass pre-computed box plot\nstatistics to the box plot drawer. The first figure demonstrates\nhow to remove and add individual components (note that the\nmean is the only value not shown by default). The second\nfigure demonstrates how the styles of the artists can\nbe customized. A good general reference on boxplots and their history can be found\nhere: http://vita.had.co.nz/papers/boxplots.pdf', \"After we've computed the stats, we can go through and change anything.\nJust to prove it, I'll set the median of each set to the median of all\nthe data, and double the means\", 'Demonstrate how to toggle the display of different elements: Demonstrate how to customize the display different elements: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bxp matplotlib.cbook.boxplot_stats Total running time of the script: (0 minutes 1.692 seconds) Download Python source code: bxp.py Download Jupyter notebook: bxp.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\n# fake data\nnp.random.seed(19680801)\ndata = np.random.lognormal(size=(37, 4), mean=1.5, sigma=1.75)\nlabels = list('ABCD')\n\n# compute the boxplot stats\nstats = cbook.boxplot_stats(data, labels=labels, bootstrap=10000)\n\", \"for n in range(len(stats)):\n    stats[n]med = np.median(data)\n    stats[n]mean *= 2\n\nprint(list(stats[0]))\n\nfs = 10  # fontsize\n\", \"label mean iqr cilo cihi whishi whislo fliers q1 med q3\n\", \"fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(6, 6), sharey=True)\naxs[0, 0].bxp(stats)\naxs[0, 0].set_title('Default', fontsize=fs)\n\naxs[0, 1].bxp(stats, showmeans=True)\naxs[0, 1].set_title('showmeans=True', fontsize=fs)\n\naxs[0, 2].bxp(stats, showmeans=True, meanline=True)\naxs[0, 2].set_title('showmeans=True,\\\nmeanline=True', fontsize=fs)\n\naxs[1, 0].bxp(stats, showbox=False, showcaps=False)\ntufte_title = 'Tufte Style\\\n(showbox=False,\\\nshowcaps=False)'\naxs[1, 0].set_title(tufte_title, fontsize=fs)\n\naxs[1, 1].bxp(stats, shownotches=True)\naxs[1, 1].set_title('notch=True', fontsize=fs)\n\naxs[1, 2].bxp(stats, showfliers=False)\naxs[1, 2].set_title('showfliers=False', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale('log')\n    ax.set_yticklabels([])\n\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n\", 'boxprops = dict(linestyle=\\'--\\', linewidth=3, color=\\'darkgoldenrod\\')\nflierprops = dict(marker=\\'o\\', markerfacecolor=\\'green\\', markersize=12,\n                  linestyle=\\'none\\')\nmedianprops = dict(linestyle=\\'-.\\', linewidth=2.5, color=\\'firebrick\\')\nmeanpointprops = dict(marker=\\'D\\', markeredgecolor=\\'black\\',\n                      markerfacecolor=\\'firebrick\\')\nmeanlineprops = dict(linestyle=\\'--\\', linewidth=2.5, color=\\'purple\\')\n\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=(6, 6), sharey=True)\naxs[0, 0].bxp(stats, boxprops=boxprops)\naxs[0, 0].set_title(\\'Custom boxprops\\', fontsize=fs)\n\naxs[0, 1].bxp(stats, flierprops=flierprops, medianprops=medianprops)\naxs[0, 1].set_title(\\'Custom medianprops\\\nand flierprops\\', fontsize=fs)\n\naxs[1, 0].bxp(stats, meanprops=meanpointprops, meanline=False,\n              showmeans=True)\naxs[1, 0].set_title(\\'Custom mean\\\nas point\\', fontsize=fs)\n\naxs[1, 1].bxp(stats, meanprops=meanlineprops, meanline=True,\n              showmeans=True)\naxs[1, 1].set_title(\\'Custom mean\\\nas line\\', fontsize=fs)\n\nfor ax in axs.flat:\n    ax.set_yscale(\\'log\\')\n    ax.set_yticklabels([])\n\nfig.suptitle(\"I never said they\\'d be pretty\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n",
    "id": 137
},
{
    "title": "Plot a confidence ellipse of a two-dimensional dataset#",
    "text": "This example shows how to plot a confidence ellipse of a\ntwo-dimensional dataset, using its pearson correlation coefficient. The approach that is used to obtain the correct geometry is\nexplained and proved here: https://carstenschelp.github.io/2018/09/14/Plot_Confidence_Ellipse_001.html The method avoids the use of an iterative eigen decomposition algorithm\nand makes use of the fact that a normalized covariance matrix (composed of\npearson correlation coefficients and ones) is particularly easy to handle. This function plots the confidence ellipse of the covariance of the given\narray-like variables x and y. The ellipse is plotted into the given\naxes-object ax. The radiuses of the ellipse can be controlled by n_std which is the number\nof standard deviations. The default value is 3 which makes the ellipse\nenclose 98.9% of the points if the data is normally distributed\nlike in these examples (3 standard deviations in 1-D contain 99.7%\nof the data, which is 98.9% of the data in 2-D).', \"Creates a random two-dimensional dataset with the specified\ntwo-dimensional mean (mu) and dimensions (scale).\nThe correlation can be controlled by the param 'dependency',\na 2x2 matrix.\", 'Note that the shape for the weak correlation (right) is an ellipse,\nnot a circle because x and y are differently scaled.\nHowever, the fact that x and y are uncorrelated is shown by\nthe axes of the ellipse being aligned with the x- and y-axis\nof the coordinate system. A plot with n_std = 3 (blue), 2 (purple) and 1 (red) Use the keyword arguments specified for matplotlib.patches.Patch in order\nto have the ellipse rendered in different ways. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.transforms.Affine2D matplotlib.patches.Ellipse Total running time of the script: (0 minutes 1.201 seconds) Download Python source code: confidence_ellipse.py Download Jupyter notebook: confidence_ellipse.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\nimport matplotlib.transforms as transforms\n def confidence_ellipse(x, y, ax, n_std=3.0, facecolor=\\'none\\', **kwargs):\n    \"\"\"\n    Create a plot of the covariance confidence ellipse of *x* and *y*.\n\n    Parameters\n    ----------\n    x, y : array-like, shape (n, )\n        Input data.\n\n    ax : matplotlib.axes.Axes\n        The axes object to draw the ellipse into.\n\n    n_std : float\n        The number of standard deviations to determine the ellipse\\'s radiuses.\n\n    **kwargs\n        Forwarded to `~matplotlib.patches.Ellipse`\n\n    Returns\n    -------\n    matplotlib.patches.Ellipse\n    \"\"\"\n    if x.size != y.size:\n        raise ValueError(\"x and y must be the same size\")\n\n    cov = np.cov(x, y)\n    pearson = cov[0, 1]/np.sqrt(cov[0, 0] * cov[1, 1])\n    # Using a special case to obtain the eigenvalues of this\n    # two-dimensional dataset.\n    ell_radius_x = np.sqrt(1 + pearson)\n    ell_radius_y = np.sqrt(1 - pearson)\n    ellipse = Ellipse((0, 0), width=ell_radius_x * 2, height=ell_radius_y * 2,\n                      facecolor=facecolor, **kwargs)\n\n    # Calculating the standard deviation of x from\n    # the squareroot of the variance and multiplying\n    # with the given number of standard deviations.\n    scale_x = np.sqrt(cov[0, 0]) * n_std\n    mean_x = np.mean(x)\n\n    # calculating the standard deviation of y ...\n    scale_y = np.sqrt(cov[1, 1]) * n_std\n    mean_y = np.mean(y)\n\n    transf = transforms.Affine2D() \\\\\n        .rotate_deg(45) \\\\\n        .scale(scale_x, scale_y) \\\\\n        .translate(mean_x, mean_y)\n\n    ellipse.set_transform(transf + ax.transData)\n    return ax.add_patch(ellipse)\n def get_correlated_dataset(n, dependency, mu, scale):\n    latent = np.random.randn(n, 2)\n    dependent = latent.dot(dependency)\n    scaled = dependent * scale\n    scaled_with_offset = scaled + mu\n    # return x and y of the new, correlated dataset\n    return scaled_with_offset[:, 0], scaled_with_offset[:, 1]\n', \"np.random.seed(0)\n\nPARAMETERS = {\n    'Positive correlation': [[0.85, 0.35],\n                             [0.15, -0.65]],\n    'Negative correlation': [[0.9, -0.4],\n                             [0.1, -0.6]],\n    'Weak correlation': [[1, 0],\n                         [0, 1]],\n}\n\nmu = 2, 4\nscale = 3, 5\n\nfig, axs = plt.subplots(1, 3, figsize=(9, 3))\nfor ax, (title, dependency) in zip(axs, PARAMETERS.items()):\n    x, y = get_correlated_dataset(800, dependency, mu, scale)\n    ax.scatter(x, y, s=0.5)\n\n    ax.axvline(c='grey', lw=1)\n    ax.axhline(c='grey', lw=1)\n\n    confidence_ellipse(x, y, ax, edgecolor='red')\n\n    ax.scatter(mu[0], mu[1], c='red', s=3)\n    ax.set_title(title)\n\nplt.show()\n\", \"fig, ax_nstd = plt.subplots(figsize=(6, 6))\n\ndependency_nstd = [[0.8, 0.75],\n                   [-0.2, 0.35]]\nmu = 0, 0\nscale = 8, 5\n\nax_nstd.axvline(c='grey', lw=1)\nax_nstd.axhline(c='grey', lw=1)\n\nx, y = get_correlated_dataset(500, dependency_nstd, mu, scale)\nax_nstd.scatter(x, y, s=0.5)\n\nconfidence_ellipse(x, y, ax_nstd, n_std=1,\n                   label=r'$1\\\\sigma$', edgecolor='firebrick')\nconfidence_ellipse(x, y, ax_nstd, n_std=2,\n                   label=r'$2\\\\sigma$', edgecolor='fuchsia', linestyle='--')\nconfidence_ellipse(x, y, ax_nstd, n_std=3,\n                   label=r'$3\\\\sigma$', edgecolor='blue', linestyle=':')\n\nax_nstd.scatter(mu[0], mu[1], c='red', s=3)\nax_nstd.set_title('Different standard deviations')\nax_nstd.legend()\nplt.show()\n\", \"fig, ax_kwargs = plt.subplots(figsize=(6, 6))\ndependency_kwargs = [[-0.8, 0.5],\n                     [-0.2, 0.5]]\nmu = 2, -3\nscale = 6, 5\n\nax_kwargs.axvline(c='grey', lw=1)\nax_kwargs.axhline(c='grey', lw=1)\n\nx, y = get_correlated_dataset(500, dependency_kwargs, mu, scale)\n# Plot the ellipse with zorder=0 in order to demonstrate\n# its transparency (caused by the use of alpha).\nconfidence_ellipse(x, y, ax_kwargs,\n                   alpha=0.5, facecolor='pink', edgecolor='purple', zorder=0)\n\nax_kwargs.scatter(x, y, s=0.5)\nax_kwargs.scatter(mu[0], mu[1], c='red', s=3)\nax_kwargs.set_title('Using keyword arguments')\n\nfig.subplots_adjust(hspace=0.25)\nplt.show()\n",
    "id": 138
},
{
    "title": "Violin plot customization#",
    "text": "This example demonstrates how to fully customize violin plots. The first plot\nshows the default style by providing only the data. The second plot first\nlimits what Matplotlib draws with additional keyword arguments. Then a\nsimplified representation of a box plot is drawn on top. Lastly, the styles of\nthe artists of the violins are modified. For more information on violin plots, the scikit-learn docs have a great\nsection: https://scikit-learn.org/stable/modules/density.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.violinplot / matplotlib.pyplot.violinplot matplotlib.axes.Axes.vlines / matplotlib.pyplot.vlines Download Python source code: customized_violin.py Download Jupyter notebook: customized_violin.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjacent_values(vals, q1, q3):\n    upper_adjacent_value = q3 + (q3 - q1) * 1.5\n    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])\n\n    lower_adjacent_value = q1 - (q3 - q1) * 1.5\n    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)\n    return lower_adjacent_value, upper_adjacent_value\n\n\ndef set_axis_style(ax, labels):\n    ax.set_xticks(np.arange(1, len(labels) + 1), labels=labels)\n    ax.set_xlim(0.25, len(labels) + 0.75)\n    ax.set_xlabel('Sample name')\n\n\n# create test data\nnp.random.seed(19680801)\ndata = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)]\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True)\n\nax1.set_title('Default violin plot')\nax1.set_ylabel('Observed values')\nax1.violinplot(data)\n\nax2.set_title('Customized violin plot')\nparts = ax2.violinplot(\n        data, showmeans=False, showmedians=False,\n        showextrema=False)\n\nfor pc in partsbodies:\n    pc.set_facecolor('#D43F3A')\n    pc.set_edgecolor('black')\n    pc.set_alpha(1)\n\nquartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1)\nwhiskers = np.array([\n    adjacent_values(sorted_array, q1, q3)\n    for sorted_array, q1, q3 in zip(data, quartile1, quartile3)])\nwhiskers_min, whiskers_max = whiskers[:, 0], whiskers[:, 1]\n\ninds = np.arange(1, len(medians) + 1)\nax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3)\nax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5)\nax2.vlines(inds, whiskers_min, whiskers_max, color='k', linestyle='-', lw=1)\n\n# set style for the axes\nlabels = A B C D\nfor ax in [ax1, ax2]:\n    set_axis_style(ax, labels)\n\nplt.subplots_adjust(bottom=0.15, wspace=0.05)\nplt.show()\n",
    "id": 139
},
{
    "title": "Errorbar function#",
    "text": "This exhibits the most basic use of the error bar method.\nIn this case, constant values are provided for the error\nin both the x- and y-directions. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar Download Python source code: errorbar.py Download Jupyter notebook: errorbar.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\nfig, ax = plt.subplots()\nax.errorbar(x, y, xerr=0.2, yerr=0.4)\nplt.show()\n",
    "id": 140
},
{
    "title": "Different ways of specifying error bars#",
    "text": "Errors can be specified as a constant value (as shown in\nErrorbar function). However, this example demonstrates\nhow they vary by specifying arrays of error values. If the raw x and y data have length N, there are two options: Error varies for each point, but the error values are\nsymmetric (i.e. the lower and upper values are equal). Error varies for each point, and the lower and upper limits\n(in that order) are different (asymmetric case) In addition, this example demonstrates how to use log\nscale with error bars. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar Download Python source code: errorbar_features.py Download Jupyter notebook: errorbar_features.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.arange(0.1, 4, 0.5)\ny = np.exp(-x)\n\n# example error bar values that vary with x-position\nerror = 0.1 + 0.2 * x\n\nfig, (ax0, ax1) = plt.subplots(nrows=2, sharex=True)\nax0.errorbar(x, y, yerr=error, fmt='-o')\nax0.set_title('variable, symmetric error')\n\n# error bar values w/ different -/+ errors that\n# also vary with the x-position\nlower_error = 0.4 * error\nupper_error = error\nasymmetric_error = [lower_error, upper_error]\n\nax1.errorbar(x, y, xerr=asymmetric_error, fmt='o')\nax1.set_title('variable, asymmetric error')\nax1.set_yscale('log')\nplt.show()\n",
    "id": 141
},
{
    "title": "Including upper and lower limits in error bars#",
    "text": "In matplotlib, errors bars can have \"limits\". Applying limits to the\nerror bars essentially makes the error unidirectional. Because of that,\nupper and lower limits can be applied in both the y- and x-directions\nvia the uplims, lolims, xuplims, and xlolims parameters,\nrespectively. These parameters can be scalar or boolean arrays. For example, if xlolims is True, the x-error bars will only\nextend from the data towards increasing values. If uplims is an\narray filled with False except for the 4th and 7th values, all of the\ny-error bars will be bidirectional, except the 4th and 7th bars, which\nwill extend from the data towards decreasing y-values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar Download Python source code: errorbar_limits.py Download Jupyter notebook: errorbar_limits.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# example data\nx = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])\ny = np.exp(-x)\nxerr = 0.1\nyerr = 0.2\n\n# lower & upper limits of the error\nlolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool)\nuplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool)\nls = 'dotted'\n\nfig, ax = plt.subplots(figsize=(7, 4))\n\n# standard error bars\nax.errorbar(x, y, xerr=xerr, yerr=yerr, linestyle=ls)\n\n# including upper limits\nax.errorbar(x, y + 0.5, xerr=xerr, yerr=yerr, uplims=uplims,\n            linestyle=ls)\n\n# including lower limits\nax.errorbar(x, y + 1.0, xerr=xerr, yerr=yerr, lolims=lolims,\n            linestyle=ls)\n\n# including upper and lower limits\nax.errorbar(x, y + 1.5, xerr=xerr, yerr=yerr,\n            lolims=lolims, uplims=uplims,\n            marker='o', markersize=8,\n            linestyle=ls)\n\n# Plot a series with lower and upper limits in both x & y\n# constant x-error with varying y-error\nxerr = 0.2\nyerr = np.full_like(x, 0.2)\nyerr[[3, 6]] = 0.3\n\n# mock up some limits by modifying previous data\nxlolims = lolims\nxuplims = uplims\nlolims = np.zeros_like(x)\nuplims = np.zeros_like(x)\nlolims[[6]] = True  # only limited at this index\nuplims[[3]] = True  # only limited at this index\n\n# do the plotting\nax.errorbar(x, y + 2.1, xerr=xerr, yerr=yerr,\n            xlolims=xlolims, xuplims=xuplims,\n            uplims=uplims, lolims=lolims,\n            marker='o', markersize=8,\n            linestyle='none')\n\n# tidy up the figure\nax.set_xlim((0, 5.5))\nax.set_title('Errorbar upper and lower limits')\nplt.show()\n",
    "id": 142
},
{
    "title": "Creating boxes from error bars using PatchCollection#",
    "text": "In this example, we snazz up a pretty standard error bar plot by adding\na rectangle patch defined by the limits of the bars in both the x- and\ny- directions. To do this, we have to write our own custom function\ncalled make_error_boxes. Close inspection of this function will\nreveal the preferred pattern in writing functions for matplotlib: an Axes object is passed directly to the function the function operates on the Axes methods directly, not through\nthe pyplot interface plotting keyword arguments that could be abbreviated are spelled out for\nbetter code readability in the future (for example we use facecolor\ninstead of fc) the artists returned by the Axes plotting methods are then\nreturned by the function so that, if desired, their styles\ncan be modified later outside of the function (they are not\nmodified in this example). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar matplotlib.axes.Axes.add_collection matplotlib.collections.PatchCollection Download Python source code: errorbars_and_boxes.py Download Jupyter notebook: errorbars_and_boxes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Rectangle\n\n# Number of data points\nn = 5\n\n# Dummy data\nnp.random.seed(19680801)\nx = np.arange(0, n, 1)\ny = np.random.rand(n) * 5.\n\n# Dummy errors (above and below)\nxerr = np.random.rand(2, n) + 0.1\nyerr = np.random.rand(2, n) + 0.2\n\n\ndef make_error_boxes(ax, xdata, ydata, xerror, yerror, facecolor='r',\n                     edgecolor='none', alpha=0.5):\n\n    # Loop over data points; create box from errors at each point\n    errorboxes = [Rectangle((x - xe[0], y - ye[0]), xe.sum(), ye.sum())\n                  for x, y, xe, ye in zip(xdata, ydata, xerror.T, yerror.T)]\n\n    # Create patch collection with specified colour/alpha\n    pc = PatchCollection(errorboxes, facecolor=facecolor, alpha=alpha,\n                         edgecolor=edgecolor)\n\n    # Add collection to axes\n    ax.add_collection(pc)\n\n    # Plot errorbars\n    artists = ax.errorbar(xdata, ydata, xerr=xerror, yerr=yerror,\n                          fmt='none', ecolor='k')\n\n    return artists\n\n\n# Create figure and axes\nfig, ax = plt.subplots(1)\n\n# Call function to create error boxes\n_ = make_error_boxes(ax, x, y, xerr, yerr)\n\nplt.show()\n",
    "id": 143
},
{
    "title": "Hexagonal binned plot#",
    "text": "hexbin is a 2D histogram plot, in which the bins are hexagons and\nthe color represents the number of data points within each bin. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hexbin / matplotlib.pyplot.hexbin Download Python source code: hexbin_demo.py Download Jupyter notebook: hexbin_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nn = 100_000\nx = np.random.standard_normal(n)\ny = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\nxlim = x.min(), x.max()\nylim = y.min(), y.max()\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, sharey=True, figsize=(9, 4))\n\nhb = ax0.hexbin(x, y, gridsize=50, cmap=\\'inferno\\')\nax0.set(xlim=xlim, ylim=ylim)\nax0.set_title(\"Hexagon binning\")\ncb = fig.colorbar(hb, ax=ax0, label=\\'counts\\')\n\nhb = ax1.hexbin(x, y, gridsize=50, bins=\\'log\\', cmap=\\'inferno\\')\nax1.set(xlim=xlim, ylim=ylim)\nax1.set_title(\"With a log color scale\")\ncb = fig.colorbar(hb, ax=ax1, label=\\'log10(N)\\')\n\nplt.show()\n",
    "id": 144
},
{
    "title": "Histograms#",
    "text": "How to plot histograms with Matplotlib.', \"To generate a 1D histogram we only need a single vector of numbers. For a 2D\nhistogram we'll need a second vector. We'll generate both below, and show\nthe histogram for each vector.\", \"The histogram method returns (among other things) a patches object. This\ngives us access to the properties of the objects drawn. Using this, we can\nedit the histogram to our liking. Let's change the color of each bar\nbased on its y value.\", 'To plot a 2D histogram, one only needs two vectors of the same length,\ncorresponding to each axis of the histogram. Customizing a 2D histogram is similar to the 1D case, you can control\nvisual components such as the bin size or color normalization. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist matplotlib.pyplot.hist2d matplotlib.ticker.PercentFormatter Total running time of the script: (0 minutes 1.729 seconds) Download Python source code: hist.py Download Jupyter notebook: hist.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors\nfrom matplotlib.ticker import PercentFormatter\n\n# Create a random number generator with a fixed seed for reproducibility\nrng = np.random.default_rng(19680801)\n N_points = 100000\nn_bins = 20\n\n# Generate two normal distributions\ndist1 = rng.standard_normal(N_points)\ndist2 = 0.4 * rng.standard_normal(N_points) + 5\n\nfig, axs = plt.subplots(1, 2, sharey=True, tight_layout=True)\n\n# We can set the number of bins with the *bins* keyword argument.\naxs[0].hist(dist1, bins=n_bins)\naxs[1].hist(dist2, bins=n_bins)\n', \"fig, axs = plt.subplots(1, 2, tight_layout=True)\n\n# N is the count in each bin, bins is the lower-limit of the bin\nN, bins, patches = axs[0].hist(dist1, bins=n_bins)\n\n# We'll color code by height, but you could use any scalar\nfracs = N / N.max()\n\n# we need to normalize the data to 0..1 for the full range of the colormap\nnorm = colors.Normalize(fracs.min(), fracs.max())\n\n# Now, we'll loop through our objects and set the color of each accordingly\nfor thisfrac, thispatch in zip(fracs, patches):\n    color = plt.cm.viridis(norm(thisfrac))\n    thispatch.set_facecolor(color)\n\n# We can also normalize our inputs by the total number of counts\naxs[1].hist(dist1, bins=n_bins, density=True)\n\n# Now we format the y-axis to display percentage\naxs[1].yaxis.set_major_formatter(PercentFormatter(xmax=1))\n\", 'fig, ax = plt.subplots(tight_layout=True)\nhist = ax.hist2d(dist1, dist2)\n fig, axs = plt.subplots(3, 1, figsize=(5, 15), sharex=True, sharey=True,\n                        tight_layout=True)\n\n# We can increase the number of bins on each axis\naxs[0].hist2d(dist1, dist2, bins=40)\n\n# As well as define normalization of the colors\naxs[1].hist2d(dist1, dist2, bins=40, norm=colors.LogNorm())\n\n# We can also define custom numbers of bins for each axis\naxs[2].hist2d(dist1, dist2, bins=(80, 10), norm=colors.LogNorm())\n\nplt.show()\n",
    "id": 145
},
{
    "title": "Plotting cumulative distributions#",
    "text": "This example shows how to plot the empirical cumulative distribution function\n(ECDF) of a sample. We also show the theoretical CDF. In engineering, ECDFs are sometimes called \"non-exceedance\" curves: the y-value\nfor a given x-value gives probability that an observation from the sample is\nbelow that x-value. For example, the value of 220 on the x-axis corresponds to\nabout 0.80 on the y-axis, so there is an 80% chance that an observation in the\nsample does not exceed 220. Conversely, the empirical complementary\ncumulative distribution function (the ECCDF, or \"exceedance\" curve) shows the\nprobability y that an observation from the sample is above a value x. A direct method to plot ECDFs is Axes.ecdf. Passing complementary=True\nresults in an ECCDF instead. Alternatively, one can use ax.hist(data, density=True, cumulative=True) to\nfirst bin the data, as if plotting a histogram, and then compute and plot the\ncumulative sums of the frequencies of entries in each bin. Here, to plot the\nECCDF, pass cumulative=-1. Note that this approach results in an\napproximation of the E(C)CDF, whereas Axes.ecdf is exact. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist matplotlib.axes.Axes.ecdf / matplotlib.pyplot.ecdf Download Python source code: histogram_cumulative.py Download Jupyter notebook: histogram_cumulative.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu = 200\nsigma = 25\nn_bins = 25\ndata = np.random.normal(mu, sigma, size=100)\n\nfig = plt.figure(figsize=(9, 4), layout=\"constrained\")\naxs = fig.subplots(1, 2, sharex=True, sharey=True)\n\n# Cumulative distributions.\naxs[0].ecdf(data, label=\"CDF\")\nn, bins, patches = axs[0].hist(data, n_bins, density=True, histtype=\"step\",\n                               cumulative=True, label=\"Cumulative histogram\")\nx = np.linspace(data.min(), data.max())\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (x - mu))**2))\ny = y.cumsum()\ny /= y[-1]\naxs[0].plot(x, y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Complementary cumulative distributions.\naxs[1].ecdf(data, complementary=True, label=\"CCDF\")\naxs[1].hist(data, bins=bins, density=True, histtype=\"step\", cumulative=-1,\n            label=\"Reversed cumulative histogram\")\naxs[1].plot(x, 1 - y, \"k--\", linewidth=1.5, label=\"Theory\")\n\n# Label the figure.\nfig.suptitle(\"Cumulative distributions\")\nfor ax in axs:\n    ax.grid(True)\n    ax.legend()\n    ax.set_xlabel(\"Annual rainfall (mm)\")\n    ax.set_ylabel(\"Probability of occurrence\")\n    ax.label_outer()\n\nplt.show()\n",
    "id": 146
},
{
    "title": "Some features of the histogram (hist) function#",
    "text": "In addition to the basic histogram, this demo shows a few optional features: Setting the number of data bins. The density parameter, which normalizes bin heights so that the integral of\nthe histogram is 1. The resulting histogram is an approximation of the\nprobability density function. Selecting different bin counts and sizes can significantly affect the shape\nof a histogram. The Astropy docs have a great section on how to select these\nparameters. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_xlabel matplotlib.axes.Axes.set_ylabel Download Python source code: histogram_features.py Download Jupyter notebook: histogram_features.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nrng = np.random.default_rng(19680801)\n\n# example data\nmu = 106  # mean of distribution\nsigma = 17  # standard deviation of distribution\nx = rng.normal(loc=mu, scale=sigma, size=420)\n\nnum_bins = 42\n\nfig, ax = plt.subplots()\n\n# the histogram of the data\nn, bins, patches = ax.hist(x, num_bins, density=True)\n\n# add a 'best fit' line\ny = ((1 / (np.sqrt(2 * np.pi) * sigma)) *\n     np.exp(-0.5 * (1 / sigma * (bins - mu))**2))\nax.plot(bins, y, '--')\nax.set_xlabel('Value')\nax.set_ylabel('Probability density')\nax.set_title('Histogram of normal distribution sample: '\n             fr'$\\\\mu={mu:.0f}$, $\\\\sigma={sigma:.0f}$')\n\n# Tweak spacing to prevent clipping of ylabel\nfig.tight_layout()\nplt.show()\n",
    "id": 147
},
{
    "title": "Demo of the histogram function's different histtype settings#",
    "text": "Histogram with step curve that has a color fill. Histogram with step curve with no fill. Histogram with custom and unequal bin widths. Two histograms with stacked bars. Selecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist Download Python source code: histogram_histtypes.py Download Jupyter notebook: histogram_histtypes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nmu_x = 200\nsigma_x = 25\nx = np.random.normal(mu_x, sigma_x, size=100)\n\nmu_w = 200\nsigma_w = 10\nw = np.random.normal(mu_w, sigma_w, size=100)\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].hist(x, 20, density=True, histtype='stepfilled', facecolor='g',\n               alpha=0.75)\naxs[0, 0].set_title('stepfilled')\n\naxs[0, 1].hist(x, 20, density=True, histtype='step', facecolor='g',\n               alpha=0.75)\naxs[0, 1].set_title('step')\n\naxs[1, 0].hist(x, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].hist(w, density=True, histtype='barstacked', rwidth=0.8)\naxs[1, 0].set_title('barstacked')\n\n# Create a histogram by providing the bin edges (unequally spaced).\nbins = [100, 150, 180, 195, 205, 220, 250, 300]\naxs[1, 1].hist(x, bins, density=True, histtype='bar', rwidth=0.8)\naxs[1, 1].set_title('bar, unequal bins')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 148
},
{
    "title": "The histogram (hist) function with multiple data sets#",
    "text": "Plot histogram with multiple sample sets and demonstrate: Use of legend with multiple sample sets Stacked bars Step curve with no fill Data sets of different sample sizes Selecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.hist / matplotlib.pyplot.hist Download Python source code: histogram_multihist.py Download Jupyter notebook: histogram_multihist.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nn_bins = 10\nx = np.random.randn(1000, 3)\n\nfig, ((ax0, ax1), (ax2, ax3)) = plt.subplots(nrows=2, ncols=2)\n\ncolors = red tan lime\nax0.hist(x, n_bins, density=True, histtype='bar', color=colors, label=colors)\nax0.legend(prop={'size': 10})\nax0.set_title('bars with legend')\n\nax1.hist(x, n_bins, density=True, histtype='bar', stacked=True)\nax1.set_title('stacked bar')\n\nax2.hist(x, n_bins, histtype='step', stacked=True, fill=False)\nax2.set_title('stack step (unfilled)')\n\n# Make a multiple-histogram of data-sets with different length.\nx_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]\nax3.hist(x_multi, n_bins, histtype='bar')\nax3.set_title('different sample sizes')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 149
},
{
    "title": "Producing multiple histograms side by side#",
    "text": "This example plots horizontal histograms of different samples along\na categorical x-axis. Additionally, the histograms are plotted to\nbe symmetrical about their x-position, thus making them very similar\nto violin plots.', \"To make this highly specialized plot, we can't use the standard hist\nmethod. Instead, we use barh to draw the horizontal bars directly. The\nvertical positions and lengths of the bars are computed via the\nnp.histogram function. The histograms for all the samples are\ncomputed using the same range (min and max values) and number of bins,\nso that the bins for each sample are in the same vertical positions.\", 'Selecting different bin counts and sizes can significantly affect the\nshape of a histogram. The Astropy docs have a great section on how to\nselect these parameters:\nhttp://docs.astropy.org/en/stable/visualization/histogram.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.barh / matplotlib.pyplot.barh Download Python source code: multiple_histograms_side_by_side.py Download Jupyter notebook: multiple_histograms_side_by_side.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\nnumber_of_bins = 20\n\n# An example of three data sets to compare\nnumber_of_data_points = 387\nlabels = A\", \"B\", \"C\ndata_sets = [np.random.normal(0, 1, number_of_data_points),\n             np.random.normal(6, 1, number_of_data_points),\n             np.random.normal(-3, 1, number_of_data_points)]\n\n# Computed quantities to aid plotting\nhist_range = (np.min(data_sets), np.max(data_sets))\nbinned_data_sets = [\n    np.histogram(d, range=hist_range, bins=number_of_bins)[0]\n    for d in data_sets\n]\nbinned_maximums = np.max(binned_data_sets, axis=1)\nx_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))\n\n# The bin_edges are the same for all of the histograms\nbin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1)\nheights = np.diff(bin_edges)\ncenters = bin_edges[:-1] + heights / 2\n\n# Cycle through and plot each histogram\nfig, ax = plt.subplots()\nfor x_loc, binned_data in zip(x_locations, binned_data_sets):\n    lefts = x_loc - 0.5 * binned_data\n    ax.barh(centers, binned_data, height=heights, left=lefts)\n\nax.set_xticks(x_locations, labels)\n\nax.set_ylabel(\"Data values\")\nax.set_xlabel(\"Data sets\")\n\nplt.show()\n",
    "id": 150
},
{
    "title": "Time Series Histogram#",
    "text": "This example demonstrates how to efficiently visualize large numbers of time\nseries in a way that could potentially reveal hidden substructure and patterns\nthat are not immediately obvious, and display them in a visually appealing way. In this example, we generate multiple sinusoidal \"signal\" series that are\nburied under a larger number of random walk \"noise/background\" series. For an\nunbiased Gaussian random walk with standard deviation of \u03c3, the RMS deviation\nfrom the origin after n steps is \u03c3*sqrt(n). So in order to keep the sinusoids\nvisible on the same scale as the random walks, we scale the amplitude by the\nrandom walk RMS. In addition, we also introduce a small random offset phi\nto shift the sines left/right, and some additive random noise to shift\nindividual data points up/down to make the signal a bit more \"realistic\" (you\nwouldn\\'t expect a perfect sine wave to appear in your data). The first plot shows the typical way of visualizing multiple time series by\noverlaying them on top of each other with plt.plot and a small value of\nalpha. The second and third plots show how to reinterpret the data as a 2d\nhistogram, with optional interpolation between data points, by using\nnp.histogram2d and plt.pcolormesh. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh matplotlib.figure.Figure.colorbar Total running time of the script: (0 minutes 1.936 seconds) Download Python source code: time_series_histogram.py Download Jupyter notebook: time_series_histogram.ipynb ",
    "code": "import time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axes = plt.subplots(nrows=3, figsize=(6, 8), layout=\\'constrained\\')\n\n# Fix random state for reproducibility\nnp.random.seed(19680801)\n# Make some data; a 1D random walk + small fraction of sine waves\nnum_series = 1000\nnum_points = 100\nSNR = 0.10  # Signal to Noise Ratio\nx = np.linspace(0, 4 * np.pi, num_points)\n# Generate unbiased Gaussian random walks\nY = np.cumsum(np.random.randn(num_series, num_points), axis=-1)\n# Generate sinusoidal signals\nnum_signal = round(SNR * num_series)\nphi = (np.pi / 8) * np.random.randn(num_signal, 1)  # small random offset\nY[-num_signal:] = (\n    np.sqrt(np.arange(num_points))  # random walk RMS scaling factor\n    * (np.sin(x - phi)\n       + 0.05 * np.random.randn(num_signal, num_points))  # small random noise\n)\n\n\n# Plot series using `plot` and a small value of `alpha`. With this view it is\n# very difficult to observe the sinusoidal behavior because of how many\n# overlapping series there are. It also takes a bit of time to run because so\n# many individual artists need to be generated.\ntic = time.time()\naxes[0].plot(x, Y.T, color=\"C0\", alpha=0.1)\ntoc = time.time()\naxes[0].set_title(\"Line plot with alpha\")\nprint(f\"{toc-tic:.3f} sec. elapsed\")\n\n\n# Now we will convert the multiple time series into a histogram. Not only will\n# the hidden signal be more visible, but it is also a much quicker procedure.\ntic = time.time()\n# Linearly interpolate between the points in each time series\nnum_fine = 800\nx_fine = np.linspace(x.min(), x.max(), num_fine)\ny_fine = np.concatenate([np.interp(x_fine, x, y_row) for y_row in Y])\nx_fine = np.broadcast_to(x_fine, (num_series, num_fine)).ravel()\n\n\n# Plot (x, y) points in 2d histogram with log colorscale\n# It is pretty evident that there is some kind of structure under the noise\n# You can tune vmax to make signal more visible\ncmap = plt.colormapsplasma\ncmap = cmap.with_extremes(bad=cmap(0))\nh, xedges, yedges = np.histogram2d(x_fine, y_fine, bins=[400, 100])\npcm = axes[1].pcolormesh(xedges, yedges, h.T, cmap=cmap,\n                         norm=\"log\", vmax=1.5e2, rasterized=True)\nfig.colorbar(pcm, ax=axes[1], label=\"# points\", pad=0)\naxes[1].set_title(\"2d histogram and log color scale\")\n\n# Same data but on linear color scale\npcm = axes[2].pcolormesh(xedges, yedges, h.T, cmap=cmap,\n                         vmax=1.5e2, rasterized=True)\nfig.colorbar(pcm, ax=axes[2], label=\"# points\", pad=0)\naxes[2].set_title(\"2d histogram and linear color scale\")\n\ntoc = time.time()\nprint(f\"{toc-tic:.3f} sec. elapsed\")\nplt.show()\n 0.147 sec. elapsed\n0.048 sec. elapsed\n",
    "id": 151
},
{
    "title": "Violin plot basics#",
    "text": "Violin plots are similar to histograms and box plots in that they show\nan abstract representation of the probability distribution of the\nsample. Rather than showing counts of data points that fall into bins\nor order statistics, violin plots use kernel density estimation (KDE) to\ncompute an empirical distribution of the sample. That computation\nis controlled by several parameters. This example demonstrates how to\nmodify the number of points at which the KDE is evaluated (points)\nand how to modify the bandwidth of the KDE (bw_method). For more information on violin plots and KDE, the scikit-learn docs\nhave a great section: https://scikit-learn.org/stable/modules/density.html References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.violinplot / matplotlib.pyplot.violinplot Download Python source code: violinplot.py Download Jupyter notebook: violinplot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# fake data\nfs = 10  # fontsize\npos = [1, 2, 4, 5, 7, 8]\ndata = [np.random.normal(0, std, size=100) for std in pos]\n\nfig, axs = plt.subplots(nrows=2, ncols=5, figsize=(10, 6))\n\naxs[0, 0].violinplot(data, pos, points=20, widths=0.3,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[0, 0].set_title(\\'Custom violinplot 1\\', fontsize=fs)\n\naxs[0, 1].violinplot(data, pos, points=40, widths=0.5,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method=\\'silverman\\')\naxs[0, 1].set_title(\\'Custom violinplot 2\\', fontsize=fs)\n\naxs[0, 2].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5)\naxs[0, 2].set_title(\\'Custom violinplot 3\\', fontsize=fs)\n\naxs[0, 3].violinplot(data, pos, points=60, widths=0.7, showmeans=True,\n                     showextrema=True, showmedians=True, bw_method=0.5,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]])\naxs[0, 3].set_title(\\'Custom violinplot 4\\', fontsize=fs)\n\naxs[0, 4].violinplot(data[-1:], pos[-1:], points=60, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[0, 4].set_title(\\'Custom violinplot 5\\', fontsize=fs)\n\naxs[1, 0].violinplot(data, pos, points=80, vert=False, widths=0.7,\n                     showmeans=True, showextrema=True, showmedians=True)\naxs[1, 0].set_title(\\'Custom violinplot 6\\', fontsize=fs)\n\naxs[1, 1].violinplot(data, pos, points=100, vert=False, widths=0.9,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method=\\'silverman\\')\naxs[1, 1].set_title(\\'Custom violinplot 7\\', fontsize=fs)\n\naxs[1, 2].violinplot(data, pos, points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     bw_method=0.5)\naxs[1, 2].set_title(\\'Custom violinplot 8\\', fontsize=fs)\n\naxs[1, 3].violinplot(data, pos, points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[[0.1], [], [], [0.175, 0.954], [0.75], [0.25]],\n                     bw_method=0.5)\naxs[1, 3].set_title(\\'Custom violinplot 9\\', fontsize=fs)\n\naxs[1, 4].violinplot(data[-1:], pos[-1:], points=200, vert=False, widths=1.1,\n                     showmeans=True, showextrema=True, showmedians=True,\n                     quantiles=[0.05, 0.1, 0.8, 0.9], bw_method=0.5)\naxs[1, 4].set_title(\\'Custom violinplot 10\\', fontsize=fs)\n\n\nfor ax in axs.flat:\n    ax.set_yticklabels([])\n\nfig.suptitle(\"Violin Plotting Examples\")\nfig.subplots_adjust(hspace=0.4)\nplt.show()\n",
    "id": 152
},
{
    "title": "Pie charts#",
    "text": "Demo of plotting a pie chart. This example illustrates various parameters of pie. Plot a pie chart of animals and label the slices. To add\nlabels, pass a list of labels to the labels parameter Each slice of the pie chart is a patches.Wedge object; therefore in\naddition to the customizations shown here, each wedge can be customized using\nthe wedgeprops argument, as demonstrated in\nNested pie charts. Pass a function or format string to autopct to label slices. By default, the label values are obtained from the percent size of the slice. Pass a list of colors to colors to set the color of each slice. Pass a list of hatch patterns to hatch to set the pattern of each slice. Use the labeldistance and pctdistance parameters to position the labels\nand autopct text respectively. labeldistance and pctdistance are ratios of the radius; therefore they\nvary between 0 for the center of the pie and 1 for the edge of the\npie, and can be set to greater than 1 to place text outside the pie. In addition to the basic pie chart, this demo shows a few optional features: offsetting a slice using explode add a drop-shadow using shadow custom start angle using startangle This example orders the slices, separates (explodes) them, and rotates them. The default startangle is 0, which would start the first slice (\"Frogs\") on\nthe positive x-axis. This example sets startangle = 90 such that all the\nslices are rotated counter-clockwise by 90 degrees, and the frog slice starts\non the positive y-axis. By changing the radius parameter, and often the text size for better visual\nappearance, the pie chart can be scaled. The shadow parameter may optionally take a dictionary with arguments to\nthe Shadow patch. This can be used to modify the default shadow. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pie / matplotlib.pyplot.pie Total running time of the script: (0 minutes 1.788 seconds) Download Python source code: pie_features.py Download Jupyter notebook: pie_features.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nlabels = 'Frogs Hogs Dogs Logs'\nsizes = [15, 30, 45, 10]\n\nfig, ax = plt.subplots()\nax.pie(sizes, labels=labels)\n\", \"fig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%1.1f%%')\n\", \"fig, ax = plt.subplots()\nax.pie(sizes, labels=labels,\n       colors=olivedrab rosybrown gray saddlebrown)\n\", \"fig, ax = plt.subplots()\nax.pie(sizes, labels=labels, hatch=**O oO O.O .||.)\n\", \"fig, ax = plt.subplots()\nax.pie(sizes, labels=labels, autopct='%1.1f%%',\n       pctdistance=1.25, labeldistance=.6)\n\", 'explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. \\'Hogs\\')\n\nfig, ax = plt.subplots()\nax.pie(sizes, explode=explode, labels=labels, autopct=\\'%1.1f%%\\',\n       shadow=True, startangle=90)\nplt.show()\n', \"fig, ax = plt.subplots()\n\nax.pie(sizes, labels=labels, autopct='%.0f%%',\n       textprops={'size': 'smaller'}, radius=0.5)\nplt.show()\n\", \"fig, ax = plt.subplots()\nax.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n       shadow={'ox': -0.04, 'edgecolor': 'none shade': 0.9}, startangle=90)\nplt.show()\n",
    "id": 154
},
{
    "title": "Bar of pie#",
    "text": "Make a \"bar of pie\" chart where the first slice of the pie is\n\"exploded\" into a bar chart with a further breakdown of said slice\\'s\ncharacteristics. The example demonstrates using a figure with multiple\nsets of axes and using the axes patches list to add two ConnectionPatches\nto link the subplot charts. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.axes.Axes.pie / matplotlib.pyplot.pie matplotlib.patches.ConnectionPatch Download Python source code: bar_of_pie.py Download Jupyter notebook: bar_of_pie.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import ConnectionPatch\n\n# make figure and assign axis objects\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(9, 5))\nfig.subplots_adjust(wspace=0)\n\n# pie chart parameters\noverall_ratios = [.27, .56, .17]\nlabels = [\\'Approve\\', \\'Disapprove\\', \\'Undecided\\\nexplode = [0.1, 0, 0]\n# rotate so that first wedge is split by the x-axis\nangle = -180 * overall_ratios[0]\nwedges, *_ = ax1.pie(overall_ratios, autopct=\\'%1.1f%%\\', startangle=angle,\n                     labels=labels, explode=explode)\n\n# bar chart parameters\nage_ratios = [.33, .54, .07, .06]\nage_labels = [\\'Under 35\\', \\'35-49\\', \\'50-65\\', \\'Over 65\\\nbottom = 1\nwidth = .2\n\n# Adding from the top matches the legend.\nfor j, (height, label) in enumerate(reversed([*zip(age_ratios, age_labels)])):\n    bottom -= height\n    bc = ax2.bar(0, height, width, bottom=bottom, color=\\'C0\\', label=label,\n                 alpha=0.1 + 0.25 * j)\n    ax2.bar_label(bc, labels=[f\"{height:.0%}, label_type=\\'center\\')\n\nax2.set_title(\\'Age of approvers\\')\nax2.legend()\nax2.axis(\\'off\\')\nax2.set_xlim(- 2.5 * width, 2.5 * width)\n\n# use ConnectionPatch to draw lines between the two plots\ntheta1, theta2 = wedges[0].theta1, wedges[0].theta2\ncenter, r = wedges[0].center, wedges[0].r\nbar_height = sum(age_ratios)\n\n# draw top connecting line\nx = r * np.cos(np.pi / 180 * theta2) + center[0]\ny = r * np.sin(np.pi / 180 * theta2) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, bar_height), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\ncon.set_linewidth(4)\nax2.add_artist(con)\n\n# draw bottom connecting line\nx = r * np.cos(np.pi / 180 * theta1) + center[0]\ny = r * np.sin(np.pi / 180 * theta1) + center[1]\ncon = ConnectionPatch(xyA=(-width / 2, 0), coordsA=ax2.transData,\n                      xyB=(x, y), coordsB=ax1.transData)\ncon.set_color([0, 0, 0])\nax2.add_artist(con)\ncon.set_linewidth(4)\n\nplt.show()\n",
    "id": 155
},
{
    "title": "Nested pie charts#",
    "text": "The following examples show two ways to build a nested pie chart\nin Matplotlib. Such charts are often referred to as donut charts. See also the Left ventricle bullseye example. The most straightforward way to build a pie chart is to use the\npie method.', \"In this case, pie takes values corresponding to counts in a group.\nWe'll first generate some fake data, corresponding to three groups.\nIn the inner circle, we'll treat each number as belonging to its\nown group. In the outer circle, we'll plot them as members of their\noriginal 3 groups.\", \"The effect of the donut shape is achieved by setting a width to\nthe pie's wedges through the wedgeprops argument.\", 'However, you can accomplish the same output by using a bar plot on\naxes with a polar coordinate system. This may give more flexibility on\nthe exact design of the plot. In this case, we need to map x-values of the bar chart onto radians of\na circle. The cumulative sum of the values are used as the edges\nof the bars. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pie / matplotlib.pyplot.pie matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.projections.polar Axes.set (matplotlib.artist.Artist.set) matplotlib.axes.Axes.set_axis_off Download Python source code: nested_pie.py Download Jupyter notebook: nested_pie.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n fig, ax = plt.subplots()\n\nsize = 0.3\nvals = np.array([[60., 32.], [37., 40.], [29., 10.]])\n\ncmap = plt.colormapstab20c\nouter_colors = cmap(np.arange(3)*4)\ninner_colors = cmap([1, 2, 5, 6, 9, 10])\n\nax.pie(vals.sum(axis=1), radius=1, colors=outer_colors,\n       wedgeprops=dict(width=size, edgecolor=\\'w\\'))\n\nax.pie(vals.flatten(), radius=1-size, colors=inner_colors,\n       wedgeprops=dict(width=size, edgecolor=\\'w\\'))\n\nax.set(aspect=\"equal\", title=\\'Pie plot with `ax.pie`\\')\nplt.show()\n fig, ax = plt.subplots(subplot_kw=dict(projection=\"polar\"))\n\nsize = 0.3\nvals = np.array([[60., 32.], [37., 40.], [29., 10.]])\n# Normalize vals to 2 pi\nvalsnorm = vals/np.sum(vals)*2*np.pi\n# Obtain the ordinates of the bar edges\nvalsleft = np.cumsum(np.append(0, valsnorm.flatten()[:-1])).reshape(vals.shape)\n\ncmap = plt.colormapstab20c\nouter_colors = cmap(np.arange(3)*4)\ninner_colors = cmap([1, 2, 5, 6, 9, 10])\n\nax.bar(x=valsleft[:, 0],\n       width=valsnorm.sum(axis=1), bottom=1-size, height=size,\n       color=outer_colors, edgecolor=\\'w\\', linewidth=1, align=\"edge\")\n\nax.bar(x=valsleft.flatten(),\n       width=valsnorm.flatten(), bottom=1-2*size, height=size,\n       color=inner_colors, edgecolor=\\'w\\', linewidth=1, align=\"edge\")\n\nax.set(title=\"Pie plot with `ax.bar` and polar coordinates\")\nax.set_axis_off()\nplt.show()\n",
    "id": 156
},
{
    "title": "Labeling a pie and a donut#",
    "text": "Welcome to the Matplotlib bakery. We will create a pie and a donut\nchart through the pie method and\nshow how to label them with a legend\nas well as with annotations.', \"As usual we would start by defining the imports and create a figure with\nsubplots.\nNow it's time for the pie. Starting with a pie recipe, we create the data\nand a list of labels from it.\", 'We can provide a function to the autopct argument, which will expand\nautomatic percentage labeling by showing absolute values; we calculate\nthe latter back from relative data and the known sum of all values. We then create the pie and store the returned objects for later. The first\nreturned element of the returned tuple is a list of the wedges. Those are\nmatplotlib.patches.Wedge patches, which can directly be used as the handles\nfor a legend. We can use the legend\\'s bbox_to_anchor argument to position\nthe legend outside of the pie. Here we use the axes coordinates (1, 0, 0.5,\n1) together with the location \"center left\"; i.e. the left central\npoint of the legend will be at the left central point of the bounding box,\nspanning from (1, 0) to (1.5, 1) in axes coordinates.', \"Now it's time for the donut. Starting with a donut recipe, we transcribe\nthe data to numbers (converting 1 egg to 50 g), and directly plot the pie.\nThe pie? Wait... it's going to be donut, is it not?\nWell, as we see here, the donut is a pie, having a certain width set to\nthe wedges, which is different from its radius. It's as easy as it gets.\nThis is done via the wedgeprops argument.\", 'We then want to label the wedges via\nannotations. We first create some\ndictionaries of common properties, which we can later pass as keyword\nargument. We then iterate over all wedges and for each', \"calculate the angle of the wedge's center,\", 'from that obtain the coordinates of the point at that angle on the\ncircumference, determine the horizontal alignment of the text, depending on which side\nof the circle the point lies, update the connection style with the obtained angle to have the annotation\narrow point outwards from the donut, finally, create the annotation with all the previously\ndetermined parameters. And here it is, the donut. Note however, that if we were to use this recipe,\nthe ingredients would suffice for around 6 donuts - producing one huge\ndonut is untested and might result in kitchen errors. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.pie / matplotlib.pyplot.pie matplotlib.axes.Axes.legend / matplotlib.pyplot.legend Download Python source code: pie_and_donut_labels.py Download Jupyter notebook: pie_and_donut_labels.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(figsize=(6, 3), subplot_kw=dict(aspect=\"equal\"))\n\nrecipe = 375 g flour\",\n          \"75 g sugar\",\n          \"250 g butter\",\n          \"300 g berries\n\ndata = [float(x.split()[0]) for x in recipe]\ningredients = [x.split()[-1] for x in recipe]\n\n\ndef func(pct, allvals):\n    absolute = int(np.round(pct/100.*np.sum(allvals)))\n    return f\"{pct:.1f}%\\\n({absolute:d} g)\"\n\n\nwedges, texts, autotexts = ax.pie(data, autopct=lambda pct: func(pct, data),\n                                  textprops=dict(color=\"w\"))\n\nax.legend(wedges, ingredients,\n          title=\"Ingredients\",\n          loc=\"center left\",\n          bbox_to_anchor=(1, 0, 0.5, 1))\n\nplt.setp(autotexts, size=8, weight=\"bold\")\n\nax.set_title(\"Matplotlib bakery: A pie\")\n\nplt.show()\n fig, ax = plt.subplots(figsize=(6, 3), subplot_kw=dict(aspect=\"equal\"))\n\nrecipe = 225 g flour\",\n          \"90 g sugar\",\n          \"1 egg\",\n          \"60 g butter\",\n          \"100 ml milk\",\n          \"1/2 package of yeast\n\ndata = [225, 90, 50, 60, 100, 5]\n\nwedges, texts = ax.pie(data, wedgeprops=dict(width=0.5), startangle=-40)\n\nbbox_props = dict(boxstyle=\"square,pad=0.3\", fc=\"w\", ec=\"k\", lw=0.72)\nkw = dict(arrowprops=dict(arrowstyle=\"-\"),\n          bbox=bbox_props, zorder=0, va=\"center\")\n\nfor i, p in enumerate(wedges):\n    ang = (p.theta2 - p.theta1)/2. + p.theta1\n    y = np.sin(np.deg2rad(ang))\n    x = np.cos(np.deg2rad(ang))\n    horizontalalignment = {-1: \"right\", 1: \"left\"}[int(np.sign(x))]\n    connectionstyle = f\"angle,angleA=0,angleB={ang}\"\n    kwarrowprops.update({\"connectionstyle\": connectionstyle})\n    ax.annotate(recipe[i], xy=(x, y), xytext=(1.35*np.sign(x), 1.4*y),\n                horizontalalignment=horizontalalignment, **kw)\n\nax.set_title(\"Matplotlib bakery: A donut\")\n\nplt.show()\n",
    "id": 157
},
{
    "title": "Bar chart on polar axis#",
    "text": "Demo of bar plot on a polar axis. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar / matplotlib.pyplot.bar matplotlib.projections.polar Download Python source code: polar_bar.py Download Jupyter notebook: polar_bar.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute pie slices\nN = 20\ntheta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)\nradii = 10 * np.random.rand(N)\nwidth = np.pi / 4 * np.random.rand(N)\ncolors = plt.cm.viridis(radii / 10.)\n\nax = plt.subplot(projection='polar')\nax.bar(theta, radii, width=width, bottom=0.0, color=colors, alpha=0.5)\n\nplt.show()\n",
    "id": 158
},
{
    "title": "Polar plot#",
    "text": "Demo of a line plot on a polar axis. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.projections.polar matplotlib.projections.polar.PolarAxes matplotlib.projections.polar.PolarAxes.set_rticks matplotlib.projections.polar.PolarAxes.set_rmax matplotlib.projections.polar.PolarAxes.set_rlabel_position Download Python source code: polar_demo.py Download Jupyter notebook: polar_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\nfig, ax = plt.subplots(subplot_kw={\\'projection\\': \\'polar\\'})\nax.plot(theta, r)\nax.set_rmax(2)\nax.set_rticks([0.5, 1, 1.5, 2])  # Less radial ticks\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\nax.grid(True)\n\nax.set_title(\"A line plot on a polar axis\", va=\\'bottom\\')\nplt.show()\n",
    "id": 159
},
{
    "title": "Error bar rendering on polar axis#",
    "text": "Demo of error bar plot in polar coordinates.\nTheta error bars are curved lines ended with caps oriented towards the\ncenter.\nRadius error bars are straight lines oriented towards center with\nperpendicular caps. Please acknowledge that large theta error bars will be overlapping.\nThis may reduce readability of the output plot. See example figure below: On the other hand, large radius error bars will never overlap, they just\nlead to unwanted scale in the data, reducing the displayed range. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.errorbar / matplotlib.pyplot.errorbar matplotlib.projections.polar Total running time of the script: (0 minutes 2.954 seconds) Download Python source code: polar_error_caps.py Download Jupyter notebook: polar_error_caps.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.arange(0, 2 * np.pi, np.pi / 4)\nr = theta / np.pi / 2 + 0.5\n\nfig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection=\\'polar\\')\nax.errorbar(theta, r, xerr=0.25, yerr=0.1, capsize=7, fmt=\"o\", c=\"seagreen\")\nax.set_title(\"Pretty polar error bars\")\nplt.show()\n fig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection=\\'polar\\')\nax.errorbar(theta, r, xerr=5.25, yerr=0.1, capsize=7, fmt=\"o\", c=\"darkred\")\nax.set_title(\"Overlapping theta error bars\")\nplt.show()\n fig = plt.figure(figsize=(10, 10))\nax = fig.add_subplot(projection=\\'polar\\')\nax.errorbar(theta, r, xerr=0.25, yerr=10.1, capsize=7, fmt=\"o\", c=\"orangered\")\nax.set_title(\"Large radius error bars\")\nplt.show()\n",
    "id": 160
},
{
    "title": "Polar legend#",
    "text": "Using a legend on a polar-axis plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.axes.Axes.legend / matplotlib.pyplot.legend matplotlib.projections.polar matplotlib.projections.polar.PolarAxes Download Python source code: polar_legend.py Download Jupyter notebook: polar_legend.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection=\"polar\", facecolor=\"lightgoldenrodyellow\")\n\nr = np.linspace(0, 3, 301)\ntheta = 2 * np.pi * r\nax.plot(theta, r, color=\"tab:orange\", lw=3, label=\"a line\")\nax.plot(0.5 * theta, r, color=\"tab:blue\", ls=\"--\", lw=3, label=\"another line\")\nax.tick_params(grid_color=\"palegoldenrod\")\n# For polar axes, it may be useful to move the legend slightly away from the\n# axes center, to avoid overlap between the legend and the axes.  The following\n# snippet places the legend\\'s lower left corner just outside the polar axes\n# at an angle of 67.5 degrees in polar coordinates.\nangle = np.deg2rad(67.5)\nax.legend(loc=\"lower left\",\n          bbox_to_anchor=(.5 + np.cos(angle)/2, .5 + np.sin(angle)/2))\n\nplt.show()\n",
    "id": 161
},
{
    "title": "Scatter plot on polar axis#",
    "text": "Size increases radially in this example and color increases with angle\n(just to verify the symbols are being scattered correctly). The main difference with the previous plot is the configuration of the origin\nradius, producing an annulus. Additionally, the theta zero location is set to\nrotate the plot. The main difference with the previous plots is the configuration of the\ntheta start and end limits, producing a sector instead of a full circle. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.scatter / matplotlib.pyplot.scatter matplotlib.projections.polar matplotlib.projections.polar.PolarAxes.set_rorigin matplotlib.projections.polar.PolarAxes.set_theta_zero_location matplotlib.projections.polar.PolarAxes.set_thetamin matplotlib.projections.polar.PolarAxes.set_thetamax Total running time of the script: (0 minutes 1.353 seconds) Download Python source code: polar_scatter.py Download Jupyter notebook: polar_scatter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# Compute areas and colors\nN = 150\nr = 2 * np.random.rand(N)\ntheta = 2 * np.pi * np.random.rand(N)\narea = 200 * r**2\ncolors = theta\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\", \"fig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_rorigin(-2.5)\nax.set_theta_zero_location('W', offset=10)\n\", \"fig = plt.figure()\nax = fig.add_subplot(projection='polar')\nc = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\n\nax.set_thetamin(45)\nax.set_thetamax(135)\n\nplt.show()\n",
    "id": 162
},
{
    "title": "Using accented text in Matplotlib#",
    "text": "Matplotlib supports accented characters via TeX mathtext or Unicode. Using mathtext, the following accents are provided: \\\\hat, \\\\breve, \\\\grave,\n\\\\bar, \\\\acute, \\\\tilde, \\\\vec, \\\\dot, \\\\ddot. All of them have the same\nsyntax, e.g. \\\\bar{o} yields \"o overbar\", \\\\ddot{o} yields \"o umlaut\".\nShortcuts such as \\\\\"o \\\\\\'e \\\\`e \\\\~n \\\\.x \\\\^y are also supported. You can also use Unicode characters directly in strings. Download Python source code: accented_text.py Download Jupyter notebook: accented_text.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n# Mathtext demo\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_title(r\\'$\\\\ddot{o}\\\\acute{e}\\\\grave{e}\\\\hat{O}\\'\n             r\\'\\\\breve{i}\\\\bar{A}\\\\tilde{n}\\\\vec{q}$\\', fontsize=20)\n\n# Shorthand is also supported and curly braces are optional\nax.set_xlabel(r\"\"\"$\\\\\"o\\\\ddot o \\\\\\'e\\\\`e\\\\~n\\\\.x\\\\^y$\"\"\", fontsize=20)\nax.text(4, 0.5, r\"$F=m\\\\ddot{x}$\")\nfig.tight_layout()\n fig, ax = plt.subplots()\nax.set_title(\"GISCARD CHAHUT\u00c9 \u00c0 L\\'ASSEMBL\u00c9E\")\nax.set_xlabel(\"LE COUP DE D\u00c9 DE DE GAULLE\")\nax.set_ylabel(\\'Andr\u00e9 was here!\\')\nax.text(0.2, 0.8, \\'Institut f\u00fcr Festk\u00f6rperphysik\\', rotation=45)\nax.text(0.4, 0.2, \\'AVA (check kerning)\\')\n\nplt.show()\n",
    "id": 164
},
{
    "title": "Align y-labels#",
    "text": "Two methods are shown here, one using a short call to Figure.align_ylabels\nand the second a manual way to align the labels. See also Figure.align_ylabels and Figure.align_labels for a direct method\nof doing the same thing.\nAlso Aligning Labels Or we can manually align the axis labels between subplots manually using the\nset_label_coords method of the y-axis object. Note this requires\nwe know a good offset value which is hardcoded. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.align_ylabels matplotlib.axis.Axis.set_label_coords matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_ylabel matplotlib.axes.Axes.set_ylim Download Python source code: align_ylabels.py Download Jupyter notebook: align_ylabels.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef make_plot(axs):\n    box = dict(facecolor='yellow', pad=5, alpha=0.2)\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n    ax1 = axs[0, 0]\n    ax1.plot(2000*np.random.rand(10))\n    ax1.set_title('ylabels not aligned')\n    ax1.set_ylabel('misaligned 1', bbox=box)\n    ax1.set_ylim(0, 2000)\n\n    ax3 = axs[1, 0]\n    ax3.set_ylabel('misaligned 2', bbox=box)\n    ax3.plot(np.random.rand(10))\n\n    ax2 = axs[0, 1]\n    ax2.set_title('ylabels aligned')\n    ax2.plot(2000*np.random.rand(10))\n    ax2.set_ylabel('aligned 1', bbox=box)\n    ax2.set_ylim(0, 2000)\n\n    ax4 = axs[1, 1]\n    ax4.plot(np.random.rand(10))\n    ax4.set_ylabel('aligned 2', bbox=box)\n\n\n# Plot 1:\nfig, axs = plt.subplots(2, 2)\nfig.subplots_adjust(left=0.2, wspace=0.6)\nmake_plot(axs)\n\n# just align the last column of axes:\nfig.align_ylabels(axs[:, 1])\nplt.show()\n\", 'fig, axs = plt.subplots(2, 2)\nfig.subplots_adjust(left=0.2, wspace=0.6)\n\nmake_plot(axs)\n\nlabelx = -0.3  # axes coords\n\nfor j in range(2):\n    axs[j, 1].yaxis.set_label_coords(labelx, 0.5)\n\nplt.show()\n",
    "id": 165
},
{
    "title": "Scale invariant angle label#",
    "text": "This example shows how to create a scale invariant angle annotation. It is\noften useful to mark angles between lines or inside shapes with a circular arc.\nWhile Matplotlib provides an Arc, an inherent problem when directly\nusing it for such purposes is that an arc being circular in data space is not\nnecessarily circular in display space. Also, the arc's radius is often best\ndefined in a coordinate system which is independent of the actual data\ncoordinates - at least if you want to be able to freely zoom into your plot\nwithout the annotation growing to infinity.\", \"This calls for a solution where the arc's center is defined in data space, but\nits radius in a physical unit like points or pixels, or as a ratio of the Axes\ndimension. The following AngleAnnotation class provides such solution.\", 'The example below serves two purposes: It provides a ready-to-use solution for the problem of easily drawing angles\nin graphs.', \"It shows how to subclass a Matplotlib artist to enhance its functionality, as\nwell as giving a hands-on example on how to use Matplotlib's transform\nsystem.\", 'If mainly interested in the former, you may copy the below class and jump to\nthe Usage section.', \"The essential idea here is to subclass Arc and set its transform\nto the IdentityTransform, making the parameters of the arc\ndefined in pixel space.\nWe then override the Arc's attributes _center, theta1,\ntheta2, width and height and make them properties, coupling to\ninternal methods that calculate the respective parameters each time the\nattribute is accessed and thereby ensuring that the arc in pixel space stays\nsynchronized with the input points and size.\nFor example, each time the arc's drawing method would query its _center\nattribute, instead of receiving the same number all over again, it will\ninstead receive the result of the get_center_in_pixels method we defined\nin the subclass. This method transforms the center in data coordinates to\npixels via the Axes transform ax.transData. The size and the angles are\ncalculated in a similar fashion, such that the arc changes its shape\nautomatically when e.g. zooming or panning interactively.\", \"The functionality of this class allows to annotate the arc with a text. This\ntext is a Annotation stored in an attribute text. Since the\narc's position and radius are defined only at draw time, we need to update\nthe text's position accordingly. This is done by reimplementing the Arc's\ndraw() method to let it call an updating method for the text.\", 'The arc and the text will be added to the provided Axes at instantiation: it\nis hence not strictly necessary to keep a reference to it. Required arguments to AngleAnnotation are the center of the arc, xy,\nand two points, such that the arc spans between the two vectors connecting\np1 and p2 with xy, respectively. Those are given in data coordinates.\nFurther arguments are the size of the arc and its unit. Additionally, a\ntext can be specified, that will be drawn either in- or outside of the arc,\naccording to the value of textposition. Usage of those arguments is shown\nbelow. The textposition and unit keyword arguments may be used to modify the\nlocation of the text label, as shown below: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.Arc matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate matplotlib.text.Annotation matplotlib.transforms.IdentityTransform matplotlib.transforms.TransformedBbox matplotlib.transforms.Bbox Download Python source code: angle_annotation.py Download Jupyter notebook: angle_annotation.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Arc\nfrom matplotlib.transforms import Bbox, IdentityTransform, TransformedBbox\n\n\nclass AngleAnnotation(Arc):\n    \"\"\"\n    Draws an arc between two vectors which appears circular in display space.\n    \"\"\"\n    def __init__(self, xy, p1, p2, size=75, unit=\"points\", ax=None,\n                 text=\"\", textposition=\"inside\", text_kw=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        xy, p1, p2 : tuple or array of two floats\n            Center position and two points. Angle annotation is drawn between\n            the two vectors connecting *p1* and *p2* with *xy*, respectively.\n            Units are data coordinates.\n\n        size : float\n            Diameter of the angle annotation in units specified by *unit*.\n\n        unit : str\n            One of the following strings to specify the unit of *size*:\n\n            * \"pixels\": pixels\n            * \"points\": points, use points instead of pixels to not have a\n              dependence on the DPI\n            * \"axes width\", \"axes height\": relative units of Axes width, height\n            * \"axes min\", \"axes max\": minimum or maximum of relative Axes\n              width, height\n\n        ax : `matplotlib.axes.Axes`\n            The Axes to add the angle annotation to.\n\n        text : str\n            The text to mark the angle with.\n\n        textposition : {\"inside\", \"outside\", \"edge\"}\n            Whether to show the text in- or outside the arc. \"edge\" can be used\n            for custom positions anchored at the arc\\'s edge.\n\n        text_kw : dict\n            Dictionary of arguments passed to the Annotation.\n\n        **kwargs\n            Further parameters are passed to `matplotlib.patches.Arc`. Use this\n            to specify, color, linewidth etc. of the arc.\n\n        \"\"\"\n        self.ax = ax or plt.gca()\n        self._xydata = xy  # in data coordinates\n        self.vec1 = p1\n        self.vec2 = p2\n        self.size = size\n        self.unit = unit\n        self.textposition = textposition\n\n        super().__init__(self._xydata, size, size, angle=0.0,\n                         theta1=self.theta1, theta2=self.theta2, **kwargs)\n\n        self.set_transform(IdentityTransform())\n        self.ax.add_patch(self)\n\n        self.kw = dict(ha=\"center\", va=\"center\",\n                       xycoords=IdentityTransform(),\n                       xytext=(0, 0), textcoords=\"offset points\",\n                       annotation_clip=True)\n        self.kw.update(text_kw or {})\n        self.text = ax.annotate(text, xy=self._center, **self.kw)\n\n    def get_size(self):\n        factor = 1.\n        if self.unit == \"points\":\n            factor = self.ax.figure.dpi / 72.\n        elif self.unit[:4] == \"axes\":\n            b = TransformedBbox(Bbox.unit(), self.ax.transAxes)\n            dic = {\"max\": max(b.width, b.height),\n                   \"min\": min(b.width, b.height),\n                   \"width\": b.width, \"height\": b.height}\n            factor = dic[self.unit[5:]]\n        return self.size * factor\n\n    def set_size(self, size):\n        self.size = size\n\n    def get_center_in_pixels(self):\n        \"\"\"return center in pixels\"\"\"\n        return self.ax.transData.transform(self._xydata)\n\n    def set_center(self, xy):\n        \"\"\"set center in data coordinates\"\"\"\n        self._xydata = xy\n\n    def get_theta(self, vec):\n        vec_in_pixels = self.ax.transData.transform(vec) - self._center\n        return np.rad2deg(np.arctan2(vec_in_pixels[1], vec_in_pixels[0]))\n\n    def get_theta1(self):\n        return self.get_theta(self.vec1)\n\n    def get_theta2(self):\n        return self.get_theta(self.vec2)\n\n    def set_theta(self, angle):\n        pass\n\n    # Redefine attributes of the Arc to always give values in pixel space\n    _center = property(get_center_in_pixels, set_center)\n    theta1 = property(get_theta1, set_theta)\n    theta2 = property(get_theta2, set_theta)\n    width = property(get_size, set_size)\n    height = property(get_size, set_size)\n\n    # The following two methods are needed to update the text position.\n    def draw(self, renderer):\n        self.update_text()\n        super().draw(renderer)\n\n    def update_text(self):\n        c = self._center\n        s = self.get_size()\n        angle_span = (self.theta2 - self.theta1) % 360\n        angle = np.deg2rad(self.theta1 + angle_span / 2)\n        r = s / 2\n        if self.textposition == \"inside\":\n            r = s / np.interp(angle_span, [60, 90, 135, 180],\n                                          [3.3, 3.5, 3.8, 4])\n        self.text.xy = c + r * np.array([np.cos(angle), np.sin(angle)])\n        if self.textposition == \"outside\":\n            def R90(a, r, w, h):\n                if a < np.arctan(h/2/(r+w/2)):\n                    return np.sqrt((r+w/2)**2 + (np.tan(a)*(r+w/2))**2)\n                else:\n                    c = np.sqrt((w/2)**2+(h/2)**2)\n                    T = np.arcsin(c * np.cos(np.pi/2 - a + np.arcsin(h/2/c))/r)\n                    xy = r * np.array([np.cos(a + T), np.sin(a + T)])\n                    xy += np.array([w/2, h/2])\n                    return np.sqrt(np.sum(xy**2))\n\n            def R(a, r, w, h):\n                aa = (a % (np.pi/4))*((a % (np.pi/2)) <= np.pi/4) + \\\\\n                     (np.pi/4 - (a % (np.pi/4)))*((a % (np.pi/2)) >= np.pi/4)\n                return R90(aa, r, *[w, h][::int(np.sign(np.cos(2*a)))])\n\n            bbox = self.text.get_window_extent()\n            X = R(angle, r, bbox.width, bbox.height)\n            trans = self.ax.figure.dpi_scale_trans.inverted()\n            offs = trans.transform(((X-s/2), 0))[0] * 72\n            self.text.set_position([offs*np.cos(angle), offs*np.sin(angle)])\n fig, ax = plt.subplots()\nfig.canvas.draw()  # Need to draw the figure to define renderer\nax.set_title(\"AngleLabel example\")\n\n# Plot two crossing lines and label each angle between them with the above\n# ``AngleAnnotation`` tool.\ncenter = (4.5, 650)\np1 = [(2.5, 710), (6.0, 605)]\np2 = [(3.0, 275), (5.5, 900)]\nline1, = ax.plot(*zip(*p1))\nline2, = ax.plot(*zip(*p2))\npoint, = ax.plot(*center, marker=\"o\")\n\nam1 = AngleAnnotation(center, p1[1], p2[1], ax=ax, size=75, text=r\"$\\\\alpha$\")\nam2 = AngleAnnotation(center, p2[1], p1[0], ax=ax, size=35, text=r\"$\\\\beta$\")\nam3 = AngleAnnotation(center, p1[0], p2[0], ax=ax, size=75, text=r\"$\\\\gamma$\")\nam4 = AngleAnnotation(center, p2[0], p1[1], ax=ax, size=35, text=r\"$\\\\theta$\")\n\n\n# Showcase some styling options for the angle arc, as well as the text.\np = [(6.0, 400), (5.3, 410), (5.6, 300)]\nax.plot(*zip(*p))\nam5 = AngleAnnotation(p[1], p[0], p[2], ax=ax, size=40, text=r\"$\\\\Phi$\",\n                      linestyle=\"--\", color=\"gray\", textposition=\"outside\",\n                      text_kw=dict(fontsize=16, color=\"gray\"))\n # Helper function to draw angle easily.\ndef plot_angle(ax, pos, angle, length=0.95, acol=\"C0\", **kwargs):\n    vec2 = np.array([np.cos(np.deg2rad(angle)), np.sin(np.deg2rad(angle))])\n    xy = np.c_[[length, 0], [0, 0], vec2*length].T + np.array(pos)\n    ax.plot(*xy.T, color=acol)\n    return AngleAnnotation(pos, xy[0], xy[2], ax=ax, **kwargs)\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)\nfig.suptitle(\"AngleLabel keyword arguments\")\nfig.canvas.draw()  # Need to draw the figure to define renderer\n\n# Showcase different text positions.\nax1.margins(y=0.4)\nax1.set_title(\"textposition\")\nkw = dict(size=75, unit=\"points\", text=r\"$60\u00b0$\")\n\nam6 = plot_angle(ax1, (2.0, 0), 60, textposition=\"inside\", **kw)\nam7 = plot_angle(ax1, (3.5, 0), 60, textposition=\"outside\", **kw)\nam8 = plot_angle(ax1, (5.0, 0), 60, textposition=\"edge\",\n                 text_kw=dict(bbox=dict(boxstyle=\"round\", fc=\"w\")), **kw)\nam9 = plot_angle(ax1, (6.5, 0), 60, textposition=\"edge\",\n                 text_kw=dict(xytext=(30, 20), arrowprops=dict(arrowstyle=\"->\",\n                              connectionstyle=\"arc3,rad=-0.2\")), **kw)\n\nfor x, text in zip([2.0, 3.5, 5.0, 6.5], [\\'\"inside\"\\', \\'\"outside\"\\', \\'\"edge\"\\',\n                                          \\'\"edge\", custom arrow\\):\n    ax1.annotate(text, xy=(x, 0), xycoords=ax1.get_xaxis_transform(),\n                 bbox=dict(boxstyle=\"round\", fc=\"w\"), ha=\"left\", fontsize=8,\n                 annotation_clip=True)\n\n# Showcase different size units. The effect of this can best be observed\n# by interactively changing the figure size\nax2.margins(y=0.4)\nax2.set_title(\"unit\")\nkw = dict(text=r\"$60\u00b0$\", textposition=\"outside\")\n\nam10 = plot_angle(ax2, (2.0, 0), 60, size=50, unit=\"pixels\", **kw)\nam11 = plot_angle(ax2, (3.5, 0), 60, size=50, unit=\"points\", **kw)\nam12 = plot_angle(ax2, (5.0, 0), 60, size=0.25, unit=\"axes min\", **kw)\nam13 = plot_angle(ax2, (6.5, 0), 60, size=0.25, unit=\"axes max\", **kw)\n\nfor x, text in zip([2.0, 3.5, 5.0, 6.5], [\\'\"pixels\"\\', \\'\"points\"\\',\n                                          \\'\"axes min\"\\', \\'\"axes max\"\\):\n    ax2.annotate(text, xy=(x, 0), xycoords=ax2.get_xaxis_transform(),\n                 bbox=dict(boxstyle=\"round\", fc=\"w\"), ha=\"left\", fontsize=8,\n                 annotation_clip=True)\n\nplt.show()\n",
    "id": 166
},
{
    "title": "Angle annotations on bracket arrows#",
    "text": "This example shows how to add angle annotations to bracket arrow styles\ncreated using FancyArrowPatch. angleA and angleB are measured from a\nvertical line as positive (to the left) or negative (to the right). Blue\nFancyArrowPatch arrows indicate the directions of angleA and angleB\nfrom the vertical and axes text annotate the angle sizes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.ArrowStyle Download Python source code: angles_on_bracket_arrows.py Download Jupyter notebook: angles_on_bracket_arrows.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import FancyArrowPatch\n\n\ndef get_point_of_rotated_vertical(origin, line_length, degrees):\n    \"\"\"Return xy coordinates of the vertical line end rotated by degrees.\"\"\"\n    rad = np.deg2rad(-degrees)\n    return [origin[0] + line_length * np.sin(rad),\n            origin[1] + line_length * np.cos(rad)]\n\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 6), ylim=(-1, 5))\nax.set_title(\"Orientation of the bracket arrows relative to angleA and angleB\")\n\nstyle = \\-[\\'\nfor i, angle in enumerate([-40, 0, 60]):\n    y = 2*i\n    arrow_centers = ((1, y), (5, y))\n    vlines = ((1, y + 0.5), (5, y + 0.5))\n    anglesAB = (angle, -angle)\n    bracketstyle = f\"{style}, angleA={anglesAB[0]}, angleB={anglesAB[1]}\"\n    bracket = FancyArrowPatch(*arrow_centers, arrowstyle=bracketstyle,\n                              mutation_scale=42)\n    ax.add_patch(bracket)\n    ax.text(3, y + 0.05, bracketstyle, ha=\"center\", va=\"bottom\", fontsize=14)\n    ax.vlines([line[0] for line in vlines], [y, y], [line[1] for line in vlines],\n              linestyles=\"--\", color=\"C0\")\n    # Get the top coordinates for the drawn patches at A and B\n    patch_tops = [get_point_of_rotated_vertical(center, 0.5, angle)\n                  for center, angle in zip(arrow_centers, anglesAB)]\n    # Define the connection directions for the annotation arrows\n    connection_dirs = (1, -1) if angle > 0 else (-1, 1)\n    # Add arrows and annotation text\n    arrowstyle = \"Simple, tail_width=0.5, head_width=4, head_length=8\"\n    for vline, dir, patch_top, angle in zip(vlines, connection_dirs,\n                                            patch_tops, anglesAB):\n        kw = dict(connectionstyle=f\"arc3,rad={dir * 0.5}\",\n                  arrowstyle=arrowstyle, color=\"C0\")\n        ax.add_patch(FancyArrowPatch(vline, patch_top, **kw))\n        ax.text(vline[0] - dir * 0.15, y + 0.7, f\\'{angle}\u00b0\\', ha=\"center\",\n                va=\"center\")\n\nplt.show()\n",
    "id": 167
},
{
    "title": "Annotate Transform#",
    "text": "This example shows how to use different coordinate systems for annotations.\nFor a complete overview of the annotation capabilities, also see the\nannotation tutorial. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.transforms.Transform.transform matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate Download Python source code: annotate_transform.py Download Jupyter notebook: annotate_transform.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 10, 0.005)\ny = np.exp(-x/2.) * np.sin(2*np.pi*x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_xlim(0, 10)\nax.set_ylim(-1, 1)\n\nxdata, ydata = 5, 0\nxdisplay, ydisplay = ax.transData.transform((xdata, ydata))\n\nbbox = dict(boxstyle=\"round\", fc=\"0.8\")\narrowprops = dict(\n    arrowstyle=\"->\",\n    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\")\n\noffset = 72\nax.annotate(\n    f\\'data = ({xdata:.1f}, {ydata:.1f})\\',\n    (xdata, ydata),\n    xytext=(-2*offset, offset), textcoords=\\'offset points\\',\n    bbox=bbox, arrowprops=arrowprops)\nax.annotate(\n    f\\'display = ({xdisplay:.1f}, {ydisplay:.1f})\\',\n    xy=(xdisplay, ydisplay), xycoords=\\'figure pixels\\',\n    xytext=(0.5*offset, -offset), textcoords=\\'offset points\\',\n    bbox=bbox, arrowprops=arrowprops)\n\nplt.show()\n",
    "id": 168
},
{
    "title": "Annotating a plot#",
    "text": "This example shows how to annotate a plot with an arrow pointing to provided\ncoordinates. We modify the defaults of the arrow, to \"shrink\" it. For a complete overview of the annotation capabilities, also see the\nannotation tutorial. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate Download Python source code: annotation_basic.py Download Jupyter notebook: annotation_basic.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=2)\n\nax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            )\nax.set_ylim(-2, 2)\nplt.show()\n",
    "id": 169
},
{
    "title": "Annotating Plots#",
    "text": "The following examples show how it is possible to annotate plots in Matplotlib.\nThis includes highlighting specific points of interest and using various\nvisual tools to call attention to this point. For a more complete and in-depth\ndescription of the annotation and text tools in Matplotlib, see the\ntutorial on annotation.', \"You must specify an annotation point xy=(x, y) to annotate this point.\nAdditionally, you may specify a text point xytext=(x, y) for the location\nof the text for this annotation. Optionally, you can specify the coordinate\nsystem of xy and xytext with one of the following strings for xycoords\nand textcoords (default is 'data'):\", 'Note: for physical coordinate systems (points or pixels) the origin is the\n(bottom, left) of the figure or axes. Optionally, you can specify arrow properties which draws and arrow\nfrom the text to the annotated point by giving a dictionary of arrow\nproperties Valid keys are: You can specify the xypoint and the xytext in different positions and\ncoordinate systems, and optionally turn on a connecting line and mark the\npoint with a marker. Annotations work on polar axes too.', \"In the example below, the xy point is in native coordinates (xycoords\ndefaults to 'data'). For a polar axes, this is in (theta, radius) space.\nThe text in the example is placed in the fractional figure coordinate system.\nText keyword arguments like horizontal and vertical alignment are respected.\", \"You can also use polar notation on a cartesian axes. Here the native\ncoordinate system ('data') is cartesian, so you need to specify the\nxycoords and textcoords as 'polar' if you want to use (theta, radius).\", 'The arrow between xytext and the annotation point, as well as the bubble\nthat covers the annotation text, are highly customizable. Below are a few\nparameter options as well as their resulting output.', \"We'll create another figure so that it doesn't get too cluttered\", \"Below we'll show a few more examples of coordinate systems and how the\nlocation of annotations may be specified.\", 'Total running time of the script: (0 minutes 1.905 seconds) Download Python source code: annotation_demo.py Download Jupyter notebook: annotation_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\nfrom matplotlib.text import OffsetFrom\n', \"'figure points'   : points from the lower left corner of the figure\n'figure pixels'   : pixels from the lower left corner of the figure\n'figure fraction' : (0, 0) is lower left of figure and (1, 1) is upper right\n'axes points'     : points from lower left corner of axes\n'axes pixels'     : pixels from lower left corner of axes\n'axes fraction'   : (0, 0) is lower left of axes and (1, 1) is upper right\n'offset points'   : Specify an offset (in points) from the xy value\n'offset pixels'   : Specify an offset (in pixels) from the xy value\n'data'            : use the axes data coordinate system\n\", 'width : the width of the arrow in points\nfrac  : the fraction of the arrow length occupied by the head\nheadwidth : the width of the base of the arrow head in points\nshrink : move the tip and base some percent away from the\n         annotated point and text\nany key for matplotlib.patches.polygon  (e.g., facecolor)\n', \"# Create our figure and data we'll use for plotting\nfig, ax = plt.subplots(figsize=(4, 4))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\n\n# Plot a line and add some simple annotations\nline, = ax.plot(t, s)\nax.annotate('figure pixels',\n            xy=(10, 10), xycoords='figure pixels')\nax.annotate('figure points',\n            xy=(107, 110), xycoords='figure points',\n            fontsize=12)\nax.annotate('figure fraction',\n            xy=(.025, .975), xycoords='figure fraction',\n            horizontalalignment='left', verticalalignment='top',\n            fontsize=20)\n\n# The following examples show off how these arrows are drawn.\n\nax.annotate('point offset from data',\n            xy=(3, 1), xycoords='data',\n            xytext=(-10, 90), textcoords='offset points',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='center', verticalalignment='bottom')\n\nax.annotate('axes fraction',\n            xy=(2, 1), xycoords='data',\n            xytext=(0.36, 0.68), textcoords='axes fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='right', verticalalignment='top')\n\n# You may also use negative points or pixels to specify from (right, top).\n# E.g., (-10, 10) is 10 points to the left of the right side of the axes and 10\n# points above the bottom\n\nax.annotate('pixel offset from axes fraction',\n            xy=(1, 0), xycoords='axes fraction',\n            xytext=(-20, 20), textcoords='offset pixels',\n            horizontalalignment='right',\n            verticalalignment='bottom')\n\nax.set(xlim=(-1, 5), ylim=(-3, 5))\n\", \"fig, ax = plt.subplots(subplot_kw=dict(projection='polar'), figsize=(3, 3))\nr = np.arange(0, 1, 0.001)\ntheta = 2*2*np.pi*r\nline, = ax.plot(theta, r)\n\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # theta, radius\n            xytext=(0.05, 0.05),    # fraction, fraction\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom')\n\", \"el = Ellipse((0, 0), 10, 20, facecolor='r', alpha=0.5)\n\nfig, ax = plt.subplots(subplot_kw=dict(aspect='equal'))\nax.add_artist(el)\nel.set_clip_box(ax.bbox)\nax.annotate('the top',\n            xy=(np.pi/2., 10.),      # theta, radius\n            xytext=(np.pi/3, 20.),   # theta, radius\n            xycoords='polar',\n            textcoords='polar',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom',\n            clip_on=True)  # clip to the axes bounding box\n\nax.set(xlim=[-20, 20], ylim=[-20, 20])\n\", 'fig, ax = plt.subplots(figsize=(8, 5))\n\nt = np.arange(0.0, 5.0, 0.01)\ns = np.cos(2*np.pi*t)\nline, = ax.plot(t, s, lw=3)\n\nax.annotate(\n    \\'straight\\',\n    xy=(0, 1), xycoords=\\'data\\',\n    xytext=(-50, 30), textcoords=\\'offset points\\',\n    arrowprops=dict(arrowstyle=\"->\"))\nax.annotate(\n    \\'arc3,\\\nrad 0.2\\',\n    xy=(0.5, -1), xycoords=\\'data\\',\n    xytext=(-80, -60), textcoords=\\'offset points\\',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"arc3,rad=.2\"))\nax.annotate(\n    \\'arc,\\\nangle 50\\',\n    xy=(1., 1), xycoords=\\'data\\',\n    xytext=(-90, 50), textcoords=\\'offset points\\',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"arc,angleA=0,armA=50,rad=10\"))\nax.annotate(\n    \\'arc,\\\narms\\',\n    xy=(1.5, -1), xycoords=\\'data\\',\n    xytext=(-80, -60), textcoords=\\'offset points\\',\n    arrowprops=dict(\n        arrowstyle=\"->\",\n        connectionstyle=\"arc,angleA=0,armA=40,angleB=-90,armB=30,rad=7\"))\nax.annotate(\n    \\'angle,\\\nangle 90\\',\n    xy=(2., 1), xycoords=\\'data\\',\n    xytext=(-70, 30), textcoords=\\'offset points\\',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\nax.annotate(\n    \\'angle3,\\\nangle -90\\',\n    xy=(2.5, -1), xycoords=\\'data\\',\n    xytext=(-80, -60), textcoords=\\'offset points\\',\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle3,angleA=0,angleB=-90\"))\nax.annotate(\n    \\'angle,\\\nround\\',\n    xy=(3., 1), xycoords=\\'data\\',\n    xytext=(-60, 30), textcoords=\\'offset points\\',\n    bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\nax.annotate(\n    \\'angle,\\\nround4\\',\n    xy=(3.5, -1), xycoords=\\'data\\',\n    xytext=(-70, -80), textcoords=\\'offset points\\',\n    size=20,\n    bbox=dict(boxstyle=\"round4,pad=.5\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    connectionstyle=\"angle,angleA=0,angleB=-90,rad=10\"))\nax.annotate(\n    \\'angle,\\\nshrink\\',\n    xy=(4., 1), xycoords=\\'data\\',\n    xytext=(-60, 30), textcoords=\\'offset points\\',\n    bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n    arrowprops=dict(arrowstyle=\"->\",\n                    shrinkA=0, shrinkB=10,\n                    connectionstyle=\"angle,angleA=0,angleB=90,rad=10\"))\n# You can pass an empty string to get only annotation arrows rendered\nax.annotate(\\'\\', xy=(4., 1.), xycoords=\\'data\\',\n            xytext=(4.5, -1), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"<->\",\n                            connectionstyle=\"bar\",\n                            ec=\"k\",\n                            shrinkA=5, shrinkB=5))\n\nax.set(xlim=(-1, 5), ylim=(-4, 3))\n fig, ax = plt.subplots()\n\nel = Ellipse((2, -1), 0.5, 0.5)\nax.add_patch(el)\n\nax.annotate(\\'$->$\\',\n            xy=(2., -1), xycoords=\\'data\\',\n            xytext=(-150, -140), textcoords=\\'offset points\\',\n            bbox=dict(boxstyle=\"round\", fc=\"0.8\"),\n            arrowprops=dict(arrowstyle=\"->\",\n                            patchB=el,\n                            connectionstyle=\"angle,angleA=90,angleB=0,rad=10\"))\nax.annotate(\\'arrow\\\nfancy\\',\n            xy=(2., -1), xycoords=\\'data\\',\n            xytext=(-100, 60), textcoords=\\'offset points\\',\n            size=20,\n            arrowprops=dict(arrowstyle=\"fancy\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"angle3,angleA=0,angleB=-90\"))\nax.annotate(\\'arrow\\\nsimple\\',\n            xy=(2., -1), xycoords=\\'data\\',\n            xytext=(100, 60), textcoords=\\'offset points\\',\n            size=20,\n            arrowprops=dict(arrowstyle=\"simple\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"arc3,rad=0.3\"))\nax.annotate(\\'wedge\\',\n            xy=(2., -1), xycoords=\\'data\\',\n            xytext=(-100, -100), textcoords=\\'offset points\\',\n            size=20,\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=0.7\",\n                            fc=\"0.6\", ec=\"none\",\n                            patchB=el,\n                            connectionstyle=\"arc3,rad=-0.3\"))\nax.annotate(\\'bubble,\\\ncontours\\',\n            xy=(2., -1), xycoords=\\'data\\',\n            xytext=(0, -70), textcoords=\\'offset points\\',\n            size=20,\n            bbox=dict(boxstyle=\"round\",\n                      fc=(1.0, 0.7, 0.7),\n                      ec=(1., .5, .5)),\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=1.\",\n                            fc=(1.0, 0.7, 0.7), ec=(1., .5, .5),\n                            patchA=None,\n                            patchB=el,\n                            relpos=(0.2, 0.8),\n                            connectionstyle=\"arc3,rad=-0.1\"))\nax.annotate(\\'bubble\\',\n            xy=(2., -1), xycoords=\\'data\\',\n            xytext=(55, 0), textcoords=\\'offset points\\',\n            size=20, va=\"center\",\n            bbox=dict(boxstyle=\"round\", fc=(1.0, 0.7, 0.7), ec=\"none\"),\n            arrowprops=dict(arrowstyle=\"wedge,tail_width=1.\",\n                            fc=(1.0, 0.7, 0.7), ec=\"none\",\n                            patchA=None,\n                            patchB=el,\n                            relpos=(0.2, 0.5)))\n\nax.set(xlim=(-1, 5), ylim=(-5, 3))\n fig, (ax1, ax2) = plt.subplots(1, 2)\n\nbbox_args = dict(boxstyle=\"round\", fc=\"0.8\")\narrow_args = dict(arrowstyle=\"->\")\n\n# Here we\\'ll demonstrate the extents of the coordinate system and how\n# we place annotating text.\n\nax1.annotate(\\'figure fraction : 0, 0\\', xy=(0, 0), xycoords=\\'figure fraction\\',\n             xytext=(20, 20), textcoords=\\'offset points\\',\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate(\\'figure fraction : 1, 1\\', xy=(1, 1), xycoords=\\'figure fraction\\',\n             xytext=(-20, -20), textcoords=\\'offset points\\',\n             ha=\"right\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate(\\'axes fraction : 0, 0\\', xy=(0, 0), xycoords=\\'axes fraction\\',\n             xytext=(20, 20), textcoords=\\'offset points\\',\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax1.annotate(\\'axes fraction : 1, 1\\', xy=(1, 1), xycoords=\\'axes fraction\\',\n             xytext=(-20, -20), textcoords=\\'offset points\\',\n             ha=\"right\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\n# It is also possible to generate draggable annotations\n\nan1 = ax1.annotate(\\'Drag me 1\\', xy=(.5, .7), xycoords=\\'data\\',\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args)\n\nan2 = ax1.annotate(\\'Drag me 2\\', xy=(.5, .5), xycoords=an1,\n                   xytext=(.5, .3), textcoords=\\'axes fraction\\',\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args,\n                   arrowprops=dict(patchB=an1.get_bbox_patch(),\n                                   connectionstyle=\"arc3,rad=0.2\",\n                                   **arrow_args))\nan1.draggable()\nan2.draggable()\n\nan3 = ax1.annotate(\\'\\', xy=(.5, .5), xycoords=an2,\n                   xytext=(.5, .5), textcoords=an1,\n                   ha=\"center\", va=\"center\",\n                   bbox=bbox_args,\n                   arrowprops=dict(patchA=an1.get_bbox_patch(),\n                                   patchB=an2.get_bbox_patch(),\n                                   connectionstyle=\"arc3,rad=0.2\",\n                                   **arrow_args))\n\n# Finally we\\'ll show off some more complex annotation and placement\n\ntext = ax2.annotate(\\'xy=(0, 1)\\\nxycoords=(\"data\", \"axes fraction\")\\',\n                    xy=(0, 1), xycoords=(\"data\", \\'axes fraction\\'),\n                    xytext=(0, -20), textcoords=\\'offset points\\',\n                    ha=\"center\", va=\"top\",\n                    bbox=bbox_args,\n                    arrowprops=arrow_args)\n\nax2.annotate(\\'xy=(0.5, 0)\\\nxycoords=artist\\',\n             xy=(0.5, 0.), xycoords=text,\n             xytext=(0, -20), textcoords=\\'offset points\\',\n             ha=\"center\", va=\"top\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax2.annotate(\\'xy=(0.8, 0.5)\\\nxycoords=ax1.transData\\',\n             xy=(0.8, 0.5), xycoords=ax1.transData,\n             xytext=(10, 10),\n             textcoords=OffsetFrom(ax2.bbox, (0, 0), \"points\"),\n             ha=\"left\", va=\"bottom\",\n             bbox=bbox_args,\n             arrowprops=arrow_args)\n\nax2.set(xlim=[-2, 2], ylim=[-2, 2])\nplt.show()\n",
    "id": 170
},
{
    "title": "Annotation Polar#",
    "text": "This example shows how to create an annotation on a polar graph. For a complete overview of the annotation capabilities, also see the\nAnnotations. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.projections.polar matplotlib.axes.Axes.annotate / matplotlib.pyplot.annotate Download Python source code: annotation_polar.py Download Jupyter notebook: annotation_polar.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\nr = np.arange(0, 1, 0.001)\ntheta = 2 * 2*np.pi * r\nline, = ax.plot(theta, r, color='#ee8d18', lw=3)\n\nind = 800\nthisr, thistheta = r[ind], theta[ind]\nax.plot([thistheta], [thisr], 'o')\nax.annotate('a polar annotation',\n            xy=(thistheta, thisr),  # theta, radius\n            xytext=(0.05, 0.05),    # fraction, fraction\n            textcoords='figure fraction',\n            arrowprops=dict(facecolor='black', shrink=0.05),\n            horizontalalignment='left',\n            verticalalignment='bottom',\n            )\nplt.show()\n",
    "id": 171
},
{
    "title": "Arrow Demo#",
    "text": "Three ways of drawing arrows to encode arrow \"strength\" (e.g., transition\nprobabilities in a Markov model) using arrow length, width, or alpha (opacity). Download Python source code: arrow_demo.py Download Jupyter notebook: arrow_demo.ipynb ",
    "code": "import itertools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef make_arrow_graph(ax, data, size=4, display=\\'length\\', shape=\\'right\\',\n                     max_arrow_width=0.03, arrow_sep=0.02, alpha=0.5,\n                     normalize_data=False, ec=None, labelcolor=None,\n                     **kwargs):\n    \"\"\"\n    Makes an arrow plot.\n\n    Parameters\n    ----------\n    ax\n        The axes where the graph is drawn.\n    data\n        Dict with probabilities for the bases and pair transitions.\n    size\n        Size of the plot, in inches.\n    display : {\\'length\\', \\'width\\', \\'alpha\\'}\n        The arrow property to change.\n    shape : {\\'full\\', \\'left\\', \\'right\\'}\n        For full or half arrows.\n    max_arrow_width : float\n        Maximum width of an arrow, in data coordinates.\n    arrow_sep : float\n        Separation between arrows in a pair, in data coordinates.\n    alpha : float\n        Maximum opacity of arrows.\n    **kwargs\n        `.FancyArrow` properties, e.g. *linewidth* or *edgecolor*.\n    \"\"\"\n\n    ax.set(xlim=(-0.25, 1.25), ylim=(-0.25, 1.25), xticks=[], yticks=[],\n           title=f\\'flux encoded as arrow {display}\\')\n    max_text_size = size * 12\n    min_text_size = size\n    label_text_size = size * 4\n\n    bases = \\'ATGC\\'\n    coords = {\n        \\'A\\': np.array([0, 1]),\n        \\'T\\': np.array([1, 1]),\n        \\'G\\': np.array([0, 0]),\n        \\'C\\': np.array([1, 0]),\n    }\n    colors = {\\'A\\': \\'r\\', \\'T\\': \\'k\\', \\'G\\': \\'g\\', \\'C\\': \\'b\\'}\n\n    for base in bases:\n        fontsize = np.clip(max_text_size * data[base]**(1/2),\n                           min_text_size, max_text_size)\n        ax.text(*coords[base], f\\'${base}_3$\\',\n                color=colors[base], size=fontsize,\n                horizontalalignment=\\'center\\', verticalalignment=\\'center\\',\n                weight=\\'bold\\')\n\n    arrow_h_offset = 0.25  # data coordinates, empirically determined\n    max_arrow_length = 1 - 2 * arrow_h_offset\n    max_head_width = 2.5 * max_arrow_width\n    max_head_length = 2 * max_arrow_width\n    sf = 0.6  # max arrow size represents this in data coords\n\n    if normalize_data:\n        # find maximum value for rates, i.e. where keys are 2 chars long\n        max_val = max((v for k, v in data.items() if len(k) == 2), default=0)\n        # divide rates by max val, multiply by arrow scale factor\n        for k, v in data.items():\n            data[k] = v / max_val * sf\n\n    # iterate over strings \\'AT\\', \\'TA\\', \\'AG\\', \\'GA\\', etc.\n    for pair in map(\\'\\'.join, itertools.permutations(bases, 2)):\n        # set the length of the arrow\n        if display == \\'length\\':\n            length = (max_head_length\n                      + data[pair] / sf * (max_arrow_length - max_head_length))\n        else:\n            length = max_arrow_length\n        # set the transparency of the arrow\n        if display == \\'alpha\\':\n            alpha = min(data[pair] / sf, alpha)\n        # set the width of the arrow\n        if display == \\'width\\':\n            scale = data[pair] / sf\n            width = max_arrow_width * scale\n            head_width = max_head_width * scale\n            head_length = max_head_length * scale\n        else:\n            width = max_arrow_width\n            head_width = max_head_width\n            head_length = max_head_length\n\n        fc = colors[pair[0]]\n\n        cp0 = coords[pair[0]]\n        cp1 = coords[pair[1]]\n        # unit vector in arrow direction\n        delta = cos, sin = (cp1 - cp0) / np.hypot(*(cp1 - cp0))\n        x_pos, y_pos = (\n            (cp0 + cp1) / 2  # midpoint\n            - delta * length / 2  # half the arrow length\n            + np.array([-sin, cos]) * arrow_sep  # shift outwards by arrow_sep\n        )\n        ax.arrow(\n            x_pos, y_pos, cos * length, sin * length,\n            fc=fc, ec=ec or fc, alpha=alpha, width=width,\n            head_width=head_width, head_length=head_length, shape=shape,\n            length_includes_head=True,\n            **kwargs\n        )\n\n        # figure out coordinates for text:\n        # if drawing relative to base: x and y are same as for arrow\n        # dx and dy are one arrow width left and up\n        orig_positions = {\n            \\'base\\': [3 * max_arrow_width, 3 * max_arrow_width],\n            \\'center\\': [length / 2, 3 * max_arrow_width],\n            \\'tip\\': [length - 3 * max_arrow_width, 3 * max_arrow_width],\n        }\n        # for diagonal arrows, put the label at the arrow base\n        # for vertical or horizontal arrows, center the label\n        where = \\'base\\' if (cp0 != cp1).all() else \\'center\\'\n        # rotate based on direction of arrow (cos, sin)\n        M = [[cos, -sin], [sin, cos]]\n        x, y = np.dot(M, orig_positions[where]) + [x_pos, y_pos]\n        label = r\\'$r_{_{\\\\mathrm{%s}}}$\\' % (pair,)\n        ax.text(x, y, label, size=label_text_size, ha=\\'center\\', va=\\'center\\',\n                color=labelcolor or fc)\n\n\nif __name__ == \\'__main__\\':\n    data = {  # test data\n        \\'A\\': 0.4, \\'T\\': 0.3, \\'G\\': 0.6, \\'C\\': 0.2,\n        \\'AT\\': 0.4, \\'AC\\': 0.3, \\'AG\\': 0.2,\n        \\'TA\\': 0.2, \\'TC\\': 0.3, \\'TG\\': 0.4,\n        \\'CT\\': 0.2, \\'CG\\': 0.3, \\'CA\\': 0.2,\n        \\'GA\\': 0.1, \\'GT\\': 0.4, \\'GC\\': 0.1,\n    }\n\n    size = 4\n    fig = plt.figure(figsize=(3 * size, size), layout=\"constrained\")\n    axs = fig.subplot_mosaic([length\", \"width\", \"alpha])\n\n    for display, ax in axs.items():\n        make_arrow_graph(\n            ax, data, display=display, linewidth=0.001, edgecolor=None,\n            normalize_data=True, size=size)\n\n    plt.show()\n",
    "id": 172
},
{
    "title": "Auto-wrapping text#",
    "text": "Matplotlib can wrap text automatically, but if it's too long, the text will be\ndisplayed slightly outside of the boundaries of the axis anyways.\", \"Note: Auto-wrapping does not work together with\nsavefig(..., bbox_inches='tight'). The 'tight' setting rescales the canvas\nto accommodate all content and happens before wrapping. This affects\n%matplotlib inline in IPython and Jupyter notebooks where the inline\nsetting uses bbox_inches='tight' by default when saving the image to\nembed.\", 'Download Python source code: autowrap.py Download Jupyter notebook: autowrap.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\nplt.axis((0, 10, 0, 10))\nt = (\"This is a really long string that I\\'d rather have wrapped so that it \"\n     \"doesn\\'t go outside of the figure, but if it\\'s long enough it will go \"\n     \"off the top or bottom!\")\nplt.text(4, 1, t, ha=\\'left\\', rotation=15, wrap=True)\nplt.text(6, 5, t, ha=\\'left\\', rotation=15, wrap=True)\nplt.text(5, 5, t, ha=\\'right\\', rotation=-15, wrap=True)\nplt.text(5, 10, t, fontsize=18, style=\\'oblique\\', ha=\\'center\\',\n         va=\\'top\\', wrap=True)\nplt.text(3, 4, t, family=\\'serif\\', style=\\'italic\\', ha=\\'right\\', wrap=True)\nplt.text(-1, 0, t, ha=\\'left\\', rotation=-15, wrap=True)\n\nplt.show()\n",
    "id": 173
},
{
    "title": "Composing Custom Legends#",
    "text": "Composing custom legends piece-by-piece. Note For more information on creating and customizing legends, see the following\npages: Legend guide Legend Demo', \"Sometimes you don't want a legend that is explicitly tied to data that\nyou have plotted. For example, say you have plotted 10 lines, but don't\nwant a legend item to show up for each one. If you simply plot the lines\nand call ax.legend(), you will get the following:\", \"Note that no legend entries were created.\nIn this case, we can compose a legend using Matplotlib objects that aren't\nexplicitly tied to the data that was plotted. For example:\", \"There are many other Matplotlib objects that can be used in this way. In the\ncode below we've listed a few common ones.\", 'Total running time of the script: (0 minutes 1.275 seconds) Download Python source code: custom_legends.py Download Jupyter notebook: custom_legends.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib import cycler\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nN = 10\ndata = (np.geomspace(1, 10, 100) + np.random.randn(N, 100)).T\ncmap = plt.cm.coolwarm\nmpl.rcParamsaxes.prop_cycle = cycler(color=cmap(np.linspace(0, 1, N)))\n\nfig, ax = plt.subplots()\nlines = ax.plot(data)\nax.legend()\n\", 'No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n', \"from matplotlib.lines import Line2D\n\ncustom_lines = [Line2D([0], [0], color=cmap(0.), lw=4),\n                Line2D([0], [0], color=cmap(.5), lw=4),\n                Line2D([0], [0], color=cmap(1.), lw=4)]\n\nfig, ax = plt.subplots()\nlines = ax.plot(data)\nax.legend(custom_lines, Cold Medium Hot)\n\", \"from matplotlib.lines import Line2D\nfrom matplotlib.patches import Patch\n\nlegend_elements = [Line2D([0], [0], color='b', lw=4, label='Line'),\n                   Line2D([0], [0], marker='o', color='w', label='Scatter',\n                          markerfacecolor='g', markersize=15),\n                   Patch(facecolor='orange', edgecolor='r',\n                         label='Color Patch')]\n\n# Create the figure\nfig, ax = plt.subplots()\nax.legend(handles=legend_elements, loc='center')\n\nplt.show()\n",
    "id": 174
},
{
    "title": "Date tick labels#",
    "text": "Matplotlib date plotting is done by converting date instances into\ndays since an epoch (by default 1970-01-01T00:00:00). The\nmatplotlib.dates module provides the converter functions date2num\nand num2date that convert datetime.datetime and numpy.datetime64\nobjects to and from Matplotlib's internal representation. These data\ntypes are registered with the unit conversion mechanism described in\nmatplotlib.units, so the conversion happens automatically for the user.\nThe registration process also sets the default tick locator and\nformatter for the axis to be AutoDateLocator and\nAutoDateFormatter.\", 'An alternative formatter is the ConciseDateFormatter,\nused in the second Axes below (see\nFormatting date ticks using ConciseDateFormatter), which often removes the need to\nrotate the tick labels. The last Axes formats the dates manually, using\nDateFormatter to format the dates using the format strings documented\nat datetime.date.strftime. Total running time of the script: (0 minutes 1.204 seconds) Download Python source code: date.py Download Jupyter notebook: date.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as mdates\n\n# Load a numpy record array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit ('D') in\n# the date column.\ndata = cbook.get_sample_data('goog.npz')price_data\n\nfig, axs = plt.subplots(3, 1, figsize=(6.4, 7), layout='constrained')\n# common to all three:\nfor ax in axs:\n    ax.plot('date adj_close', data=data)\n    # Major ticks every half year, minor ticks every month,\n    ax.xaxis.set_major_locator(mdates.MonthLocator(bymonth=(1, 7)))\n    ax.xaxis.set_minor_locator(mdates.MonthLocator())\n    ax.grid(True)\n    ax.set_ylabel(r'Price [\\\\$]')\n\n# different formats:\nax = axs[0]\nax.set_title('DefaultFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\n\nax = axs[1]\nax.set_title('ConciseFormatter', loc='left', y=0.85, x=0.02, fontsize='medium')\nax.xaxis.set_major_formatter(\n    mdates.ConciseDateFormatter(ax.xaxis.get_major_locator()))\n\nax = axs[2]\nax.set_title('Manual DateFormatter', loc='left', y=0.85, x=0.02,\n             fontsize='medium')\n# Text in the x-axis will be displayed in 'YYYY-mm' format.\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%b'))\n# Rotates and right-aligns the x labels so they don't crowd each other.\nfor label in ax.get_xticklabels(which='major'):\n    label.set(rotation=30, horizontalalignment='right')\n\nplt.show()\n",
    "id": 175
},
{
    "title": "AnnotationBbox demo#",
    "text": "AnnotationBbox creates an annotation using an OffsetBox, and\nprovides more fine-grained control than Axes.annotate. This example\ndemonstrates the use of AnnotationBbox together with three different\nOffsetBoxes: TextArea, DrawingArea, and OffsetImage. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.Circle matplotlib.offsetbox.TextArea matplotlib.offsetbox.DrawingArea matplotlib.offsetbox.OffsetImage matplotlib.offsetbox.AnnotationBbox matplotlib.cbook.get_sample_data matplotlib.pyplot.subplots matplotlib.pyplot.imread Download Python source code: demo_annotation_box.py Download Jupyter notebook: demo_annotation_box.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.offsetbox import (AnnotationBbox, DrawingArea, OffsetImage,\n                                  TextArea)\nfrom matplotlib.patches import Circle\n\nfig, ax = plt.subplots()\n\n# Define a 1st position to annotate (display it with a marker)\nxy = (0.5, 0.7)\nax.plot(xy[0], xy[1], \".r\")\n\n# Annotate the 1st position with a text box (\\'Test 1\\')\noffsetbox = TextArea(\"Test 1\")\n\nab = AnnotationBbox(offsetbox, xy,\n                    xybox=(-20, 40),\n                    xycoords=\\'data\\',\n                    boxcoords=\"offset points\",\n                    arrowprops=dict(arrowstyle=\"->\"),\n                    bboxprops=dict(boxstyle=\"sawtooth\"))\nax.add_artist(ab)\n\n# Annotate the 1st position with another text box (\\'Test\\')\noffsetbox = TextArea(\"Test\")\n\nab = AnnotationBbox(offsetbox, xy,\n                    xybox=(1.02, xy[1]),\n                    xycoords=\\'data\\',\n                    boxcoords=(\"axes fraction\", \"data\"),\n                    box_alignment=(0., 0.5),\n                    arrowprops=dict(arrowstyle=\"->\"))\nax.add_artist(ab)\n\n# Define a 2nd position to annotate (don\\'t display with a marker this time)\nxy = [0.3, 0.55]\n\n# Annotate the 2nd position with a circle patch\nda = DrawingArea(20, 20, 0, 0)\np = Circle((10, 10), 10)\nda.add_artist(p)\n\nab = AnnotationBbox(da, xy,\n                    xybox=(1., xy[1]),\n                    xycoords=\\'data\\',\n                    boxcoords=(\"axes fraction\", \"data\"),\n                    box_alignment=(0.2, 0.5),\n                    arrowprops=dict(arrowstyle=\"->\"),\n                    bboxprops=dict(alpha=0.5))\n\nax.add_artist(ab)\n\n# Annotate the 2nd position with an image (a generated array of pixels)\narr = np.arange(100).reshape((10, 10))\nim = OffsetImage(arr, zoom=2)\nim.image.axes = ax\n\nab = AnnotationBbox(im, xy,\n                    xybox=(-50., 50.),\n                    xycoords=\\'data\\',\n                    boxcoords=\"offset points\",\n                    pad=0.3,\n                    arrowprops=dict(arrowstyle=\"->\"))\n\nax.add_artist(ab)\n\n# Annotate the 2nd position with another image (a Grace Hopper portrait)\nwith get_sample_data(\"grace_hopper.jpg\") as file:\n    arr_img = plt.imread(file)\n\nimagebox = OffsetImage(arr_img, zoom=0.2)\nimagebox.image.axes = ax\n\nab = AnnotationBbox(imagebox, xy,\n                    xybox=(120., -80.),\n                    xycoords=\\'data\\',\n                    boxcoords=\"offset points\",\n                    pad=0.5,\n                    arrowprops=dict(\n                        arrowstyle=\"->\",\n                        connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n                    )\n\nax.add_artist(ab)\n\n# Fix the display limits to see everything\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\n\nplt.show()\n",
    "id": 176
},
{
    "title": "Using a text as a Path#",
    "text": "TextPath creates a Path that is the outline of the\ncharacters of a text. The resulting path can be employed e.g. as a clip path\nfor an image. Total running time of the script: (0 minutes 1.930 seconds) Download Python source code: demo_text_path.py Download Jupyter notebook: demo_text_path.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.image import BboxImage\nfrom matplotlib.offsetbox import (AnchoredOffsetbox, AnnotationBbox,\n                                  AuxTransformBox)\nfrom matplotlib.patches import PathPatch, Shadow\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import IdentityTransform\n\n\nclass PathClippedImagePatch(PathPatch):\n    \"\"\"\n    The given image is used to draw the face of the patch. Internally,\n    it uses BboxImage whose clippath set to the path of the patch.\n\n    FIXME : The result is currently dpi dependent.\n    \"\"\"\n\n    def __init__(self, path, bbox_image, **kwargs):\n        super().__init__(path, **kwargs)\n        self.bbox_image = BboxImage(\n            self.get_window_extent, norm=None, origin=None)\n        self.bbox_image.set_data(bbox_image)\n\n    def set_facecolor(self, color):\n        \"\"\"Simply ignore facecolor.\"\"\"\n        super().set_facecolor(\"none\")\n\n    def draw(self, renderer=None):\n        # the clip path must be updated every draw. any solution? -JJ\n        self.bbox_image.set_clip_path(self._path, self.get_transform())\n        self.bbox_image.draw(renderer)\n        super().draw(renderer)\n\n\nif __name__ == \"__main__\":\n\n    fig, (ax1, ax2) = plt.subplots(2)\n\n    # EXAMPLE 1\n\n    arr = plt.imread(get_sample_data(\"grace_hopper.jpg\"))\n\n    text_path = TextPath((0, 0), \"!?\", size=150)\n    p = PathClippedImagePatch(text_path, arr, ec=\"k\")\n\n    # make offset box\n    offsetbox = AuxTransformBox(IdentityTransform())\n    offsetbox.add_artist(p)\n\n    # make anchored offset box\n    ao = AnchoredOffsetbox(loc=\\'upper left\\', child=offsetbox, frameon=True,\n                           borderpad=0.2)\n    ax1.add_artist(ao)\n\n    # another text\n    for usetex, ypos, string in [\n            (False, 0.25, r\"textpath supports mathtext\"),\n            (True, 0.05, r\"textpath supports \\\\TeX\"),\n    ]:\n        text_path = TextPath((0, 0), string, size=20, usetex=usetex)\n\n        p1 = PathPatch(text_path, ec=\"w\", lw=3, fc=\"w\", alpha=0.9)\n        p2 = PathPatch(text_path, ec=\"none\", fc=\"k\")\n\n        offsetbox2 = AuxTransformBox(IdentityTransform())\n        offsetbox2.add_artist(p1)\n        offsetbox2.add_artist(p2)\n\n        ab = AnnotationBbox(offsetbox2, (0.95, ypos),\n                            xycoords=\\'axes fraction\\',\n                            boxcoords=\"offset points\",\n                            box_alignment=(1., 0.),\n                            frameon=False,\n                            )\n        ax1.add_artist(ab)\n\n    ax1.imshow([[0, 1, 2], [1, 2, 3]], cmap=plt.cm.gist_gray_r,\n               interpolation=\"bilinear\", aspect=\"auto\")\n\n    # EXAMPLE 2\n\n    arr = np.arange(256).reshape(1, 256)\n\n    for usetex, xpos, string in [\n            (False, 0.25,\n             r\"$\\\\left[\\\\sum_{n=1}^\\\\infty\\\\frac{-e^{i\\\\pi}}{2^n}\\\\right]$!\"),\n            (True, 0.75,\n             r\"$\\\\displaystyle\\\\left[\\\\sum_{n=1}^\\\\infty\"\n             r\"\\\\frac{-e^{i\\\\pi}}{2^n}\\\\right]$!\"),\n    ]:\n        text_path = TextPath((0, 0), string, size=40, usetex=usetex)\n        text_patch = PathClippedImagePatch(text_path, arr, ec=\"none\")\n        shadow1 = Shadow(text_patch, 1, -1, fc=\"none\", ec=\"0.6\", lw=3)\n        shadow2 = Shadow(text_patch, 1, -1, fc=\"0.3\", ec=\"none\")\n\n        # make offset box\n        offsetbox = AuxTransformBox(IdentityTransform())\n        offsetbox.add_artist(shadow1)\n        offsetbox.add_artist(shadow2)\n        offsetbox.add_artist(text_patch)\n\n        # place the anchored offset box using AnnotationBbox\n        ab = AnnotationBbox(offsetbox, (xpos, 0.5), box_alignment=(0.5, 0.5))\n\n        ax2.add_artist(ab)\n\n    ax2.set_xlim(0, 1)\n    ax2.set_ylim(0, 1)\n\n    plt.show()\n",
    "id": 177
},
{
    "title": "Text Rotation Mode#",
    "text": "This example illustrates the effect of rotation_mode on the positioning\nof rotated text.', \"Rotated Texts are created by passing the parameter rotation to\nthe constructor or the axes' method text.\", 'The actual positioning depends on the additional parameters\nhorizontalalignment, verticalalignment and rotation_mode.\nrotation_mode determines the order of rotation and alignment:', \"rotation_mode='default' (or None) first rotates the text and then aligns\nthe bounding box of the rotated text.\", \"rotation_mode='anchor' aligns the unrotated text and then rotates the\ntext around the point of alignment.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.text / matplotlib.pyplot.text Download Python source code: demo_text_rotation_mode.py Download Jupyter notebook: demo_text_rotation_mode.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef test_rotation_mode(fig, mode):\n    ha_list = left\", \"center\", \"right\n    va_list = top\", \"center\", \"baseline\", \"bottom\n    axs = fig.subplots(len(va_list), len(ha_list), sharex=True, sharey=True,\n                       subplot_kw=dict(aspect=1),\n                       gridspec_kw=dict(hspace=0, wspace=0))\n\n    # labels and title\n    for ha, ax in zip(ha_list, axs[-1, :]):\n        ax.set_xlabel(ha)\n    for va, ax in zip(va_list, axs[:, 0]):\n        ax.set_ylabel(va)\n    axs[0, 1].set_title(f\"rotation_mode=\\'{mode}\\'\", size=\"large\")\n\n    kw = (\n        {} if mode == \"default\" else\n        {\"bbox\": dict(boxstyle=\"square,pad=0.\", ec=\"none\", fc=\"C1\", alpha=0.3)}\n    )\n\n    texts = {}\n\n    # use a different text alignment in each axes\n    for i, va in enumerate(va_list):\n        for j, ha in enumerate(ha_list):\n            ax = axs[i, j]\n            # prepare axes layout\n            ax.set(xticks=[], yticks=[])\n            ax.axvline(0.5, color=\"skyblue\", zorder=0)\n            ax.axhline(0.5, color=\"skyblue\", zorder=0)\n            ax.plot(0.5, 0.5, color=\"C0\", marker=\"o\", zorder=1)\n            # add text with rotation and alignment settings\n            tx = ax.text(0.5, 0.5, \"Tpg\",\n                         size=\"x-large\", rotation=40,\n                         horizontalalignment=ha, verticalalignment=va,\n                         rotation_mode=mode, **kw)\n            texts[ax] = tx\n\n    if mode == \"default\":\n        # highlight bbox\n        fig.canvas.draw()\n        for ax, text in texts.items():\n            bb = text.get_window_extent().transformed(ax.transData.inverted())\n            rect = plt.Rectangle((bb.x0, bb.y0), bb.width, bb.height,\n                                 facecolor=\"C1\", alpha=0.3, zorder=2)\n            ax.add_patch(rect)\n\n\nfig = plt.figure(figsize=(8, 5))\nsubfigs = fig.subfigures(1, 2)\ntest_rotation_mode(subfigs[0], \"default\")\ntest_rotation_mode(subfigs[1], \"anchor\")\nplt.show()\n",
    "id": 178
},
{
    "title": "The difference between \\dfrac and \\frac#",
    "text": "In this example, the differences between the \\\\dfrac and \\\\frac TeX macros are\nillustrated; in particular, the difference between display style and text style\nfractions when using Mathtex. New in version 2.1. Note To use \\\\dfrac with the LaTeX engine (text.usetex : True), you need to\nimport the amsmath package with the text.latex.preamble rc, which is\nan unsupported feature; therefore, it is probably a better idea to just\nuse the \\\\displaystyle option before the \\\\frac macro to get this behavior\nwith the LaTeX engine. Download Python source code: dfrac_demo.py Download Jupyter notebook: dfrac_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(5.25, 0.75))\nfig.text(0.5, 0.3, r'\\\\dfrac: $\\\\dfrac{a}{b}$',\n         horizontalalignment='center', verticalalignment='center')\nfig.text(0.5, 0.7, r'\\\\frac: $\\\\frac{a}{b}$',\n         horizontalalignment='center', verticalalignment='center')\nplt.show()\n",
    "id": 179
},
{
    "title": "Labeling ticks using engineering notation#",
    "text": "Use of the engineering Formatter. Total running time of the script: (0 minutes 1.063 seconds) Download Python source code: engineering_formatter.py Download Jupyter notebook: engineering_formatter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import EngFormatter\n\n# Fixing random state for reproducibility\nprng = np.random.RandomState(19680801)\n\n# Create artificial data to plot.\n# The x data span over several decades to demonstrate several SI prefixes.\nxs = np.logspace(1, 9, 100)\nys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2\n\n# Figure width is doubled (2*6.4) to display nicely 2 subplots side by side.\nfig, (ax0, ax1) = plt.subplots(nrows=2, figsize=(7, 9.6))\nfor ax in (ax0, ax1):\n    ax.set_xscale(\\'log\\')\n\n# Demo of the default settings, with a user-defined unit label.\nax0.set_title(\\'Full unit ticklabels, w/ default precision & space separator\\')\nformatter0 = EngFormatter(unit=\\'Hz\\')\nax0.xaxis.set_major_formatter(formatter0)\nax0.plot(xs, ys)\nax0.set_xlabel(\\'Frequency\\')\n\n# Demo of the options `places` (number of digit after decimal point) and\n# `sep` (separator between the number and the prefix/unit).\nax1.set_title(\\'SI-prefix only ticklabels, 1-digit precision & \\'\n              \\'thin space separator\\')\nformatter1 = EngFormatter(places=1, sep=\"\\\\N{THIN SPACE}\")  # U+2009\nax1.xaxis.set_major_formatter(formatter1)\nax1.plot(xs, ys)\nax1.set_xlabel(\\'Frequency [Hz]\\')\n\nplt.tight_layout()\nplt.show()\n",
    "id": 180
},
{
    "title": "Annotation arrow style reference#",
    "text": "Overview of the arrow styles available in annotate. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.ArrowStyle matplotlib.patches.ArrowStyle.get_styles matplotlib.axes.Axes.annotate Download Python source code: fancyarrow_demo.py Download Jupyter notebook: fancyarrow_demo.ipynb ",
    "code": "import inspect\nimport itertools\nimport re\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nstyles = mpatches.ArrowStyle.get_styles()\nncol = 2\nnrow = (len(styles) + 1) // ncol\naxs = (plt.figure(figsize=(4 * ncol, 1 + nrow))\n       .add_gridspec(1 + nrow, ncol,\n                     wspace=.7, left=.1, right=.9, bottom=0, top=1).subplots())\nfor ax in axs.flat:\n    ax.set_axis_off()\nfor ax in axs[0, :]:\n    ax.text(0, .5, \"arrowstyle\",\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"center\", verticalalignment=\"center\")\n    ax.text(.35, .5, \"default parameters\",\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\nfor ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):\n    l, = ax.plot(.25, .5, \"ok\", transform=ax.transAxes)\n    ax.annotate(stylename, (.25, .5), (-0.1, .5),\n                xycoords=\"axes fraction\", textcoords=\"axes fraction\",\n                size=\"large\", color=\"tab:blue\",\n                horizontalalignment=\"center\", verticalalignment=\"center\",\n                arrowprops=dict(\n                    arrowstyle=stylename, connectionstyle=\"arc3,rad=-0.05\",\n                    color=\"k\", shrinkA=5, shrinkB=5, patchB=l,\n                ),\n                bbox=dict(boxstyle=\"square\", fc=\"w\"))\n    # wrap at every nth comma (n = 1 or 2, depending on text length)\n    s = str(inspect.signature(stylecls))[1:-1]\n    n = 2 if s.count(\\',\\') > 3 else 1\n    ax.text(.35, .5,\n            re.sub(\\', \\', lambda m, c=itertools.count(1): m.group()\n                   if next(c) % n else \\'\\\n\\', s),\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\n\nplt.show()\n",
    "id": 181
},
{
    "title": "Styling text boxes#",
    "text": "This example shows how to style text boxes using bbox parameters. Download Python source code: fancytextbox_demo.py Download Jupyter notebook: fancytextbox_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nplt.text(0.6, 0.7, \"eggs\", size=50, rotation=30.,\n         ha=\"center\", va=\"center\",\n         bbox=dict(boxstyle=\"round\",\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\nplt.text(0.55, 0.6, \"spam\", size=50, rotation=-25.,\n         ha=\"right\", va=\"top\",\n         bbox=dict(boxstyle=\"square\",\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\nplt.show()\n",
    "id": 182
},
{
    "title": "Figure legend demo#",
    "text": "Instead of plotting a legend on each axis, a legend for all the artists on all\nthe sub-axes of a figure can be plotted instead. Sometimes we do not want the legend to overlap the axes. If you use\nconstrained layout you can specify \"outside right upper\", and\nconstrained layout will make room for the legend. Total running time of the script: (0 minutes 1.068 seconds) Download Python source code: figlegend_demo.py Download Jupyter notebook: figlegend_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, axs = plt.subplots(1, 2)\n\nx = np.arange(0.0, 2.0, 0.02)\ny1 = np.sin(2 * np.pi * x)\ny2 = np.exp(-x)\nl1, = axs[0].plot(x, y1)\nl2, = axs[0].plot(x, y2, marker='o')\n\ny3 = np.sin(4 * np.pi * x)\ny4 = np.exp(-2 * x)\nl3, = axs[1].plot(x, y3, color='tab:green')\nl4, = axs[1].plot(x, y4, color='tab:red', marker='^')\n\nfig.legend((l1, l2), ('Line 1 Line 2'), loc='upper left')\nfig.legend((l3, l4), ('Line 3 Line 4'), loc='upper right')\n\nplt.tight_layout()\nplt.show()\n\", \"fig, axs = plt.subplots(1, 2, layout='constrained')\n\nx = np.arange(0.0, 2.0, 0.02)\ny1 = np.sin(2 * np.pi * x)\ny2 = np.exp(-x)\nl1, = axs[0].plot(x, y1)\nl2, = axs[0].plot(x, y2, marker='o')\n\ny3 = np.sin(4 * np.pi * x)\ny4 = np.exp(-2 * x)\nl3, = axs[1].plot(x, y3, color='tab:green')\nl4, = axs[1].plot(x, y4, color='tab:red', marker='^')\n\nfig.legend((l1, l2), ('Line 1 Line 2'), loc='upper left')\nfig.legend((l3, l4), ('Line 3 Line 4'), loc='outside right upper')\n\nplt.show()\n",
    "id": 183
},
{
    "title": "Configuring the font family#",
    "text": "You can explicitly set which font family is picked up, either by specifying\nfamily names of fonts installed on user's system, or generic-families\n(e.g., 'serif sans-serif monospace fantasy' or 'cursive'),\nor a combination of both.\n(see Text properties and layout)\", \"In the example below, we are overriding the default sans-serif generic family\nto include a specific (Tahoma) font. (Note that the best way to achieve this\nwould simply be to prepend 'Tahoma' in 'font.family')\", 'The default family is set with the font.family rcparam,\ne.g. and for the font.family you set a list of font styles to try to find\nin order: The font.family defaults are OS dependent and can be viewed with: Choose default sans-serif font Choose sans-serif font and specify to it to \"Nimbus Sans\" Choose default monospace font Choose monospace font and specify to it to \"FreeMono\" Download Python source code: font_family_rc.py Download Jupyter notebook: font_family_rc.ipynb ",
    "code": "rcParamsfont.family = 'sans-serif'\n\", \"rcParamsfont.sans-serif = Tahoma DejaVu Sans',\n                               'Lucida Grande Verdana\n\", 'import matplotlib.pyplot as plt\n\nprint(plt.rcParamsfont.sans-serif[0])\nprint(plt.rcParamsfont.monospace[0])\n DejaVu Sans\nDejaVu Sans Mono\n def print_text(text):\n    fig, ax = plt.subplots(figsize=(6, 1), facecolor=\"#eefade\")\n    ax.text(0.5, 0.5, text, ha=\\'center\\', va=\\'center\\', size=40)\n    ax.axis(\"off\")\n    plt.show()\n\n\nplt.rcParamsfont.family = \"sans-serif\"\nprint_text(\"Hello World! 01\")\n plt.rcParamsfont.family = \"sans-serif\"\nplt.rcParamsfont.sans-serif = Nimbus Sans\nprint_text(\"Hello World! 02\")\n plt.rcParamsfont.family = \"monospace\"\nprint_text(\"Hello World! 03\")\n plt.rcParamsfont.family = \"monospace\"\nplt.rcParamsfont.monospace = FreeMono\nprint_text(\"Hello World! 04\")\n",
    "id": 184
},
{
    "title": "Using a ttf font file in Matplotlib#",
    "text": "Although it is usually not a good idea to explicitly point to a single ttf file\nfor a font instance, you can do so by passing a pathlib.Path instance as the\nfont parameter. Note that passing paths as strs is intentionally not\nsupported, but you can simply wrap strs in pathlib.Paths as needed. Here, we use the Computer Modern roman font (cmr10) shipped with\nMatplotlib. For a more flexible solution, see\nConfiguring the font family and\nFonts demo (object-oriented style). References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.set_title Download Python source code: font_file.py Download Jupyter notebook: font_file.ipynb ",
    "code": "from pathlib import Path\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib as mpl\n\nfig, ax = plt.subplots()\n\nfpath = Path(mpl.get_data_path(), \"fonts/ttf/cmr10.ttf\")\nax.set_title(f\\'This is a special font: {fpath.name}\\', font=fpath)\nax.set_xlabel(\\'This is the default font\\')\n\nplt.show()\n",
    "id": 185
},
{
    "title": "Font table#",
    "text": "Matplotlib's font support is provided by the FreeType library.\", 'Here, we use table to draw a table that shows the glyphs by Unicode\ncodepoint. For brevity, the table only contains the first 256 glyphs. The example is a full working script. You can download it and use it to\ninvestigate a font by running Total running time of the script: (0 minutes 1.118 seconds) Download Python source code: font_table.py Download Jupyter notebook: font_table.ipynb ",
    "code": "python font_table.py /path/to/font/file\n import os\nfrom pathlib import Path\nimport unicodedata\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.font_manager as fm\nfrom matplotlib.ft2font import FT2Font\n\n\ndef print_glyphs(path):\n    \"\"\"\n    Print the all glyphs in the given font file to stdout.\n\n    Parameters\n    ----------\n    path : str or None\n        The path to the font file.  If None, use Matplotlib\\'s default font.\n    \"\"\"\n    if path is None:\n        path = fm.findfont(fm.FontProperties())  # The default font.\n\n    font = FT2Font(path)\n\n    charmap = font.get_charmap()\n    max_indices_len = len(str(max(charmap.values())))\n\n    print(\"The font face contains the following glyphs:\")\n    for char_code, glyph_index in charmap.items():\n        char = chr(char_code)\n        name = unicodedata.name(\n                char,\n                f\"{char_code:#x} ({font.get_glyph_name(glyph_index)})\")\n        print(f\"{glyph_index:>{max_indices_len}} {char} {name}\")\n\n\ndef draw_font_table(path):\n    \"\"\"\n    Draw a font table of the first 255 chars of the given font.\n\n    Parameters\n    ----------\n    path : str or None\n        The path to the font file.  If None, use Matplotlib\\'s default font.\n    \"\"\"\n    if path is None:\n        path = fm.findfont(fm.FontProperties())  # The default font.\n\n    font = FT2Font(path)\n    # A charmap is a mapping of \"character codes\" (in the sense of a character\n    # encoding, e.g. latin-1) to glyph indices (i.e. the internal storage table\n    # of the font face).\n    # In FreeType>=2.1, a Unicode charmap (i.e. mapping Unicode codepoints)\n    # is selected by default.  Moreover, recent versions of FreeType will\n    # automatically synthesize such a charmap if the font does not include one\n    # (this behavior depends on the font format; for example it is present\n    # since FreeType 2.0 for Type 1 fonts but only since FreeType 2.8 for\n    # TrueType (actually, SFNT) fonts).\n    # The code below (specifically, the ``chr(char_code)`` call) assumes that\n    # we have indeed selected a Unicode charmap.\n    codes = font.get_charmap().items()\n\n    labelc = [f\"{i:X}\" for i in range(16)]\n    labelr = [f\"{i:02X}\" for i in range(0, 16*16, 16)]\n    chars = [\" for c in range(16)] for r in range(16)]\n\n    for char_code, glyph_index in codes:\n        if char_code >= 256:\n            continue\n        row, col = divmod(char_code, 16)\n        chars[row][col] = chr(char_code)\n\n    fig, ax = plt.subplots(figsize=(8, 4))\n    ax.set_title(os.path.basename(path))\n    ax.set_axis_off()\n\n    table = ax.table(\n        cellText=chars,\n        rowLabels=labelr,\n        colLabels=labelc,\n        rowColours=palegreen * 16,\n        colColours=palegreen * 16,\n        cellColours=[.95\" for c in range(16)] for r in range(16)],\n        cellLoc=\\'center\\',\n        loc=\\'upper left\\',\n    )\n    for key, cell in table.get_celld().items():\n        row, col = key\n        if row > 0 and col > -1:  # Beware of table\\'s idiosyncratic indexing...\n            cell.set_text_props(font=Path(path))\n\n    fig.tight_layout()\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    from argparse import ArgumentParser\n\n    parser = ArgumentParser(description=\"Display a font table.\")\n    parser.add_argument(\"path\", nargs=\"?\", help=\"Path to the font file.\")\n    parser.add_argument(\"--print-all\", action=\"store_true\",\n                        help=\"Additionally, print all chars to stdout.\")\n    args = parser.parse_args()\n\n    if args.print_all:\n        print_glyphs(args.path)\n    draw_font_table(args.path)\n",
    "id": 186
},
{
    "title": "Fonts demo (object-oriented style)#",
    "text": "Set font properties using setters. See Fonts demo (keyword arguments) to achieve the same effect using keyword arguments. Download Python source code: fonts_demo.py Download Jupyter notebook: fonts_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.font_manager import FontProperties\n\nfig = plt.figure()\nalignment = {'horizontalalignment': 'center verticalalignment': 'baseline'}\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\nheading_font = FontProperties(size='large')\n\n# Show family options\nfig.text(0.1, 0.9, 'family', fontproperties=heading_font, **alignment)\nfamilies = serif sans-serif cursive fantasy monospace\nfor k, family in enumerate(families):\n    font = FontProperties()\n    font.set_family(family)\n    fig.text(0.1, yp[k], family, fontproperties=font, **alignment)\n\n# Show style options\nstyles = normal italic oblique\nfig.text(0.3, 0.9, 'style', fontproperties=heading_font, **alignment)\nfor k, style in enumerate(styles):\n    font = FontProperties()\n    font.set_family('sans-serif')\n    font.set_style(style)\n    fig.text(0.3, yp[k], style, fontproperties=font, **alignment)\n\n# Show variant options\nvariants = normal small-caps\nfig.text(0.5, 0.9, 'variant', fontproperties=heading_font, **alignment)\nfor k, variant in enumerate(variants):\n    font = FontProperties()\n    font.set_family('serif')\n    font.set_variant(variant)\n    fig.text(0.5, yp[k], variant, fontproperties=font, **alignment)\n\n# Show weight options\nweights = light normal medium semibold bold heavy black\nfig.text(0.7, 0.9, 'weight', fontproperties=heading_font, **alignment)\nfor k, weight in enumerate(weights):\n    font = FontProperties()\n    font.set_weight(weight)\n    fig.text(0.7, yp[k], weight, fontproperties=font, **alignment)\n\n# Show size options\nsizes = [\n    'xx-small x-small small medium large x-large xx-large\nfig.text(0.9, 0.9, 'size', fontproperties=heading_font, **alignment)\nfor k, size in enumerate(sizes):\n    font = FontProperties()\n    font.set_size(size)\n    fig.text(0.9, yp[k], size, fontproperties=font, **alignment)\n\n# Show bold italic\nfont = FontProperties(style='italic', weight='bold', size='x-small')\nfig.text(0.3, 0.1, 'bold italic', fontproperties=font, **alignment)\nfont = FontProperties(style='italic', weight='bold', size='medium')\nfig.text(0.3, 0.2, 'bold italic', fontproperties=font, **alignment)\nfont = FontProperties(style='italic', weight='bold', size='x-large')\nfig.text(0.3, 0.3, 'bold italic', fontproperties=font, **alignment)\n\nplt.show()\n",
    "id": 187
},
{
    "title": "Fonts demo (keyword arguments)#",
    "text": "Set font properties using keyword arguments. See Fonts demo (object-oriented style) to achieve the same effect using setters. Download Python source code: fonts_demo_kw.py Download Jupyter notebook: fonts_demo_kw.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\nalignment = {'horizontalalignment': 'center verticalalignment': 'baseline'}\nyp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\n\n# Show family options\nfig.text(0.1, 0.9, 'family', size='large', **alignment)\nfamilies = serif sans-serif cursive fantasy monospace\nfor k, family in enumerate(families):\n    fig.text(0.1, yp[k], family, family=family, **alignment)\n\n# Show style options\nfig.text(0.3, 0.9, 'style', **alignment)\nstyles = normal italic oblique\nfor k, style in enumerate(styles):\n    fig.text(0.3, yp[k], style, family='sans-serif', style=style, **alignment)\n\n# Show variant options\nfig.text(0.5, 0.9, 'variant', **alignment)\nvariants = normal small-caps\nfor k, variant in enumerate(variants):\n    fig.text(0.5, yp[k], variant, family='serif', variant=variant, **alignment)\n\n# Show weight options\nfig.text(0.7, 0.9, 'weight', **alignment)\nweights = light normal medium semibold bold heavy black\nfor k, weight in enumerate(weights):\n    fig.text(0.7, yp[k], weight, weight=weight, **alignment)\n\n# Show size options\nfig.text(0.9, 0.9, 'size', **alignment)\nsizes = [\n    'xx-small x-small small medium large x-large xx-large\nfor k, size in enumerate(sizes):\n    fig.text(0.9, yp[k], size, size=size, **alignment)\n\n# Show bold italic\nfig.text(0.3, 0.1, 'bold italic',\n         style='italic', weight='bold', size='x-small', **alignment)\nfig.text(0.3, 0.2, 'bold italic',\n         style='italic', weight='bold', size='medium', **alignment)\nfig.text(0.3, 0.3, 'bold italic',\n         style='italic', weight='bold', size='x-large', **alignment)\n\nplt.show()\n",
    "id": 188
},
{
    "title": "Labelling subplots#",
    "text": "Labelling subplots is relatively straightforward, and varies,\nso Matplotlib does not have a general method for doing this. Simplest is putting the label inside the axes. Note, here\nwe use pyplot.subplot_mosaic, and use the subplot labels\nas keys for the subplots, which is a nice convenience. However,\nthe same method works with pyplot.subplots or keys that are\ndifferent than what you want to label the subplot with. We may prefer the labels outside the axes, but still aligned\nwith each other, in which case we use a slightly different transform: If we want it aligned with the title, either incorporate in the title or\nuse the loc keyword argument: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.subplot_mosaic /\nmatplotlib.pyplot.subplot_mosaic matplotlib.axes.Axes.set_title matplotlib.axes.Axes.text matplotlib.transforms.ScaledTranslation Total running time of the script: (0 minutes 1.479 seconds) Download Python source code: label_subplots.py Download Jupyter notebook: label_subplots.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig, axs = plt.subplot_mosaic([a) c), b) c), d) d)],\n                              layout='constrained')\n\nfor label, ax in axs.items():\n    # label physical distance in and down:\n    trans = mtransforms.ScaledTranslation(10/72, -5/72, fig.dpi_scale_trans)\n    ax.text(0.0, 1.0, label, transform=ax.transAxes + trans,\n            fontsize='medium', verticalalignment='top', fontfamily='serif',\n            bbox=dict(facecolor='0.7', edgecolor='none', pad=3.0))\n\nplt.show()\n\", \"fig, axs = plt.subplot_mosaic([a) c), b) c), d) d)],\n                              layout='constrained')\n\nfor label, ax in axs.items():\n    # label physical distance to the left and up:\n    trans = mtransforms.ScaledTranslation(-20/72, 7/72, fig.dpi_scale_trans)\n    ax.text(0.0, 1.0, label, transform=ax.transAxes + trans,\n            fontsize='medium', va='bottom', fontfamily='serif')\n\nplt.show()\n\", \"fig, axs = plt.subplot_mosaic([a) c), b) c), d) d)],\n                              layout='constrained')\n\nfor label, ax in axs.items():\n    ax.set_title('Normal Title', fontstyle='italic')\n    ax.set_title(label, fontfamily='serif', loc='left', fontsize='medium')\n\nplt.show()\n",
    "id": 189
},
{
    "title": "Legend using pre-defined labels#",
    "text": "Defining legend labels with plots. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot matplotlib.axes.Axes.legend / matplotlib.pyplot.legend Download Python source code: legend.py Download Jupyter notebook: legend.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Make some fake data.\na = b = np.arange(0, 3, .02)\nc = np.exp(a)\nd = c[::-1]\n\n# Create plots with pre-defined labels.\nfig, ax = plt.subplots()\nax.plot(a, c, 'k--', label='Model length')\nax.plot(a, d, 'k:', label='Data length')\nax.plot(a, c + d, 'k', label='Total message length')\n\nlegend = ax.legend(loc='upper center', shadow=True, fontsize='x-large')\n\n# Put a nicer background color on the legend.\nlegend.get_frame().set_facecolor('C0')\n\nplt.show()\n",
    "id": 190
},
{
    "title": "Legend Demo#",
    "text": "Plotting legends in Matplotlib.', \"There are many ways to create and customize legends in Matplotlib. Below\nwe'll show a few examples for how to do so.\", \"First we'll show off how to make a legend for specific lines.\", \"Next we'll demonstrate plotting more complex labels.\", 'Here we attach legends to more complex plots.', \"Now we'll showcase legend entries with more than one legend key.\", 'Finally, it is also possible to write custom classes that define\nhow to stylize legends. Total running time of the script: (0 minutes 2.058 seconds) Download Python source code: legend_demo.py Download Jupyter notebook: legend_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.collections as mcol\nfrom matplotlib.legend_handler import HandlerLineCollection, HandlerTuple\nfrom matplotlib.lines import Line2D\n\nt1 = np.arange(0.0, 2.0, 0.1)\nt2 = np.arange(0.0, 2.0, 0.01)\n\nfig, ax = plt.subplots()\n\n# note that plot returns a list of lines.  The \"l1, = plot\" usage\n# extracts the first element of the list into l1 using tuple\n# unpacking.  So l1 is a Line2D instance, not a sequence of lines\nl1, = ax.plot(t2, np.exp(-t2))\nl2, l3 = ax.plot(t2, np.sin(2 * np.pi * t2), \\'--o\\', t1, np.log(1 + t1), \\'.\\')\nl4, = ax.plot(t2, np.exp(-t2) * np.sin(2 * np.pi * t2), \\'s-.\\')\n\nax.legend((l2, l4), (\\'oscillatory\\', \\'damped\\'), loc=\\'upper right\\', shadow=True)\nax.set_xlabel(\\'time\\')\nax.set_ylabel(\\'volts\\')\nax.set_title(\\'Damped oscillation\\')\nplt.show()\n x = np.linspace(0, 1)\n\nfig, (ax0, ax1) = plt.subplots(2, 1)\n\n# Plot the lines y=x**n for n=1..4.\nfor n in range(1, 5):\n    ax0.plot(x, x**n, label=f\"{n=}\")\nleg = ax0.legend(loc=\"upper left\", bbox_to_anchor=[0, 1],\n                 ncols=2, shadow=True, title=\"Legend\", fancybox=True)\nleg.get_title().set_color(\"red\")\n\n# Demonstrate some more complex labels.\nax1.plot(x, x**2, label=\"multi\\\nline\")\nhalf_pi = np.linspace(0, np.pi / 2)\nax1.plot(np.sin(half_pi), np.cos(half_pi), label=r\"$\\\\frac{1}{2}\\\\pi$\")\nax1.plot(x, 2**(x**2), label=\"$2^{x^2}$\")\nax1.legend(shadow=True, fancybox=True)\n\nplt.show()\n fig, axs = plt.subplots(3, 1, layout=\"constrained\")\ntop_ax, middle_ax, bottom_ax = axs\n\ntop_ax.bar([0, 1, 2], [0.2, 0.3, 0.1], width=0.4, label=\"Bar 1\",\n           align=\"center\")\ntop_ax.bar([0.5, 1.5, 2.5], [0.3, 0.2, 0.2], color=\"red\", width=0.4,\n           label=\"Bar 2\", align=\"center\")\ntop_ax.legend()\n\nmiddle_ax.errorbar([0, 1, 2], [2, 3, 1], xerr=0.4, fmt=\"s\", label=\"test 1\")\nmiddle_ax.errorbar([0, 1, 2], [3, 2, 4], yerr=0.3, fmt=\"o\", label=\"test 2\")\nmiddle_ax.errorbar([0, 1, 2], [1, 1, 3], xerr=0.4, yerr=0.3, fmt=\"^\",\n                   label=\"test 3\")\nmiddle_ax.legend()\n\nbottom_ax.stem([0.3, 1.5, 2.7], [1, 3.6, 2.7], label=\"stem test\")\nbottom_ax.legend()\n\nplt.show()\n', \"fig, (ax1, ax2) = plt.subplots(2, 1, layout='constrained')\n\n# First plot: two legend keys for a single entry\np1 = ax1.scatter([1], [5], c='r', marker='s', s=100)\np2 = ax1.scatter([3], [2], c='b', marker='o', s=100)\n# `plot` returns a list, but we want the handle - thus the comma on the left\np3, = ax1.plot([1, 5], [4, 4], 'm-d')\n\n# Assign two of the handles to the same legend entry by putting them in a tuple\n# and using a generic handler map (which would be used for any additional\n# tuples of handles like (p1, p3)).\nl = ax1.legend([(p1, p3), p2], two keys one key, scatterpoints=1,\n               numpoints=1, handler_map={tuple: HandlerTuple(ndivide=None)})\n\n# Second plot: plot two bar charts on top of each other and change the padding\n# between the legend keys\nx_left = [1, 2, 3]\ny_pos = [1, 3, 2]\ny_neg = [2, 1, 4]\n\nrneg = ax2.bar(x_left, y_neg, width=0.5, color='w', hatch='///', label='-1')\nrpos = ax2.bar(x_left, y_pos, width=0.5, color='k', label='+1')\n\n# Treat each legend entry differently by using specific `HandlerTuple`s\nl = ax2.legend([(rpos, rneg), (rneg, rpos)], pad!=0 pad=0,\n               handler_map={(rpos, rneg): HandlerTuple(ndivide=None),\n                            (rneg, rpos): HandlerTuple(ndivide=None, pad=0.)})\nplt.show()\n\", 'class HandlerDashedLines(HandlerLineCollection):\n    \"\"\"\n    Custom Handler for LineCollection instances.\n    \"\"\"\n    def create_artists(self, legend, orig_handle,\n                       xdescent, ydescent, width, height, fontsize, trans):\n        # figure out how many lines there are\n        numlines = len(orig_handle.get_segments())\n        xdata, xdata_marker = self.get_xdata(legend, xdescent, ydescent,\n                                             width, height, fontsize)\n        leglines = []\n        # divide the vertical space where the lines will go\n        # into equal parts based on the number of lines\n        ydata = np.full_like(xdata, height / (numlines + 1))\n        # for each line, create the line at the proper location\n        # and set the dash pattern\n        for i in range(numlines):\n            legline = Line2D(xdata, ydata * (numlines - i) - ydescent)\n            self.update_prop(legline, orig_handle, legend)\n            # set color, dash pattern, and linewidth to that\n            # of the lines in linecollection\n            try:\n                color = orig_handle.get_colors()[i]\n            except IndexError:\n                color = orig_handle.get_colors()[0]\n            try:\n                dashes = orig_handle.get_dashes()[i]\n            except IndexError:\n                dashes = orig_handle.get_dashes()[0]\n            try:\n                lw = orig_handle.get_linewidths()[i]\n            except IndexError:\n                lw = orig_handle.get_linewidths()[0]\n            if dashes[1] is not None:\n                legline.set_dashes(dashes[1])\n            legline.set_color(color)\n            legline.set_transform(trans)\n            legline.set_linewidth(lw)\n            leglines.append(legline)\n        return leglines\n\nx = np.linspace(0, 5, 100)\n\nfig, ax = plt.subplots()\ncolors = plt.rcParams[\\'axes.prop_cycle\\.by_key()[\\'color\\[:5]\nstyles = [\\'solid\\', \\'dashed\\', \\'dashed\\', \\'dashed\\', \\'solid\\\nfor i, color, style in zip(range(5), colors, styles):\n    ax.plot(x, np.sin(x) - .1 * i, c=color, ls=style)\n\n# make proxy artists\n# make list of one line -- doesn\\'t matter what the coordinates are\nline = [[(0, 0)]]\n# set up the proxy artist\nlc = mcol.LineCollection(5 * line, linestyles=styles, colors=colors)\n# create the legend\nax.legend([lc], [\\'multi-line\\, handler_map={type(lc): HandlerDashedLines()},\n          handlelength=2.5, handleheight=3)\n\nplt.show()\n",
    "id": 191
},
{
    "title": "Artist within an artist#",
    "text": "Override basic methods so an artist can contain another\nartist. In this case, the line contains a Text instance to label it. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.lines matplotlib.lines.Line2D matplotlib.lines.Line2D.set_data matplotlib.artist matplotlib.artist.Artist matplotlib.artist.Artist.draw matplotlib.artist.Artist.set_transform matplotlib.text matplotlib.text.Text matplotlib.text.Text.set_color matplotlib.text.Text.set_fontsize matplotlib.text.Text.set_position matplotlib.axes.Axes.add_line matplotlib.transforms matplotlib.transforms.Affine2D Download Python source code: line_with_text.py Download Jupyter notebook: line_with_text.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.lines as lines\nimport matplotlib.text as mtext\nimport matplotlib.transforms as mtransforms\n\n\nclass MyLine(lines.Line2D):\n    def __init__(self, *args, **kwargs):\n        # we'll update the position when the line data is set\n        self.text = mtext.Text(0, 0, '')\n        super().__init__(*args, **kwargs)\n\n        # we can't access the label attr until *after* the line is\n        # initiated\n        self.text.set_text(self.get_label())\n\n    def set_figure(self, figure):\n        self.text.set_figure(figure)\n        super().set_figure(figure)\n\n    # Override the axes property setter to set Axes on our children as well.\n    @lines.Line2D.axes.setter\n    def axes(self, new_axes):\n        self.text.axes = new_axes\n        lines.Line2D.axes.fset(self, new_axes)  # Call the superclass property setter.\n\n    def set_transform(self, transform):\n        # 2 pixel offset\n        texttrans = transform + mtransforms.Affine2D().translate(2, 2)\n        self.text.set_transform(texttrans)\n        super().set_transform(transform)\n\n    def set_data(self, x, y):\n        if len(x):\n            self.text.set_position((x[-1], y[-1]))\n\n        super().set_data(x, y)\n\n    def draw(self, renderer):\n        # draw my label at the end of the line with 2 pixel offset\n        super().draw(renderer)\n        self.text.draw(renderer)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nx, y = np.random.rand(2, 20)\nline = MyLine(x, y, mfc='red', ms=12, label='line label')\nline.text.set_color('red')\nline.text.set_fontsize(16)\n\nax.add_line(line)\n\nplt.show()\n",
    "id": 192
},
{
    "title": "Convert texts to images#",
    "text": "References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.figimage matplotlib.figure.Figure.text matplotlib.transforms.IdentityTransform matplotlib.image.imread Download Python source code: mathtext_asarray.py Download Jupyter notebook: mathtext_asarray.ipynb ",
    "code": "from io import BytesIO\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.transforms import IdentityTransform\n\n\ndef text_to_rgba(s, *, dpi, **kwargs):\n    # To convert a text string to an image, we can:\n    # - draw it on an empty and transparent figure;\n    # - save the figure to a temporary buffer using ``bbox_inches=\"tight\",\n    #   pad_inches=0`` which will pick the correct area to save;\n    # - load the buffer using ``plt.imread``.\n    #\n    # (If desired, one can also directly save the image to the filesystem.)\n    fig = Figure(facecolor=\"none\")\n    fig.text(0, 0, s, **kwargs)\n    with BytesIO() as buf:\n        fig.savefig(buf, dpi=dpi, format=\"png\", bbox_inches=\"tight\",\n                    pad_inches=0)\n        buf.seek(0)\n        rgba = plt.imread(buf)\n    return rgba\n\n\nfig = plt.figure()\nrgba1 = text_to_rgba(r\"IQ: $\\\\sigma_i=15$\", color=\"blue\", fontsize=20, dpi=200)\nrgba2 = text_to_rgba(r\"some other string\", color=\"red\", fontsize=20, dpi=200)\n# One can then draw such text images to a Figure using `.Figure.figimage`.\nfig.figimage(rgba1, 100, 50)\nfig.figimage(rgba2, 100, 150)\n\n# One can also directly draw texts to a figure with positioning\n# in pixel coordinates by using `.Figure.text` together with\n# `.transforms.IdentityTransform`.\nfig.text(100, 250, r\"IQ: $\\\\sigma_i=15$\", color=\"blue\", fontsize=20,\n         transform=IdentityTransform())\nfig.text(100, 350, r\"some other string\", color=\"red\", fontsize=20,\n         transform=IdentityTransform())\n\nplt.show()\n",
    "id": 193
},
{
    "title": "Mathtext#",
    "text": "Use Matplotlib's internal LaTeX parser and layout engine. For true LaTeX\nrendering, see the text.usetex option.\", 'Download Python source code: mathtext_demo.py Download Jupyter notebook: mathtext_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.plot([1, 2, 3], label=r'$\\\\sqrt{x^2}$')\nax.legend()\n\nax.set_xlabel(r'$\\\\Delta_i^j$', fontsize=20)\nax.set_ylabel(r'$\\\\Delta_{i+1}^j$', fontsize=20)\nax.set_title(r'$\\\\Delta_i^j \\\\hspace{0.4} \\\\mathrm{versus} \\\\hspace{0.4} '\n             r'\\\\Delta_{i+1}^j$', fontsize=20)\n\ntex = r'$\\\\mathcal{R}\\\\prod_{i=\\\\alpha_{i+1}}^\\\\infty a_i\\\\sin(2 \\\\pi f x_i)$'\nax.text(1, 1.6, tex, fontsize=20, va='bottom')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 194
},
{
    "title": "Mathtext Examples#",
    "text": "Selected features of Matplotlib's math rendering engine.\", 'Download Python source code: mathtext_examples.py Download Jupyter notebook: mathtext_examples.ipynb ",
    "code": "0 $W^{3\\\\beta}_{\\\\delta_1 \\\\rho_1 \\\\sigma_2} = U^{3\\\\beta}_{\\\\delta_1 \\\\rho_1} + \\\\frac{1}{8 \\\\pi 2} \\\\int^{\\\\alpha_2}_{\\\\alpha_2} d \\\\alpha^\\\\prime_2 \\\\left[\\\\frac{ U^{2\\\\beta}_{\\\\delta_1 \\\\rho_1} - \\\\alpha^\\\\prime_2U^{1\\\\beta}_{\\\\rho_1 \\\\sigma_2} }{U^{0\\\\beta}_{\\\\rho_1 \\\\sigma_2}}\\\\right]$\n1 $\\\\alpha_i > \\\\beta_i,\\\\ \\\\alpha_{i+1}^j = {\\\\rm sin}(2\\\\pi f_j t_i) e^{-5 t_i/\\\\tau},\\\\ \\\\ldots$\n2 $\\\\frac{3}{4},\\\\ \\\\binom{3}{4},\\\\ \\\\genfrac{}{}{0}{}{3}{4},\\\\ \\\\left(\\\\frac{5 - \\\\frac{1}{x}}{4}\\\\right),\\\\ \\\\ldots$\n3 $\\\\sqrt{2},\\\\ \\\\sqrt[3]{x},\\\\ \\\\ldots$\n4 $\\\\mathrm{Roman}\\\\ , \\\\ \\\\mathit{Italic}\\\\ , \\\\ \\\\mathtt{Typewriter} \\\\ \\\\mathrm{or}\\\\ \\\\mathcal{CALLIGRAPHY}$\n5 $\\\\acute a,\\\\ \\\\bar a,\\\\ \\\\breve a,\\\\ \\\\dot a,\\\\ \\\\ddot a, \\\\ \\\\grave a, \\\\ \\\\hat a,\\\\ \\\\tilde a,\\\\ \\\\vec a,\\\\ \\\\widehat{xyz},\\\\ \\\\widetilde{xyz},\\\\ \\\\ldots$\n6 $\\\\alpha,\\\\ \\\\beta,\\\\ \\\\chi,\\\\ \\\\delta,\\\\ \\\\lambda,\\\\ \\\\mu,\\\\ \\\\Delta,\\\\ \\\\Gamma,\\\\ \\\\Omega,\\\\ \\\\Phi,\\\\ \\\\Pi,\\\\ \\\\Upsilon,\\\\ \\\nabla,\\\\ \\\\aleph,\\\\ \\\\beth,\\\\ \\\\daleth,\\\\ \\\\gimel,\\\\ \\\\ldots$\n7 $\\\\coprod,\\\\ \\\\int,\\\\ \\\\oint,\\\\ \\\\prod,\\\\ \\\\sum,\\\\ \\\\log,\\\\ \\\\sin,\\\\ \\\\approx,\\\\ \\\\oplus,\\\\ \\\\star,\\\\ \\\\varpropto,\\\\ \\\\infty,\\\\ \\\\partial,\\\\ \\\\Re,\\\\ \\\\leftrightsquigarrow, \\\\ \\\\ldots$\n import re\nimport subprocess\nimport sys\n\nimport matplotlib.pyplot as plt\n\n# Selection of features following \"Writing mathematical expressions\" tutorial,\n# with randomly picked examples.\nmathtext_demos = {\n    \"Header demo\":\n        r\"$W^{3\\\\beta}_{\\\\delta_1 \\\\rho_1 \\\\sigma_2} = \"\n        r\"U^{3\\\\beta}_{\\\\delta_1 \\\\rho_1} + \\\\frac{1}{8 \\\\pi 2} \"\n        r\"\\\\int^{\\\\alpha_2}_{\\\\alpha_2} d \\\\alpha^\\\\prime_2 \\\\left[\\\\frac{ \"\n        r\"U^{2\\\\beta}_{\\\\delta_1 \\\\rho_1} - \\\\alpha^\\\\prime_2U^{1\\\\beta}_\"\n        r\"{\\\\rho_1 \\\\sigma_2} }{U^{0\\\\beta}_{\\\\rho_1 \\\\sigma_2}}\\\\right]$\",\n\n    \"Subscripts and superscripts\":\n        r\"$\\\\alpha_i > \\\\beta_i,\\\\ \"\n        r\"\\\\alpha_{i+1}^j = {\\\\rm sin}(2\\\\pi f_j t_i) e^{-5 t_i/\\\\tau},\\\\ \"\n        r\"\\\\ldots$\",\n\n    \"Fractions, binomials and stacked numbers\":\n        r\"$\\\\frac{3}{4},\\\\ \\\\binom{3}{4},\\\\ \\\\genfrac{}{}{0}{}{3}{4},\\\\ \"\n        r\"\\\\left(\\\\frac{5 - \\\\frac{1}{x}}{4}\\\\right),\\\\ \\\\ldots$\",\n\n    \"Radicals\":\n        r\"$\\\\sqrt{2},\\\\ \\\\sqrt[3]{x},\\\\ \\\\ldots$\",\n\n    \"Fonts\":\n        r\"$\\\\mathrm{Roman}\\\\ , \\\\ \\\\mathit{Italic}\\\\ , \\\\ \\\\mathtt{Typewriter} \\\\ \"\n        r\"\\\\mathrm{or}\\\\ \\\\mathcal{CALLIGRAPHY}$\",\n\n    \"Accents\":\n        r\"$\\\\acute a,\\\\ \\\\bar a,\\\\ \\\\breve a,\\\\ \\\\dot a,\\\\ \\\\ddot a, \\\\ \\\\grave a, \\\\ \"\n        r\"\\\\hat a,\\\\ \\\\tilde a,\\\\ \\\\vec a,\\\\ \\\\widehat{xyz},\\\\ \\\\widetilde{xyz},\\\\ \"\n        r\"\\\\ldots$\",\n\n    \"Greek, Hebrew\":\n        r\"$\\\\alpha,\\\\ \\\\beta,\\\\ \\\\chi,\\\\ \\\\delta,\\\\ \\\\lambda,\\\\ \\\\mu,\\\\ \"\n        r\"\\\\Delta,\\\\ \\\\Gamma,\\\\ \\\\Omega,\\\\ \\\\Phi,\\\\ \\\\Pi,\\\\ \\\\Upsilon,\\\\ \\\nabla,\\\\ \"\n        r\"\\\\aleph,\\\\ \\\\beth,\\\\ \\\\daleth,\\\\ \\\\gimel,\\\\ \\\\ldots$\",\n\n    \"Delimiters, functions and Symbols\":\n        r\"$\\\\coprod,\\\\ \\\\int,\\\\ \\\\oint,\\\\ \\\\prod,\\\\ \\\\sum,\\\\ \"\n        r\"\\\\log,\\\\ \\\\sin,\\\\ \\\\approx,\\\\ \\\\oplus,\\\\ \\\\star,\\\\ \\\\varpropto,\\\\ \"\n        r\"\\\\infty,\\\\ \\\\partial,\\\\ \\\\Re,\\\\ \\\\leftrightsquigarrow, \\\\ \\\\ldots$\",\n}\nn_lines = len(mathtext_demos)\n\n\ndef doall():\n    # Colors used in Matplotlib online documentation.\n    mpl_grey_rgb = (51 / 255, 51 / 255, 51 / 255)\n\n    # Creating figure and axis.\n    fig = plt.figure(figsize=(7, 7))\n    ax = fig.add_axes([0.01, 0.01, 0.98, 0.90],\n                      facecolor=\"white\", frameon=True)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_title(\"Matplotlib\\'s math rendering engine\",\n                 color=mpl_grey_rgb, fontsize=14, weight=\\'bold\\')\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Gap between lines in axes coords\n    line_axesfrac = 1 / n_lines\n\n    # Plot header demonstration formula.\n    full_demo = mathtext_demos[\\'Header demo\\\n    ax.annotate(full_demo,\n                xy=(0.5, 1. - 0.59 * line_axesfrac),\n                color=\\'tab:orange\\', ha=\\'center\\', fontsize=20)\n\n    # Plot feature demonstration formulae.\n    for i_line, (title, demo) in enumerate(mathtext_demos.items()):\n        print(i_line, demo)\n        if i_line == 0:\n            continue\n\n        baseline = 1 - i_line * line_axesfrac\n        baseline_next = baseline - line_axesfrac\n        fill_color = [\\'white\\', \\'tab:blue\\[i_line % 2]\n        ax.axhspan(baseline, baseline_next, color=fill_color, alpha=0.2)\n        ax.annotate(f\\'{title}:\\',\n                    xy=(0.06, baseline - 0.3 * line_axesfrac),\n                    color=mpl_grey_rgb, weight=\\'bold\\')\n        ax.annotate(demo,\n                    xy=(0.04, baseline - 0.75 * line_axesfrac),\n                    color=mpl_grey_rgb, fontsize=16)\n\n    plt.show()\n\n\nif \\'--latex\\' in sys.argv:\n    # Run: python mathtext_examples.py --latex\n    # Need amsmath and amssymb packages.\n    with open(\"mathtext_examples.ltx\", \"w\") as fd:\n        fd.write(\"\\\\\\\\documentclass{article}\\\n\")\n        fd.write(\"\\\\\\\\usepackage{amsmath, amssymb}\\\n\")\n        fd.write(\"\\\\\\\\begin{document}\\\n\")\n        fd.write(\"\\\\\\\\begin{enumerate}\\\n\")\n\n        for s in mathtext_demos.values():\n            s = re.sub(r\"(?<!\\\\\\\\)\\\\$\", \"$$\", s)\n            fd.write(\"\\\\\\\\item %s\\\n\" % s)\n\n        fd.write(\"\\\\\\\\end{enumerate}\\\n\")\n        fd.write(\"\\\\\\\\end{document}\\\n\")\n\n    subprocess.call(pdflatex\", \"mathtext_examples.ltx)\nelse:\n    doall()\n",
    "id": 195
},
{
    "title": "Math fontfamily#",
    "text": "A simple example showcasing the new math_fontfamily parameter that can\nbe used to change the family of fonts for each individual text\nelement in a plot. If no parameter is set, the global value\nrcParamsmathtext.fontset (default: \\'dejavusans\\') will be used. Download Python source code: mathtext_fontfamily_example.py Download Jupyter notebook: mathtext_fontfamily_example.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# A simple plot for the background.\nax.plot(range(11), color=\"0.9\")\n\n# A text mixing normal text and math text.\nmsg = (r\"Normal Text. $Text\\\\ in\\\\ math\\\\ mode:\\\\ \"\n       r\"\\\\int_{0}^{\\\\infty } x^2 dx$\")\n\n# Set the text in the plot.\nax.text(1, 7, msg, size=12, math_fontfamily=\\'cm\\')\n\n# Set another font for the next text.\nax.text(1, 3, msg, size=12, math_fontfamily=\\'dejavuserif\\')\n\n# *math_fontfamily* can be used in most places where there is text,\n# like in the title:\nax.set_title(r\"$Title\\\\ in\\\\ math\\\\ mode:\\\\ \\\\int_{0}^{\\\\infty } x^2 dx$\",\n             math_fontfamily=\\'stixsans\\', size=14)\n\n# Note that the normal text is not changed by *math_fontfamily*.\nplt.show()\n",
    "id": 196
},
{
    "title": "Multiline#",
    "text": "Download Python source code: multiline.py Download Jupyter notebook: multiline.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(7, 4))\n\nax0.set_aspect(1)\nax0.plot(np.arange(10))\nax0.set_xlabel(\\'this is a xlabel\\\n(with newlines!)\\')\nax0.set_ylabel(\\'this is vertical\\\ntest\\', multialignment=\\'center\\')\nax0.text(2, 7, \\'this is\\\nyet another test\\',\n         rotation=45,\n         horizontalalignment=\\'center\\',\n         verticalalignment=\\'top\\',\n         multialignment=\\'center\\')\n\nax0.grid()\n\n\nax1.text(0.29, 0.4, \"Mat\\\nTTp\\\n123\", size=18,\n         va=\"baseline\", ha=\"right\", multialignment=\"left\",\n         bbox=dict(fc=\"none\"))\n\nax1.text(0.34, 0.4, \"Mag\\\nTTT\\\n123\", size=18,\n         va=\"baseline\", ha=\"left\", multialignment=\"left\",\n         bbox=dict(fc=\"none\"))\n\nax1.text(0.95, 0.4, \"Mag\\\nTTT$^{A^A}$\\\n123\", size=18,\n         va=\"baseline\", ha=\"right\", multialignment=\"left\",\n         bbox=dict(fc=\"none\"))\n\nax1.set_xticks([0.2, 0.4, 0.6, 0.8, 1.],\n               labels=Jan\\\n2009\", \"Feb\\\n2009\", \"Mar\\\n2009\", \"Apr\\\n2009\",\n                       \"May\\\n2009)\n\nax1.axhline(0.4)\nax1.set_title(\"test line spacing for multiline text\")\n\nfig.subplots_adjust(bottom=0.25, top=0.75)\nplt.show()\n",
    "id": 197
},
{
    "title": "Placing text boxes#",
    "text": "When decorating axes with text boxes, two useful tricks are to place the text\nin axes coordinates (see Transformations Tutorial),\nso the text doesn't move around with changes in x or y limits. You\ncan also use the bbox property of text to surround the text with a\nPatch instance -- the bbox keyword argument takes a\ndictionary with keys that are Patch properties.\", 'Download Python source code: placing_text_boxes.py Download Jupyter notebook: placing_text_boxes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nx = 30*np.random.randn(10000)\nmu = x.mean()\nmedian = np.median(x)\nsigma = x.std()\ntextstr = '\\\n'.join((\n    r'$\\\\mu=%.2f$' % (mu, ),\n    r'$\\\\mathrm{median}=%.2f$' % (median, ),\n    r'$\\\\sigma=%.2f$' % (sigma, )))\n\nax.hist(x, 50)\n# these are matplotlib.patch.Patch properties\nprops = dict(boxstyle='round', facecolor='wheat', alpha=0.5)\n\n# place a text box in upper left in axes coords\nax.text(0.05, 0.95, textstr, transform=ax.transAxes, fontsize=14,\n        verticalalignment='top', bbox=props)\n\nplt.show()\n",
    "id": 198
},
{
    "title": "Concatenating text objects with different properties#",
    "text": "The example strings together several Text objects with different properties\n(e.g., color or font), positioning each one after the other. The first Text\nis created directly using text; all subsequent ones are created with\nannotate, which allows positioning the Text's lower left corner at the\nlower right corner (xy=(1, 0)) of the previous one (xycoords=text).\", 'Download Python source code: rainbow_text.py Download Jupyter notebook: rainbow_text.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nplt.rcParamsfont.size = 20\nax = plt.figure().add_subplot(xticks=[], yticks=[])\n\n# The first word, created with text().\ntext = ax.text(.1, .5, \"Matplotlib\", color=\"red\")\n# Subsequent words, positioned with annotate(), relative to the preceding one.\ntext = ax.annotate(\n    \" says,\", xycoords=text, xy=(1, 0), verticalalignment=\"bottom\",\n    color=\"gold\", weight=\"bold\")  # custom properties\ntext = ax.annotate(\n    \" hello\", xycoords=text, xy=(1, 0), verticalalignment=\"bottom\",\n    color=\"green\", style=\"italic\")  # custom properties\ntext = ax.annotate(\n    \" world!\", xycoords=text, xy=(1, 0), verticalalignment=\"bottom\",\n    color=\"blue\", family=\"serif\")  # custom properties\n\nplt.show()\n",
    "id": 199
},
{
    "title": "STIX Fonts#",
    "text": "Demonstration of STIX Fonts used in LaTeX\nrendering. Download Python source code: stix_fonts_demo.py Download Jupyter notebook: stix_fonts_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\ncircle123 = \"\\\\N{CIRCLED DIGIT ONE}\\\\N{CIRCLED DIGIT TWO}\\\\N{CIRCLED DIGIT THREE}\"\n\ntests = [\n    r\\'$%s\\\\;\\\\mathrm{%s}\\\\;\\\\mathbf{%s}$\\' % ((circle123,) * 3),\n    r\\'$\\\\mathsf{Sans \\\\Omega}\\\\;\\\\mathrm{\\\\mathsf{Sans \\\\Omega}}\\\\;\\'\n    r\\'\\\\mathbf{\\\\mathsf{Sans \\\\Omega}}$\\',\n    r\\'$\\\\mathtt{Monospace}$\\',\n    r\\'$\\\\mathcal{CALLIGRAPHIC}$\\',\n    r\\'$\\\\mathbb{Blackboard\\\\;\\\\pi}$\\',\n    r\\'$\\\\mathrm{\\\\mathbb{Blackboard\\\\;\\\\pi}}$\\',\n    r\\'$\\\\mathbf{\\\\mathbb{Blackboard\\\\;\\\\pi}}$\\',\n    r\\'$\\\\mathfrak{Fraktur}\\\\;\\\\mathbf{\\\\mathfrak{Fraktur}}$\\',\n    r\\'$\\\\mathscr{Script}$\\',\n]\n\nfig = plt.figure(figsize=(8, len(tests) + 2))\nfor i, s in enumerate(tests[::-1]):\n    fig.text(0, (i + .5) / len(tests), s, fontsize=32)\n\nplt.show()\n",
    "id": 200
},
{
    "title": "Rendering math equations using TeX#",
    "text": "You can use TeX to render all of your Matplotlib text by setting\nrcParamstext.usetex (default: False) to True. This requires that you have TeX and the other\ndependencies described in the Text rendering with LaTeX tutorial properly\ninstalled on your system. Matplotlib caches processed TeX expressions, so that\nonly the first occurrence of an expression triggers a TeX compilation. Later\noccurrences reuse the rendered image from the cache and are thus faster. Unicode input is supported, e.g. for the y-axis label in this example. A more complex example. Download Python source code: tex_demo.py Download Jupyter notebook: tex_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParamstext.usetex = True\n\n\nt = np.linspace(0.0, 1.0, 100)\ns = np.cos(4 * np.pi * t) + 2\n\nfig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)\nax.plot(t, s)\n\nax.set_xlabel(r'\\\\textbf{time (s)}')\nax.set_ylabel('\\\\\\\\textit{Velocity (\\\\N{DEGREE SIGN}/sec)}', fontsize=16)\nax.set_title(r'\\\\TeX\\\\ is Number $\\\\displaystyle\\\\sum_{n=1}^\\\\infty'\n             r'\\\\frac{-e^{i\\\\pi}}{2^n}$!', fontsize=16, color='r')\n\", 'fig, ax = plt.subplots()\n# interface tracking profiles\nN = 500\ndelta = 0.6\nX = np.linspace(-1, 1, N)\nax.plot(X, (1 - np.tanh(4 * X / delta)) / 2,    # phase field tanh profiles\n        X, (1.4 + np.tanh(4 * X / delta)) / 4, \"C2\",  # composition profile\n        X, X < 0, \"k--\")                        # sharp interface\n\n# legend\nax.legend((\"phase field\", \"level set\", \"sharp interface\"),\n          shadow=True, loc=(0.01, 0.48), handlelength=1.5, fontsize=16)\n\n# the arrow\nax.annotate(\"\", xy=(-delta / 2., 0.1), xytext=(delta / 2., 0.1),\n            arrowprops=dict(arrowstyle=\"<->\", connectionstyle=\"arc3\"))\nax.text(0, 0.1, r\"$\\\\delta$\",\n        color=\"black\", fontsize=24,\n        horizontalalignment=\"center\", verticalalignment=\"center\",\n        bbox=dict(boxstyle=\"round\", fc=\"white\", ec=\"black\", pad=0.2))\n\n# Use tex in labels\nax.set_xticks([-1, 0, 1])\nax.set_xticklabels($-1$\", r\"$\\\\pm 0$\", \"$+1$, color=\"k\", size=20)\n\n# Left Y-axis labels, combine math mode and text mode\nax.set_ylabel(r\"\\\\bf{phase field} $\\\\phi$\", color=\"C0\", fontsize=20)\nax.set_yticks([0, 0.5, 1])\nax.set_yticklabels([r\"\\\\bf{0}\", r\"\\\\bf{.5}\", r\"\\\\bf{1}, color=\"k\", size=20)\n\n# Right Y-axis labels\nax.text(1.02, 0.5, r\"\\\\bf{level set} $\\\\phi$\",\n        color=\"C2\", fontsize=20, rotation=90,\n        horizontalalignment=\"left\", verticalalignment=\"center\",\n        clip_on=False, transform=ax.transAxes)\n\n# Use multiline environment inside a `text`.\n# level set equations\neq1 = (r\"\\\\begin{eqnarray*}\"\n       r\"|\\\nabla\\\\phi| &=& 1,\\\\\\\\\"\n       r\"\\\\frac{\\\\partial \\\\phi}{\\\\partial t} + U|\\\nabla \\\\phi| &=& 0 \"\n       r\"\\\\end{eqnarray*}\")\nax.text(1, 0.9, eq1, color=\"C2\", fontsize=18,\n        horizontalalignment=\"right\", verticalalignment=\"top\")\n\n# phase field equations\neq2 = (r\"\\\\begin{eqnarray*}\"\n       r\"\\\\mathcal{F} &=& \\\\int f\\\\left( \\\\phi, c \\\\right) dV, \\\\\\\\ \"\n       r\"\\\\frac{ \\\\partial \\\\phi } { \\\\partial t } &=& -M_{ \\\\phi } \"\n       r\"\\\\frac{ \\\\delta \\\\mathcal{F} } { \\\\delta \\\\phi }\"\n       r\"\\\\end{eqnarray*}\")\nax.text(0.18, 0.18, eq2, color=\"C0\", fontsize=16)\n\nax.text(-1, .30, r\"gamma: $\\\\gamma$\", color=\"r\", fontsize=20)\nax.text(-1, .18, r\"Omega: $\\\\Omega$\", color=\"b\", fontsize=20)\n\nplt.show()\n",
    "id": 201
},
{
    "title": "Text alignment#",
    "text": "Texts are aligned relative to their anchor point depending on the properties\nhorizontalalignment and verticalalignment. (Source code, 2x.png, png) The following plot uses this to align text relative to a plotted rectangle. Download Python source code: text_alignment.py Download Jupyter notebook: text_alignment.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\n# Build a rectangle in axes coords\nleft, width = .25, .5\nbottom, height = .25, .5\nright = left + width\ntop = bottom + height\np = plt.Rectangle((left, bottom), width, height, fill=False)\np.set_transform(ax.transAxes)\np.set_clip_on(False)\nax.add_patch(p)\n\nax.text(left, bottom, 'left top',\n        horizontalalignment='left',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, bottom, 'left bottom',\n        horizontalalignment='left',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right bottom',\n        horizontalalignment='right',\n        verticalalignment='bottom',\n        transform=ax.transAxes)\n\nax.text(right, top, 'right top',\n        horizontalalignment='right',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(right, bottom, 'center top',\n        horizontalalignment='center',\n        verticalalignment='top',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'right center',\n        horizontalalignment='right',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, 0.5 * (bottom + top), 'left center',\n        horizontalalignment='left',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(0.5 * (left + right), 0.5 * (bottom + top), 'middle',\n        horizontalalignment='center',\n        verticalalignment='center',\n        transform=ax.transAxes)\n\nax.text(right, 0.5 * (bottom + top), 'centered',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation='vertical',\n        transform=ax.transAxes)\n\nax.text(left, top, 'rotated\\\nwith newlines',\n        horizontalalignment='center',\n        verticalalignment='center',\n        rotation=45,\n        transform=ax.transAxes)\n\nax.set_axis_off()\n\nplt.show()\n",
    "id": 202
},
{
    "title": "Text Commands#",
    "text": "Plotting text of many different kinds. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.suptitle matplotlib.figure.Figure.add_subplot matplotlib.figure.Figure.subplots_adjust matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_xlabel matplotlib.axes.Axes.set_ylabel matplotlib.axes.Axes.text matplotlib.axes.Axes.annotate Download Python source code: text_commands.py Download Jupyter notebook: text_commands.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\nfig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')\n\nax = fig.add_subplot()\nfig.subplots_adjust(top=0.85)\nax.set_title('axes title')\n\nax.set_xlabel('xlabel')\nax.set_ylabel('ylabel')\n\nax.text(3, 8, 'boxed italics text in data coords', style='italic',\n        bbox={'facecolor': 'red alpha': 0.5, 'pad': 10})\n\nax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)\n\nax.text(3, 2, 'Unicode: Institut f\\\\374r Festk\\\\366rperphysik')\n\nax.text(0.95, 0.01, 'colored text in axes coords',\n        verticalalignment='bottom', horizontalalignment='right',\n        transform=ax.transAxes,\n        color='green', fontsize=15)\n\n\nax.plot([2], [1], 'o')\nax.annotate('annotate', xy=(2, 1), xytext=(3, 4),\n            arrowprops=dict(facecolor='black', shrink=0.05))\n\nax.set(xlim=(0, 10), ylim=(0, 10))\n\nplt.show()\n",
    "id": 203
},
{
    "title": "Controlling style of text and labels using a dictionary#",
    "text": "This example shows how to share parameters across many text objects and labels\nby creating a dictionary of options passed across several functions. Download Python source code: text_fontdict.py Download Jupyter notebook: text_fontdict.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfont = {'family': 'serif',\n        'color':  'darkred',\n        'weight': 'normal',\n        'size': 16,\n        }\n\nx = np.linspace(0.0, 5.0, 100)\ny = np.cos(2*np.pi*x) * np.exp(-x)\n\nplt.plot(x, y, 'k')\nplt.title('Damped exponential decay', fontdict=font)\nplt.text(2, 0.65, r'$\\\\cos(2 \\\\pi t) \\\\exp(-t)$', fontdict=font)\nplt.xlabel('time (s)', fontdict=font)\nplt.ylabel('voltage (mV)', fontdict=font)\n\n# Tweak spacing to prevent clipping of ylabel\nplt.subplots_adjust(left=0.15)\nplt.show()\n",
    "id": 204
},
{
    "title": "Text Rotation Relative To Line#",
    "text": "Text objects in matplotlib are normally rotated with respect to the\nscreen coordinate system (i.e., 45 degrees rotation plots text along a\nline that is in between horizontal and vertical no matter how the axes\nare changed). However, at times one wants to rotate text with respect\nto something on the plot. In this case, the correct angle won't be\nthe angle of that object in the plot coordinate system, but the angle\nthat that object APPEARS in the screen coordinate system. This angle\ncan be determined automatically by setting the parameter\ntransform_rotates_text, as shown in the example below.\", 'Download Python source code: text_rotation_relative_to_line.py Download Jupyter notebook: text_rotation_relative_to_line.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\n# Plot diagonal line (45 degrees)\nh = ax.plot(range(0, 10), range(0, 10))\n\n# set limits so that it no longer looks on screen to be 45 degrees\nax.set_xlim([-10, 20])\n\n# Locations to plot text\nl1 = np.array((1, 1))\nl2 = np.array((5, 5))\n\n# Rotate angle\nangle = 45\n\n# Plot text\nth1 = ax.text(*l1, 'text not rotated correctly', fontsize=16,\n              rotation=angle, rotation_mode='anchor')\nth2 = ax.text(*l2, 'text rotated correctly', fontsize=16,\n              rotation=angle, rotation_mode='anchor',\n              transform_rotates_text=True)\n\nplt.show()\n",
    "id": 205
},
{
    "title": "Title positioning#",
    "text": "Matplotlib can display plot titles centered, flush with the left side of\na set of axes, and flush with the right side of a set of axes. The vertical position is automatically chosen to avoid decorations\n(i.e. labels and ticks) on the topmost x-axis: Automatic positioning can be turned off by manually specifying the y\nkeyword argument for the title or setting rcParamsaxes.titley (default: None) in the rcParams. Total running time of the script: (0 minutes 1.282 seconds) Download Python source code: titles_demo.py Download Jupyter notebook: titles_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nplt.plot(range(10))\n\nplt.title('Center Title')\nplt.title('Left Title', loc='left')\nplt.title('Right Title', loc='right')\n\nplt.show()\n\", \"fig, axs = plt.subplots(1, 2, layout='constrained')\n\nax = axs[0]\nax.plot(range(10))\nax.xaxis.set_label_position('top')\nax.set_xlabel('X-label')\nax.set_title('Center Title')\n\nax = axs[1]\nax.plot(range(10))\nax.xaxis.set_label_position('top')\nax.xaxis.tick_top()\nax.set_xlabel('X-label')\nax.set_title('Center Title')\nplt.show()\n\", \"fig, axs = plt.subplots(1, 2, layout='constrained')\n\nax = axs[0]\nax.plot(range(10))\nax.xaxis.set_label_position('top')\nax.set_xlabel('X-label')\nax.set_title('Manual y', y=1.0, pad=-14)\n\nplt.rcParamsaxes.titley = 1.0    # y is in axes-relative coordinates.\nplt.rcParamsaxes.titlepad = -14  # pad is in points...\nax = axs[1]\nax.plot(range(10))\nax.set_xlabel('X-label')\nax.set_title('rcParam y')\n\nplt.show()\n",
    "id": 206
},
{
    "title": "Unicode minus#",
    "text": "By default, tick labels at negative values are rendered using a Unicode\nminus (U+2212) rather than an ASCII hyphen (U+002D). This can be controlled\nby setting rcParamsaxes.unicode_minus (default: True). The replacement is performed at draw time of the tick labels (usually during a\npyplot.show() or pyplot.savefig() call). Therefore, all tick labels of\nthe figure follow the same setting and we cannot demonstrate both glyphs on\nreal tick labels of the same figure simultaneously. Instead, this example simply showcases the difference between the two glyphs\nin a magnified font. Download Python source code: unicode_minus.py Download Jupyter notebook: unicode_minus.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(4, 2))\nfig.text(.15, .6, \"Unicode minus:\", fontsize=20)\nfig.text(.85, .6, \"\\\\N{MINUS SIGN}1\", ha=\\'right\\', fontsize=20)\nfig.text(.15, .3, \"ASCII hyphen:\", fontsize=20)\nfig.text(.85, .3, \"-1\", ha=\\'right\\', fontsize=20)\nplt.show()\n",
    "id": 207
},
{
    "title": "Usetex Baseline Test#",
    "text": "Comparison of text baselines computed for mathtext and usetex. Download Python source code: usetex_baseline_test.py Download Jupyter notebook: usetex_baseline_test.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nplt.rcParams.update({\"mathtext.fontset\": \"cm\", \"mathtext.rm\": \"serif\"})\naxs = plt.figure(figsize=(2 * 3, 6.5)).subplots(1, 2)\nfor ax, usetex in zip(axs, [False, True]):\n    ax.axvline(0, color=\"r\")\n    test_strings = lg\", r\"$\\\\frac{1}{2}\\\\pi$\", r\"$p^{3^A}$\", r\"$p_{3_2}$\n    for i, s in enumerate(test_strings):\n        ax.axhline(i, color=\"r\")\n        ax.text(0., 3 - i, s,\n                usetex=usetex,\n                verticalalignment=\"baseline\",\n                size=50,\n                bbox=dict(pad=0, ec=\"k\", fc=\"none\"))\n    ax.set(xlim=(-0.1, 1.1), ylim=(-.8, 3.9), xticks=[], yticks=[],\n           title=f\"usetex={usetex}\\\n\")\nplt.show()\n",
    "id": 208
},
{
    "title": "Usetex Fonteffects#",
    "text": "This script demonstrates that font effects specified in your pdftex.map\nare now supported in usetex mode. Download Python source code: usetex_fonteffects.py Download Jupyter notebook: usetex_fonteffects.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef setfont(font):\n    return rf'\\\\font\\\\a {font} at 14pt\\\\a '\n\n\nfig = plt.figure()\nfor y, font, text in zip(\n    range(5),\n    ptmr8r ptmri8r ptmro8r ptmr8rn ptmrr8re,\n    [f'Nimbus Roman No9 L {x}'\n     for x in  Italics (real italics for comparison)',\n               '(slanted) (condensed) (extended)],\n):\n    fig.text(.1, 1 - (y + 1) / 6, setfont(font) + text, usetex=True)\n\nfig.suptitle('Usetex font effects')\n# Would also work if saving to pdf.\nplt.show()\n",
    "id": 209
},
{
    "title": "Text watermark#",
    "text": "A watermark effect can be achieved by drawing a semi-transparent text. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure.text Download Python source code: watermark_text.py Download Jupyter notebook: watermark_text.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nax.plot(np.random.rand(20), '-o', ms=20, lw=2, alpha=0.7, mfc='orange')\nax.grid()\n\nax.text(0.5, 0.5, 'created with matplotlib', transform=ax.transAxes,\n        fontsize=40, color='gray', alpha=0.5,\n        ha='center', va='center', rotation=30)\n\nplt.show()\n",
    "id": 210
},
{
    "title": "Color Demo#",
    "text": "Matplotlib recognizes the following formats to specify a color: an RGB or RGBA tuple of float values in [0, 1] (e.g. (0.1, 0.2, 0.5)\nor (0.1, 0.2, 0.5, 0.3)). RGBA is short for Red, Green, Blue, Alpha;', \"a hex RGB or RGBA string (e.g., '#0F0F0F' or '#0F0F0F0F');\", \"a shorthand hex RGB or RGBA string, equivalent to the hex RGB or RGBA\nstring obtained by duplicating each character, (e.g., '#abc', equivalent\nto '#aabbcc', or '#abcd', equivalent to '#aabbccdd');\", \"a string representation of a float value in [0, 1] inclusive for gray\nlevel (e.g., '0.5');\", \"a single letter string, i.e. one of\n{'b g r c m y k w'}, which are short-hand notations\nfor shades of blue, green, red, cyan, magenta, yellow, black, and white;\", 'a X11/CSS4 (\"html\") color name, e.g. \"blue\";', \"a name from the xkcd color survey,\nprefixed with 'xkcd:' (e.g., 'xkcd:sky blue');\", 'a \"Cn\" color spec, i.e. \\'C\\' followed by a number, which is an index into\nthe default property cycle (rcParamsaxes.prop_cycle (default: cycler(\\'color\\', [\\'#1f77b4\\', \\'#ff7f0e\\', \\'#2ca02c\\', \\'#d62728\\', \\'#9467bd\\', \\'#8c564b\\', \\'#e377c2\\', \\'#7f7f7f\\', \\'#bcbd22\\', \\'#17becf\\))); the indexing is intended\nto occur at rendering time, and defaults to black if the cycle does not\ninclude color.', \"one of {'tab:blue tab:orange tab:green tab:red tab:purple',\n'tab:brown tab:pink tab:gray tab:olive tab:cyan'} which are\nthe Tableau Colors from the 'tab10' categorical palette (which is the\ndefault color cycle);\", 'For more information on colors in matplotlib see the Specifying colors tutorial; the matplotlib.colors API; the List of named colors example. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors matplotlib.axes.Axes.plot matplotlib.axes.Axes.set_facecolor matplotlib.axes.Axes.set_title matplotlib.axes.Axes.set_xlabel matplotlib.axes.Axes.set_ylabel matplotlib.axes.Axes.tick_params Download Python source code: color_demo.py Download Jupyter notebook: color_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0.0, 2.0, 201)\ns = np.sin(2 * np.pi * t)\n\n# 1) RGB tuple:\nfig, ax = plt.subplots(facecolor=(.18, .31, .31))\n# 2) hex string:\nax.set_facecolor('#eafff5')\n# 3) gray level string:\nax.set_title('Voltage vs. time chart', color='0.7')\n# 4) single letter color string\nax.set_xlabel('Time [s]', color='c')\n# 5) a named color:\nax.set_ylabel('Voltage [mV]', color='peachpuff')\n# 6) a named xkcd color:\nax.plot(t, s, 'xkcd:crimson')\n# 7) Cn notation:\nax.plot(t, .7*s, color='C4', linestyle='--')\n# 8) tab notation:\nax.tick_params(labelcolor='tab:orange')\n\n\nplt.show()\n",
    "id": 212
},
{
    "title": "Color by y-value#",
    "text": "Use masked arrays to plot a line with different colors by y-value. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot Download Python source code: color_by_yvalue.py Download Jupyter notebook: color_by_yvalue.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2 * np.pi * t)\n\nupper = 0.77\nlower = -0.77\n\nsupper = np.ma.masked_where(s < upper, s)\nslower = np.ma.masked_where(s > lower, s)\nsmiddle = np.ma.masked_where((s < lower) | (s > upper), s)\n\nfig, ax = plt.subplots()\nax.plot(t, smiddle, t, slower, t, supper)\nplt.show()\n",
    "id": 213
},
{
    "title": "Colors in the default property cycle#",
    "text": "Display the colors from the default prop_cycle, which is obtained from the\nrc parameters. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.axhline / matplotlib.pyplot.axhline matplotlib.axes.Axes.axvline / matplotlib.pyplot.axvline matplotlib.axes.Axes.set_facecolor matplotlib.figure.Figure.suptitle Download Python source code: color_cycle_default.py Download Jupyter notebook: color_cycle_default.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nprop_cycle = plt.rcParamsaxes.prop_cycle\ncolors = prop_cycle.by_key()color\n\nlwbase = plt.rcParamslines.linewidth\nthin = lwbase / 2\nthick = lwbase * 3\n\nfig, axs = plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True)\nfor icol in range(2):\n    if icol == 0:\n        lwx, lwy = thin, lwbase\n    else:\n        lwx, lwy = lwbase, thick\n    for irow in range(2):\n        for i, color in enumerate(colors):\n            axs[irow, icol].axhline(i, color=color, lw=lwx)\n            axs[irow, icol].axvline(i, color=color, lw=lwy)\n\n    axs[1, icol].set_facecolor('k')\n    axs[1, icol].xaxis.set_ticks(np.arange(0, 10, 2))\n    axs[0, icol].set_title(f'line widths (pts): {lwx:g}, {lwy:g}',\n                           fontsize='medium')\n\nfor irow in range(2):\n    axs[irow, 0].yaxis.set_ticks(np.arange(0, 10, 2))\n\nfig.suptitle('Colors in the default prop_cycle', fontsize='large')\n\nplt.show()\n",
    "id": 214
},
{
    "title": "Colorbar#",
    "text": "Use colorbar by specifying the mappable object (here\nthe AxesImage returned by imshow)\nand the axes to attach the colorbar to. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colorbar.Colorbar.minorticks_on matplotlib.colorbar.Colorbar.minorticks_off Download Python source code: colorbar_basics.py Download Jupyter notebook: colorbar_basics.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# setup some generic data\nN = 37\nx, y = np.mgrid[:N, :N]\nZ = (np.cos(x*0.2) + np.sin(y*0.3))\n\n# mask out the negative and positive values, respectively\nZpos = np.ma.masked_less(Z, 0)\nZneg = np.ma.masked_greater(Z, 0)\n\nfig, (ax1, ax2, ax3) = plt.subplots(figsize=(13, 3), ncols=3)\n\n# plot just the positive data and save the\n# color \"mappable\" object returned by ax1.imshow\npos = ax1.imshow(Zpos, cmap=\\'Blues\\', interpolation=\\'none\\')\n\n# add the colorbar using the figure\\'s method,\n# telling which mappable we\\'re talking about and\n# which axes object it should be near\nfig.colorbar(pos, ax=ax1)\n\n# repeat everything above for the negative data\n# you can specify location, anchor and shrink the colorbar\nneg = ax2.imshow(Zneg, cmap=\\'Reds_r\\', interpolation=\\'none\\')\nfig.colorbar(neg, ax=ax2, location=\\'right\\', anchor=(0, 0.3), shrink=0.7)\n\n# Plot both positive and negative values between +/- 1.2\npos_neg_clipped = ax3.imshow(Z, cmap=\\'RdBu\\', vmin=-1.2, vmax=1.2,\n                             interpolation=\\'none\\')\n# Add minorticks on the colorbar to make it easy to read the\n# values off the colorbar.\ncbar = fig.colorbar(pos_neg_clipped, ax=ax3, extend=\\'both\\')\ncbar.minorticks_on()\nplt.show()\n",
    "id": 215
},
{
    "title": "Colormap reference#",
    "text": "Reference for colormaps included with Matplotlib. A reversed version of each of these colormaps is available by appending\n_r to the name, as shown in Reversed colormaps. See Choosing Colormaps in Matplotlib for an in-depth discussion about\ncolormaps, including colorblind-friendliness, and\nCreating Colormaps in Matplotlib for a guide to creating\ncolormaps. Append _r to the name of any built-in colormap to get the reversed\nversion: The built-in reversed colormaps are generated using Colormap.reversed.\nFor an example, see Reversing a colormap References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors matplotlib.axes.Axes.imshow matplotlib.figure.Figure.text matplotlib.axes.Axes.set_axis_off Total running time of the script: (0 minutes 2.235 seconds) Download Python source code: colormap_reference.py Download Jupyter notebook: colormap_reference.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ncmaps = [(\\'Perceptually Uniform Sequential\\', [\n            \\'viridis\\', \\'plasma\\', \\'inferno\\', \\'magma\\', \\'cividis\\),\n         (\\'Sequential\\', [\n            \\'Greys\\', \\'Purples\\', \\'Blues\\', \\'Greens\\', \\'Oranges\\', \\'Reds\\',\n            \\'YlOrBr\\', \\'YlOrRd\\', \\'OrRd\\', \\'PuRd\\', \\'RdPu\\', \\'BuPu\\',\n            \\'GnBu\\', \\'PuBu\\', \\'YlGnBu\\', \\'PuBuGn\\', \\'BuGn\\', \\'YlGn\\),\n         (\\'Sequential (2)\\', [\n            \\'binary\\', \\'gist_yarg\\', \\'gist_gray\\', \\'gray\\', \\'bone\\', \\'pink\\',\n            \\'spring\\', \\'summer\\', \\'autumn\\', \\'winter\\', \\'cool\\', \\'Wistia\\',\n            \\'hot\\', \\'afmhot\\', \\'gist_heat\\', \\'copper\\),\n         (\\'Diverging\\', [\n            \\'PiYG\\', \\'PRGn\\', \\'BrBG\\', \\'PuOr\\', \\'RdGy\\', \\'RdBu\\',\n            \\'RdYlBu\\', \\'RdYlGn\\', \\'Spectral\\', \\'coolwarm\\', \\'bwr\\', \\'seismic\\),\n         (\\'Cyclic\\', [\\'twilight\\', \\'twilight_shifted\\', \\'hsv\\),\n         (\\'Qualitative\\', [\n            \\'Pastel1\\', \\'Pastel2\\', \\'Paired\\', \\'Accent\\',\n            \\'Dark2\\', \\'Set1\\', \\'Set2\\', \\'Set3\\',\n            \\'tab10\\', \\'tab20\\', \\'tab20b\\', \\'tab20c\\),\n         (\\'Miscellaneous\\', [\n            \\'flag\\', \\'prism\\', \\'ocean\\', \\'gist_earth\\', \\'terrain\\', \\'gist_stern\\',\n            \\'gnuplot\\', \\'gnuplot2\\', \\'CMRmap\\', \\'cubehelix\\', \\'brg\\',\n            \\'gist_rainbow\\', \\'rainbow\\', \\'jet\\', \\'turbo\\', \\'nipy_spectral\\',\n            \\'gist_ncar\\)]\n\ngradient = np.linspace(0, 1, 256)\ngradient = np.vstack((gradient, gradient))\n\n\ndef plot_color_gradients(cmap_category, cmap_list):\n    # Create figure and adjust figure height to number of colormaps\n    nrows = len(cmap_list)\n    figh = 0.35 + 0.15 + (nrows + (nrows-1)*0.1)*0.22\n    fig, axs = plt.subplots(nrows=nrows, figsize=(6.4, figh))\n    fig.subplots_adjust(top=1-.35/figh, bottom=.15/figh, left=0.2, right=0.99)\n\n    axs[0].set_title(f\"{cmap_category} colormaps\", fontsize=14)\n\n    for ax, cmap_name in zip(axs, cmap_list):\n        ax.imshow(gradient, aspect=\\'auto\\', cmap=cmap_name)\n        ax.text(-.01, .5, cmap_name, va=\\'center\\', ha=\\'right\\', fontsize=10,\n                transform=ax.transAxes)\n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.\n    for ax in axs:\n        ax.set_axis_off()\n\n\nfor cmap_category, cmap_list in cmaps:\n    plot_color_gradients(cmap_category, cmap_list)\n plot_color_gradients(\"Original and reversed \", [\\'viridis\\', \\'viridis_r\\)\n",
    "id": 216
},
{
    "title": "Creating a colormap from a list of colors#",
    "text": "For more detail on creating and manipulating colormaps see\nCreating Colormaps in Matplotlib. Creating a colormap from a list of colors\ncan be done with the LinearSegmentedColormap.from_list method. You must\npass a list of RGB tuples that define the mixture of colors from 0 to 1. It is also possible to create a custom mapping for a colormap. This is\naccomplished by creating dictionary that specifies how the RGB channels\nchange from one end of the cmap to the other. Example: suppose you want red to increase from 0 to 1 over the bottom\nhalf, green to do the same over the middle half, and blue over the top\nhalf. Then you would use: If, as in this example, there are no discontinuities in the r, g, and b\ncomponents, then it is quite simple: the second and third element of\neach tuple, above, is the same -- call it \"y\". The first element (\"x\")\ndefines interpolation intervals over the full range of 0 to 1, and it\nmust span that whole range. In other words, the values of x divide the\n0-to-1 range into a set of segments, and y gives the end-point color\nvalues for each segment.', \"Now consider the green, cdictgreen is saying that for:\", '0 <= x <= 0.25, y is zero; no green. 0.25 < x <= 0.75, y varies linearly from 0 to 1. 0.75 < x <= 1, y remains at 1, full green. If there are discontinuities, then it is a little more complicated. Label the 3\nelements in each row in the cdict entry for a given color as (x, y0,\ny1). Then for values of x between x[i] and x[i+1] the color value\nis interpolated between y1[i] and y0[i+1]. Going back to a cookbook example:', \"and look at cdictred[1]; because y0 != y1, it is saying that for\nx from 0 to 0.5, red increases from 0 to 1, but then it jumps down, so that\nfor x from 0.5 to 1, red increases from 0.7 to 1. Green ramps from 0 to 1\nas x goes from 0 to 0.5, then jumps back to 0, and ramps back to 1 as x\ngoes from 0.5 to 1.\", 'Above is an attempt to show that for x in the range x[i] to x[i+1],\nthe interpolation is between y1[i] and y0[i+1]. So, y0[0] and\ny1[-1] are never used. Now we will use this example to illustrate 2 ways of\nhandling custom colormaps.\nFirst, the most direct and explicit: Second, create the map explicitly and register it.\nLike the first method, this method works with any kind\nof Colormap, not just\na LinearSegmentedColormap: Make the figure, with 4 subplots: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.imshow / matplotlib.pyplot.imshow matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.colors matplotlib.colors.LinearSegmentedColormap matplotlib.colors.LinearSegmentedColormap.from_list matplotlib.cm matplotlib.cm.ScalarMappable.set_cmap matplotlib.cm.register_cmap Total running time of the script: (0 minutes 1.466 seconds) Download Python source code: custom_cmap.py Download Jupyter notebook: custom_cmap.ipynb ",
    "code": "cdict = {\n    'red': (\n        (0.0,  0.0, 0.0),\n        (0.5,  1.0, 1.0),\n        (1.0,  1.0, 1.0),\n    ),\n    'green': (\n        (0.0,  0.0, 0.0),\n        (0.25, 0.0, 0.0),\n        (0.75, 1.0, 1.0),\n        (1.0,  1.0, 1.0),\n    ),\n    'blue': (\n        (0.0,  0.0, 0.0),\n        (0.5,  0.0, 0.0),\n        (1.0,  1.0, 1.0),\n    )\n}\n\", \"cdict = {\n    'red': (\n        (0.0,  0.0, 0.0),\n        (0.5,  1.0, 0.7),\n        (1.0,  1.0, 1.0),\n    ),\n    'green': (\n        (0.0,  0.0, 0.0),\n        (0.5,  1.0, 0.0),\n        (1.0,  1.0, 1.0),\n    ),\n    'blue': (\n        (0.0,  0.0, 0.0),\n        (0.5,  0.0, 0.0),\n        (1.0,  1.0, 1.0),\n    )\n}\n\", 'row i:   x  y0  y1\n               /\n              /\nrow i+1: x  y0  y1\n import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.colors import LinearSegmentedColormap\n\n# Make some illustrative fake data:\n\nx = np.arange(0, np.pi, 0.1)\ny = np.arange(0, 2 * np.pi, 0.1)\nX, Y = np.meshgrid(x, y)\nZ = np.cos(X) * np.sin(Y) * 10\n colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # R -> G -> B\nn_bins = [3, 6, 10, 100]  # Discretizes the interpolation into bins\ncmap_name = \\'my_list\\'\nfig, axs = plt.subplots(2, 2, figsize=(6, 9))\nfig.subplots_adjust(left=0.02, bottom=0.06, right=0.95, top=0.94, wspace=0.05)\nfor n_bin, ax in zip(n_bins, axs.flat):\n    # Create the colormap\n    cmap = LinearSegmentedColormap.from_list(cmap_name, colors, N=n_bin)\n    # Fewer bins will result in \"coarser\" colomap interpolation\n    im = ax.imshow(Z, origin=\\'lower\\', cmap=cmap)\n    ax.set_title(\"N bins: %s\" % n_bin)\n    fig.colorbar(im, ax=ax)\n', \"cdict1 = {\n    'red': (\n        (0.0, 0.0, 0.0),\n        (0.5, 0.0, 0.1),\n        (1.0, 1.0, 1.0),\n    ),\n    'green': (\n        (0.0, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    ),\n    'blue': (\n        (0.0, 0.0, 1.0),\n        (0.5, 0.1, 0.0),\n        (1.0, 0.0, 0.0),\n    )\n}\n\ncdict2 = {\n    'red': (\n        (0.0, 0.0, 0.0),\n        (0.5, 0.0, 1.0),\n        (1.0, 0.1, 1.0),\n    ),\n    'green': (\n        (0.0, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    ),\n    'blue': (\n        (0.0, 0.0, 0.1),\n        (0.5, 1.0, 0.0),\n        (1.0, 0.0, 0.0),\n    )\n}\n\ncdict3 = {\n    'red': (\n        (0.0, 0.0, 0.0),\n        (0.25, 0.0, 0.0),\n        (0.5, 0.8, 1.0),\n        (0.75, 1.0, 1.0),\n        (1.0, 0.4, 1.0),\n    ),\n    'green': (\n        (0.0, 0.0, 0.0),\n        (0.25, 0.0, 0.0),\n        (0.5, 0.9, 0.9),\n        (0.75, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    ),\n    'blue': (\n        (0.0, 0.0, 0.4),\n        (0.25, 1.0, 1.0),\n        (0.5, 1.0, 0.8),\n        (0.75, 0.0, 0.0),\n        (1.0, 0.0, 0.0),\n    )\n}\n\n# Make a modified version of cdict3 with some transparency\n# in the middle of the range.\ncdict4 = {\n    **cdict3,\n    'alpha': (\n        (0.0, 1.0, 1.0),\n        # (0.25, 1.0, 1.0),\n        (0.5, 0.3, 0.3),\n        # (0.75, 1.0, 1.0),\n        (1.0, 1.0, 1.0),\n    ),\n}\n\", \"blue_red1 = LinearSegmentedColormap('BlueRed1', cdict1)\n\", \"mpl.colormaps.register(LinearSegmentedColormap('BlueRed2', cdict2))\nmpl.colormaps.register(LinearSegmentedColormap('BlueRed3', cdict3))\nmpl.colormaps.register(LinearSegmentedColormap('BlueRedAlpha', cdict4))\n\", 'fig, axs = plt.subplots(2, 2, figsize=(6, 9))\nfig.subplots_adjust(left=0.02, bottom=0.06, right=0.95, top=0.94, wspace=0.05)\n\nim1 = axs[0, 0].imshow(Z, cmap=blue_red1)\nfig.colorbar(im1, ax=axs[0, 0])\n\nim2 = axs[1, 0].imshow(Z, cmap=\\'BlueRed2\\')\nfig.colorbar(im2, ax=axs[1, 0])\n\n# Now we will set the third cmap as the default.  One would\n# not normally do this in the middle of a script like this;\n# it is done here just to illustrate the method.\n\nplt.rcParams[\\'image.cmap\\ = \\'BlueRed3\\'\n\nim3 = axs[0, 1].imshow(Z)\nfig.colorbar(im3, ax=axs[0, 1])\naxs[0, 1].set_title(\"Alpha = 1\")\n\n# Or as yet another variation, we can replace the rcParams\n# specification *before* the imshow with the following *after*\n# imshow.\n# This sets the new default *and* sets the colormap of the last\n# image-like item plotted via pyplot, if any.\n#\n\n# Draw a line with low zorder so it will be behind the image.\naxs[1, 1].plot([0, 10 * np.pi], [0, 20 * np.pi], color=\\'c\\', lw=20, zorder=-1)\n\nim4 = axs[1, 1].imshow(Z)\nfig.colorbar(im4, ax=axs[1, 1])\n\n# Here it is: changing the colormap for the current image and its\n# colorbar after they have been plotted.\nim4.set_cmap(\\'BlueRedAlpha\\')\naxs[1, 1].set_title(\"Varying alpha\")\n\nfig.suptitle(\\'Custom Blue-Red colormaps\\', fontsize=16)\nfig.subplots_adjust(top=0.9)\n\nplt.show()\n",
    "id": 217
},
{
    "title": "List of named colors#",
    "text": "This plots a list of the named colors supported in matplotlib.\nFor more information on colors in matplotlib see the Specifying colors tutorial; the matplotlib.colors API; the Color Demo. First we define a helper function for making a table of colors, then we use it\non some common color categories. XKCD colors are supported, but they produce a large figure, so we skip them\nfor now. You can use the following code if desired: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors matplotlib.colors.rgb_to_hsv matplotlib.colors.to_rgba matplotlib.figure.Figure.get_size_inches matplotlib.figure.Figure.subplots_adjust matplotlib.axes.Axes.text matplotlib.patches.Rectangle Total running time of the script: (0 minutes 1.147 seconds) Download Python source code: named_colors.py Download Jupyter notebook: named_colors.ipynb ",
    "code": "import math\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Rectangle\n\n\ndef plot_colortable(colors, *, ncols=4, sort_colors=True):\n\n    cell_width = 212\n    cell_height = 22\n    swatch_width = 48\n    margin = 12\n\n    # Sort colors by hue, saturation, value and name.\n    if sort_colors is True:\n        names = sorted(\n            colors, key=lambda c: tuple(mcolors.rgb_to_hsv(mcolors.to_rgb(c))))\n    else:\n        names = list(colors)\n\n    n = len(names)\n    nrows = math.ceil(n / ncols)\n\n    width = cell_width * ncols + 2 * margin\n    height = cell_height * nrows + 2 * margin\n    dpi = 72\n\n    fig, ax = plt.subplots(figsize=(width / dpi, height / dpi), dpi=dpi)\n    fig.subplots_adjust(margin/width, margin/height,\n                        (width-margin)/width, (height-margin)/height)\n    ax.set_xlim(0, cell_width * ncols)\n    ax.set_ylim(cell_height * (nrows-0.5), -cell_height/2.)\n    ax.yaxis.set_visible(False)\n    ax.xaxis.set_visible(False)\n    ax.set_axis_off()\n\n    for i, name in enumerate(names):\n        row = i % nrows\n        col = i // nrows\n        y = row * cell_height\n\n        swatch_start_x = cell_width * col\n        text_pos_x = cell_width * col + swatch_width + 7\n\n        ax.text(text_pos_x, y, name, fontsize=14,\n                horizontalalignment='left',\n                verticalalignment='center')\n\n        ax.add_patch(\n            Rectangle(xy=(swatch_start_x, y-9), width=swatch_width,\n                      height=18, facecolor=colors[name], edgecolor='0.7')\n        )\n\n    return fig\n\", 'plot_colortable(mcolors.BASE_COLORS, ncols=3, sort_colors=False)\n plot_colortable(mcolors.TABLEAU_COLORS, ncols=2, sort_colors=False)\n plot_colortable(mcolors.CSS4_COLORS)\nplt.show()\n xkcd_fig = plot_colortable(mcolors.XKCD_COLORS)\nxkcd_fig.savefig(\"XKCD_Colors.png\")\n",
    "id": 218
},
{
    "title": "Ways to set a color's alpha value#",
    "text": "Compare setting alpha by the alpha keyword argument and by one of the Matplotlib color\nformats. Often, the alpha keyword is the only tool needed to add transparency to a\ncolor. In some cases, the (matplotlib_color, alpha) color format provides an easy way\nto fine-tune the appearance of a Figure. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.bar matplotlib.pyplot.subplots Download Python source code: set_alpha.py Download Jupyter notebook: set_alpha.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4))\n\nx_values = [n for n in range(20)]\ny_values = np.random.randn(20)\n\nfacecolors = [\\'green\\' if y > 0 else \\'red\\' for y in y_values]\nedgecolors = facecolors\n\nax1.bar(x_values, y_values, color=facecolors, edgecolor=edgecolors, alpha=0.5)\nax1.set_title(\"Explicit \\'alpha\\' keyword value\\\nshared by all bars and edges\")\n\n\n# Normalize y values to get distinct face alpha values.\nabs_y = [abs(y) for y in y_values]\nface_alphas = [n / max(abs_y) for n in abs_y]\nedge_alphas = [1 - alpha for alpha in face_alphas]\n\ncolors_with_alphas = list(zip(facecolors, face_alphas))\nedgecolors_with_alphas = list(zip(edgecolors, edge_alphas))\n\nax2.bar(x_values, y_values, color=colors_with_alphas,\n        edgecolor=edgecolors_with_alphas)\nax2.set_title(\\'Normalized alphas for\\\neach bar and each edge\\')\n\nplt.show()\n",
    "id": 219
},
{
    "title": "Arrow guide#",
    "text": "Adding arrow patches to plots. Arrows are often used to annotate plots. This tutorial shows how to plot arrows\nthat behave differently when the data limits on a plot are changed. In general,\npoints on a plot can either be fixed in \"data space\" or \"display space\".\nSomething plotted in data space moves when the data limits are altered - an\nexample would be the points in a scatter plot. Something plotted in display\nspace stays static when data limits are altered - an example would be a\nfigure title or the axis labels.', \"Arrows consist of a head (and possibly a tail) and a stem drawn between a\nstart point and end point, called 'anchor points' from now on.\nHere we show three use cases for plotting arrows, depending on whether the\nhead or anchor points need to be fixed in data or display space:\", 'Head shape fixed in display space, anchor points fixed in data space Head shape and anchor points fixed in display space Entire patch fixed in data space Below each use case is presented in turn.', \"This is useful if you are annotating a plot, and don't want the arrow\nto change shape or position if you pan or scale the plot.\", 'In this case we use patches.FancyArrowPatch. Note that when the axis limits are changed, the arrow shape stays the same,\nbut the anchor points move.', \"This is useful if you are annotating a plot, and don't want the arrow to\nchange shape or position if you pan or scale the plot.\", 'In this case we use patches.FancyArrowPatch, and pass the keyword argument\ntransform=ax.transAxes where ax is the axes we are adding the patch\nto. Note that when the axis limits are changed, the arrow shape and location\nstay the same. In this case we use patches.Arrow, or patches.FancyArrow (the latter is\nin orange). Note that when the axis limits are changed, the arrow shape and location\nchange.', \"FancyArrow's API is relatively awkward, and requires in particular passing\nlength_includes_head=True so that the arrow tip is (dx, dy) away\nfrom the arrow start. It is only included in this reference because it is\nthe arrow class returned by Axes.arrow (in green).\", 'Download Python source code: arrow_guide.py Download Jupyter notebook: arrow_guide.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nx_tail = 0.1\ny_tail = 0.5\nx_head = 0.9\ny_head = 0.8\ndx = x_head - x_tail\ndy = y_head - y_tail\n fig, axs = plt.subplots(nrows=2)\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100)\naxs[0].add_patch(arrow)\n\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100)\naxs[1].add_patch(arrow)\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n fig, axs = plt.subplots(nrows=2)\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100,\n                                 transform=axs[0].transAxes)\naxs[0].add_patch(arrow)\n\narrow = mpatches.FancyArrowPatch((x_tail, y_tail), (x_head, y_head),\n                                 mutation_scale=100,\n                                 transform=axs[1].transAxes)\naxs[1].add_patch(arrow)\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n fig, axs = plt.subplots(nrows=2)\n\narrow = mpatches.Arrow(x_tail, y_tail, dx, dy)\naxs[0].add_patch(arrow)\narrow = mpatches.FancyArrow(x_tail, y_tail - .4, dx, dy,\n                            width=.1, length_includes_head=True, color=\"C1\")\naxs[0].add_patch(arrow)\naxs[0].arrow(x_tail + 1, y_tail - .4, dx, dy,\n             width=.1, length_includes_head=True, color=\"C2\")\n\narrow = mpatches.Arrow(x_tail, y_tail, dx, dy)\naxs[1].add_patch(arrow)\narrow = mpatches.FancyArrow(x_tail, y_tail - .4, dx, dy,\n                            width=.1, length_includes_head=True, color=\"C1\")\naxs[1].add_patch(arrow)\naxs[1].arrow(x_tail + 1, y_tail - .4, dx, dy,\n             width=.1, length_includes_head=True, color=\"C2\")\naxs[1].set(xlim=(0, 2), ylim=(0, 2))\n plt.show()\n",
    "id": 221
},
{
    "title": "Reference for Matplotlib artists#",
    "text": "This example displays several of Matplotlib's graphics primitives (artists).\nA full list of artists is documented at the artist API.\", 'See also Circles, Wedges and Polygons, which groups\nall artists into a single PatchCollection instead. Copyright (c) 2010, Bartosz Telenczuk\nBSD License References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.lines matplotlib.lines.Line2D matplotlib.patches matplotlib.patches.Circle matplotlib.patches.Ellipse matplotlib.patches.Wedge matplotlib.patches.Rectangle matplotlib.patches.Arrow matplotlib.patches.PathPatch matplotlib.patches.FancyBboxPatch matplotlib.patches.RegularPolygon matplotlib.axes.Axes.add_artist Download Python source code: artist_reference.py Download Jupyter notebook: artist_reference.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib as mpl\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n# Prepare the data for the PathPatch below.\nPath = mpath.Path\ncodes, verts = zip(*[\n    (Path.MOVETO, [0.018, -0.11]),\n    (Path.CURVE4, [-0.031, -0.051]),\n    (Path.CURVE4, [-0.115, 0.073]),\n    (Path.CURVE4, [-0.03, 0.073]),\n    (Path.LINETO, [-0.011, 0.039]),\n    (Path.CURVE4, [0.043, 0.121]),\n    (Path.CURVE4, [0.075, -0.005]),\n    (Path.CURVE4, [0.035, -0.027]),\n    (Path.CLOSEPOLY, [0.018, -0.11])])\n\nartists = [\n    mpatches.Circle((0, 0), 0.1, ec=\"none\"),\n    mpatches.Rectangle((-0.025, -0.05), 0.05, 0.1, ec=\"none\"),\n    mpatches.Wedge((0, 0), 0.1, 30, 270, ec=\"none\"),\n    mpatches.RegularPolygon((0, 0), 5, radius=0.1),\n    mpatches.Ellipse((0, 0), 0.2, 0.1),\n    mpatches.Arrow(-0.05, -0.05, 0.1, 0.1, width=0.1),\n    mpatches.PathPatch(mpath.Path(verts, codes), ec=\"none\"),\n    mpatches.FancyBboxPatch((-0.025, -0.05), 0.05, 0.1, ec=\"none\",\n                            boxstyle=mpatches.BoxStyle(\"Round\", pad=0.02)),\n    mlines.Line2D([-0.06, 0.0, 0.1], [0.05, -0.05, 0.05], lw=5),\n]\n\naxs = plt.figure(figsize=(6, 6), layout=\"constrained\").subplots(3, 3)\nfor i, (ax, artist) in enumerate(zip(axs.flat, artists)):\n    artist.set(color=mpl.colormapshsv(i / len(artists)))\n    ax.add_artist(artist)\n    ax.set(title=type(artist).__name__,\n           aspect=1, xlim=(-.2, .2), ylim=(-.2, .2))\n    ax.set_axis_off()\nplt.show()\n",
    "id": 222
},
{
    "title": "Line, Poly and RegularPoly Collection with autoscaling#",
    "text": "For the first two subplots, we will use spirals. Their size will be set in\nplot units, not data units. Their positions will be set in data units by using\nthe offsets and offset_transform keyword arguments of the LineCollection\nand PolyCollection. The third subplot will make regular polygons, with the same\ntype of scaling and positioning as in the first two. The last subplot illustrates the use of offsets=(xo, yo),\nthat is, a single tuple instead of a list of tuples, to generate\nsuccessively offset curves, with the offset given in data\nunits. This behavior is available only for the LineCollection. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.figure.Figure matplotlib.collections matplotlib.collections.LineCollection matplotlib.collections.RegularPolyCollection matplotlib.axes.Axes.add_collection matplotlib.axes.Axes.autoscale_view matplotlib.transforms.Affine2D matplotlib.transforms.Affine2D.scale Download Python source code: collections.py Download Jupyter notebook: collections.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import collections, transforms\n\nnverts = 50\nnpts = 100\n\n# Make some spirals\nr = np.arange(nverts)\ntheta = np.linspace(0, 2*np.pi, nverts)\nxx = r * np.sin(theta)\nyy = r * np.cos(theta)\nspiral = np.column_stack([xx, yy])\n\n# Fixing random state for reproducibility\nrs = np.random.RandomState(19680801)\n\n# Make some offsets\nxyo = rs.randn(npts, 2)\n\n# Make a list of colors cycling through the default series.\ncolors = plt.rcParams[\\'axes.prop_cycle\\.by_key()[\\'color\\\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\nfig.subplots_adjust(top=0.92, left=0.07, right=0.97,\n                    hspace=0.3, wspace=0.3)\n\n\ncol = collections.LineCollection(\n    [spiral], offsets=xyo, offset_transform=ax1.transData)\ntrans = fig.dpi_scale_trans + transforms.Affine2D().scale(1.0/72.0)\ncol.set_transform(trans)  # the points to pixels transform\n# Note: the first argument to the collection initializer\n# must be a list of sequences of (x, y) tuples; we have only\n# one sequence, but we still have to put it in a list.\nax1.add_collection(col, autolim=True)\n# autolim=True enables autoscaling.  For collections with\n# offsets like this, it is neither efficient nor accurate,\n# but it is good enough to generate a plot that you can use\n# as a starting point.  If you know beforehand the range of\n# x and y that you want to show, it is better to set them\n# explicitly, leave out the *autolim* keyword argument (or set it to False),\n# and omit the \\'ax1.autoscale_view()\\' call below.\n\n# Make a transform for the line segments such that their size is\n# given in points:\ncol.set_color(colors)\n\nax1.autoscale_view()  # See comment above, after ax1.add_collection.\nax1.set_title(\\'LineCollection using offsets\\')\n\n\n# The same data as above, but fill the curves.\ncol = collections.PolyCollection(\n    [spiral], offsets=xyo, offset_transform=ax2.transData)\ntrans = transforms.Affine2D().scale(fig.dpi/72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax2.add_collection(col, autolim=True)\ncol.set_color(colors)\n\n\nax2.autoscale_view()\nax2.set_title(\\'PolyCollection using offsets\\')\n\n# 7-sided regular polygons\n\ncol = collections.RegularPolyCollection(\n    7, sizes=np.abs(xx) * 10.0, offsets=xyo, offset_transform=ax3.transData)\ntrans = transforms.Affine2D().scale(fig.dpi / 72.0)\ncol.set_transform(trans)  # the points to pixels transform\nax3.add_collection(col, autolim=True)\ncol.set_color(colors)\nax3.autoscale_view()\nax3.set_title(\\'RegularPolyCollection using offsets\\')\n\n\n# Simulate a series of ocean current profiles, successively\n# offset by 0.1 m/s so that they form what is sometimes called\n# a \"waterfall\" plot or a \"stagger\" plot.\n\nnverts = 60\nncurves = 20\noffs = (0.1, 0.0)\n\nyy = np.linspace(0, 2*np.pi, nverts)\nym = np.max(yy)\nxx = (0.2 + (ym - yy) / ym) ** 2 * np.cos(yy - 0.4) * 0.5\nsegs = []\nfor i in range(ncurves):\n    xxx = xx + 0.02*rs.randn(nverts)\n    curve = np.column_stack([xxx, yy * 100])\n    segs.append(curve)\n\ncol = collections.LineCollection(segs, offsets=offs)\nax4.add_collection(col, autolim=True)\ncol.set_color(colors)\nax4.autoscale_view()\nax4.set_title(\\'Successive data offsets\\')\nax4.set_xlabel(\\'Zonal velocity component (m/s)\\')\nax4.set_ylabel(\\'Depth (m)\\')\n# Reverse the y-axis so depth increases downward\nax4.set_ylim(ax4.get_ylim()[::-1])\n\n\nplt.show()\n",
    "id": 223
},
{
    "title": "Compound path#",
    "text": "Make a compound path -- in this case two simple polygons, a rectangle\nand a triangle. Use CLOSEPOLY and MOVETO for the different parts of\nthe compound path References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.axes.Axes.add_patch matplotlib.axes.Axes.autoscale_view Download Python source code: compound_path.py Download Jupyter notebook: compound_path.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nvertices = []\ncodes = []\n\ncodes = [Path.MOVETO] + [Path.LINETO]*3 + [Path.CLOSEPOLY]\nvertices = [(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)]\n\ncodes += [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY]\nvertices += [(4, 4), (5, 5), (5, 4), (0, 0)]\n\npath = Path(vertices, codes)\n\npathpatch = PathPatch(path, facecolor='none', edgecolor='green')\n\nfig, ax = plt.subplots()\nax.add_patch(pathpatch)\nax.set_title('A compound path')\n\nax.autoscale_view()\n\nplt.show()\n",
    "id": 224
},
{
    "title": "Dolphins#",
    "text": "This example shows how to draw, and manipulate shapes given vertices\nand nodes using the Path, PathPatch and\ntransforms classes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.patches.Circle matplotlib.axes.Axes.add_patch matplotlib.transforms matplotlib.transforms.Affine2D matplotlib.transforms.Affine2D.rotate_deg Download Python source code: dolphin.py Download Jupyter notebook: dolphin.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Affine2D\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nr = np.random.rand(50)\nt = np.random.rand(50) * np.pi * 2.0\nx = r * np.cos(t)\ny = r * np.sin(t)\n\nfig, ax = plt.subplots(figsize=(6, 6))\ncircle = Circle((0, 0), 1, facecolor=\\'none\\',\n                edgecolor=(0, 0.8, 0.8), linewidth=3, alpha=0.5)\nax.add_patch(circle)\n\nim = plt.imshow(np.random.random((100, 100)),\n                origin=\\'lower\\', cmap=cm.winter,\n                interpolation=\\'spline36\\',\n                extent=(-1, 1, -1, 1))\nim.set_clip_path(circle)\n\nplt.plot(x, y, \\'o\\', color=(0.9, 0.9, 1.0), alpha=0.8)\n\n# Dolphin from OpenClipart library by Andy Fitzsimon\n#   <cc:License rdf:about=\"http://web.resource.org/cc/PublicDomain\">\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/Reproduction\"/>\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/Distribution\"/>\n#     <cc:permits rdf:resource=\"http://web.resource.org/cc/DerivativeWorks\"/>\n#   </cc:License>\n\ndolphin = \"\"\"\nM -0.59739425,160.18173 C -0.62740401,160.18885 -0.57867129,160.11183\n-0.57867129,160.11183 C -0.57867129,160.11183 -0.5438361,159.89315\n-0.39514638,159.81496 C -0.24645668,159.73678 -0.18316813,159.71981\n-0.18316813,159.71981 C -0.18316813,159.71981 -0.10322971,159.58124\n-0.057804323,159.58725 C -0.029723983,159.58913 -0.061841603,159.60356\n-0.071265813,159.62815 C -0.080250183,159.65325 -0.082918513,159.70554\n-0.061841203,159.71248 C -0.040763903,159.7194 -0.0066711426,159.71091\n0.077336307,159.73612 C 0.16879567,159.76377 0.28380306,159.86448\n0.31516668,159.91533 C 0.3465303,159.96618 0.5011127,160.1771\n0.5011127,160.1771 C 0.63668998,160.19238 0.67763022,160.31259\n0.66556395,160.32668 C 0.65339985,160.34212 0.66350443,160.33642\n0.64907098,160.33088 C 0.63463742,160.32533 0.61309688,160.297\n0.5789627,160.29339 C 0.54348657,160.28968 0.52329693,160.27674\n0.50728856,160.27737 C 0.49060916,160.27795 0.48965803,160.31565\n0.46114204,160.33673 C 0.43329696,160.35786 0.4570711,160.39871\n0.43309565,160.40685 C 0.4105108,160.41442 0.39416631,160.33027\n0.3954995,160.2935 C 0.39683269,160.25672 0.43807996,160.21522\n0.44567915,160.19734 C 0.45327833,160.17946 0.27946869,159.9424\n-0.061852613,159.99845 C -0.083965233,160.0427 -0.26176109,160.06683\n-0.26176109,160.06683 C -0.30127962,160.07028 -0.21167141,160.09731\n-0.24649368,160.1011 C -0.32642366,160.11569 -0.34521187,160.06895\n-0.40622293,160.0819 C -0.467234,160.09485 -0.56738444,160.17461\n-0.59739425,160.18173\n\"\"\"\n\nvertices = []\ncodes = []\nparts = dolphin.split()\ni = 0\ncode_map = {\n    \\'M\\': Path.MOVETO,\n    \\'C\\': Path.CURVE4,\n    \\'L\\': Path.LINETO,\n}\n\nwhile i < len(parts):\n    path_code = code_map[parts[i]]\n    npoints = Path.NUM_VERTICES_FOR_CODE[path_code]\n    codes.extend([path_code] * npoints)\n    vertices.extend([[*map(float, y.split(\\',\\'))]\n                     for y in parts[i + 1:][:npoints]])\n    i += npoints + 1\nvertices = np.array(vertices)\nvertices[:, 1] -= 160\n\ndolphin_path = Path(vertices, codes)\ndolphin_patch = PathPatch(dolphin_path, facecolor=(0.6, 0.6, 0.6),\n                          edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch)\n\nvertices = Affine2D().rotate_deg(60).transform(vertices)\ndolphin_path2 = Path(vertices, codes)\ndolphin_patch2 = PathPatch(dolphin_path2, facecolor=(0.5, 0.5, 0.5),\n                           edgecolor=(0.0, 0.0, 0.0))\nax.add_patch(dolphin_patch2)\n\nplt.show()\n",
    "id": 225
},
{
    "title": "Mmh Donuts!!!#",
    "text": "Draw donuts (miam!) using Paths and PathPatches.\nThis example shows the effect of the path's orientations in a compound path.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.patches.Circle matplotlib.axes.Axes.add_patch matplotlib.axes.Axes.annotate matplotlib.axes.Axes.set_aspect matplotlib.axes.Axes.set_xlim matplotlib.axes.Axes.set_ylim matplotlib.axes.Axes.set_title Download Python source code: donut.py Download Jupyter notebook: donut.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\n\ndef wise(v):\n    if v == 1:\n        return \"CCW\"\n    else:\n        return \"CW\"\n\n\ndef make_circle(r):\n    t = np.arange(0, np.pi * 2.0, 0.01)\n    t = t.reshape((len(t), 1))\n    x = r * np.cos(t)\n    y = r * np.sin(t)\n    return np.hstack((x, y))\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\n\ninside_vertices = make_circle(0.5)\noutside_vertices = make_circle(1.0)\ncodes = np.ones(\n    len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO\ncodes[0] = mpath.Path.MOVETO\n\nfor i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):\n    # Concatenate the inside and outside subpaths together, changing their\n    # order as needed\n    vertices = np.concatenate((outside_vertices[::outside],\n                               inside_vertices[::inside]))\n    # Shift the path\n    vertices[:, 0] += i * 2.5\n    # The codes will be all \"LINETO\" commands, except for \"MOVETO\"s at the\n    # beginning of each subpath\n    all_codes = np.concatenate((codes, codes))\n    # Create the Path object\n    path = mpath.Path(vertices, all_codes)\n    # Add plot it\n    patch = mpatches.PathPatch(path, facecolor=\\'#885500\\', edgecolor=\\'black\\')\n    ax.add_patch(patch)\n\n    ax.annotate(f\"Outside {wise(outside)},\\\nInside {wise(inside)}\",\n                (i * 2.5, -1.5), va=\"top\", ha=\"center\")\n\nax.set_xlim(-2, 10)\nax.set_ylim(-3, 2)\nax.set_title(\\'Mmm, donuts!\\')\nax.set_aspect(1.0)\nplt.show()\n",
    "id": 226
},
{
    "title": "Ellipse with orientation arrow demo#",
    "text": "This demo shows how to draw an ellipse with\nan orientation arrow (clockwise or counterclockwise).\nCompare this to the Ellipse collection example. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Ellipse Download Python source code: ellipse_arrow.py Download Jupyter notebook: ellipse_arrow.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Ellipse\nfrom matplotlib.transforms import Affine2D\n\n# Create a figure and axis\nfig, ax = plt.subplots(subplot_kw={\"aspect\": \"equal\"})\n\nellipse = Ellipse(\n    xy=(2, 4),\n    width=30,\n    height=20,\n    angle=35,\n    facecolor=\"none\",\n    edgecolor=\"b\"\n)\nax.add_patch(ellipse)\n\n# Plot an arrow marker at the end point of minor axis\nvertices = ellipse.get_co_vertices()\nt = Affine2D().rotate_deg(ellipse.angle)\nax.plot(\n    vertices[0][0],\n    vertices[0][1],\n    color=\"b\",\n    marker=MarkerStyle(\">\", \"full\", t),\n    markersize=10\n)\n# Note: To reverse the orientation arrow, switch the marker type from > to <.\n\nplt.show()\n",
    "id": 227
},
{
    "title": "Ellipse Collection#",
    "text": "Drawing a collection of ellipses. While this would equally be possible using\na EllipseCollection or PathCollection, the use\nof an EllipseCollection allows for much shorter code. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.collections matplotlib.collections.EllipseCollection matplotlib.axes.Axes.add_collection matplotlib.axes.Axes.autoscale_view matplotlib.cm.ScalarMappable.set_array Download Python source code: ellipse_collection.py Download Jupyter notebook: ellipse_collection.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import EllipseCollection\n\nx = np.arange(10)\ny = np.arange(15)\nX, Y = np.meshgrid(x, y)\n\nXY = np.column_stack((X.ravel(), Y.ravel()))\n\nww = X / 10.0\nhh = Y / 15.0\naa = X * 9\n\n\nfig, ax = plt.subplots()\n\nec = EllipseCollection(ww, hh, aa, units='x', offsets=XY,\n                       offset_transform=ax.transData)\nec.set_array((X + Y).ravel())\nax.add_collection(ec)\nax.autoscale_view()\nax.set_xlabel('X')\nax.set_ylabel('y')\ncbar = plt.colorbar(ec)\ncbar.set_label('X+Y')\nplt.show()\n",
    "id": 228
},
{
    "title": "Ellipse Demo#",
    "text": "Draw many ellipses. Here individual ellipses are drawn. Compare this\nto the Ellipse collection example.",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nNUM = 250\n\nells = [Ellipse(xy=np.random.rand(2) * 10,\n                width=np.random.rand(), height=np.random.rand(),\n                angle=np.random.rand() * 360)\n        for i in range(NUM)]\n\nfig, ax = plt.subplots()\nax.set(xlim=(0, 10), ylim=(0, 10), aspect=\"equal\")\n\nfor e in ells:\n    ax.add_artist(e)\n    e.set_clip_box(ax.bbox)\n    e.set_alpha(np.random.rand())\n    e.set_facecolor(np.random.rand(3))\n\nplt.show()\n",
    "id": 229
},
{
    "title": "Drawing fancy boxes#",
    "text": "The following examples show how to plot boxes with different visual properties.', \"First we'll show some sample boxes with fancybox.\", \"Next we'll show off multiple fancy boxes at once.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.FancyBboxPatch matplotlib.patches.BoxStyle matplotlib.patches.BoxStyle.get_styles matplotlib.transforms.Bbox matplotlib.figure.Figure.text matplotlib.axes.Axes.text Total running time of the script: (0 minutes 1.138 seconds) Download Python source code: fancybox_demo.py Download Jupyter notebook: fancybox_demo.ipynb ",
    "code": "import inspect\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatch\nfrom matplotlib.patches import FancyBboxPatch\nimport matplotlib.transforms as mtransforms\n styles = mpatch.BoxStyle.get_styles()\nncol = 2\nnrow = (len(styles) + 1) // ncol\naxs = (plt.figure(figsize=(3 * ncol, 1 + nrow))\n       .add_gridspec(1 + nrow, ncol, wspace=.5).subplots())\nfor ax in axs.flat:\n    ax.set_axis_off()\nfor ax in axs[0, :]:\n    ax.text(.2, .5, \"boxstyle\",\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"right\", verticalalignment=\"center\")\n    ax.text(.4, .5, \"default parameters\",\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\nfor ax, (stylename, stylecls) in zip(axs[1:, :].T.flat, styles.items()):\n    ax.text(.2, .5, stylename, bbox=dict(boxstyle=stylename, fc=\"w\", ec=\"k\"),\n            transform=ax.transAxes, size=\"large\", color=\"tab:blue\",\n            horizontalalignment=\"right\", verticalalignment=\"center\")\n    ax.text(.4, .5, str(inspect.signature(stylecls))[1:-1].replace(\", \", \"\\\n\"),\n            transform=ax.transAxes,\n            horizontalalignment=\"left\", verticalalignment=\"center\")\n def add_fancy_patch_around(ax, bb, **kwargs):\n    fancy = FancyBboxPatch(bb.p0, bb.width, bb.height,\n                           fc=(1, 0.8, 1, 0.5), ec=(1, 0.5, 1, 0.5),\n                           **kwargs)\n    ax.add_patch(fancy)\n    return fancy\n\n\ndef draw_control_points_for_patches(ax):\n    for patch in ax.patches:\n        patch.axes.plot(*patch.get_path().vertices.T, \".\",\n                        c=patch.get_edgecolor())\n\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\n\n# Bbox object around which the fancy box will be drawn.\nbb = mtransforms.Bbox([[0.3, 0.4], [0.7, 0.6]])\n\nax = axs[0, 0]\n# a fancy box with round corners. pad=0.1\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\")\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title=\\'boxstyle=\"round,pad=0.1\"\\')\n\nax = axs[0, 1]\n# bbox=round has two optional arguments: pad and rounding_size.\n# They can be set during the initialization.\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.1\")\n# The boxstyle and its argument can be later modified with set_boxstyle().\n# Note that the old attributes are simply forgotten even if the boxstyle name\n# is same.\nfancy.set_boxstyle(\"round,pad=0.1,rounding_size=0.2\")\n# or: fancy.set_boxstyle(\"round\", pad=0.1, rounding_size=0.2)\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title=\\'boxstyle=\"round,pad=0.1,rounding_size=0.2\"\\')\n\nax = axs[1, 0]\n# mutation_scale determines the overall scale of the mutation, i.e. both pad\n# and rounding_size is scaled according to this value.\nfancy = add_fancy_patch_around(\n    ax, bb, boxstyle=\"round,pad=0.1\", mutation_scale=2)\nax.set(xlim=(0, 1), ylim=(0, 1), aspect=1,\n       title=\\'boxstyle=\"round,pad=0.1\"\\\n mutation_scale=2\\')\n\nax = axs[1, 1]\n# When the aspect ratio of the axes is not 1, the fancy box may not be what you\n# expected (green).\nfancy = add_fancy_patch_around(ax, bb, boxstyle=\"round,pad=0.2\")\nfancy.set(facecolor=\"none\", edgecolor=\"green\")\n# You can compensate this by setting the mutation_aspect (pink).\nfancy = add_fancy_patch_around(\n    ax, bb, boxstyle=\"round,pad=0.3\", mutation_aspect=0.5)\nax.set(xlim=(-.5, 1.5), ylim=(0, 1), aspect=2,\n       title=\\'boxstyle=\"round,pad=0.3\"\\\nmutation_aspect=.5\\')\n\nfor ax in axs.flat:\n    draw_control_points_for_patches(ax)\n    # Draw the original bbox (using boxstyle=square with pad=0).\n    fancy = add_fancy_patch_around(ax, bb, boxstyle=\"square,pad=0\")\n    fancy.set(edgecolor=\"black\", facecolor=\"none\", zorder=10)\n\nfig.tight_layout()\n\n\nplt.show()\n",
    "id": 230
},
{
    "title": "Hatch demo#",
    "text": "Hatches can be added to most polygons in Matplotlib, including bar,\nfill_between, contourf, and children of Polygon.\nThey are currently supported in the PS, PDF, SVG, OSX, and Agg backends. The WX\nand Cairo backends do not currently support hatching. See also Contourf Hatching for\nan example using contourf, and\nHatch style reference for swatches\nof the existing hatches. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Ellipse matplotlib.patches.Polygon matplotlib.axes.Axes.add_patch matplotlib.patches.Patch.set_hatch matplotlib.axes.Axes.bar / matplotlib.pyplot.bar Download Python source code: hatch_demo.py Download Jupyter notebook: hatch_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Ellipse, Polygon\n\nx = np.arange(1, 5)\ny1 = np.arange(1, 5)\ny2 = np.ones(y1.shape) * 4\n\nfig = plt.figure()\naxs = fig.subplot_mosaic([[\\'bar1\\', \\'patches\\, [\\'bar2\\', \\'patches\\])\n\naxs[\\'bar1\\.bar(x, y1, edgecolor=\\'black\\', hatch=\"/\")\naxs[\\'bar1\\.bar(x, y2, bottom=y1, edgecolor=\\'black\\', hatch=\\'//\\')\n\naxs[\\'bar2\\.bar(x, y1, edgecolor=\\'black\\', hatch=[\\'--\\', \\'+\\', \\'x\\', \\'\\\\\\\\\\)\naxs[\\'bar2\\.bar(x, y2, bottom=y1, edgecolor=\\'black\\',\n                hatch=[\\'*\\', \\'o\\', \\'O\\', \\'.\\)\n\nx = np.arange(0, 40, 0.2)\naxs[\\'patches\\.fill_between(x, np.sin(x) * 4 + 30, y2=0,\n                            hatch=\\'///\\', zorder=2, fc=\\'c\\')\naxs[\\'patches\\.add_patch(Ellipse((4, 50), 10, 10, fill=True,\n                                 hatch=\\'*\\', facecolor=\\'y\\'))\naxs[\\'patches\\.add_patch(Polygon([(10, 20), (30, 50), (50, 10)],\n                                 hatch=\\'\\\\\\\\/...\\', facecolor=\\'g\\'))\naxs[\\'patches\\.set_xlim([0, 40])\naxs[\\'patches\\.set_ylim([10, 60])\naxs[\\'patches\\.set_aspect(1)\nplt.show()\n",
    "id": 231
},
{
    "title": "Hatch style reference#",
    "text": "Hatches can be added to most polygons in Matplotlib, including bar,\nfill_between, contourf, and children of Polygon.\nThey are currently supported in the PS, PDF, SVG, OSX, and Agg backends. The WX\nand Cairo backends do not currently support hatching. See also Contourf Hatching for\nan example using contourf, and\nHatch demo for more usage examples. Hatching patterns can be repeated to increase the density. Hatching patterns can be combined to create additional patterns. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Rectangle matplotlib.axes.Axes.add_patch matplotlib.axes.Axes.text Download Python source code: hatch_style_reference.py Download Jupyter notebook: hatch_style_reference.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Rectangle\n\nfig, axs = plt.subplots(2, 5, layout=\\'constrained\\', figsize=(6.4, 3.2))\n\nhatches = [\\'/\\', \\'\\\\\\\\\\', \\'|\\', \\'-\\', \\'+\\', \\'x\\', \\'o\\', \\'O\\', \\'.\\', \\'*\\\n\n\ndef hatches_plot(ax, h):\n    ax.add_patch(Rectangle((0, 0), 2, 2, fill=False, hatch=h))\n    ax.text(1, -0.5, f\"\\' {h} \\'\", size=15, ha=\"center\")\n    ax.axis(\\'equal\\')\n    ax.axis(\\'off\\')\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n', \"fig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = // \\\\\\\\\\\\\\\\ || -- ++ xx oo OO .. **\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n\", \"fig, axs = plt.subplots(2, 5, layout='constrained', figsize=(6.4, 3.2))\n\nhatches = /o \\\\\\\\| |* -\\\\\\\\ +o x* o- O| O. *-\n\nfor ax, h in zip(axs.flat, hatches):\n    hatches_plot(ax, h)\n",
    "id": 232
},
{
    "title": "Plotting multiple lines with a LineCollection#",
    "text": "Matplotlib can efficiently draw multiple lines at once using a\nLineCollection, as showcased below. In the following example, instead of passing a list of colors\n(colors=colors), we pass an array of values (array=x) that get\ncolormapped. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.collections matplotlib.collections.LineCollection matplotlib.cm.ScalarMappable.set_array matplotlib.axes.Axes.add_collection matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar matplotlib.pyplot.sci Download Python source code: line_collection.py Download Jupyter notebook: line_collection.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import LineCollection\n\nx = np.arange(100)\n# Here are many sets of y to plot vs. x\nys = x[:50, np.newaxis] + x[np.newaxis, :]\n\nsegs = np.zeros((50, 100, 2))\nsegs[:, :, 1] = ys\nsegs[:, :, 0] = x\n\n# Mask some values to test masked array support:\nsegs = np.ma.masked_where((segs > 50) & (segs < 60), segs)\n\n# We need to set the plot limits, they will not autoscale\nfig, ax = plt.subplots()\nax.set_xlim(x.min(), x.max())\nax.set_ylim(ys.min(), ys.max())\n\n# *colors* is sequence of rgba tuples.\n# *linestyle* is a string or dash tuple. Legal string values are\n# solid|dashed|dashdot|dotted.  The dash tuple is (offset, onoffseq) where\n# onoffseq is an even length tuple of on and off ink in points.  If linestyle\n# is omitted, 'solid' is used.\n# See `matplotlib.collections.LineCollection` for more information.\ncolors = plt.rcParamsaxes.prop_cycle.by_key()color\n\nline_segments = LineCollection(segs, linewidths=(0.5, 1, 1.5, 2),\n                               colors=colors, linestyle='solid')\nax.add_collection(line_segments)\nax.set_title('Line collection with masked arrays')\nplt.show()\n\", \"N = 50\nx = np.arange(N)\nys = [x + i for i in x]  # Many sets of y to plot vs. x\nsegs = [np.column_stack([x, y]) for y in ys]\n\nfig, ax = plt.subplots()\nax.set_xlim(np.min(x), np.max(x))\nax.set_ylim(np.min(ys), np.max(ys))\n\nline_segments = LineCollection(segs, array=x,\n                               linewidths=(0.5, 1, 1.5, 2),\n                               linestyles='solid')\nax.add_collection(line_segments)\naxcb = fig.colorbar(line_segments)\naxcb.set_label('Line Number')\nax.set_title('Line Collection with mapped colors')\nplt.sci(line_segments)  # This allows interactive changing of the colormap.\nplt.show()\n",
    "id": 233
},
{
    "title": "Circles, Wedges and Polygons#",
    "text": "This example demonstrates how to use collections.PatchCollection. See also Reference for Matplotlib artists, which instead\nadds each artist separately to its own axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.Circle matplotlib.patches.Wedge matplotlib.patches.Polygon matplotlib.collections.PatchCollection matplotlib.collections.Collection.set_array matplotlib.axes.Axes.add_collection matplotlib.figure.Figure.colorbar Download Python source code: patch_collection.py Download Jupyter notebook: patch_collection.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.patches import Circle, Polygon, Wedge\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\n\nresolution = 50  # the number of vertices\nN = 3\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\npatches = []\nfor x1, y1, r in zip(x, y, radii):\n    circle = Circle((x1, y1), r)\n    patches.append(circle)\n\nx = np.random.rand(N)\ny = np.random.rand(N)\nradii = 0.1*np.random.rand(N)\ntheta1 = 360.0*np.random.rand(N)\ntheta2 = 360.0*np.random.rand(N)\nfor x1, y1, r, t1, t2 in zip(x, y, radii, theta1, theta2):\n    wedge = Wedge((x1, y1), r, t1, t2)\n    patches.append(wedge)\n\n# Some limiting conditions on Wedge\npatches += [\n    Wedge((.3, .7), .1, 0, 360),             # Full circle\n    Wedge((.7, .8), .2, 0, 360, width=0.05),  # Full ring\n    Wedge((.8, .3), .2, 0, 45),              # Full sector\n    Wedge((.8, .3), .2, 45, 90, width=0.10),  # Ring sector\n]\n\nfor i in range(N):\n    polygon = Polygon(np.random.rand(N, 2), closed=True)\n    patches.append(polygon)\n\ncolors = 100 * np.random.rand(len(patches))\np = PatchCollection(patches, alpha=0.4)\np.set_array(colors)\nax.add_collection(p)\nfig.colorbar(p, ax=ax)\n\nplt.show()\n",
    "id": 234
},
{
    "title": "PathPatch object#",
    "text": "This example shows how to create Path and PathPatch\nobjects through Matplotlib's API.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.axes.Axes.add_patch Download Python source code: path_patch.py Download Jupyter notebook: path_patch.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nfig, ax = plt.subplots()\n\nPath = mpath.Path\npath_data = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n    ]\ncodes, verts = zip(*path_data)\npath = mpath.Path(verts, codes)\npatch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)\nax.add_patch(patch)\n\n# plot control points and connecting lines\nx, y = zip(*path.vertices)\nline, = ax.plot(x, y, 'go-')\n\nax.grid()\nax.axis('equal')\nplt.show()\n",
    "id": 235
},
{
    "title": "Bezier Curve#",
    "text": "This example showcases the PathPatch object to create a Bezier\npolycurve path patch. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.patches matplotlib.patches.PathPatch matplotlib.axes.Axes.add_patch Download Python source code: quad_bezier.py Download Jupyter notebook: quad_bezier.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\nimport matplotlib.path as mpath\n\nPath = mpath.Path\n\nfig, ax = plt.subplots()\npp1 = mpatches.PathPatch(\n    Path([(0, 0), (1, 0), (1, 1), (0, 0)],\n         [Path.MOVETO, Path.CURVE3, Path.CURVE3, Path.CLOSEPOLY]),\n    fc=\"none\", transform=ax.transData)\n\nax.add_patch(pp1)\nax.plot([0.75], [0.25], \"ro\")\nax.set_title(\\'The red point should be on the path\\')\n\nplt.show()\n",
    "id": 236
},
{
    "title": "Scatter plot#",
    "text": "This example showcases a simple scatter plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.scatter / matplotlib.pyplot.scatter Download Python source code: scatter.py Download Jupyter notebook: scatter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\n\nplt.scatter(x, y, s=area, c=colors, alpha=0.5)\nplt.show()\n",
    "id": 237
},
{
    "title": "Bayesian Methods for Hackers style sheet#",
    "text": "This example demonstrates the style used in the Bayesian Methods for Hackers\n[1] online book. http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/ Download Python source code: bmh.py Download Jupyter notebook: bmh.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nplt.style.use(\\'bmh\\')\n\n\ndef plot_beta_hist(ax, a, b):\n    ax.hist(np.random.beta(a, b, size=10000),\n            histtype=\"stepfilled\", bins=25, alpha=0.8, density=True)\n\n\nfig, ax = plt.subplots()\nplot_beta_hist(ax, 10, 10)\nplot_beta_hist(ax, 4, 12)\nplot_beta_hist(ax, 50, 12)\nplot_beta_hist(ax, 6, 55)\nax.set_title(\"\\'bmh\\' style sheet\")\n\nplt.show()\n",
    "id": 239
},
{
    "title": "Dark background style sheet#",
    "text": "This example demonstrates the \"dark_background\" style, which uses white for\nelements that are typically black (text, borders, etc). Note that not all plot\nelements default to colors defined by an rc parameter. Download Python source code: dark_background.py Download Jupyter notebook: dark_background.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use(\\'dark_background\\')\n\nfig, ax = plt.subplots()\n\nL = 6\nx = np.linspace(0, L)\nncolors = len(plt.rcParams[\\'axes.prop_cycle\\)\nshift = np.linspace(0, L, ncolors, endpoint=False)\nfor s in shift:\n    ax.plot(x, np.sin(x + s), \\'o-\\')\nax.set_xlabel(\\'x-axis\\')\nax.set_ylabel(\\'y-axis\\')\nax.set_title(\"\\'dark_background\\' style sheet\")\n\nplt.show()\n",
    "id": 240
},
{
    "title": "FiveThirtyEight style sheet#",
    "text": "This shows an example of the \"fivethirtyeight\" styling, which\ntries to replicate the styles from FiveThirtyEight.com. Download Python source code: fivethirtyeight.py Download Jupyter notebook: fivethirtyeight.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use(\\'fivethirtyeight\\')\n\nx = np.linspace(0, 10)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nax.plot(x, np.sin(x) + x + np.random.randn(50))\nax.plot(x, np.sin(x) + 0.5 * x + np.random.randn(50))\nax.plot(x, np.sin(x) + 2 * x + np.random.randn(50))\nax.plot(x, np.sin(x) - 0.5 * x + np.random.randn(50))\nax.plot(x, np.sin(x) - 2 * x + np.random.randn(50))\nax.plot(x, np.sin(x) + np.random.randn(50))\nax.set_title(\"\\'fivethirtyeight\\' style sheet\")\n\nplt.show()\n",
    "id": 241
},
{
    "title": "ggplot style sheet#",
    "text": "This example demonstrates the \"ggplot\" style, which adjusts the style to\nemulate ggplot (a popular plotting package for R). These settings were shamelessly stolen from [1] (with permission). https://everyhue.me/posts/sane-color-scheme-for-matplotlib/ Download Python source code: ggplot.py Download Jupyter notebook: ggplot.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('ggplot')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, axs = plt.subplots(ncols=2, nrows=2)\nax1, ax2, ax3, ax4 = axs.flat\n\n# scatter plot (Note: `plt.scatter` doesn't use default colors)\nx, y = np.random.normal(size=(2, 200))\nax1.plot(x, y, 'o')\n\n# sinusoidal lines with colors from default color cycle\nL = 2*np.pi\nx = np.linspace(0, L)\nncolors = len(plt.rcParamsaxes.prop_cycle)\nshift = np.linspace(0, L, ncolors, endpoint=False)\nfor s in shift:\n    ax2.plot(x, np.sin(x + s), '-')\nax2.margins(0)\n\n# bar graphs\nx = np.arange(5)\ny1, y2 = np.random.randint(1, 25, size=(2, 5))\nwidth = 0.25\nax3.bar(x, y1, width)\nax3.bar(x + width, y2, width,\n        color=list(plt.rcParamsaxes.prop_cycle)[2]color)\nax3.set_xticks(x + width, labels=a b c d e)\n\n# circles with colors from default color cycle\nfor i, color in enumerate(plt.rcParamsaxes.prop_cycle):\n    xy = np.random.normal(size=2)\n    ax4.add_patch(plt.Circle(xy, radius=0.3, color=colorcolor))\nax4.axis('equal')\nax4.margins(0)\n\nplt.show()\n",
    "id": 242
},
{
    "title": "Grayscale style sheet#",
    "text": "This example demonstrates the \"grayscale\" style sheet, which changes all colors\nthat are defined as rcParams to grayscale. Note, however, that not all\nplot elements respect rcParams. Download Python source code: grayscale.py Download Jupyter notebook: grayscale.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef color_cycle_example(ax):\n    L = 6\n    x = np.linspace(0, L)\n    ncolors = len(plt.rcParams[\\'axes.prop_cycle\\)\n    shift = np.linspace(0, L, ncolors, endpoint=False)\n    for s in shift:\n        ax.plot(x, np.sin(x + s), \\'o-\\')\n\n\ndef image_and_patch_example(ax):\n    ax.imshow(np.random.random(size=(20, 20)), interpolation=\\'none\\')\n    c = plt.Circle((5, 5), radius=5, label=\\'patch\\')\n    ax.add_patch(c)\n\n\nplt.style.use(\\'grayscale\\')\n\nfig, (ax1, ax2) = plt.subplots(ncols=2)\nfig.suptitle(\"\\'grayscale\\' style sheet\")\n\ncolor_cycle_example(ax1)\nimage_and_patch_example(ax2)\n\nplt.show()\n",
    "id": 243
},
{
    "title": "Solarized Light stylesheet#",
    "text": "This shows an example of \"Solarized_Light\" styling, which\ntries to replicate the styles of: https://ethanschoonover.com/solarized/ jrnold/ggthemes http://www.pygal.org/en/stable/documentation/builtin_styles.html#light-solarized and work of: tonysyu/mpltools using all 8 accents of the color palette - starting with blue Still TODO: Create alpha values for bar and stacked charts. .33 or .5 Apply Layout Rules Download Python source code: plot_solarizedlight2.py Download Jupyter notebook: plot_solarizedlight2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.linspace(0, 10)\nwith plt.style.context('Solarize_Light2'):\n    plt.plot(x, np.sin(x) + x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 2 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 3 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 4 + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 5 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 6 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 7 * x + np.random.randn(50))\n    plt.plot(x, np.sin(x) + 8 * x + np.random.randn(50))\n    # Number of accent colors in the color scheme\n    plt.title('8 Random Lines - Line')\n    plt.xlabel('x label', fontsize=14)\n    plt.ylabel('y label', fontsize=14)\n\nplt.show()\n",
    "id": 244
},
{
    "title": "Style sheets reference#",
    "text": "This script demonstrates the different available style sheets on a\ncommon set of example plots: scatter plot, image, bar graph, patches,\nline plot and histogram. Any of these style sheets can be imported (i.e. activated) by its name.\nFor example for the ggplot style: The names of the available style sheets can be found\nin the list matplotlib.style.available\n(they are also printed in the corner of each plot below). See more details in Customizing Matplotlib\nusing style sheets. Total running time of the script: (0 minutes 25.381 seconds) Download Python source code: style_sheets_reference.py Download Jupyter notebook: style_sheets_reference.ipynb ",
    "code": ">>> plt.style.use('ggplot')\n\", 'import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Rectangle\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef plot_scatter(ax, prng, nb_samples=100):\n    \"\"\"Scatter plot.\"\"\"\n    for mu, sigma, marker in [(-.5, 0.75, \\'o\\'), (0.75, 1., \\'s\\')]:\n        x, y = prng.normal(loc=mu, scale=sigma, size=(2, nb_samples))\n        ax.plot(x, y, ls=\\'none\\', marker=marker)\n    ax.set_xlabel(\\'X-label\\')\n    ax.set_title(\\'Axes title\\')\n    return ax\n\n\ndef plot_colored_lines(ax):\n    \"\"\"Plot lines with colors following the style color cycle.\"\"\"\n    t = np.linspace(-10, 10, 100)\n\n    def sigmoid(t, t0):\n        return 1 / (1 + np.exp(-(t - t0)))\n\n    nb_colors = len(plt.rcParams[\\'axes.prop_cycle\\)\n    shifts = np.linspace(-5, 5, nb_colors)\n    amplitudes = np.linspace(1, 1.5, nb_colors)\n    for t0, a in zip(shifts, amplitudes):\n        ax.plot(t, a * sigmoid(t, t0), \\'-\\')\n    ax.set_xlim(-10, 10)\n    return ax\n\n\ndef plot_bar_graphs(ax, prng, min_value=5, max_value=25, nb_samples=5):\n    \"\"\"Plot two bar graphs side by side, with letters as x-tick labels.\"\"\"\n    x = np.arange(nb_samples)\n    ya, yb = prng.randint(min_value, max_value, size=(2, nb_samples))\n    width = 0.25\n    ax.bar(x, ya, width)\n    ax.bar(x + width, yb, width, color=\\'C2\\')\n    ax.set_xticks(x + width, labels=[\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\)\n    return ax\n\n\ndef plot_colored_circles(ax, prng, nb_samples=15):\n    \"\"\"\n    Plot circle patches.\n\n    NB: draws a fixed amount of samples, rather than using the length of\n    the color cycle, because different styles may have different numbers\n    of colors.\n    \"\"\"\n    for sty_dict, j in zip(plt.rcParams[\\'axes.prop_cycle\\(),\n                           range(nb_samples)):\n        ax.add_patch(plt.Circle(prng.normal(scale=3, size=2),\n                                radius=1.0, color=sty_dict[\\'color\\))\n    ax.grid(visible=True)\n\n    # Add title for enabling grid\n    plt.title(\\'ax.grid(True)\\', family=\\'monospace\\', fontsize=\\'small\\')\n\n    ax.set_xlim([-4, 8])\n    ax.set_ylim([-5, 6])\n    ax.set_aspect(\\'equal\\', adjustable=\\'box\\')  # to plot circles as circles\n    return ax\n\n\ndef plot_image_and_patch(ax, prng, size=(20, 20)):\n    \"\"\"Plot an image with random values and superimpose a circular patch.\"\"\"\n    values = prng.random_sample(size=size)\n    ax.imshow(values, interpolation=\\'none\\')\n    c = plt.Circle((5, 5), radius=5, label=\\'patch\\')\n    ax.add_patch(c)\n    # Remove ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\ndef plot_histograms(ax, prng, nb_samples=10000):\n    \"\"\"Plot 4 histograms and a text annotation.\"\"\"\n    params = ((10, 10), (4, 12), (50, 12), (6, 55))\n    for a, b in params:\n        values = prng.beta(a, b, size=nb_samples)\n        ax.hist(values, histtype=\"stepfilled\", bins=30,\n                alpha=0.8, density=True)\n\n    # Add a small annotation.\n    ax.annotate(\\'Annotation\\', xy=(0.25, 4.25),\n                xytext=(0.9, 0.9), textcoords=ax.transAxes,\n                va=\"top\", ha=\"right\",\n                bbox=dict(boxstyle=\"round\", alpha=0.2),\n                arrowprops=dict(\n                          arrowstyle=\"->\",\n                          connectionstyle=\"angle,angleA=-95,angleB=35,rad=10\"),\n                )\n    return ax\n\n\ndef plot_figure(style_label=\"\"):\n    \"\"\"Setup and plot the demonstration figure with a given style.\"\"\"\n    # Use a dedicated RandomState instance to draw the same \"random\" values\n    # across the different figures.\n    prng = np.random.RandomState(96917002)\n\n    fig, axs = plt.subplots(ncols=6, nrows=1, num=style_label,\n                            figsize=(14.8, 2.8), layout=\\'constrained\\')\n\n    # make a suptitle, in the same style for all subfigures,\n    # except those with dark backgrounds, which get a lighter color:\n    background_color = mcolors.rgb_to_hsv(\n        mcolors.to_rgb(plt.rcParams[\\'figure.facecolor\\))[2]\n    if background_color < 0.5:\n        title_color = [0.8, 0.8, 1]\n    else:\n        title_color = np.array([19, 6, 84]) / 256\n    fig.suptitle(style_label, x=0.01, ha=\\'left\\', color=title_color,\n                 fontsize=14, fontfamily=\\'DejaVu Sans\\', fontweight=\\'normal\\')\n\n    plot_scatter(axs[0], prng)\n    plot_image_and_patch(axs[1], prng)\n    plot_bar_graphs(axs[2], prng)\n    plot_colored_lines(axs[3])\n    plot_histograms(axs[4], prng)\n    plot_colored_circles(axs[5], prng)\n\n    # add divider\n    rec = Rectangle((1 + 0.025, -2), 0.05, 16,\n                    clip_on=False, color=\\'gray\\')\n\n    axs[4].add_artist(rec)\n\nif __name__ == \"__main__\":\n\n    # Set up a list of all available styles, in alphabetical order but\n    # the `default` and `classic` ones, which will be forced resp. in\n    # first and second position.\n    # styles with leading underscores are for internal use such as testing\n    # and plot types gallery. These are excluded here.\n    style_list = [\\'default\\', \\'classic\\ + sorted(\n        style for style in plt.style.available\n        if style != \\'classic\\' and not style.startswith(\\'_\\'))\n\n    # Plot a demonstration figure for every available style sheet.\n    for style_label in style_list:\n        with plt.rc_context({\"figure.max_open_warning\": len(style_list)}):\n            with plt.style.context(style_label):\n                plot_figure(style_label=style_label)\n\n    plt.show()\n",
    "id": 245
},
{
    "title": "Infinite lines#",
    "text": "axvline and axhline draw infinite vertical /\nhorizontal lines, at given x / y positions. They are usually used to mark\nspecial data values, e.g. in this example the center and limit values of the\nsigmoid function. axline draws infinite straight lines in arbitrary directions. axline can also be used with a transform parameter, which\napplies to the point, but not to the slope. This can be useful for drawing\ndiagonal grid lines with a fixed slope, which stay in place when the\nplot limits are moved. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.axhline / matplotlib.pyplot.axhline matplotlib.axes.Axes.axvline / matplotlib.pyplot.axvline matplotlib.axes.Axes.axline / matplotlib.pyplot.axline Download Python source code: axline.py Download Jupyter notebook: axline.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(-10, 10, 100)\nsig = 1 / (1 + np.exp(-t))\n\nplt.axhline(y=0, color=\"black\", linestyle=\"--\")\nplt.axhline(y=0.5, color=\"black\", linestyle=\":\")\nplt.axhline(y=1.0, color=\"black\", linestyle=\"--\")\nplt.axvline(color=\"grey\")\nplt.axline((0, 0.5), slope=0.25, color=\"black\", linestyle=(0, (5, 5)))\nplt.plot(t, sig, linewidth=2, label=r\"$\\\\sigma(t) = \\\\frac{1}{1 + e^{-t}}$\")\nplt.xlim(-10, 10)\nplt.xlabel(\"t\")\nplt.legend(fontsize=14)\nplt.show()\n', \"for pos in np.linspace(-2, 1, 10):\n    plt.axline((pos, 0), slope=0.5, color='k', transform=plt.gca().transAxes)\n\nplt.ylim([0, 1])\nplt.xlim([0, 1])\nplt.show()\n",
    "id": 247
},
{
    "title": "Simple plot#",
    "text": "A simple plot where a list of numbers are plotted against their index,\nresulting in a straight line. Use a format string (here, 'o-r') to set the\nmarkers (circles), linestyle (solid line) and color (red).\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.plot matplotlib.pyplot.ylabel matplotlib.pyplot.show Download Python source code: pyplot_simple.py Download Jupyter notebook: pyplot_simple.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4], 'o-r')\nplt.ylabel('some numbers')\nplt.show()\n",
    "id": 248
},
{
    "title": "Text and mathtext using pyplot#",
    "text": "Set the special text objects title, xlabel, and\nylabel through the dedicated pyplot functions. Additional text\nobjects can be placed in the axes using text. You can use TeX-like mathematical typesetting in all texts; see also\nWriting mathematical expressions. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.hist matplotlib.pyplot.xlabel matplotlib.pyplot.ylabel matplotlib.pyplot.text matplotlib.pyplot.grid matplotlib.pyplot.show Download Python source code: pyplot_text.py Download Jupyter notebook: pyplot_text.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.arange(0.0, 2.0, 0.01)\ns = np.sin(2*np.pi*t)\n\nplt.plot(t, s)\nplt.text(0, -1, r'Hello, world!', fontsize=15)\nplt.title(r'$\\\\mathcal{A}\\\\sin(\\\\omega t)$', fontsize=20)\nplt.xlabel('Time [s]')\nplt.ylabel('Voltage [mV]')\nplt.show()\n",
    "id": 249
},
{
    "title": "Multiple lines using pyplot#",
    "text": "Plot three datasets with a single call to plot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.plot / matplotlib.pyplot.plot Download Python source code: pyplot_three.py Download Jupyter notebook: pyplot_three.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# evenly sampled time at 200ms intervals\nt = np.arange(0., 5., 0.2)\n\n# red dashes, blue squares and green triangles\nplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')\nplt.show()\n",
    "id": 250
},
{
    "title": "Two subplots using pyplot#",
    "text": "Create a figure with two subplots using pyplot.subplot. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.pyplot.subplot Download Python source code: pyplot_two_subplots.py Download Jupyter notebook: pyplot_two_subplots.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.exp(-t) * np.cos(2*np.pi*t)\n\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\n\nplt.figure()\nplt.subplot(211)\nplt.plot(t1, f(t1), color='tab:blue', marker='o')\nplt.plot(t2, f(t2), color='black')\n\nplt.subplot(212)\nplt.plot(t2, np.cos(2*np.pi*t2), color='tab:orange', linestyle='--')\nplt.show()\n",
    "id": 251
},
{
    "title": "Anchored Direction Arrow#",
    "text": "Download Python source code: demo_anchored_direction_arrows.py Download Jupyter notebook: demo_anchored_direction_arrows.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.font_manager as fm\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredDirectionArrows\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.imshow(np.random.random((10, 10)))\n\n# Simple example\nsimple_arrow = AnchoredDirectionArrows(ax.transAxes, 'X Y')\nax.add_artist(simple_arrow)\n\n# High contrast arrow\nhigh_contrast_part_1 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'w fc': 'none alpha': 1,\n                                         'lw': 2}\n                            )\nax.add_artist(high_contrast_part_1)\n\nhigh_contrast_part_2 = AnchoredDirectionArrows(\n                            ax.transAxes,\n                            '111', r'11$\\\\overline{2}$',\n                            loc='upper right',\n                            arrow_props={'ec': 'none fc': 'k'},\n                            text_props={'ec': 'w fc': 'k lw': 0.4}\n                            )\nax.add_artist(high_contrast_part_2)\n\n# Rotated arrow\nfontprops = fm.FontProperties(family='serif')\n\nrotated_arrow = AnchoredDirectionArrows(\n                    ax.transAxes,\n                    '30 120',\n                    loc='center',\n                    color='w',\n                    angle=30,\n                    fontproperties=fontprops\n                    )\nax.add_artist(rotated_arrow)\n\n# Altering arrow directions\na1 = AnchoredDirectionArrows(\n        ax.transAxes, 'A B', loc='lower center',\n        length=-0.15,\n        sep_x=0.03, sep_y=0.03,\n        color='r'\n    )\nax.add_artist(a1)\n\na2 = AnchoredDirectionArrows(\n        ax.transAxes, 'A  B', loc='lower left',\n        aspect_ratio=-1,\n        sep_x=0.01, sep_y=-0.02,\n        color='orange'\n        )\nax.add_artist(a2)\n\n\na3 = AnchoredDirectionArrows(\n        ax.transAxes, ' A B', loc='lower right',\n        length=-0.15,\n        aspect_ratio=-1,\n        sep_y=-0.1, sep_x=0.04,\n        color='cyan'\n        )\nax.add_artist(a3)\n\nplt.show()\n",
    "id": 253
},
{
    "title": "Axes divider#",
    "text": "Axes divider to calculate location of axes and\ncreate a divider for them using existing axes instances. Download Python source code: demo_axes_divider.py Download Jupyter notebook: demo_axes_divider.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\n\n\ndef get_demo_image():\n    z = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\n    return z, (-3, 4, -4, 3)\n\n\ndef demo_simple_image(ax):\n    Z, extent = get_demo_image()\n\n    im = ax.imshow(Z, extent=extent)\n    cb = plt.colorbar(im)\n    cb.ax.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_locatable_axes_hard(fig):\n    from mpl_toolkits.axes_grid1 import Size, SubplotDivider\n\n    divider = SubplotDivider(fig, 2, 2, 2, aspect=True)\n\n    # axes for image\n    ax = fig.add_subplot(axes_locator=divider.new_locator(nx=0, ny=0))\n    # axes for colorbar\n    ax_cb = fig.add_subplot(axes_locator=divider.new_locator(nx=2, ny=0))\n\n    divider.set_horizontal([\n        Size.AxesX(ax),  # main axes\n        Size.Fixed(0.05),  # padding, 0.1 inch\n        Size.Fixed(0.2),  # colorbar, 0.3 inch\n    ])\n    divider.set_vertical([Size.AxesY(ax)])\n\n    Z, extent = get_demo_image()\n\n    im = ax.imshow(Z, extent=extent)\n    plt.colorbar(im, cax=ax_cb)\n    ax_cb.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_locatable_axes_easy(ax):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n    divider = make_axes_locatable(ax)\n\n    ax_cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n    fig = ax.get_figure()\n    fig.add_axes(ax_cb)\n\n    Z, extent = get_demo_image()\n    im = ax.imshow(Z, extent=extent)\n\n    plt.colorbar(im, cax=ax_cb)\n    ax_cb.yaxis.tick_right()\n    ax_cb.yaxis.set_tick_params(labelright=False)\n\n\ndef demo_images_side_by_side(ax):\n    from mpl_toolkits.axes_grid1 import make_axes_locatable\n\n    divider = make_axes_locatable(ax)\n\n    Z, extent = get_demo_image()\n    ax2 = divider.append_axes(\"right\", size=\"100%\", pad=0.05)\n    fig1 = ax.get_figure()\n    fig1.add_axes(ax2)\n\n    ax.imshow(Z, extent=extent)\n    ax2.imshow(Z, extent=extent)\n    ax2.yaxis.set_tick_params(labelleft=False)\n\n\ndef demo():\n    fig = plt.figure(figsize=(6, 6))\n\n    # PLOT 1\n    # simple image & colorbar\n    ax = fig.add_subplot(2, 2, 1)\n    demo_simple_image(ax)\n\n    # PLOT 2\n    # image and colorbar with draw-time positioning -- a hard way\n    demo_locatable_axes_hard(fig)\n\n    # PLOT 3\n    # image and colorbar with draw-time positioning -- an easy way\n    ax = fig.add_subplot(2, 2, 3)\n    demo_locatable_axes_easy(ax)\n\n    # PLOT 4\n    # two images side by side with fixed padding.\n    ax = fig.add_subplot(2, 2, 4)\n    demo_images_side_by_side(ax)\n\n    plt.show()\n\n\ndemo()\n",
    "id": 254
},
{
    "title": "Demo Axes Grid#",
    "text": "Grid of 2x2 images with a single colorbar or with one colorbar per axes. Download Python source code: demo_axes_grid.py Download Jupyter notebook: demo_axes_grid.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(10.5, 2.5))\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nextent = (-3, 4, -4, 3)\n\n\n# A grid of 2x2 images with 0.05 inch pad between images and only the\n# lower-left axes is labeled.\ngrid = ImageGrid(\n    fig, 141,  # similar to fig.add_subplot(141).\n     nrows_ncols=(2, 2), axes_pad=0.05, label_mode=\"1\")\nfor ax in grid:\n    ax.imshow(Z, extent=extent)\n# This only affects axes in first column and second row as share_all=False.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images with a single colorbar.\ngrid = ImageGrid(\n    fig, 142,  # similar to fig.add_subplot(142).\n    nrows_ncols=(2, 2), axes_pad=0.0, label_mode=\"L\", share_all=True,\n    cbar_location=\"top\", cbar_mode=\"single\")\nfor ax in grid:\n    im = ax.imshow(Z, extent=extent)\ngrid.cbar_axes[0].colorbar(im)\nfor cax in grid.cbar_axes:\n    cax.tick_params(labeltop=False)\n# This affects all axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images. Each image has its own colorbar.\ngrid = ImageGrid(\n    fig, 143,  # similar to fig.add_subplot(143).\n    nrows_ncols=(2, 2), axes_pad=0.1, label_mode=\"1\", share_all=True,\n    cbar_location=\"top\", cbar_mode=\"each\", cbar_size=\"7%\", cbar_pad=\"2%\")\nfor ax, cax in zip(grid, grid.cbar_axes):\n    im = ax.imshow(Z, extent=extent)\n    cax.colorbar(im)\n    cax.tick_params(labeltop=False)\n# This affects all axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\n# A grid of 2x2 images. Each image has its own colorbar.\ngrid = ImageGrid(\n    fig, 144,  # similar to fig.add_subplot(144).\n    nrows_ncols=(2, 2), axes_pad=(0.45, 0.15), label_mode=\"1\", share_all=True,\n    cbar_location=\"right\", cbar_mode=\"each\", cbar_size=\"7%\", cbar_pad=\"2%\")\n# Use a different colorbar range every time\nlimits = ((0, 1), (-2, 2), (-1.7, 1.4), (-1.5, 1))\nfor ax, cax, vlim in zip(grid, grid.cbar_axes, limits):\n    im = ax.imshow(Z, extent=extent, vmin=vlim[0], vmax=vlim[1])\n    cb = cax.colorbar(im)\n    cb.set_ticks((vlim[0], vlim[1]))\n# This affects all axes as share_all = True.\ngrid.axes_llc.set(xticks=[-2, 0, 2], yticks=[-2, 0, 2])\n\n\nplt.show()\n",
    "id": 255
},
{
    "title": "Axes Grid2#",
    "text": "Grid of images with shared xaxis and yaxis. Download Python source code: demo_axes_grid2.py Download Jupyter notebook: demo_axes_grid2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\n\ndef add_inner_title(ax, title, loc, **kwargs):\n    from matplotlib.offsetbox import AnchoredText\n    from matplotlib.patheffects import withStroke\n    prop = dict(path_effects=[withStroke(foreground=\\'w\\', linewidth=3)],\n                size=plt.rcParams[\\'legend.fontsize\\)\n    at = AnchoredText(title, loc=loc, prop=prop,\n                      pad=0., borderpad=0.5,\n                      frameon=False, **kwargs)\n    ax.add_artist(at)\n    return at\n\n\nfig = plt.figure(figsize=(6, 6))\n\n# Prepare images\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\nextent = (-3, 4, -4, 3)\nZS = [Z[i::3, :] for i in range(3)]\nextent = extent[0], extent[1]/3., extent[2], extent[3]\n\n# *** Demo 1: colorbar at each axes ***\ngrid = ImageGrid(\n    # 211 = at the position of fig.add_subplot(211)\n    fig, 211, nrows_ncols=(1, 3), axes_pad=0.05, label_mode=\"1\", share_all=True,\n    cbar_location=\"top\", cbar_mode=\"each\", cbar_size=\"7%\", cbar_pad=\"1%\")\ngrid[0].set(xticks=[-2, 0], yticks=[-2, 0, 2])\n\nfor i, (ax, z) in enumerate(zip(grid, ZS)):\n    im = ax.imshow(z, origin=\"lower\", extent=extent)\n    cb = ax.cax.colorbar(im)\n    # Changing the colorbar ticks\n    if i in [1, 2]:\n        cb.set_ticks([-1, 0, 1])\n\nfor ax, im_title in zip(grid, Image 1\", \"Image 2\", \"Image 3):\n    add_inner_title(ax, im_title, loc=\\'lower left\\')\n\n# *** Demo 2: shared colorbar ***\ngrid2 = ImageGrid(\n    fig, 212, nrows_ncols=(1, 3), axes_pad=0.05, label_mode=\"1\", share_all=True,\n    cbar_location=\"right\", cbar_mode=\"single\", cbar_size=\"10%\", cbar_pad=0.05)\ngrid2[0].set(xlabel=\"X\", ylabel=\"Y\", xticks=[-2, 0], yticks=[-2, 0, 2])\n\nclim = (np.min(ZS), np.max(ZS))\nfor ax, z in zip(grid2, ZS):\n    im = ax.imshow(z, clim=clim, origin=\"lower\", extent=extent)\n\n# With cbar_mode=\"single\", cax attribute of all axes are identical.\nax.cax.colorbar(im)\n\nfor ax, im_title in zip(grid2, (a)\", \"(b)\", \"(c)):\n    add_inner_title(ax, im_title, loc=\\'upper left\\')\n\nplt.show()\n",
    "id": 256
},
{
    "title": "HBoxDivider and VBoxDivider demo#",
    "text": "Using an HBoxDivider to arrange subplots.', \"Note that both axes' location are adjusted so that they have\nequal heights while maintaining their aspect ratios.\", 'Using a VBoxDivider to arrange subplots.', \"Note that both axes' location are adjusted so that they have\nequal widths while maintaining their aspect ratios.\", 'Download Python source code: demo_axes_hbox_divider.py Download Jupyter notebook: demo_axes_hbox_divider.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1.axes_divider import HBoxDivider, VBoxDivider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\narr1 = np.arange(20).reshape((4, 5))\narr2 = np.arange(20).reshape((5, 4))\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.imshow(arr1)\nax2.imshow(arr2)\n\npad = 0.5  # pad in inches\ndivider = HBoxDivider(\n    fig, 111,\n    horizontal=[Size.AxesX(ax1), Size.Fixed(pad), Size.AxesX(ax2)],\n    vertical=[Size.AxesY(ax1), Size.Scaled(1), Size.AxesY(ax2)])\nax1.set_axes_locator(divider.new_locator(0))\nax2.set_axes_locator(divider.new_locator(2))\n\nplt.show()\n fig, (ax1, ax2) = plt.subplots(2, 1)\nax1.imshow(arr1)\nax2.imshow(arr2)\n\ndivider = VBoxDivider(\n    fig, 111,\n    horizontal=[Size.AxesX(ax1), Size.Scaled(1), Size.AxesX(ax2)],\n    vertical=[Size.AxesY(ax1), Size.Fixed(pad), Size.AxesY(ax2)])\n\nax1.set_axes_locator(divider.new_locator(0))\nax2.set_axes_locator(divider.new_locator(2))\n\nplt.show()\n",
    "id": 257
},
{
    "title": "Showing RGB channels using RGBAxes#",
    "text": "RGBAxes creates a layout of 4 Axes for displaying RGB\nchannels: one large Axes for the RGB image and 3 smaller Axes for the R, G, B\nchannels. Download Python source code: demo_axes_rgb.py Download Jupyter notebook: demo_axes_rgb.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.axes_rgb import RGBAxes, make_rgb_axes\n\n\ndef get_rgb():\n    Z = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\n    Z[Z < 0] = 0.\n    Z = Z / Z.max()\n\n    R = Z[:13, :13]\n    G = Z[2:, 2:]\n    B = Z[:13, 2:]\n\n    return R, G, B\n\n\ndef make_cube(r, g, b):\n    ny, nx = r.shape\n    R = np.zeros((ny, nx, 3))\n    R[:, :, 0] = r\n    G = np.zeros_like(R)\n    G[:, :, 1] = g\n    B = np.zeros_like(R)\n    B[:, :, 2] = b\n\n    RGB = R + G + B\n\n    return R, G, B, RGB\n\n\ndef demo_rgb1():\n    fig = plt.figure()\n    ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8], pad=0.0)\n    r, g, b = get_rgb()\n    ax.imshow_rgb(r, g, b)\n\n\ndef demo_rgb2():\n    fig, ax = plt.subplots()\n    ax_r, ax_g, ax_b = make_rgb_axes(ax, pad=0.02)\n\n    r, g, b = get_rgb()\n    im_r, im_g, im_b, im_rgb = make_cube(r, g, b)\n    ax.imshow(im_rgb)\n    ax_r.imshow(im_r)\n    ax_g.imshow(im_g)\n    ax_b.imshow(im_b)\n\n    for ax in fig.axes:\n        ax.tick_params(direction=\\'in\\', color=\\'w\\')\n        ax.spines[:].set_color(\"w\")\n\n\ndemo_rgb1()\ndemo_rgb2()\n\nplt.show()\n",
    "id": 258
},
{
    "title": "Adding a colorbar to inset axes#",
    "text": "Download Python source code: demo_colorbar_of_inset_axes.py Download Jupyter notebook: demo_colorbar_of_inset_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes, zoomed_inset_axes\n\nfig, ax = plt.subplots(figsize=[5, 4])\nax.set(aspect=1, xlim=(-15, 15), ylim=(-20, 5))\n\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\nextent = (-3, 4, -4, 3)\n\naxins = zoomed_inset_axes(ax, zoom=2, loc=\\'upper left\\')\naxins.set(xticks=[], yticks=[])\nim = axins.imshow(Z, extent=extent, origin=\"lower\")\n\n# colorbar\ncax = inset_axes(axins,\n                 width=\"5%\",  # width = 10% of parent_bbox width\n                 height=\"100%\",  # height : 50%\n                 loc=\\'lower left\\',\n                 bbox_to_anchor=(1.05, 0., 1, 1),\n                 bbox_transform=axins.transAxes,\n                 borderpad=0,\n                 )\nfig.colorbar(im, cax=cax)\n\nplt.show()\n",
    "id": 259
},
{
    "title": "Colorbar with AxesDivider#",
    "text": "The axes_divider.make_axes_locatable function takes an existing axes, adds\nit to a new AxesDivider and returns the AxesDivider. The append_axes\nmethod of the AxesDivider can then be used to create a new axes on a given\nside (\"top\", \"right\", \"bottom\", or \"left\") of the original axes. This example\nuses append_axes to add colorbars next to axes. Download Python source code: demo_colorbar_with_axes_divider.py Download Jupyter notebook: demo_colorbar_with_axes_divider.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.subplots_adjust(wspace=0.5)\n\nim1 = ax1.imshow([[1, 2], [3, 4]])\nax1_divider = make_axes_locatable(ax1)\n# Add an Axes to the right of the main Axes.\ncax1 = ax1_divider.append_axes(\"right\", size=\"7%\", pad=\"2%\")\ncb1 = fig.colorbar(im1, cax=cax1)\n\nim2 = ax2.imshow([[1, 2], [3, 4]])\nax2_divider = make_axes_locatable(ax2)\n# Add an Axes above the main Axes.\ncax2 = ax2_divider.append_axes(\"top\", size=\"7%\", pad=\"2%\")\ncb2 = fig.colorbar(im2, cax=cax2, orientation=\"horizontal\")\n# Change tick position to top (with the default tick position \"bottom\", ticks\n# overlap the image).\ncax2.xaxis.set_ticks_position(\"top\")\n\nplt.show()\n",
    "id": 260
},
{
    "title": "Controlling the position and size of colorbars with Inset Axes#",
    "text": "This example shows how to control the position, height, and width of\ncolorbars using inset_axes. Inset axes placement is controlled as for legends: either by providing a loc\noption (\"upper right\", \"best\", ...), or by providing a locator with respect to\nthe parent bbox. Parameters such as bbox_to_anchor and borderpad likewise\nwork in the same way, and are also demonstrated here. Download Python source code: demo_colorbar_with_inset_locator.py Download Jupyter notebook: demo_colorbar_with_inset_locator.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=[6, 3])\n\nim1 = ax1.imshow([[1, 2], [2, 3]])\naxins1 = inset_axes(\n    ax1,\n    width=\"50%\",  # width: 50% of parent_bbox width\n    height=\"5%\",  # height: 5%\n    loc=\"upper right\",\n)\naxins1.xaxis.set_ticks_position(\"bottom\")\nfig.colorbar(im1, cax=axins1, orientation=\"horizontal\", ticks=[1, 2, 3])\n\nim = ax2.imshow([[1, 2], [2, 3]])\naxins = inset_axes(\n    ax2,\n    width=\"5%\",  # width: 5% of parent_bbox width\n    height=\"50%\",  # height: 50%\n    loc=\"lower left\",\n    bbox_to_anchor=(1.05, 0., 1, 1),\n    bbox_transform=ax2.transAxes,\n    borderpad=0,\n)\nfig.colorbar(im, cax=axins, ticks=[1, 2, 3])\n\nplt.show()\n",
    "id": 261
},
{
    "title": "Per-row or per-column colorbars#",
    "text": "This example shows how to use one common colorbar for each row or column\nof an image grid. Download Python source code: demo_edge_colorbar.py Download Jupyter notebook: demo_edge_colorbar.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import AxesGrid\n\n\ndef get_demo_image():\n    z = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\n    return z, (-3, 4, -4, 3)\n\n\ndef demo_bottom_cbar(fig):\n    \"\"\"\n    A grid of 2x2 images with a colorbar for each column.\n    \"\"\"\n    grid = AxesGrid(fig, 121,  # similar to subplot(121)\n                    nrows_ncols=(2, 2),\n                    axes_pad=0.10,\n                    share_all=True,\n                    label_mode=\"1\",\n                    cbar_location=\"bottom\",\n                    cbar_mode=\"edge\",\n                    cbar_pad=0.25,\n                    cbar_size=\"15%\",\n                    direction=\"column\"\n                    )\n\n    Z, extent = get_demo_image()\n    cmaps = autumn\", \"summer\n    for i in range(4):\n        im = grid[i].imshow(Z, extent=extent, cmap=cmaps[i//2])\n        if i % 2:\n            grid.cbar_axes[i//2].colorbar(im)\n\n    for cax in grid.cbar_axes:\n        cax.axis[cax.orientation].set_label(\"Bar\")\n\n    # This affects all axes as share_all = True.\n    grid.axes_llc.set_xticks([-2, 0, 2])\n    grid.axes_llc.set_yticks([-2, 0, 2])\n\n\ndef demo_right_cbar(fig):\n    \"\"\"\n    A grid of 2x2 images. Each row has its own colorbar.\n    \"\"\"\n    grid = AxesGrid(fig, 122,  # similar to subplot(122)\n                    nrows_ncols=(2, 2),\n                    axes_pad=0.10,\n                    label_mode=\"1\",\n                    share_all=True,\n                    cbar_location=\"right\",\n                    cbar_mode=\"edge\",\n                    cbar_size=\"7%\",\n                    cbar_pad=\"2%\",\n                    )\n    Z, extent = get_demo_image()\n    cmaps = spring\", \"winter\n    for i in range(4):\n        im = grid[i].imshow(Z, extent=extent, cmap=cmaps[i//2])\n        if i % 2:\n            grid.cbar_axes[i//2].colorbar(im)\n\n    for cax in grid.cbar_axes:\n        cax.axis[cax.orientation].set_label(\\'Foo\\')\n\n    # This affects all axes because we set share_all = True.\n    grid.axes_llc.set_xticks([-2, 0, 2])\n    grid.axes_llc.set_yticks([-2, 0, 2])\n\n\nfig = plt.figure()\n\ndemo_bottom_cbar(fig)\ndemo_right_cbar(fig)\n\nplt.show()\n",
    "id": 262
},
{
    "title": "Axes with a fixed physical size#",
    "text": "Note that this can be accomplished with the main library for\nAxes on Figures that do not change size: Adding single Axes at a time Download Python source code: demo_fixed_size_axes.py Download Jupyter notebook: demo_fixed_size_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider, Size\n fig = plt.figure(figsize=(6, 6))\n\n# The first items are for padding and the second items are for the axes.\n# sizes are in inch.\nh = [Size.Fixed(1.0), Size.Fixed(4.5)]\nv = [Size.Fixed(0.7), Size.Fixed(5.)]\n\ndivider = Divider(fig, (0, 0, 1, 1), h, v, aspect=False)\n# The width and height of the rectangle are ignored.\n\nax = fig.add_axes(divider.get_position(),\n                  axes_locator=divider.new_locator(nx=1, ny=1))\n\nax.plot([1, 2, 3])\n fig = plt.figure(figsize=(6, 6))\n\n# The first & third items are for padding and the second items are for the\n# axes. Sizes are in inches.\nh = [Size.Fixed(1.0), Size.Scaled(1.), Size.Fixed(.2)]\nv = [Size.Fixed(0.7), Size.Scaled(1.), Size.Fixed(.5)]\n\ndivider = Divider(fig, (0, 0, 1, 1), h, v, aspect=False)\n# The width and height of the rectangle are ignored.\n\nax = fig.add_axes(divider.get_position(),\n                  axes_locator=divider.new_locator(nx=1, ny=1))\n\nax.plot([1, 2, 3])\n\nplt.show()\n",
    "id": 263
},
{
    "title": "Setting a fixed aspect on ImageGrid cells#",
    "text": "Download Python source code: demo_imagegrid_aspect.py Download Jupyter notebook: demo_imagegrid_aspect.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure()\n\ngrid1 = ImageGrid(fig, 121, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [0, 1]:\n    grid1[i].set_aspect(2)\n\ngrid2 = ImageGrid(fig, 122, (2, 2), axes_pad=0.1,\n                  aspect=True, share_all=True)\nfor i in [1, 3]:\n    grid2[i].set_aspect(2)\n\nplt.show()\n",
    "id": 264
},
{
    "title": "Inset locator demo#",
    "text": "The inset_locator's inset_axes allows\neasily placing insets in the corners of the axes by specifying a width and\nheight and optionally a location (loc) that accepts locations as codes,\nsimilar to legend.\nBy default, the inset is offset by some points from the axes,\ncontrolled via the borderpad parameter.\", 'The parameters bbox_to_anchor and bbox_transform can be used for a more\nfine-grained control over the inset position and size or even to position\nthe inset at completely arbitrary positions.\nThe bbox_to_anchor sets the bounding box in coordinates according to the\nbbox_transform. In the above the axes transform together with 4-tuple bounding boxes has been\nused as it mostly is useful to specify an inset relative to the axes it is\nan inset to. However, other use cases are equally possible. The following\nexample examines some of those. Download Python source code: inset_locator_demo.py Download Jupyter notebook: inset_locator_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfig, (ax, ax2) = plt.subplots(1, 2, figsize=[5.5, 2.8])\n\n# Create inset of width 1.3 inches and height 0.9 inches\n# at the default upper right location\naxins = inset_axes(ax, width=1.3, height=0.9)\n\n# Create inset of width 30% and height 40% of the parent axes\\' bounding box\n# at the lower left corner (loc=3)\naxins2 = inset_axes(ax, width=\"30%\", height=\"40%\", loc=3)\n\n# Create inset of mixed specifications in the second subplot;\n# width is 30% of parent axes\\' bounding box and\n# height is 1 inch at the upper left corner (loc=2)\naxins3 = inset_axes(ax2, width=\"30%\", height=1., loc=2)\n\n# Create an inset in the lower right corner (loc=4) with borderpad=1, i.e.\n# 10 points padding (as 10pt is the default fontsize) to the parent axes\naxins4 = inset_axes(ax2, width=\"20%\", height=\"20%\", loc=4, borderpad=1)\n\n# Turn ticklabels of insets off\nfor axi in [axins, axins2, axins3, axins4]:\n    axi.tick_params(labelleft=False, labelbottom=False)\n\nplt.show()\n fig = plt.figure(figsize=[5.5, 2.8])\nax = fig.add_subplot(121)\n\n# We use the axes transform as bbox_transform. Therefore, the bounding box\n# needs to be specified in axes coordinates ((0, 0) is the lower left corner\n# of the axes, (1, 1) is the upper right corner).\n# The bounding box (.2, .4, .6, .5) starts at (.2, .4) and ranges to (.8, .9)\n# in those coordinates.\n# Inside this bounding box an inset of half the bounding box\\' width and\n# three quarters of the bounding box\\' height is created. The lower left corner\n# of the inset is aligned to the lower left corner of the bounding box (loc=3).\n# The inset is then offset by the default 0.5 in units of the font size.\n\naxins = inset_axes(ax, width=\"50%\", height=\"75%\",\n                   bbox_to_anchor=(.2, .4, .6, .5),\n                   bbox_transform=ax.transAxes, loc=3)\n\n# For visualization purposes we mark the bounding box by a rectangle\nax.add_patch(plt.Rectangle((.2, .4), .6, .5, ls=\"--\", ec=\"c\", fc=\"none\",\n                           transform=ax.transAxes))\n\n# We set the axis limits to something other than the default, in order to not\n# distract from the fact that axes coordinates are used here.\nax.set(xlim=(0, 10), ylim=(0, 10))\n\n\n# Note how the two following insets are created at the same positions, one by\n# use of the default parent axes\\' bbox and the other via a bbox in axes\n# coordinates and the respective transform.\nax2 = fig.add_subplot(222)\naxins2 = inset_axes(ax2, width=\"30%\", height=\"50%\")\n\nax3 = fig.add_subplot(224)\naxins3 = inset_axes(ax3, width=\"100%\", height=\"100%\",\n                    bbox_to_anchor=(.7, .5, .3, .5),\n                    bbox_transform=ax3.transAxes)\n\n# For visualization purposes we mark the bounding box by a rectangle\nax2.add_patch(plt.Rectangle((0, 0), 1, 1, ls=\"--\", lw=2, ec=\"c\", fc=\"none\"))\nax3.add_patch(plt.Rectangle((.7, .5), .3, .5, ls=\"--\", lw=2,\n                            ec=\"c\", fc=\"none\"))\n\n# Turn ticklabels off\nfor axi in [axins2, axins3, ax2, ax3]:\n    axi.tick_params(labelleft=False, labelbottom=False)\n\nplt.show()\n fig = plt.figure(figsize=[5.5, 2.8])\nax = fig.add_subplot(131)\n\n# Create an inset outside the axes\naxins = inset_axes(ax, width=\"100%\", height=\"100%\",\n                   bbox_to_anchor=(1.05, .6, .5, .4),\n                   bbox_transform=ax.transAxes, loc=2, borderpad=0)\naxins.tick_params(left=False, right=True, labelleft=False, labelright=True)\n\n# Create an inset with a 2-tuple bounding box. Note that this creates a\n# bbox without extent. This hence only makes sense when specifying\n# width and height in absolute units (inches).\naxins2 = inset_axes(ax, width=0.5, height=0.4,\n                    bbox_to_anchor=(0.33, 0.25),\n                    bbox_transform=ax.transAxes, loc=3, borderpad=0)\n\n\nax2 = fig.add_subplot(133)\nax2.set_xscale(\"log\")\nax2.set(xlim=(1e-6, 1e6), ylim=(-2, 6))\n\n# Create inset in data coordinates using ax.transData as transform\naxins3 = inset_axes(ax2, width=\"100%\", height=\"100%\",\n                    bbox_to_anchor=(1e-2, 2, 1e3, 3),\n                    bbox_transform=ax2.transData, loc=2, borderpad=0)\n\n# Create an inset horizontally centered in figure coordinates and vertically\n# bound to line up with the axes.\nfrom matplotlib.transforms import blended_transform_factory  # noqa\n\ntransform = blended_transform_factory(fig.transFigure, ax2.transAxes)\naxins4 = inset_axes(ax2, width=\"16%\", height=\"34%\",\n                    bbox_to_anchor=(0, 0, 1, 1),\n                    bbox_transform=transform, loc=8, borderpad=0)\n\nplt.show()\n",
    "id": 265
},
{
    "title": "Inset locator demo 2#",
    "text": "This demo shows how to create a zoomed inset via zoomed_inset_axes.\nIn the first subplot an AnchoredSizeBar shows the zoom effect.\nIn the second subplot a connection to the region of interest is\ncreated via mark_inset. A version of the second subplot, not using the toolkit, is available in\nZoom region inset axes. Download Python source code: inset_locator_demo2.py Download Jupyter notebook: inset_locator_demo2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nfrom mpl_toolkits.axes_grid1.inset_locator import mark_inset, zoomed_inset_axes\n\nfig, (ax, ax2) = plt.subplots(ncols=2, figsize=[6, 3])\n\n\n# First subplot, showing an inset with a size bar.\nax.set_aspect(1)\n\naxins = zoomed_inset_axes(ax, zoom=0.5, loc=\\'upper right\\')\n# fix the number of ticks on the inset axes\naxins.yaxis.get_major_locator().set_params(nbins=7)\naxins.xaxis.get_major_locator().set_params(nbins=7)\naxins.tick_params(labelleft=False, labelbottom=False)\n\n\ndef add_sizebar(ax, size):\n    asb = AnchoredSizeBar(ax.transData,\n                          size,\n                          str(size),\n                          loc=8,\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\nadd_sizebar(ax, 0.5)\nadd_sizebar(axins, 0.5)\n\n\n# Second subplot, showing an image with an inset zoom and a marked inset\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")  # 15x15 array\nextent = (-3, 4, -4, 3)\nZ2 = np.zeros((150, 150))\nny, nx = Z.shape\nZ2[30:30+ny, 30:30+nx] = Z\n\nax2.imshow(Z2, extent=extent, origin=\"lower\")\n\naxins2 = zoomed_inset_axes(ax2, zoom=6, loc=1)\naxins2.imshow(Z2, extent=extent, origin=\"lower\")\n\n# subregion of the original image\nx1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9\naxins2.set_xlim(x1, x2)\naxins2.set_ylim(y1, y2)\n# fix the number of ticks on the inset axes\naxins2.yaxis.get_major_locator().set_params(nbins=7)\naxins2.xaxis.get_major_locator().set_params(nbins=7)\naxins2.tick_params(labelleft=False, labelbottom=False)\n\n# draw a bbox of the region of the inset axes in the parent axes and\n# connecting lines between the bbox and the inset axes area\nmark_inset(ax2, axins2, loc1=2, loc2=4, fc=\"none\", ec=\"0.5\")\n\nplt.show()\n",
    "id": 266
},
{
    "title": "Make room for ylabel using axes_grid#",
    "text": "Total running time of the script: (0 minutes 1.345 seconds) Download Python source code: make_room_for_ylabel_using_axesgrid.py Download Jupyter notebook: make_room_for_ylabel_using_axesgrid.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_area_auto_adjustable\n\nfig = plt.figure()\nax = fig.add_axes([0, 0, 1, 1])\n\nax.set_yticks([0.5], labels=very long label)\n\nmake_axes_area_auto_adjustable(ax)\n fig = plt.figure()\nax1 = fig.add_axes([0, 0, 1, 0.5])\nax2 = fig.add_axes([0, 0.5, 1, 0.5])\n\nax1.set_yticks([0.5], labels=very long label)\nax1.set_ylabel(\"Y label\")\n\nax2.set_title(\"Title\")\n\nmake_axes_area_auto_adjustable(ax1, pad=0.1, use_axes=[ax1, ax2])\nmake_axes_area_auto_adjustable(ax2, pad=0.1, use_axes=[ax1, ax2])\n fig = plt.figure()\nax1 = fig.add_axes([0, 0, 1, 1])\ndivider = make_axes_locatable(ax1)\n\nax2 = divider.append_axes(\"right\", \"100%\", pad=0.3, sharey=ax1)\nax2.tick_params(labelleft=False)\nfig.add_axes(ax2)\n\ndivider.add_auto_adjustable_area(use_axes=[ax1], pad=0.1,\n                                 adjust_dirs=left)\ndivider.add_auto_adjustable_area(use_axes=[ax2], pad=0.1,\n                                 adjust_dirs=right)\ndivider.add_auto_adjustable_area(use_axes=[ax1, ax2], pad=0.1,\n                                 adjust_dirs=top\", \"bottom)\n\nax1.set_yticks([0.5], labels=very long label)\n\nax2.set_title(\"Title\")\nax2.set_xlabel(\"X - Label\")\n\nplt.show()\n",
    "id": 267
},
{
    "title": "Parasite Simple#",
    "text": "Download Python source code: parasite_simple.py Download Jupyter notebook: parasite_simple.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111)\npar = host.twinx()\n\nhost.set_xlabel(\"Distance\")\nhost.set_ylabel(\"Density\")\npar.set_ylabel(\"Temperature\")\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\n\nhost.legend(labelcolor=\"linecolor\")\n\nhost.yaxis.get_label().set_color(p1.get_color())\npar.yaxis.get_label().set_color(p2.get_color())\n\nplt.show()\n",
    "id": 268
},
{
    "title": "Parasite Simple2#",
    "text": "Download Python source code: parasite_simple2.py Download Jupyter notebook: parasite_simple2.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\nfrom mpl_toolkits.axes_grid1.parasite_axes import HostAxes\n\nobs = [01_S1\", 3.88, 0.14, 1970, 63],\n       01_S4\", 5.6, 0.82, 1622, 150],\n       02_S1\", 2.4, 0.54, 1570, 40],\n       03_S1\", 4.1, 0.62, 2380, 170]]\n\n\nfig = plt.figure()\n\nax_kms = fig.add_subplot(axes_class=HostAxes, aspect=1)\n\n# angular proper motion(\"/yr) to linear velocity(km/s) at distance=2.3kpc\npm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5\n\naux_trans = mtransforms.Affine2D().scale(pm_to_kms, 1.)\nax_pm = ax_kms.twin(aux_trans)\n\nfor n, ds, dse, w, we in obs:\n    time = ((2007 + (10. + 4/30.)/12) - 1988.5)\n    v = ds / time * pm_to_kms\n    ve = dse / time * pm_to_kms\n    ax_kms.errorbar([v], [w], xerr=[ve], yerr=[we], color=\"k\")\n\n\nax_kms.axisbottom.set_label(\"Linear velocity at 2.3 kpc [km/s]\")\nax_kms.axisleft.set_label(\"FWHM [km/s]\")\nax_pm.axistop.set_label(r\"Proper Motion [$\\'\\'$/yr]\")\nax_pm.axistop.label.set_visible(True)\nax_pm.axisright.major_ticklabels.set_visible(False)\n\nax_kms.set_xlim(950, 3700)\nax_kms.set_ylim(950, 3100)\n# xlim and ylim of ax_pms will be automatically adjusted.\n\nplt.show()\n",
    "id": 269
},
{
    "title": "Scatter Histogram (Locatable Axes)#",
    "text": "Show the marginal distributions of a scatter plot as histograms at the sides of\nthe plot. For a nice alignment of the main axes with the marginals, the axes positions\nare defined by a Divider, produced via make_axes_locatable. Note that\nthe Divider API allows setting axes sizes and pads in inches, which is its\nmain feature. If one wants to set axes sizes and pads relative to the main Figure, see the\nScatter plot with histograms example. References The use of the following functions, methods, classes and modules is shown\nin this example: mpl_toolkits.axes_grid1.axes_divider.make_axes_locatable matplotlib.axes.Axes.set_aspect matplotlib.axes.Axes.scatter matplotlib.axes.Axes.hist Download Python source code: scatter_hist_locatable_axes.py Download Jupyter notebook: scatter_hist_locatable_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# the random data\nx = np.random.randn(1000)\ny = np.random.randn(1000)\n\n\nfig, ax = plt.subplots(figsize=(5.5, 5.5))\n\n# the scatter plot:\nax.scatter(x, y)\n\n# Set aspect of the main axes.\nax.set_aspect(1.)\n\n# create new axes on the right and on the top of the current axes\ndivider = make_axes_locatable(ax)\n# below height and pad are in inches\nax_histx = divider.append_axes(\"top\", 1.2, pad=0.1, sharex=ax)\nax_histy = divider.append_axes(\"right\", 1.2, pad=0.1, sharey=ax)\n\n# make some labels invisible\nax_histx.xaxis.set_tick_params(labelbottom=False)\nax_histy.yaxis.set_tick_params(labelleft=False)\n\n# now determine nice limits by hand:\nbinwidth = 0.25\nxymax = max(np.max(np.abs(x)), np.max(np.abs(y)))\nlim = (int(xymax/binwidth) + 1)*binwidth\n\nbins = np.arange(-lim, lim + binwidth, binwidth)\nax_histx.hist(x, bins=bins)\nax_histy.hist(y, bins=bins, orientation=\\'horizontal\\')\n\n# the xaxis of ax_histx and yaxis of ax_histy are shared with ax,\n# thus there is no need to manually adjust the xlim and ylim of these\n# axis.\n\nax_histx.set_yticks([0, 50, 100])\nax_histy.set_xticks([0, 50, 100])\n\nplt.show()\n",
    "id": 270
},
{
    "title": "Simple Anchored Artists#",
    "text": "This example illustrates the use of the anchored helper classes found in\nmatplotlib.offsetbox and in mpl_toolkits.axes_grid1.\nAn implementation of a similar figure, but without use of the toolkit,\ncan be found in Anchored Artists. Download Python source code: simple_anchored_artists.py Download Jupyter notebook: simple_anchored_artists.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef draw_text(ax):\n    \"\"\"\n    Draw two text-boxes, anchored by different corners to the upper-left\n    corner of the figure.\n    \"\"\"\n    from matplotlib.offsetbox import AnchoredText\n    at = AnchoredText(\"Figure 1a\",\n                      loc=\\'upper left\\', prop=dict(size=8), frameon=True,\n                      )\n    at.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(at)\n\n    at2 = AnchoredText(\"Figure 1(b)\",\n                       loc=\\'lower left\\', prop=dict(size=8), frameon=True,\n                       bbox_to_anchor=(0., 1.),\n                       bbox_transform=ax.transAxes\n                       )\n    at2.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(at2)\n\n\ndef draw_circle(ax):\n    \"\"\"\n    Draw a circle in axis coordinates\n    \"\"\"\n    from matplotlib.patches import Circle\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea\n    ada = AnchoredDrawingArea(20, 20, 0, 0,\n                              loc=\\'upper right\\', pad=0., frameon=False)\n    p = Circle((10, 10), 10)\n    ada.da.add_artist(p)\n    ax.add_artist(ada)\n\n\ndef draw_sizebar(ax):\n    \"\"\"\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label underneath.\n    \"\"\"\n    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\n    asb = AnchoredSizeBar(ax.transData,\n                          0.1,\n                          r\"1$^{\\\\prime}$\",\n                          loc=\\'lower center\\',\n                          pad=0.1, borderpad=0.5, sep=5,\n                          frameon=False)\n    ax.add_artist(asb)\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1.)\n\ndraw_text(ax)\ndraw_circle(ax)\ndraw_sizebar(ax)\n\nplt.show()\n",
    "id": 271
},
{
    "title": "Simple Axes Divider 1#",
    "text": "See also The axes_grid1 toolkit. Fixed axes sizes; fixed paddings. Axes sizes that scale with the figure size; fixed paddings. Download Python source code: simple_axes_divider1.py Download Jupyter notebook: simple_axes_divider1.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider, Size\n\n\ndef label_axes(ax, text):\n    \"\"\"Place a label at the center of an Axes, and remove the axis ticks.\"\"\"\n    ax.text(.5, .5, text, transform=ax.transAxes,\n            horizontalalignment=\"center\", verticalalignment=\"center\")\n    ax.tick_params(bottom=False, labelbottom=False,\n                   left=False, labelleft=False)\n fig = plt.figure(figsize=(6, 6))\nfig.suptitle(\"Fixed axes sizes, fixed paddings\")\n\n# Sizes are in inches.\nhoriz = [Size.Fixed(1.), Size.Fixed(.5), Size.Fixed(1.5), Size.Fixed(.5)]\nvert = [Size.Fixed(1.5), Size.Fixed(.5), Size.Fixed(1.)]\n\nrect = (0.1, 0.1, 0.8, 0.8)\n# Divide the axes rectangle into a grid with sizes specified by horiz * vert.\ndiv = Divider(fig, rect, horiz, vert, aspect=False)\n\n# The rect parameter will actually be ignored and overridden by axes_locator.\nax1 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=0))\nlabel_axes(ax1, \"nx=0, ny=0\")\nax2 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=2))\nlabel_axes(ax2, \"nx=0, ny=2\")\nax3 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, ny=2))\nlabel_axes(ax3, \"nx=2, ny=2\")\nax4 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, nx1=4, ny=0))\nlabel_axes(ax4, \"nx=2, nx1=4, ny=0\")\n fig = plt.figure(figsize=(6, 6))\nfig.suptitle(\"Scalable axes sizes, fixed paddings\")\n\nhoriz = [Size.Scaled(1.5), Size.Fixed(.5), Size.Scaled(1.), Size.Scaled(.5)]\nvert = [Size.Scaled(1.), Size.Fixed(.5), Size.Scaled(1.5)]\n\nrect = (0.1, 0.1, 0.8, 0.8)\n# Divide the axes rectangle into a grid with sizes specified by horiz * vert.\ndiv = Divider(fig, rect, horiz, vert, aspect=False)\n\n# The rect parameter will actually be ignored and overridden by axes_locator.\nax1 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=0))\nlabel_axes(ax1, \"nx=0, ny=0\")\nax2 = fig.add_axes(rect, axes_locator=div.new_locator(nx=0, ny=2))\nlabel_axes(ax2, \"nx=0, ny=2\")\nax3 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, ny=2))\nlabel_axes(ax3, \"nx=2, ny=2\")\nax4 = fig.add_axes(rect, axes_locator=div.new_locator(nx=2, nx1=4, ny=0))\nlabel_axes(ax4, \"nx=2, nx1=4, ny=0\")\n\nplt.show()\n",
    "id": 272
},
{
    "title": "Simple axes divider 3#",
    "text": "See also The axes_grid1 toolkit. Download Python source code: simple_axes_divider3.py Download Jupyter notebook: simple_axes_divider3.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axes_grid1 import Divider\nimport mpl_toolkits.axes_grid1.axes_size as Size\n\nfig = plt.figure(figsize=(5.5, 4))\n\n# the rect parameter will be ignored as we will set axes_locator\nrect = (0.1, 0.1, 0.8, 0.8)\nax = [fig.add_axes(rect, label=\"%d\" % i) for i in range(4)]\n\n\nhoriz = [Size.AxesX(ax[0]), Size.Fixed(.5), Size.AxesX(ax[1])]\nvert = [Size.AxesY(ax[0]), Size.Fixed(.5), Size.AxesY(ax[2])]\n\n# divide the axes rectangle into grid whose size is specified by horiz * vert\ndivider = Divider(fig, rect, horiz, vert, aspect=False)\n\n\nax[0].set_axes_locator(divider.new_locator(nx=0, ny=0))\nax[1].set_axes_locator(divider.new_locator(nx=2, ny=0))\nax[2].set_axes_locator(divider.new_locator(nx=0, ny=2))\nax[3].set_axes_locator(divider.new_locator(nx=2, ny=2))\n\nax[0].set_xlim(0, 2)\nax[1].set_xlim(0, 1)\n\nax[0].set_ylim(0, 1)\nax[2].set_ylim(0, 2)\n\ndivider.set_aspect(1.)\n\nfor ax1 in ax:\n    ax1.tick_params(labelbottom=False, labelleft=False)\n\nplt.show()\n",
    "id": 273
},
{
    "title": "Simple ImageGrid#",
    "text": "Align multiple images using ImageGrid. Download Python source code: simple_axesgrid.py Download Jupyter notebook: simple_axesgrid.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nim1 = np.arange(100).reshape((10, 10))\nim2 = im1.T\nim3 = np.flipud(im1)\nim4 = np.fliplr(im2)\n\nfig = plt.figure(figsize=(4., 4.))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(2, 2),  # creates 2x2 grid of axes\n                 axes_pad=0.1,  # pad between axes in inch.\n                 )\n\nfor ax, im in zip(grid, [im1, im2, im3, im4]):\n    # Iterating over the grid returns the Axes.\n    ax.imshow(im)\n\nplt.show()\n",
    "id": 274
},
{
    "title": "Simple ImageGrid 2#",
    "text": "Align multiple images of different sizes using\nImageGrid. Download Python source code: simple_axesgrid2.py Download Jupyter notebook: simple_axesgrid2.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cbook\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(5.5, 3.5))\ngrid = ImageGrid(fig, 111,  # similar to subplot(111)\n                 nrows_ncols=(1, 3),\n                 axes_pad=0.1,\n                 label_mode=\"L\",\n                 )\n\n# demo image\nZ = cbook.get_sample_data(\"axes_grid/bivariate_normal.npy\")\nim1 = Z\nim2 = Z[:, :10]\nim3 = Z[:, 10:]\nvmin, vmax = Z.min(), Z.max()\nfor ax, im in zip(grid, [im1, im2, im3]):\n    ax.imshow(im, origin=\"lower\", vmin=vmin, vmax=vmax)\n\nplt.show()\n",
    "id": 275
},
{
    "title": "Simple Axisline4#",
    "text": "Download Python source code: simple_axisline4.py Download Jupyter notebook: simple_axisline4.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nax = host_subplot(111)\nxx = np.arange(0, 2*np.pi, 0.01)\nax.plot(xx, np.sin(xx))\n\nax2 = ax.twin()  # ax2 is responsible for \"top\" axis and \"right\" axis\nax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi],\n               labels=$0$\", r\"$\\\\frac{1}{2}\\\\pi$\",\n                       r\"$\\\\pi$\", r\"$\\\\frac{3}{2}\\\\pi$\", r\"$2\\\\pi$)\n\nax2.axisright.major_ticklabels.set_visible(False)\nax2.axistop.major_ticklabels.set_visible(True)\n\nplt.show()\n",
    "id": 276
},
{
    "title": "Simple Colorbar#",
    "text": "Download Python source code: simple_colorbar.py Download Jupyter notebook: simple_colorbar.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nax = plt.subplot()\nim = ax.imshow(np.arange(100).reshape((10, 10)))\n\n# create an Axes on the right side of ax. The width of cax will be 5%\n# of ax and the padding between cax and ax will be fixed at 0.05 inch.\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n\nplt.colorbar(im, cax=cax)\n\nplt.show()\n",
    "id": 277
},
{
    "title": "Axis Direction#",
    "text": "Download Python source code: axis_direction.py Download Jupyter notebook: axis_direction.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n\n    ax.set_ylim(-0.1, 1.5)\n    ax.set_yticks([0, 1])\n\n    ax.axis[:].set_visible(False)\n\n    ax.axisx = ax.new_floating_axis(1, 0.5)\n    ax.axisx.set_axisline_style(\"->\", size=1.5)\n\n    return ax\n\n\nplt.rcParams.update({\n    \"axes.titlesize\": \"medium\",\n    \"axes.titley\": 1.1,\n})\n\nfig = plt.figure(figsize=(10, 4))\nfig.subplots_adjust(bottom=0.1, top=0.9, left=0.05, right=0.95)\n\nax1 = setup_axes(fig, 251)\nax1.axisx.set_axis_direction(\"left\")\n\nax2 = setup_axes(fig, 252)\nax2.axisx.label.set_text(\"Label\")\nax2.axisx.toggle(ticklabels=False)\nax2.axisx.set_axislabel_direction(\"+\")\nax2.set_title(\"label direction=$+$\")\n\nax3 = setup_axes(fig, 253)\nax3.axisx.label.set_text(\"Label\")\nax3.axisx.toggle(ticklabels=False)\nax3.axisx.set_axislabel_direction(\"-\")\nax3.set_title(\"label direction=$-$\")\n\nax4 = setup_axes(fig, 254)\nax4.axisx.set_ticklabel_direction(\"+\")\nax4.set_title(\"ticklabel direction=$+$\")\n\nax5 = setup_axes(fig, 255)\nax5.axisx.set_ticklabel_direction(\"-\")\nax5.set_title(\"ticklabel direction=$-$\")\n\nax7 = setup_axes(fig, 257)\nax7.axisx.label.set_text(\"rotation=10\")\nax7.axisx.label.set_rotation(10)\nax7.axisx.toggle(ticklabels=False)\n\nax8 = setup_axes(fig, 258)\nax8.axisx.set_axislabel_direction(\"-\")\nax8.axisx.label.set_text(\"rotation=10\")\nax8.axisx.label.set_rotation(10)\nax8.axisx.toggle(ticklabels=False)\n\nplt.show()\n",
    "id": 279
},
{
    "title": "axis_direction demo#",
    "text": "Download Python source code: demo_axis_direction.py Download Jupyter notebook: demo_axis_direction.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n    # see demo_curvelinear_grid.py for details\n    grid_helper = GridHelperCurveLinear(\n        Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform(),\n        extreme_finder=angle_helper.ExtremeFinderCycle(\n            20, 20,\n            lon_cycle=360, lat_cycle=None,\n            lon_minmax=None, lat_minmax=(0, np.inf),\n        ),\n        grid_locator1=angle_helper.LocatorDMS(12),\n        grid_locator2=grid_finder.MaxNLocator(5),\n        tick_formatter1=angle_helper.FormatterDMS(),\n    )\n    ax = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper,\n        aspect=1, xlim=(-5, 12), ylim=(-5, 10))\n    ax.axis[:].toggle(ticklabels=False)\n    ax.grid(color=\".9\")\n    return ax\n\n\ndef add_floating_axis1(ax):\n    ax.axislat = axis = ax.new_floating_axis(0, 30)\n    axis.label.set_text(r\"$\\\\theta = 30^{\\\\circ}$\")\n    axis.label.set_visible(True)\n    return axis\n\n\ndef add_floating_axis2(ax):\n    ax.axislon = axis = ax.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n    axis.label.set_visible(True)\n    return axis\n\n\nfig = plt.figure(figsize=(8, 4), layout=\"constrained\")\n\nfor i, d in enumerate(bottom\", \"left\", \"top\", \"right):\n    ax = setup_axes(fig, rect=241+i)\n    axis = add_floating_axis1(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nfor i, d in enumerate(bottom\", \"left\", \"top\", \"right):\n    ax = setup_axes(fig, rect=245+i)\n    axis = add_floating_axis2(ax)\n    axis.set_axis_direction(d)\n    ax.set(title=d)\n\nplt.show()\n",
    "id": 280
},
{
    "title": "Axis line styles#",
    "text": "This example shows some configurations for axis style. Note: The mpl_toolkits.axisartist axes classes may be confusing for new\nusers. If the only aim is to obtain arrow heads at the ends of the axes,\nrather check out the Centered spines with arrows\nexample. Download Python source code: demo_axisline_style.py Download Jupyter notebook: demo_axisline_style.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nax = fig.add_subplot(axes_class=AxesZero)\n\nfor direction in xzero\", \"yzero:\n    # adds arrows at the ends of each axis\n    ax.axis[direction].set_axisline_style(\"-|>\")\n\n    # adds X and Y-axis from the origin\n    ax.axis[direction].set_visible(True)\n\nfor direction in left\", \"right\", \"bottom\", \"top:\n    # hides borders\n    ax.axis[direction].set_visible(False)\n\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()\n",
    "id": 281
},
{
    "title": "Curvilinear grid demo#",
    "text": "Custom grid and ticklines. This example demonstrates how to use\nGridHelperCurveLinear to define custom grids and\nticklines by applying a transformation on the grid. This can be used, as\nshown on the second plot, to create polar projections in a rectangular box. Download Python source code: demo_curvelinear_grid.py Download Jupyter notebook: demo_curvelinear_grid.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import Axes, HostAxes, angle_helper\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef curvelinear_test1(fig):\n    \"\"\"\n    Grid for custom transform.\n    \"\"\"\n\n    def tr(x, y): return x, y - x\n    def inv_tr(x, y): return x, y + x\n\n    grid_helper = GridHelperCurveLinear((tr, inv_tr))\n\n    ax1 = fig.add_subplot(1, 2, 1, axes_class=Axes, grid_helper=grid_helper)\n    # ax1 will have ticks and gridlines defined by the given transform (+\n    # transData of the Axes).  Note that the transform of the Axes itself\n    # (i.e., transData) is not affected by the given transform.\n    xx, yy = tr(np.array([3, 6]), np.array([5, 10]))\n    ax1.plot(xx, yy)\n\n    ax1.set_aspect(1)\n    ax1.set_xlim(0, 10)\n    ax1.set_ylim(0, 10)\n\n    ax1.axist = ax1.new_floating_axis(0, 3)\n    ax1.axist2 = ax1.new_floating_axis(1, 7)\n    ax1.grid(True, zorder=0)\n\n\ndef curvelinear_test2(fig):\n    \"\"\"\n    Polar projection, but in a rectangular box.\n    \"\"\"\n\n    # PolarAxes.PolarTransform takes radian. However, we want our coordinate\n    # system in degree\n    tr = Affine2D().scale(np.pi/180, 1) + PolarAxes.PolarTransform()\n    # Polar projection, which involves cycle, and also has limits in\n    # its coordinates, needs a special method to find the extremes\n    # (min, max of the coordinate within the view).\n    extreme_finder = angle_helper.ExtremeFinderCycle(\n        nx=20, ny=20,  # Number of sampling points in each direction.\n        lon_cycle=360, lat_cycle=None,\n        lon_minmax=None, lat_minmax=(0, np.inf),\n    )\n    # Find grid values appropriate for the coordinate (degree, minute, second).\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    # Use an appropriate formatter.  Note that the acceptable Locator and\n    # Formatter classes are a bit different than that of Matplotlib, which\n    # cannot directly be used here (this may be possible in the future).\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(\n        tr, extreme_finder=extreme_finder,\n        grid_locator1=grid_locator1, tick_formatter1=tick_formatter1)\n    ax1 = fig.add_subplot(\n        1, 2, 2, axes_class=HostAxes, grid_helper=grid_helper)\n\n    # make ticklabels of right and top axis visible.\n    ax1.axisright.major_ticklabels.set_visible(True)\n    ax1.axistop.major_ticklabels.set_visible(True)\n    # let right axis shows ticklabels for 1st coordinate (angle)\n    ax1.axisright.get_helper().nth_coord_ticks = 0\n    # let bottom axis shows ticklabels for 2nd coordinate (radius)\n    ax1.axisbottom.get_helper().nth_coord_ticks = 1\n\n    ax1.set_aspect(1)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True, zorder=0)\n\n    # A parasite axes with given transform\n    ax2 = ax1.get_aux_axes(tr)\n    # note that ax2.transData == tr + ax1.transData\n    # Anything you draw in ax2 will match the ticks and grids of ax1.\n    ax2.plot(np.linspace(0, 30, 51), np.linspace(10, 10, 51), linewidth=2)\n\n    ax2.pcolor(np.linspace(0, 90, 4), np.linspace(0, 10, 4),\n               np.arange(9).reshape((3, 3)))\n    ax2.contour(np.linspace(0, 90, 4), np.linspace(0, 10, 4),\n                np.arange(16).reshape((4, 4)), colors=\"k\")\n\n\nif __name__ == \"__main__\":\n    fig = plt.figure(figsize=(7, 4))\n\n    curvelinear_test1(fig)\n    curvelinear_test2(fig)\n\n    plt.show()\n",
    "id": 282
},
{
    "title": "Demo CurveLinear Grid2#",
    "text": "Custom grid and ticklines. This example demonstrates how to use GridHelperCurveLinear to define\ncustom grids and ticklines by applying a transformation on the grid.\nAs showcase on the plot, a 5x5 matrix is displayed on the axes. Download Python source code: demo_curvelinear_grid2.py Download Jupyter notebook: demo_curvelinear_grid2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits.axisartist.axislines import Axes\nfrom mpl_toolkits.axisartist.grid_finder import (ExtremeFinderSimple,\n                                                 MaxNLocator)\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef curvelinear_test1(fig):\n    \"\"\"Grid for custom transform.\"\"\"\n\n    def tr(x, y):\n        return np.sign(x)*abs(x)**.5, y\n\n    def inv_tr(x, y):\n        return np.sign(x)*x**2, y\n\n    grid_helper = GridHelperCurveLinear(\n        (tr, inv_tr),\n        extreme_finder=ExtremeFinderSimple(20, 20),\n        # better tick density\n        grid_locator1=MaxNLocator(nbins=6), grid_locator2=MaxNLocator(nbins=6))\n\n    ax1 = fig.add_subplot(axes_class=Axes, grid_helper=grid_helper)\n    # ax1 will have a ticks and gridlines defined by the given\n    # transform (+ transData of the Axes). Note that the transform of the Axes\n    # itself (i.e., transData) is not affected by the given transform.\n\n    ax1.imshow(np.arange(25).reshape(5, 5),\n               vmax=50, cmap=plt.cm.gray_r, origin=\"lower\")\n\n\nif __name__ == \"__main__\":\n    fig = plt.figure(figsize=(7, 4))\n    curvelinear_test1(fig)\n    plt.show()\n",
    "id": 283
},
{
    "title": "floating_axes features#",
    "text": "Demonstration of features of the floating_axes module: Using scatter and bar with changing the shape of\nthe plot. Using GridHelperCurveLinear to rotate the plot and set the\nplot boundary. Using add_subplot to create a subplot using the return value from\nGridHelperCurveLinear. Making a sector plot by adding more features to\nGridHelperCurveLinear. Download Python source code: demo_floating_axes.py Download Jupyter notebook: demo_floating_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.floating_axes as floating_axes\nfrom mpl_toolkits.axisartist.grid_finder import (DictFormatter, FixedLocator,\n                                                 MaxNLocator)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef setup_axes1(fig, rect):\n    \"\"\"\n    A simple one.\n    \"\"\"\n    tr = Affine2D().scale(2, 1).rotate_deg(30)\n\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(-0.5, 3.5, 0, 4),\n        grid_locator1=MaxNLocator(nbins=4),\n        grid_locator2=MaxNLocator(nbins=4))\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n    ax1.grid()\n\n    aux_ax = ax1.get_aux_axes(tr)\n\n    return ax1, aux_ax\n\n\ndef setup_axes2(fig, rect):\n    \"\"\"\n    With custom locator and formatter.\n    Note that the extreme values are swapped.\n    \"\"\"\n    tr = PolarAxes.PolarTransform()\n\n    pi = np.pi\n    angle_ticks = [(0, r\"$0$\"),\n                   (.25*pi, r\"$\\\\frac{1}{4}\\\\pi$\"),\n                   (.5*pi, r\"$\\\\frac{1}{2}\\\\pi$\")]\n    grid_locator1 = FixedLocator([v for v, s in angle_ticks])\n    tick_formatter1 = DictFormatter(dict(angle_ticks))\n\n    grid_locator2 = MaxNLocator(2)\n\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(.5*pi, 0, 2, 1),\n        grid_locator1=grid_locator1,\n        grid_locator2=grid_locator2,\n        tick_formatter1=tick_formatter1,\n        tick_formatter2=None)\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n    ax1.grid()\n\n    # create a parasite axes whose transData in RA, cz\n    aux_ax = ax1.get_aux_axes(tr)\n\n    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax\n    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is\n    # drawn twice, and possibly over some other\n    # artists. So, we decrease the zorder a bit to\n    # prevent this.\n\n    return ax1, aux_ax\n\n\ndef setup_axes3(fig, rect):\n    \"\"\"\n    Sometimes, things like axis_direction need to be adjusted.\n    \"\"\"\n\n    # rotate a bit for better orientation\n    tr_rotate = Affine2D().translate(-95, 0)\n\n    # scale degree to radians\n    tr_scale = Affine2D().scale(np.pi/180., 1.)\n\n    tr = tr_rotate + tr_scale + PolarAxes.PolarTransform()\n\n    grid_locator1 = angle_helper.LocatorHMS(4)\n    tick_formatter1 = angle_helper.FormatterHMS()\n\n    grid_locator2 = MaxNLocator(3)\n\n    # Specify theta limits in degrees\n    ra0, ra1 = 8.*15, 14.*15\n    # Specify radial limits\n    cz0, cz1 = 0, 14000\n    grid_helper = floating_axes.GridHelperCurveLinear(\n        tr, extremes=(ra0, ra1, cz0, cz1),\n        grid_locator1=grid_locator1,\n        grid_locator2=grid_locator2,\n        tick_formatter1=tick_formatter1,\n        tick_formatter2=None)\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=floating_axes.FloatingAxes, grid_helper=grid_helper)\n\n    # adjust axis\n    ax1.axisleft.set_axis_direction(\"bottom\")\n    ax1.axisright.set_axis_direction(\"top\")\n\n    ax1.axisbottom.set_visible(False)\n    ax1.axistop.set_axis_direction(\"bottom\")\n    ax1.axistop.toggle(ticklabels=True, label=True)\n    ax1.axistop.major_ticklabels.set_axis_direction(\"top\")\n    ax1.axistop.label.set_axis_direction(\"top\")\n\n    ax1.axisleft.label.set_text(r\"cz [km$^{-1}$]\")\n    ax1.axistop.label.set_text(r\"$\\\\alpha_{1950}$\")\n    ax1.grid()\n\n    # create a parasite axes whose transData in RA, cz\n    aux_ax = ax1.get_aux_axes(tr)\n\n    aux_ax.patch = ax1.patch  # for aux_ax to have a clip path as in ax\n    ax1.patch.zorder = 0.9  # but this has a side effect that the patch is\n    # drawn twice, and possibly over some other\n    # artists. So, we decrease the zorder a bit to\n    # prevent this.\n\n    return ax1, aux_ax\n fig = plt.figure(figsize=(8, 4))\nfig.subplots_adjust(wspace=0.3, left=0.05, right=0.95)\n\nax1, aux_ax1 = setup_axes1(fig, 131)\naux_ax1.bar([0, 1, 2, 3], [3, 2, 1, 3])\n\nax2, aux_ax2 = setup_axes2(fig, 132)\ntheta = np.random.rand(10)*.5*np.pi\nradius = np.random.rand(10) + 1.\naux_ax2.scatter(theta, radius)\n\nax3, aux_ax3 = setup_axes3(fig, 133)\n\ntheta = (8 + np.random.rand(10)*(14 - 8))*15.  # in degrees\nradius = np.random.rand(10)*14000.\naux_ax3.scatter(theta, radius)\n\nplt.show()\n",
    "id": 284
},
{
    "title": "floating_axis demo#",
    "text": "Axis within rectangular frame. The following code demonstrates how to put a floating polar curve within a\nrectangular box. In order to get a better sense of polar curves, please look at\nCurvilinear grid demo. Download Python source code: demo_floating_axis.py Download Jupyter notebook: demo_floating_axis.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nfrom mpl_toolkits.axisartist import GridHelperCurveLinear, HostAxes\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\n\n\ndef curvelinear_test2(fig):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform()\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20,\n                                                     20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(axes_class=HostAxes, grid_helper=grid_helper)\n\n    # Now creates floating axis\n\n    # floating axis whose first coordinate (theta) is fixed at 60\n    ax1.axislat = axis = ax1.new_floating_axis(0, 60)\n    axis.label.set_text(r\"$\\\\theta = 60^{\\\\circ}$\")\n    axis.label.set_visible(True)\n\n    # floating axis whose second coordinate (r) is fixed at 6\n    ax1.axislon = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    ax1.grid(True)\n\n\nfig = plt.figure(figsize=(5, 5))\ncurvelinear_test2(fig)\nplt.show()\n",
    "id": 285
},
{
    "title": "Parasite Axes demo#",
    "text": "Create a parasite axes. Such axes would share the x scale with a host axes,\nbut show a different scale in y direction. This approach uses mpl_toolkits.axes_grid1.parasite_axes.HostAxes and\nmpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes. The standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the Multiple y-axis with Spines\nexample. An alternative approach using mpl_toolkits.axes_grid1 and\nmpl_toolkits.axisartist is shown in the\nParasite axis demo example. Download Python source code: demo_parasite_axes.py Download Jupyter notebook: demo_parasite_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.parasite_axes import HostAxes\n\nfig = plt.figure()\n\nhost = fig.add_axes([0.15, 0.1, 0.65, 0.8], axes_class=HostAxes)\npar1 = host.get_aux_axes(viewlim_mode=None, sharex=host)\npar2 = host.get_aux_axes(viewlim_mode=None, sharex=host)\n\nhost.axisright.set_visible(False)\n\npar1.axisright.set_visible(True)\npar1.axisright.major_ticklabels.set_visible(True)\npar1.axisright.label.set_visible(True)\n\npar2.axisright2 = par2.new_fixed_axis(loc=\"right\", offset=(60, 0))\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par1.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\np3, = par2.plot([0, 1, 2], [50, 30, 15], label=\"Velocity\")\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\npar1.set(ylim=(0, 4), ylabel=\"Temperature\")\npar2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nhost.legend()\n\nhost.axisleft.label.set_color(p1.get_color())\npar1.axisright.label.set_color(p2.get_color())\npar2.axisright2.label.set_color(p3.get_color())\n\nplt.show()\n",
    "id": 286
},
{
    "title": "Parasite axis demo#",
    "text": "This example demonstrates the use of parasite axis to plot multiple datasets\nonto one single plot.', \"Notice how in this example, par1 and par2 are both obtained by calling\ntwinx(), which ties their x-limits with the host's x-axis. From there, each\nof those two axis behave separately from each other: different datasets can be\nplotted, and the y-limits are adjusted separately.\", 'This approach uses mpl_toolkits.axes_grid1.parasite_axes.host_subplot and\nmpl_toolkits.axisartist.axislines.Axes. The standard and recommended approach is to use instead standard Matplotlib\naxes, as shown in the Multiple y-axis with Spines\nexample. An alternative approach using mpl_toolkits.axes_grid1.parasite_axes.HostAxes\nand mpl_toolkits.axes_grid1.parasite_axes.ParasiteAxes is shown in the\nParasite Axes demo example. Download Python source code: demo_parasite_axes2.py Download Jupyter notebook: demo_parasite_axes2.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits import axisartist\nfrom mpl_toolkits.axes_grid1 import host_subplot\n\nhost = host_subplot(111, axes_class=axisartist.Axes)\nplt.subplots_adjust(right=0.75)\n\npar1 = host.twinx()\npar2 = host.twinx()\n\npar2.axisright = par2.new_fixed_axis(loc=\"right\", offset=(60, 0))\n\npar1.axisright.toggle(all=True)\npar2.axisright.toggle(all=True)\n\np1, = host.plot([0, 1, 2], [0, 1, 2], label=\"Density\")\np2, = par1.plot([0, 1, 2], [0, 3, 2], label=\"Temperature\")\np3, = par2.plot([0, 1, 2], [50, 30, 15], label=\"Velocity\")\n\nhost.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\npar1.set(ylim=(0, 4), ylabel=\"Temperature\")\npar2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nhost.legend()\n\nhost.axisleft.label.set_color(p1.get_color())\npar1.axisright.label.set_color(p2.get_color())\npar2.axisright.label.set_color(p3.get_color())\n\nplt.show()\n",
    "id": 287
},
{
    "title": "Ticklabel alignment#",
    "text": "Download Python source code: demo_ticklabel_alignment.py Download Jupyter notebook: demo_ticklabel_alignment.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8], labels=short\", \"loooong)\n    ax.set_xticks([0.2, 0.8], labels=[r\"$\\\\frac{1}{2}\\\\pi$\", r\"$\\\\pi$)\n    return ax\n\n\nfig = plt.figure(figsize=(3, 5))\nfig.subplots_adjust(left=0.5, hspace=0.7)\n\nax = setup_axes(fig, 311)\nax.set_ylabel(\"ha=right\")\nax.set_xlabel(\"va=baseline\")\n\nax = setup_axes(fig, 312)\nax.axisleft.major_ticklabels.set_ha(\"center\")\nax.axisbottom.major_ticklabels.set_va(\"top\")\nax.set_ylabel(\"ha=center\")\nax.set_xlabel(\"va=top\")\n\nax = setup_axes(fig, 313)\nax.axisleft.major_ticklabels.set_ha(\"left\")\nax.axisbottom.major_ticklabels.set_va(\"bottom\")\nax.set_ylabel(\"ha=left\")\nax.set_xlabel(\"va=bottom\")\n\nplt.show()\n",
    "id": 288
},
{
    "title": "Ticklabel direction#",
    "text": "Download Python source code: demo_ticklabel_direction.py Download Jupyter notebook: demo_ticklabel_direction.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist.axislines as axislines\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axislines.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(6, 3))\nfig.subplots_adjust(bottom=0.2)\n\nax = setup_axes(fig, 131)\nfor axis in ax.axis.values():\n    axis.major_ticks.set_tick_out(True)\n# or you can simply do \"ax.axis[:].major_ticks.set_tick_out(True)\"\n\nax = setup_axes(fig, 132)\nax.axisleft.set_axis_direction(\"right\")\nax.axisbottom.set_axis_direction(\"top\")\nax.axisright.set_axis_direction(\"left\")\nax.axistop.set_axis_direction(\"bottom\")\n\nax = setup_axes(fig, 133)\nax.axisleft.set_axis_direction(\"right\")\nax.axis[:].major_ticks.set_tick_out(True)\n\nax.axisleft.label.set_text(\"Long Label Left\")\nax.axisbottom.label.set_text(\"Label Bottom\")\nax.axisright.label.set_text(\"Long Label Right\")\nax.axisright.label.set_visible(True)\nax.axisleft.label.set_pad(0)\nax.axisbottom.label.set_pad(10)\n\nplt.show()\n",
    "id": 289
},
{
    "title": "Simple axis direction#",
    "text": "Download Python source code: simple_axis_direction01.py Download Jupyter notebook: simple_axis_direction01.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\nfig = plt.figure(figsize=(4, 2.5))\nax1 = fig.add_subplot(axes_class=axisartist.Axes)\nfig.subplots_adjust(right=0.8)\n\nax1.axisleft.major_ticklabels.set_axis_direction(\"top\")\nax1.axisleft.label.set_text(\"Left label\")\n\nax1.axisright.label.set_visible(True)\nax1.axisright.label.set_text(\"Right label\")\nax1.axisright.label.set_axis_direction(\"left\")\n\nplt.show()\n",
    "id": 290
},
{
    "title": "Simple axis tick label and tick directions#",
    "text": "First subplot moves the tick labels to inside the spines.\nSecond subplot moves the ticks to inside the spines.\nThese effects can be obtained for a standard Axes by tick_params. Download Python source code: simple_axis_direction03.py Download Jupyter notebook: simple_axis_direction03.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport mpl_toolkits.axisartist as axisartist\n\n\ndef setup_axes(fig, pos):\n    ax = fig.add_subplot(pos, axes_class=axisartist.Axes)\n    ax.set_yticks([0.2, 0.8])\n    ax.set_xticks([0.2, 0.8])\n    return ax\n\n\nfig = plt.figure(figsize=(5, 2))\nfig.subplots_adjust(wspace=0.4, bottom=0.3)\n\nax1 = setup_axes(fig, 121)\nax1.set_xlabel(\"ax1 X-label\")\nax1.set_ylabel(\"ax1 Y-label\")\n\nax1.axis[:].invert_ticklabel_direction()\n\nax2 = setup_axes(fig, 122)\nax2.set_xlabel(\"ax2 X-label\")\nax2.set_ylabel(\"ax2 Y-label\")\n\nax2.axis[:].major_ticks.set_tick_out(False)\n\nplt.show()\n",
    "id": 291
},
{
    "title": "Simple Axis Pad#",
    "text": "Download Python source code: simple_axis_pad.py Download Jupyter notebook: simple_axis_pad.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.axisartist as axisartist\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nimport mpl_toolkits.axisartist.grid_finder as grid_finder\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import \\\\\n    GridHelperCurveLinear\n\n\ndef setup_axes(fig, rect):\n    \"\"\"Polar projection, but in a rectangular box.\"\"\"\n\n    # see demo_curvelinear_grid.py for details\n    tr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform()\n\n    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=None,\n                                                     lat_minmax=(0, np.inf),\n                                                     )\n\n    grid_locator1 = angle_helper.LocatorDMS(12)\n    grid_locator2 = grid_finder.MaxNLocator(5)\n\n    tick_formatter1 = angle_helper.FormatterDMS()\n\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        grid_locator2=grid_locator2,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    ax1 = fig.add_subplot(\n        rect, axes_class=axisartist.Axes, grid_helper=grid_helper)\n    ax1.axis[:].set_visible(False)\n    ax1.set_aspect(1.)\n    ax1.set_xlim(-5, 12)\n    ax1.set_ylim(-5, 10)\n\n    return ax1\n\n\ndef add_floating_axis1(ax1):\n    ax1.axislat = axis = ax1.new_floating_axis(0, 30)\n    axis.label.set_text(r\"$\\\\theta = 30^{\\\\circ}$\")\n    axis.label.set_visible(True)\n\n    return axis\n\n\ndef add_floating_axis2(ax1):\n    ax1.axislon = axis = ax1.new_floating_axis(1, 6)\n    axis.label.set_text(r\"$r = 6$\")\n    axis.label.set_visible(True)\n\n    return axis\n\n\nfig = plt.figure(figsize=(9, 3.))\nfig.subplots_adjust(left=0.01, right=0.99, bottom=0.01, top=0.99,\n                    wspace=0.01, hspace=0.01)\n\n\ndef ann(ax1, d):\n    if plt.rcParamstext.usetex:\n        d = d.replace(\"_\", r\"\\\\_\")\n\n    ax1.annotate(d, (0.5, 1), (5, -5),\n                 xycoords=\"axes fraction\", textcoords=\"offset points\",\n                 va=\"top\", ha=\"center\")\n\n\nax1 = setup_axes(fig, rect=141)\naxis = add_floating_axis1(ax1)\nann(ax1, r\"default\")\n\nax1 = setup_axes(fig, rect=142)\naxis = add_floating_axis1(ax1)\naxis.major_ticklabels.set_pad(10)\nann(ax1, r\"ticklabels.set_pad(10)\")\n\nax1 = setup_axes(fig, rect=143)\naxis = add_floating_axis1(ax1)\naxis.label.set_pad(20)\nann(ax1, r\"label.set_pad(20)\")\n\nax1 = setup_axes(fig, rect=144)\naxis = add_floating_axis1(ax1)\naxis.major_ticks.set_tick_out(True)\nann(ax1, \"ticks.set_tick_out(True)\")\n\nplt.show()\n",
    "id": 292
},
{
    "title": "Custom spines with axisartist#",
    "text": "This example showcases the use of axisartist to draw spines at custom\npositions (here, at y = 0). Note, however, that it is simpler to achieve this effect using standard\nSpine methods, as demonstrated in\nCentered spines with arrows. Download Python source code: simple_axisartist1.py Download Jupyter notebook: simple_axisartist1.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom mpl_toolkits import axisartist\n\nfig = plt.figure(figsize=(6, 3), layout=\"constrained\")\n# To construct axes of two different classes, we need to use gridspec (or\n# MATLAB-style add_subplot calls).\ngs = fig.add_gridspec(1, 2)\n\n\nax0 = fig.add_subplot(gs[0, 0], axes_class=axisartist.Axes)\n# Make a new axis along the first (x) axis which passes through y=0.\nax0.axisy=0 = ax0.new_floating_axis(nth_coord=0, value=0,\n                                        axis_direction=\"bottom\")\nax0.axisy=0.toggle(all=True)\nax0.axisy=0.label.set_text(\"y = 0\")\n# Make other axis invisible.\nax0.axisbottom\", \"top\", \"right.set_visible(False)\n\n\n# Alternatively, one can use AxesZero, which automatically sets up two\n# additional axis, named \"xzero\" (the y=0 axis) and \"yzero\" (the x=0 axis).\nax1 = fig.add_subplot(gs[0, 1], axes_class=axisartist.axislines.AxesZero)\n# \"xzero\" and \"yzero\" default to invisible; make xzero axis visible.\nax1.axisxzero.set_visible(True)\nax1.axisxzero.label.set_text(\"Axis Zero\")\n# Make other axis invisible.\nax1.axisbottom\", \"top\", \"right.set_visible(False)\n\n\n# Draw some sample data.\nx = np.arange(0, 2*np.pi, 0.01)\nax0.plot(x, np.sin(x))\nax1.plot(x, np.sin(x))\n\nplt.show()\n",
    "id": 293
},
{
    "title": "Simple Axisline#",
    "text": "Download Python source code: simple_axisline.py Download Jupyter notebook: simple_axisline.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import AxesZero\n\nfig = plt.figure()\nfig.subplots_adjust(right=0.85)\nax = fig.add_subplot(axes_class=AxesZero)\n\n# make right and top axis invisible\nax.axisright.set_visible(False)\nax.axistop.set_visible(False)\n\n# make xzero axis (horizontal axis line through y=0) visible.\nax.axisxzero.set_visible(True)\nax.axisxzero.label.set_text(\"Axis Zero\")\n\nax.set_ylim(-2, 4)\nax.set_xlabel(\"Label X\")\nax.set_ylabel(\"Label Y\")\n# Or:\n# ax.axisbottom.label.set_text(\"Label X\")\n# ax.axisleft.label.set_text(\"Label Y\")\n\n# make new (right-side) yaxis, but with some offset\nax.axisright2 = ax.new_fixed_axis(loc=\"right\", offset=(20, 0))\nax.axisright2.label.set_text(\"Label Y2\")\n\nax.plot([-2, 3, 2])\nplt.show()\n",
    "id": 294
},
{
    "title": "Simple Axisline3#",
    "text": "Download Python source code: simple_axisline3.py Download Jupyter notebook: simple_axisline3.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.axisartist.axislines import Axes\n\nfig = plt.figure(figsize=(3, 3))\n\nax = fig.add_subplot(axes_class=Axes)\n\nax.axisright.set_visible(False)\nax.axistop.set_visible(False)\n\nplt.show()\n",
    "id": 295
},
{
    "title": "Anatomy of a figure#",
    "text": "This figure shows the name of several matplotlib elements composing a figure References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.axes.Axes.text matplotlib.axis.Axis.set_minor_formatter matplotlib.axis.Axis.set_major_locator matplotlib.axis.Axis.set_minor_locator matplotlib.patches.Circle matplotlib.patheffects.withStroke matplotlib.ticker.FuncFormatter Download Python source code: anatomy.py Download Jupyter notebook: anatomy.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle\nfrom matplotlib.patheffects import withStroke\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nroyal_blue = [0, 20/256, 82/256]\n\n\n# make the figure\n\nnp.random.seed(19680801)\n\nX = np.linspace(0.5, 3.5, 100)\nY1 = 3+np.cos(X)\nY2 = 1+np.cos(1+X/0.75)/2\nY3 = np.random.uniform(Y1, Y2, len(X))\n\nfig = plt.figure(figsize=(7.5, 7.5))\nax = fig.add_axes([0.2, 0.17, 0.68, 0.7], aspect=1)\n\nax.xaxis.set_major_locator(MultipleLocator(1.000))\nax.xaxis.set_minor_locator(AutoMinorLocator(4))\nax.yaxis.set_major_locator(MultipleLocator(1.000))\nax.yaxis.set_minor_locator(AutoMinorLocator(4))\nax.xaxis.set_minor_formatter(\"{x:.2f}\")\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nax.tick_params(which=\\'major\\', width=1.0, length=10, labelsize=14)\nax.tick_params(which=\\'minor\\', width=1.0, length=5, labelsize=10,\n               labelcolor=\\'0.25\\')\n\nax.grid(linestyle=\"--\", linewidth=0.5, color=\\'.25\\', zorder=-10)\n\nax.plot(X, Y1, c=\\'C0\\', lw=2.5, label=\"Blue signal\", zorder=10)\nax.plot(X, Y2, c=\\'C1\\', lw=2.5, label=\"Orange signal\")\nax.plot(X[::3], Y3[::3], linewidth=0, markersize=9,\n        marker=\\'s\\', markerfacecolor=\\'none\\', markeredgecolor=\\'C4\\',\n        markeredgewidth=2.5)\n\nax.set_title(\"Anatomy of a figure\", fontsize=20, verticalalignment=\\'bottom\\')\nax.set_xlabel(\"x Axis label\", fontsize=14)\nax.set_ylabel(\"y Axis label\", fontsize=14)\nax.legend(loc=\"upper right\", fontsize=14)\n\n\n# Annotate the figure\n\ndef annotate(x, y, text, code):\n    # Circle marker\n    c = Circle((x, y), radius=0.15, clip_on=False, zorder=10, linewidth=2.5,\n               edgecolor=royal_blue + [0.6], facecolor=\\'none\\',\n               path_effects=[withStroke(linewidth=7, foreground=\\'white\\')])\n    ax.add_artist(c)\n\n    # use path_effects as a background for the texts\n    # draw the path_effects and the colored text separately so that the\n    # path_effects cannot clip other texts\n    for path_effects in [[withStroke(linewidth=7, foreground=\\'white\\')], []]:\n        color = \\'white\\' if path_effects else royal_blue\n        ax.text(x, y-0.2, text, zorder=100,\n                ha=\\'center\\', va=\\'top\\', weight=\\'bold\\', color=color,\n                style=\\'italic\\', fontfamily=\\'monospace\\',\n                path_effects=path_effects)\n\n        color = \\'white\\' if path_effects else \\'black\\'\n        ax.text(x, y-0.33, code, zorder=100,\n                ha=\\'center\\', va=\\'top\\', weight=\\'normal\\', color=color,\n                fontfamily=\\'monospace\\', fontsize=\\'medium\\',\n                path_effects=path_effects)\n\n\nannotate(3.5, -0.13, \"Minor tick label\", \"ax.xaxis.set_minor_formatter\")\nannotate(-0.03, 1.0, \"Major tick\", \"ax.yaxis.set_major_locator\")\nannotate(0.00, 3.75, \"Minor tick\", \"ax.yaxis.set_minor_locator\")\nannotate(-0.15, 3.00, \"Major tick label\", \"ax.yaxis.set_major_formatter\")\nannotate(1.68, -0.39, \"xlabel\", \"ax.set_xlabel\")\nannotate(-0.38, 1.67, \"ylabel\", \"ax.set_ylabel\")\nannotate(1.52, 4.15, \"Title\", \"ax.set_title\")\nannotate(1.75, 2.80, \"Line\", \"ax.plot\")\nannotate(2.25, 1.54, \"Markers\", \"ax.scatter\")\nannotate(3.00, 3.00, \"Grid\", \"ax.grid\")\nannotate(3.60, 3.58, \"Legend\", \"ax.legend\")\nannotate(2.5, 0.55, \"Axes\", \"fig.subplots\")\nannotate(4, 4.5, \"Figure\", \"plt.figure\")\nannotate(0.65, 0.01, \"x Axis\", \"ax.xaxis\")\nannotate(0, 0.36, \"y Axis\", \"ax.yaxis\")\nannotate(4.0, 0.7, \"Spine\", \"ax.spines\")\n\n# frame around figure\nfig.patch.set(linewidth=4, edgecolor=\\'0.5\\')\nplt.show()\n",
    "id": 297
},
{
    "title": "Firefox#",
    "text": "This example shows how to create the Firefox logo with path and patches. Download Python source code: firefox.py Download Jupyter notebook: firefox.ipynb ",
    "code": "import re\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\n\n# From: https://dmitrybaranovskiy.github.io/raphael/icons/#firefox\nfirefox = \"M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68,1.86c-2.274-0.528-3.433-0.261-3.423-0.248c0.013,0.015,3.384,0.589,3.981,1.411c0,0-1.431,0-2.856,0.41c-0.065,0.019,5.242,0.663,6.327,5.966c0,0-0.582-1.213-1.301-1.42c0.473,1.439,0.351,4.17-0.1,5.528c-0.058,0.174-0.118-0.755-1.004-1.155c0.284,2.037-0.018,5.268-1.432,6.158c-0.109,0.07,0.887-3.189,0.201-1.93c-4.093,6.276-8.959,2.539-10.934,1.208c1.585,0.388,3.267,0.108,4.242-0.559c0.982-0.672,1.564-1.162,2.087-1.047c0.522,0.117,0.87-0.407,0.464-0.872c-0.405-0.466-1.392-1.105-2.725-0.757c-0.94,0.247-2.107,1.287-3.886,0.233c-1.518-0.899-1.507-1.63-1.507-2.095c0-0.366,0.257-0.88,0.734-1.028c0.58,0.062,1.044,0.214,1.537,0.466c0.005-0.135,0.006-0.315-0.001-0.519c0.039-0.077,0.015-0.311-0.047-0.596c-0.036-0.287-0.097-0.582-0.19-0.851c0.01-0.002,0.017-0.007,0.021-0.021c0.076-0.344,2.147-1.544,2.299-1.659c0.153-0.114,0.55-0.378,0.506-1.183c-0.015-0.265-0.058-0.294-2.232-0.286c-0.917,0.003-1.425-0.894-1.589-1.245c0.222-1.231,0.863-2.11,1.919-2.704c0.02-0.011,0.015-0.021-0.008-0.027c0.219-0.127-2.524-0.006-3.76,1.604C9.674,8.045,9.219,7.95,8.71,7.95c-0.638,0-1.139,0.07-1.603,0.187c-0.05,0.013-0.122,0.011-0.208-0.001C6.769,8.04,6.575,7.88,6.365,7.672c0.161-0.18,0.324-0.356,0.495-0.526C9.201,4.804,12.43,3.357,16.002,3.356z\"  # noqa\n\n\ndef svg_parse(path):\n    commands = {\\'M\\': (Path.MOVETO,),\n                \\'L\\': (Path.LINETO,),\n                \\'Q\\': (Path.CURVE3,)*2,\n                \\'C\\': (Path.CURVE4,)*3,\n                \\'Z\\': (Path.CLOSEPOLY,)}\n    vertices = []\n    codes = []\n    cmd_values = re.split(\"([A-Za-z])\", path)[1:]  # Split over commands.\n    for cmd, values in zip(cmd_values[::2], cmd_values[1::2]):\n        # Numbers are separated either by commas, or by +/- signs (but not at\n        # the beginning of the string).\n        points = ([*map(float, re.split(\",|(?<!^)(?=[+-])\", values))] if values\n                  else [(0., 0.)])  # Only for \"z/Z\" (CLOSEPOLY).\n        points = np.reshape(points, (-1, 2))\n        if cmd.islower():\n            points += vertices[-1][-1]\n        codes.extend(commands[cmd.upper()])\n        vertices.append(points)\n    return np.array(codes), np.concatenate(vertices)\n\n\n# SVG to Matplotlib\ncodes, verts = svg_parse(firefox)\npath = Path(verts, codes)\n\nxmin, ymin = verts.min(axis=0) - 1\nxmax, ymax = verts.max(axis=0) + 1\n\nfig = plt.figure(figsize=(5, 5), facecolor=\"0.75\")  # gray background\nax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1,\n                  xlim=(xmin, xmax),  # centering\n                  ylim=(ymax, ymin),  # centering, upside down\n                  xticks=[], yticks=[])  # no ticks\n\n# White outline (width = 6)\nax.add_patch(patches.PathPatch(path, facecolor=\\'none\\', edgecolor=\\'w\\', lw=6))\n# Actual shape with black outline\nax.add_patch(patches.PathPatch(path, facecolor=\\'orange\\', edgecolor=\\'k\\', lw=2))\n\nplt.show()  # Display\n",
    "id": 298
},
{
    "title": "Integral as the area under a curve#",
    "text": "Although this is a simple example, it demonstrates some important tweaks: A simple line plot with custom color and line width. A shaded region created using a Polygon patch. A text label with mathtext rendering. figtext calls to label the x- and y-axes. Use of axis spines to hide the top and right spines. Custom tick placement and labels. Download Python source code: integral.py Download Jupyter notebook: integral.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\n\n\ndef func(x):\n    return (x - 3) * (x - 5) * (x - 7) + 85\n\n\na, b = 2, 9  # integral limits\nx = np.linspace(0, 10)\ny = func(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y, \\'r\\', linewidth=2)\nax.set_ylim(bottom=0)\n\n# Make the shaded region\nix = np.linspace(a, b)\niy = func(ix)\nverts = [(a, 0), *zip(ix, iy), (b, 0)]\npoly = Polygon(verts, facecolor=\\'0.9\\', edgecolor=\\'0.5\\')\nax.add_patch(poly)\n\nax.text(0.5 * (a + b), 30, r\"$\\\\int_a^b f(x)\\\\mathrm{d}x$\",\n        horizontalalignment=\\'center\\', fontsize=20)\n\nfig.text(0.9, 0.05, \\'$x$\\')\nfig.text(0.1, 0.9, \\'$y$\\')\n\nax.spines[[\\'top\\', \\'right\\].set_visible(False)\nax.set_xticks([a, b], labels=[\\'$a$\\', \\'$b$\\)\nax.set_yticks([])\n\nplt.show()\n",
    "id": 299
},
{
    "title": "Shaded & power normalized rendering#",
    "text": "The Mandelbrot set rendering can be improved by using a normalized recount\nassociated with a power normalized colormap (gamma=0.3). Rendering can be\nfurther enhanced thanks to shading. The maxiter gives the precision of the computation. maxiter=200 should\ntake a few seconds on most modern laptops. Total running time of the script: (0 minutes 3.134 seconds) Download Python source code: mandelbrot.py Download Jupyter notebook: mandelbrot.ipynb ",
    "code": "import numpy as np\n\n\ndef mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n    X = np.linspace(xmin, xmax, xn).astype(np.float32)\n    Y = np.linspace(ymin, ymax, yn).astype(np.float32)\n    C = X + Y[:, None] * 1j\n    N = np.zeros_like(C, dtype=int)\n    Z = np.zeros_like(C)\n    for n in range(maxiter):\n        I = abs(Z) < horizon\n        N[I] = n\n        Z[I] = Z[I]**2 + C[I]\n    N[N == maxiter-1] = 0\n    return Z, N\n\n\nif __name__ == \\'__main__\\':\n    import time\n\n    import matplotlib.pyplot as plt\n\n    import matplotlib\n    from matplotlib import colors\n\n    xmin, xmax, xn = -2.25, +0.75, 3000 // 2\n    ymin, ymax, yn = -1.25, +1.25, 2500 // 2\n    maxiter = 200\n    horizon = 2.0 ** 40\n    log_horizon = np.log2(np.log(horizon))\n    Z, N = mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon)\n\n    # Normalized recount as explained in:\n    # https://linas.org/art-gallery/escape/smooth.html\n    # https://web.archive.org/web/20160331171238/https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift?lang=en\n\n    # This line will generate warnings for null values, but it is faster to\n    # process them afterwards using the nan_to_num\n    with np.errstate(invalid=\\'ignore\\'):\n        M = np.nan_to_num(N + 1 - np.log2(np.log(abs(Z))) + log_horizon)\n\n    dpi = 72\n    width = 10\n    height = 10*yn/xn\n    fig = plt.figure(figsize=(width, height), dpi=dpi)\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1)\n\n    # Shaded rendering\n    light = colors.LightSource(azdeg=315, altdeg=10)\n    M = light.shade(M, cmap=plt.cm.hot, vert_exag=1.5,\n                    norm=colors.PowerNorm(0.3), blend_mode=\\'hsv\\')\n    ax.imshow(M, extent=[xmin, xmax, ymin, ymax], interpolation=\"bicubic\")\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Some advertisement for matplotlib\n    year = time.strftime(\"%Y\")\n    text = (\"The Mandelbrot fractal set\\\n\"\n            \"Rendered with matplotlib %s, %s - https://matplotlib.org\"\n            % (matplotlib.__version__, year))\n    ax.text(xmin+.025, ymin+.025, text, color=\"white\", fontsize=12, alpha=0.5)\n\n    plt.show()\n",
    "id": 300
},
{
    "title": "Stock prices over 32 years#",
    "text": "A graph of multiple time series that demonstrates custom styling of plot frame,\ntick lines, tick labels, and line graph properties. It also uses custom\nplacement of text labels along the right edge as an alternative to a\nconventional legend. Note: The third-party mpl style dufte produces similar-looking plots with less\ncode. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axes.Axes.text matplotlib.axis.XAxis.tick_bottom matplotlib.axis.YAxis.tick_left matplotlib.artist.Artist.set_visible Total running time of the script: (0 minutes 1.298 seconds) Download Python source code: stock_prices.py Download Jupyter notebook: stock_prices.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nimport matplotlib.transforms as mtransforms\n\nwith get_sample_data(\\'Stocks.csv\\') as file:\n    stock_data = np.genfromtxt(\n        file, delimiter=\\',\\', names=True, dtype=None,\n        converters={0: lambda x: np.datetime64(x, \\'D\\')}, skip_header=1)\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 8), layout=\\'constrained\\')\n\n# These are the colors that will be used in the plot\nax.set_prop_cycle(color=[\n    \\'#1f77b4\\', \\'#aec7e8\\', \\'#ff7f0e\\', \\'#ffbb78\\', \\'#2ca02c\\', \\'#98df8a\\',\n    \\'#d62728\\', \\'#ff9896\\', \\'#9467bd\\', \\'#c5b0d5\\', \\'#8c564b\\', \\'#c49c94\\',\n    \\'#e377c2\\', \\'#f7b6d2\\', \\'#7f7f7f\\', \\'#c7c7c7\\', \\'#bcbd22\\', \\'#dbdb8d\\',\n    \\'#17becf\\', \\'#9edae5\\)\n\nstocks_name = [\\'IBM\\', \\'Apple\\', \\'Microsoft\\', \\'Xerox\\', \\'Amazon\\', \\'Dell\\',\n               \\'Alphabet\\', \\'Adobe\\', \\'S&P 500\\', \\'NASDAQ\\\nstocks_ticker = [\\'IBM\\', \\'AAPL\\', \\'MSFT\\', \\'XRX\\', \\'AMZN\\', \\'DELL\\', \\'GOOGL\\',\n                 \\'ADBE\\', \\'GSPC\\', \\'IXIC\\\n\n# Manually adjust the label positions vertically (units are points = 1/72 inch)\ny_offsets = {k: 0 for k in stocks_ticker}\ny_offsets[\\'IBM\\ = 5\ny_offsets[\\'AAPL\\ = -5\ny_offsets[\\'AMZN\\ = -6\n\nfor nn, column in enumerate(stocks_ticker):\n    # Plot each line separately with its own color.\n    # don\\'t include any data with NaN.\n    good = np.nonzero(np.isfinite(stock_data[column]))\n    line, = ax.plot(stock_data[\\'Date\\[good], stock_data[column][good], lw=2.5)\n\n    # Add a text label to the right end of every line. Most of the code below\n    # is adding specific offsets y position because some labels overlapped.\n    y_pos = stock_data[column][-1]\n\n    # Use an offset transform, in points, for any text that needs to be nudged\n    # up or down.\n    offset = y_offsets[column] / 72\n    trans = mtransforms.ScaledTranslation(0, offset, fig.dpi_scale_trans)\n    trans = ax.transData + trans\n\n    # Again, make sure that all labels are large enough to be easily read\n    # by the viewer.\n    ax.text(np.datetime64(\\'2022-10-01\\'), y_pos, stocks_name[nn],\n            color=line.get_color(), transform=trans)\n\nax.set_xlim(np.datetime64(\\'1989-06-01\\'), np.datetime64(\\'2023-01-01\\'))\n\nfig.suptitle(\"Technology company stocks prices dollars (1990-2022)\",\n             ha=\"center\")\n\n# Remove the plot frame lines. They are unnecessary here.\nax.spines[:].set_visible(False)\n\n# Ensure that the axis ticks only show up on the bottom and left of the plot.\n# Ticks on the right and top of the plot are generally unnecessary.\nax.xaxis.tick_bottom()\nax.yaxis.tick_left()\nax.set_yscale(\\'log\\')\n\n# Provide tick lines across the plot to help your viewers trace along\n# the axis ticks. Make sure that the lines are light and small so they\n# don\\'t obscure the primary data lines.\nax.grid(True, \\'major\\', \\'both\\', ls=\\'--\\', lw=.5, c=\\'k\\', alpha=.3)\n\n# Remove the tick marks; they are unnecessary with the tick lines we just\n# plotted. Make sure your axis ticks are large enough to be easily read.\n# You don\\'t want your viewers squinting to read your plot.\nax.tick_params(axis=\\'both\\', which=\\'both\\', labelsize=\\'large\\',\n               bottom=False, top=False, labelbottom=True,\n               left=False, right=False, labelleft=True)\n\n# Finally, save the figure as a PNG.\n# You can also save it as a PDF, JPEG, etc.\n# Just change the file extension in this call.\n# fig.savefig(\\'stock-prices.png\\', bbox_inches=\\'tight\\')\nplt.show()\n",
    "id": 301
},
{
    "title": "XKCD#",
    "text": "Shows how to create an xkcd-like plot. Download Python source code: xkcd.py Download Jupyter notebook: xkcd.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n with plt.xkcd():\n    # Based on \"Stove Ownership\" from XKCD by Randall Munroe\n    # https://xkcd.com/418/\n\n    fig = plt.figure()\n    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))\n    ax.spines[[\\'top\\', \\'right\\].set_visible(False)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_ylim([-30, 10])\n\n    data = np.ones(100)\n    data[70:] -= np.arange(30)\n\n    ax.annotate(\n        \\'THE DAY I REALIZED\\\nI COULD COOK BACON\\\nWHENEVER I WANTED\\',\n        xy=(70, 1), arrowprops=dict(arrowstyle=\\'->\\'), xytext=(15, -10))\n\n    ax.plot(data)\n\n    ax.set_xlabel(\\'time\\')\n    ax.set_ylabel(\\'my overall health\\')\n    fig.text(\n        0.5, 0.05,\n        \\'\"Stove Ownership\" from xkcd by Randall Munroe\\',\n        ha=\\'center\\')\n with plt.xkcd():\n    # Based on \"The Data So Far\" from XKCD by Randall Munroe\n    # https://xkcd.com/373/\n\n    fig = plt.figure()\n    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))\n    ax.bar([0, 1], [0, 100], 0.25)\n    ax.spines[[\\'top\\', \\'right\\].set_visible(False)\n    ax.xaxis.set_ticks_position(\\'bottom\\')\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels([\\'CONFIRMED BY\\\nEXPERIMENT\\', \\'REFUTED BY\\\nEXPERIMENT\\)\n    ax.set_xlim([-0.5, 1.5])\n    ax.set_yticks([])\n    ax.set_ylim([0, 110])\n\n    ax.set_title(\"CLAIMS OF SUPERNATURAL POWERS\")\n\n    fig.text(\n        0.5, 0.05,\n        \\'\"The Data So Far\" from xkcd by Randall Munroe\\',\n        ha=\\'center\\')\n\nplt.show()\n",
    "id": 302
},
{
    "title": "Decay#",
    "text": "This example showcases: using a generator to drive an animation, changing axes limits during an animation. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 8.094 seconds) Download Python source code: animate_decay.py Download Jupyter notebook: animate_decay.ipynb ",
    "code": "import itertools\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n\ndef data_gen():\n    for cnt in itertools.count():\n        t = cnt / 10\n        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)\n\n\ndef init():\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_xlim(0, 1)\n    del xdata[:]\n    del ydata[:]\n    line.set_data(xdata, ydata)\n    return line,\n\nfig, ax = plt.subplots()\nline, = ax.plot([], [], lw=2)\nax.grid()\nxdata, ydata = [], []\n\n\ndef run(data):\n    # update the data\n    t, y = data\n    xdata.append(t)\n    ydata.append(y)\n    xmin, xmax = ax.get_xlim()\n\n    if t >= xmax:\n        ax.set_xlim(xmin, 2*xmax)\n        ax.figure.canvas.draw()\n    line.set_data(xdata, ydata)\n\n    return line,\n\n# Only save last 100 frames, but run forever\nani = animation.FuncAnimation(fig, run, data_gen, interval=100, init_func=init,\n                              save_count=100)\nplt.show()\n",
    "id": 304
},
{
    "title": "Animated histogram#",
    "text": "Use histogram's BarContainer to draw a bunch of rectangles for an animated\nhistogram.\", 'To animate the histogram, we need an animate function, which generates\na random set of numbers and updates the heights of rectangles. We utilize a\npython closure to track an instance of BarContainer whose Rectangle\npatches we shall update. Using hist() allows us to get an instance of\nBarContainer, which is a collection of Rectangle instances. Calling\nprepare_animation will define animate function working with supplied\nBarContainer, all this is used to setup FuncAnimation. Total running time of the script: (0 minutes 5.170 seconds) Download Python source code: animated_histogram.py Download Jupyter notebook: animated_histogram.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n# Fixing bin edges\nHIST_BINS = np.linspace(-4, 4, 100)\n\n# histogram our data with numpy\ndata = np.random.randn(1000)\nn, _ = np.histogram(data, HIST_BINS)\n def prepare_animation(bar_container):\n\n    def animate(frame_number):\n        # simulate new data coming in\n        data = np.random.randn(1000)\n        n, _ = np.histogram(data, HIST_BINS)\n        for count, rect in zip(n, bar_container.patches):\n            rect.set_height(count)\n        return bar_container.patches\n    return animate\n # Output generated via `matplotlib.animation.Animation.to_jshtml`.\n\nfig, ax = plt.subplots()\n_, _, bar_container = ax.hist(data, HIST_BINS, lw=1,\n                              ec=\"yellow\", fc=\"green\", alpha=0.5)\nax.set_ylim(top=55)  # set safe limit to ensure that all data is visible.\n\nani = animation.FuncAnimation(fig, prepare_animation(bar_container), 50,\n                              repeat=False, blit=True)\nplt.show()\n",
    "id": 305
},
{
    "title": "pyplot animation#",
    "text": "Generating an animation by calling pause between plotting commands. The method shown here is only suitable for simple, low-performance use. For\nmore demanding applications, look at the animation module and the\nexamples that use it. Note that calling time.sleep instead of pause would not work. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 7.753 seconds) Download Python source code: animation_demo.py Download Jupyter notebook: animation_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\ndata = np.random.random((50, 50, 50))\n\nfig, ax = plt.subplots()\n\nfor i, img in enumerate(data):\n    ax.clear()\n    ax.imshow(img)\n    ax.set_title(f\"frame {i}\")\n    # Note that using time.sleep does *not* work here!\n    plt.pause(0.1)\n",
    "id": 306
},
{
    "title": "The Bayes update#",
    "text": "This animation displays the posterior estimate updates as it is refitted when\nnew data arrives.\nThe vertical line represents the theoretical value to which the plotted\ndistribution should converge. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.905 seconds) Download Python source code: bayes_update.py Download Jupyter notebook: bayes_update.ipynb ",
    "code": "import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.animation import FuncAnimation\n\n\ndef beta_pdf(x, a, b):\n    return (x**(a-1) * (1-x)**(b-1) * math.gamma(a + b)\n            / (math.gamma(a) * math.gamma(b)))\n\n\nclass UpdateDist:\n    def __init__(self, ax, prob=0.5):\n        self.success = 0\n        self.prob = prob\n        self.line, = ax.plot([], [], 'k-')\n        self.x = np.linspace(0, 1, 200)\n        self.ax = ax\n\n        # Set up plot parameters\n        self.ax.set_xlim(0, 1)\n        self.ax.set_ylim(0, 10)\n        self.ax.grid(True)\n\n        # This vertical line represents the theoretical value, to\n        # which the plotted distribution should converge.\n        self.ax.axvline(prob, linestyle='--', color='black')\n\n    def __call__(self, i):\n        # This way the plot can continuously run and we just keep\n        # watching new realizations of the process\n        if i == 0:\n            self.success = 0\n            self.line.set_data([], [])\n            return self.line,\n\n        # Choose success based on exceed a threshold with a uniform pick\n        if np.random.rand() < self.prob:\n            self.success += 1\n        y = beta_pdf(self.x, self.success + 1, (i - self.success) + 1)\n        self.line.set_data(self.x, y)\n        return self.line,\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig, ax = plt.subplots()\nud = UpdateDist(ax, prob=0.7)\nanim = FuncAnimation(fig, ud, frames=100, interval=100, blit=True)\nplt.show()\n",
    "id": 307
},
{
    "title": "The double pendulum problem#",
    "text": "This animation illustrates the double pendulum problem. Double pendulum formula translated from the C code at\nhttp://www.physics.usyd.edu.au/~wheat/dpend_html/solve_dpend.c Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 17.031 seconds) Download Python source code: double_pendulum.py Download Jupyter notebook: double_pendulum.ipynb ",
    "code": "from collections import deque\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import cos, sin\n\nimport matplotlib.animation as animation\n\nG = 9.8  # acceleration due to gravity, in m/s^2\nL1 = 1.0  # length of pendulum 1 in m\nL2 = 1.0  # length of pendulum 2 in m\nL = L1 + L2  # maximal length of the combined pendulum\nM1 = 1.0  # mass of pendulum 1 in kg\nM2 = 1.0  # mass of pendulum 2 in kg\nt_stop = 2.5  # how many seconds to simulate\nhistory_len = 500  # how many trajectory points to display\n\n\ndef derivs(t, state):\n    dydx = np.zeros_like(state)\n\n    dydx[0] = state[1]\n\n    delta = state[2] - state[0]\n    den1 = (M1+M2) * L1 - M2 * L1 * cos(delta) * cos(delta)\n    dydx[1] = ((M2 * L1 * state[1] * state[1] * sin(delta) * cos(delta)\n                + M2 * G * sin(state[2]) * cos(delta)\n                + M2 * L2 * state[3] * state[3] * sin(delta)\n                - (M1+M2) * G * sin(state[0]))\n               / den1)\n\n    dydx[2] = state[3]\n\n    den2 = (L2/L1) * den1\n    dydx[3] = ((- M2 * L2 * state[3] * state[3] * sin(delta) * cos(delta)\n                + (M1+M2) * G * sin(state[0]) * cos(delta)\n                - (M1+M2) * L1 * state[1] * state[1] * sin(delta)\n                - (M1+M2) * G * sin(state[2]))\n               / den2)\n\n    return dydx\n\n# create a time array from 0..t_stop sampled at 0.02 second steps\ndt = 0.01\nt = np.arange(0, t_stop, dt)\n\n# th1 and th2 are the initial angles (degrees)\n# w10 and w20 are the initial angular velocities (degrees per second)\nth1 = 120.0\nw1 = 0.0\nth2 = -10.0\nw2 = 0.0\n\n# initial state\nstate = np.radians([th1, w1, th2, w2])\n\n# integrate the ODE using Euler's method\ny = np.empty((len(t), 4))\ny[0] = state\nfor i in range(1, len(t)):\n    y[i] = y[i - 1] + derivs(t[i - 1], y[i - 1]) * dt\n\n# A more accurate estimate could be obtained e.g. using scipy:\n#\n#   y = scipy.integrate.solve_ivp(derivs, t[[0, -1]], state, t_eval=t).y.T\n\nx1 = L1*sin(y[:, 0])\ny1 = -L1*cos(y[:, 0])\n\nx2 = L2*sin(y[:, 2]) + x1\ny2 = -L2*cos(y[:, 2]) + y1\n\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(autoscale_on=False, xlim=(-L, L), ylim=(-L, 1.))\nax.set_aspect('equal')\nax.grid()\n\nline, = ax.plot([], [], 'o-', lw=2)\ntrace, = ax.plot([], [], '.-', lw=1, ms=2)\ntime_template = 'time = %.1fs'\ntime_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)\nhistory_x, history_y = deque(maxlen=history_len), deque(maxlen=history_len)\n\n\ndef animate(i):\n    thisx = [0, x1[i], x2[i]]\n    thisy = [0, y1[i], y2[i]]\n\n    if i == 0:\n        history_x.clear()\n        history_y.clear()\n\n    history_x.appendleft(thisx[2])\n    history_y.appendleft(thisy[2])\n\n    line.set_data(thisx, thisy)\n    trace.set_data(history_x, history_y)\n    time_text.set_text(time_template % (i*dt))\n    return line, trace, time_text\n\n\nani = animation.FuncAnimation(\n    fig, animate, len(y), interval=dt*1000, blit=True)\nplt.show()\n",
    "id": 308
},
{
    "title": "Animated image using a precomputed list of images#",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.011 seconds) Download Python source code: dynamic_image.py Download Jupyter notebook: dynamic_image.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\n\ndef f(x, y):\n    return np.sin(x) + np.cos(y)\n\nx = np.linspace(0, 2 * np.pi, 120)\ny = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)\n\n# ims is a list of lists, each row is a list of artists to draw in the\n# current frame; here we are just animating one artist, the image, in\n# each frame\nims = []\nfor i in range(60):\n    x += np.pi / 15\n    y += np.pi / 30\n    im = ax.imshow(f(x, y), animated=True)\n    if i == 0:\n        ax.imshow(f(x, y))  # show an initial one first\n    ims.append([im])\n\nani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,\n                                repeat_delay=1000)\n\n# To save the animation, use e.g.\n#\n# ani.save(\"movie.mp4\")\n#\n# or\n#\n# writer = animation.FFMpegWriter(\n#     fps=15, metadata=dict(artist=\\'Me\\'), bitrate=1800)\n# ani.save(\"movie.mp4\", writer=writer)\n\nplt.show()\n",
    "id": 309
},
{
    "title": "Frame grabbing#",
    "text": "Use a MovieWriter directly to grab individual frames and write them to a\nfile. This avoids any event loop integration, and thus works even with the Agg\nbackend. This is not recommended for use in an interactive setting. Output generated via matplotlib.animation.Animation.to_jshtml. Download Python source code: frame_grabbing_sgskip.py Download Jupyter notebook: frame_grabbing_sgskip.ipynb ",
    "code": "import numpy as np\n\nimport matplotlib\n\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.animation import FFMpegWriter\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nmetadata = dict(title=\\'Movie Test\\', artist=\\'Matplotlib\\',\n                comment=\\'Movie support!\\')\nwriter = FFMpegWriter(fps=15, metadata=metadata)\n\nfig = plt.figure()\nl, = plt.plot([], [], \\'k-o\\')\n\nplt.xlim(-5, 5)\nplt.ylim(-5, 5)\n\nx0, y0 = 0, 0\n\nwith writer.saving(fig, \"writer_test.mp4\", 100):\n    for i in range(100):\n        x0 += 0.1 * np.random.randn()\n        y0 += 0.1 * np.random.randn()\n        l.set_data(x0, y0)\n        writer.grab_frame()\n",
    "id": 310
},
{
    "title": "Multiple axes animation#",
    "text": "This example showcases: how animation across multiple subplots works, using a figure artist in the animation. Output generated via matplotlib.animation.Animation.to_jshtml. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches.ConnectionPatch matplotlib.animation.FuncAnimation Total running time of the script: (0 minutes 2.845 seconds) Download Python source code: multiple_axes.py Download Jupyter notebook: multiple_axes.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\nfrom matplotlib.patches import ConnectionPatch\n\nfig, (axl, axr) = plt.subplots(\n    ncols=2,\n    sharey=True,\n    figsize=(6, 2),\n    gridspec_kw=dict(width_ratios=[1, 3], wspace=0),\n)\naxl.set_aspect(1)\naxr.set_box_aspect(1 / 3)\naxr.yaxis.set_visible(False)\naxr.xaxis.set_ticks([0, np.pi, 2 * np.pi], 0\", r\"$\\\\pi$\", r\"$2\\\\pi$)\n\n# draw circle with initial point in left Axes\nx = np.linspace(0, 2 * np.pi, 50)\naxl.plot(np.cos(x), np.sin(x), \"k\", lw=0.3)\npoint, = axl.plot(0, 0, \"o\")\n\n# draw full curve to set view limits in right Axes\nsine, = axr.plot(x, np.sin(x))\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (1, 0),\n    (0, 0),\n    \"data\",\n    \"data\",\n    axesA=axl,\n    axesB=axr,\n    color=\"C0\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\n\n\ndef animate(i):\n    x = np.linspace(0, i, int(i * 25 / np.pi))\n    sine.set_data(x, np.sin(x))\n    x, y = np.cos(i), np.sin(i)\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = i, y\n    return point, sine, con\n\n\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=50,\n    blit=False,  # blitting can\\'t be used with Figure artists\n    frames=x,\n    repeat_delay=100,\n)\n\nplt.show()\n",
    "id": 311
},
{
    "title": "Pausing and Resuming an Animation#",
    "text": "This example showcases: using the Animation.pause() method to pause an animation. using the Animation.resume() method to resume an animation. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Output generated via matplotlib.animation.Animation.to_jshtml. Download Python source code: pause_resume.py Download Jupyter notebook: pause_resume.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n\nclass PauseAnimation:\n    def __init__(self):\n        fig, ax = plt.subplots()\n        ax.set_title('Click to pause/resume the animation')\n        x = np.linspace(-0.1, 0.1, 1000)\n\n        # Start with a normal distribution\n        self.n0 = (1.0 / ((4 * np.pi * 2e-4 * 0.1) ** 0.5)\n                   * np.exp(-x ** 2 / (4 * 2e-4 * 0.1)))\n        self.p, = ax.plot(x, self.n0)\n\n        self.animation = animation.FuncAnimation(\n            fig, self.update, frames=200, interval=50, blit=True)\n        self.paused = False\n\n        fig.canvas.mpl_connect('button_press_event', self.toggle_pause)\n\n    def toggle_pause(self, *args, **kwargs):\n        if self.paused:\n            self.animation.resume()\n        else:\n            self.animation.pause()\n        self.paused = not self.paused\n\n    def update(self, i):\n        self.n0 += i / 100 % 5\n        self.p.set_ydata(self.n0 % 20)\n        return (self.p,)\n\n\npa = PauseAnimation()\nplt.show()\n",
    "id": 312
},
{
    "title": "Rain simulation#",
    "text": "Simulates rain drops on a surface by animating the scale and opacity\nof 50 scatter points. Author: Nicolas P. Rougier Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 3.503 seconds) Download Python source code: rain.py Download Jupyter notebook: rain.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.animation import FuncAnimation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# Create new Figure and an Axes which fills it.\nfig = plt.figure(figsize=(7, 7))\nax = fig.add_axes([0, 0, 1, 1], frameon=False)\nax.set_xlim(0, 1), ax.set_xticks([])\nax.set_ylim(0, 1), ax.set_yticks([])\n\n# Create rain data\nn_drops = 50\nrain_drops = np.zeros(n_drops, dtype=[('position', float, (2,)),\n                                      ('size',     float),\n                                      ('growth',   float),\n                                      ('color',    float, (4,))])\n\n# Initialize the raindrops in random positions and with\n# random growth rates.\nrain_dropsposition = np.random.uniform(0, 1, (n_drops, 2))\nrain_dropsgrowth = np.random.uniform(50, 200, n_drops)\n\n# Construct the scatter which we will update during animation\n# as the raindrops develop.\nscat = ax.scatter(rain_dropsposition[:, 0], rain_dropsposition[:, 1],\n                  s=rain_dropssize, lw=0.5, edgecolors=rain_dropscolor,\n                  facecolors='none')\n\n\ndef update(frame_number):\n    # Get an index which we can use to re-spawn the oldest raindrop.\n    current_index = frame_number % n_drops\n\n    # Make all colors more transparent as time progresses.\n    rain_dropscolor[:, 3] -= 1.0/len(rain_drops)\n    rain_dropscolor[:, 3] = np.clip(rain_dropscolor[:, 3], 0, 1)\n\n    # Make all circles bigger.\n    rain_dropssize += rain_dropsgrowth\n\n    # Pick a new position for oldest rain drop, resetting its size,\n    # color and growth factor.\n    rain_dropsposition[current_index] = np.random.uniform(0, 1, 2)\n    rain_dropssize[current_index] = 5\n    rain_dropscolor[current_index] = (0, 0, 0, 1)\n    rain_dropsgrowth[current_index] = np.random.uniform(50, 200)\n\n    # Update the scatter collection, with the new colors, sizes and positions.\n    scat.set_edgecolors(rain_dropscolor)\n    scat.set_sizes(rain_dropssize)\n    scat.set_offsets(rain_dropsposition)\n\n\n# Construct the animation, using the update function as the animation director.\nanimation = FuncAnimation(fig, update, interval=10, save_count=100)\nplt.show()\n",
    "id": 313
},
{
    "title": "Animated 3D random walk#",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 3.220 seconds) Download Python source code: random_walk.py Download Jupyter notebook: random_walk.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef random_walk(num_steps, max_step=0.05):\n    \"\"\"Return a 3D random walk as (num_steps, 3) array.\"\"\"\n    start_pos = np.random.random(3)\n    steps = np.random.uniform(-max_step, max_step, size=(num_steps, 3))\n    walk = start_pos + np.cumsum(steps, axis=0)\n    return walk\n\n\ndef update_lines(num, walks, lines):\n    for line, walk in zip(lines, walks):\n        # NOTE: there is no .set_data() for 3 dim data...\n        line.set_data(walk[:num, :2].T)\n        line.set_3d_properties(walk[:num, 2])\n    return lines\n\n\n# Data: 40 random walks as (num_steps, 3) arrays\nnum_steps = 30\nwalks = [random_walk(num_steps) for index in range(40)]\n\n# Attaching 3D axis to the figure\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\n\n# Create lines initially without data\nlines = [ax.plot([], [], [])[0] for _ in walks]\n\n# Setting the axes properties\nax.set(xlim3d=(0, 1), xlabel=\\'X\\')\nax.set(ylim3d=(0, 1), ylabel=\\'Y\\')\nax.set(zlim3d=(0, 1), zlabel=\\'Z\\')\n\n# Creating the Animation object\nani = animation.FuncAnimation(\n    fig, update_lines, num_steps, fargs=(walks, lines), interval=100)\n\nplt.show()\n",
    "id": 314
},
{
    "title": "Animated line plot#",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 3.379 seconds) Download Python source code: simple_anim.py Download Jupyter notebook: simple_anim.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\n\nx = np.arange(0, 2*np.pi, 0.01)\nline, = ax.plot(x, np.sin(x))\n\n\ndef animate(i):\n    line.set_ydata(np.sin(x + i / 50))  # update the data.\n    return line,\n\n\nani = animation.FuncAnimation(\n    fig, animate, interval=20, blit=True, save_count=50)\n\n# To save the animation, use e.g.\n#\n# ani.save(\"movie.mp4\")\n#\n# or\n#\n# writer = animation.FFMpegWriter(\n#     fps=15, metadata=dict(artist=\\'Me\\'), bitrate=1800)\n# ani.save(\"movie.mp4\", writer=writer)\n\nplt.show()\n",
    "id": 315
},
{
    "title": "Animated scatter saved as GIF#",
    "text": "Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 2.912 seconds) Download Python source code: simple_scatter.py Download Jupyter notebook: simple_scatter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\nax.set_xlim([0, 10])\n\nscat = ax.scatter(1, 0)\nx = np.linspace(0, 10)\n\n\ndef animate(i):\n    scat.set_offsets((x[i], 0))\n    return scat,\n\nani = animation.FuncAnimation(fig, animate, repeat=True,\n                                    frames=len(x) - 1, interval=50)\n\n# To save the animation using Pillow as a gif\n# writer = animation.PillowWriter(fps=15,\n#                                 metadata=dict(artist='Me'),\n#                                 bitrate=1800)\n# ani.save('scatter.gif', writer=writer)\n\nplt.show()\n",
    "id": 316
},
{
    "title": "Oscilloscope#",
    "text": "Emulates an oscilloscope. Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 6.324 seconds) Download Python source code: strip_chart.py Download Jupyter notebook: strip_chart.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\nfrom matplotlib.lines import Line2D\n\n\nclass Scope:\n    def __init__(self, ax, maxt=2, dt=0.02):\n        self.ax = ax\n        self.dt = dt\n        self.maxt = maxt\n        self.tdata = [0]\n        self.ydata = [0]\n        self.line = Line2D(self.tdata, self.ydata)\n        self.ax.add_line(self.line)\n        self.ax.set_ylim(-.1, 1.1)\n        self.ax.set_xlim(0, self.maxt)\n\n    def update(self, y):\n        lastt = self.tdata[-1]\n        if lastt >= self.tdata[0] + self.maxt:  # reset the arrays\n            self.tdata = [self.tdata[-1]]\n            self.ydata = [self.ydata[-1]]\n            self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)\n            self.ax.figure.canvas.draw()\n\n        # This slightly more complex calculation avoids floating-point issues\n        # from just repeatedly adding `self.dt` to the previous value.\n        t = self.tdata[0] + len(self.tdata) * self.dt\n\n        self.tdata.append(t)\n        self.ydata.append(y)\n        self.line.set_data(self.tdata, self.ydata)\n        return self.line,\n\n\ndef emitter(p=0.1):\n    \"\"\"Return a random value in [0, 1) with probability p, else 0.\"\"\"\n    while True:\n        v = np.random.rand()\n        if v > p:\n            yield 0.\n        else:\n            yield np.random.rand()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801 // 10)\n\n\nfig, ax = plt.subplots()\nscope = Scope(ax)\n\n# pass a generator in \"emitter\" to produce data for the update func\nani = animation.FuncAnimation(fig, scope.update, emitter, interval=50,\n                              blit=True, save_count=100)\n\nplt.show()\n",
    "id": 317
},
{
    "title": "MATPLOTLIB UNCHAINED#",
    "text": "Comparative path demonstration of frequency from a fake signal of a pulsar\n(mostly known because of the cover for Joy Division's Unknown Pleasures).\", 'Author: Nicolas P. Rougier Output generated via matplotlib.animation.Animation.to_jshtml. Total running time of the script: (0 minutes 5.886 seconds) Download Python source code: unchained.py Download Jupyter notebook: unchained.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# Create new Figure with black background\nfig = plt.figure(figsize=(8, 8), facecolor=\\'black\\')\n\n# Add a subplot with no frame\nax = plt.subplot(frameon=False)\n\n# Generate random data\ndata = np.random.uniform(0, 1, (64, 75))\nX = np.linspace(-1, 1, data.shape[-1])\nG = 1.5 * np.exp(-4 * X ** 2)\n\n# Generate line plots\nlines = []\nfor i in range(len(data)):\n    # Small reduction of the X extents to get a cheap perspective effect\n    xscale = 1 - i / 200.\n    # Same for linewidth (thicker strokes on bottom)\n    lw = 1.5 - i / 100.0\n    line, = ax.plot(xscale * X, i + G * data[i], color=\"w\", lw=lw)\n    lines.append(line)\n\n# Set y limit (or first line is cropped because of thickness)\nax.set_ylim(-1, 70)\n\n# No ticks\nax.set_xticks([])\nax.set_yticks([])\n\n# 2 part titles to get different font weights\nax.text(0.5, 1.0, \"MATPLOTLIB \", transform=ax.transAxes,\n        ha=\"right\", va=\"bottom\", color=\"w\",\n        family=\"sans-serif\", fontweight=\"light\", fontsize=16)\nax.text(0.5, 1.0, \"UNCHAINED\", transform=ax.transAxes,\n        ha=\"left\", va=\"bottom\", color=\"w\",\n        family=\"sans-serif\", fontweight=\"bold\", fontsize=16)\n\n\ndef update(*args):\n    # Shift all data to the right\n    data[:, 1:] = data[:, :-1]\n\n    # Fill-in new values\n    data[:, 0] = np.random.uniform(0, 1, len(data))\n\n    # Update data\n    for i in range(len(data)):\n        lines[i].set_ydata(i + G * data[i])\n\n    # Return modified artists\n    return lines\n\n# Construct the animation, using the update function as the animation director.\nanim = animation.FuncAnimation(fig, update, interval=10, save_count=100)\nplt.show()\n",
    "id": 318
},
{
    "title": "Close Event#",
    "text": "Example to show connecting events that occur when the figure closes. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: close_event.py Download Jupyter notebook: close_event.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef on_close(event):\n    print('Closed Figure!')\n\nfig = plt.figure()\nfig.canvas.mpl_connect('close_event', on_close)\n\nplt.text(0.35, 0.5, 'Close Me!', dict(size=30))\nplt.show()\n",
    "id": 320
},
{
    "title": "Mouse move and click events#",
    "text": "An example of how to interact with the plotting canvas by connecting to move\nand click events. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: coords_demo.py Download Jupyter notebook: coords_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\n\nt = np.arange(0.0, 1.0, 0.01)\ns = np.sin(2 * np.pi * t)\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n\ndef on_move(event):\n    if event.inaxes:\n        print(f'data coords {event.xdata} {event.ydata},',\n              f'pixel coords {event.x} {event.y}')\n\n\ndef on_click(event):\n    if event.button is MouseButton.LEFT:\n        print('disconnecting callback')\n        plt.disconnect(binding_id)\n\n\nbinding_id = plt.connect('motion_notify_event', on_move)\nplt.connect('button_press_event', on_click)\n\nplt.show()\n",
    "id": 321
},
{
    "title": "Cross-hair cursor#",
    "text": "This example adds a cross-hair as a data cursor. The cross-hair is\nimplemented as regular line objects that are updated on mouse move. We show three implementations: A simple cursor implementation that redraws the figure on every mouse move.\nThis is a bit slow, and you may notice some lag of the cross-hair movement. A cursor that uses blitting for speedup of the rendering. A cursor that snaps to data points. Faster cursoring is possible using native GUI drawing, as in\nAdding a cursor in WX. The mpldatacursor and mplcursors third-party packages can be used to\nachieve a similar effect. This technique stores the rendered plot as a background image. Only the\nchanged artists (cross-hair lines and text) are rendered anew. They are\ncombined with the background using blitting.', \"This technique is significantly faster. It requires a bit more setup because\nthe background has to be stored without the cross-hair lines (see\ncreate_new_background()). Additionally, a new background has to be\ncreated whenever the figure changes. This is achieved by connecting to the\n'draw_event'.\", 'The following cursor snaps its position to the data points of a Line2D\nobject. To save unnecessary redraws, the index of the last indicated data point is\nsaved in self._last_index. A redraw is only triggered when the mouse\nmoves far enough so that another data point must be selected. This reduces\nthe lag due to many redraws. Of course, blitting could still be added on top\nfor additional speedup. Download Python source code: cursor_demo.py Download Jupyter notebook: cursor_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseEvent\n\n\nclass Cursor:\n    \"\"\"\n    A cross hair cursor.\n    \"\"\"\n    def __init__(self, ax):\n        self.ax = ax\n        self.horizontal_line = ax.axhline(color=\\'k\\', lw=0.8, ls=\\'--\\')\n        self.vertical_line = ax.axvline(color=\\'k\\', lw=0.8, ls=\\'--\\')\n        # text location in axes coordinates\n        self.text = ax.text(0.72, 0.9, \\'\\', transform=ax.transAxes)\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def on_mouse_move(self, event):\n        if not event.inaxes:\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.draw()\n        else:\n            self.set_cross_hair_visible(True)\n            x, y = event.xdata, event.ydata\n            # update the line positions\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f\\'x={x:1.2f}, y={y:1.2f}\\')\n            self.ax.figure.canvas.draw()\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title(\\'Simple cursor\\')\nax.plot(x, y, \\'o\\')\ncursor = Cursor(ax)\nfig.canvas.mpl_connect(\\'motion_notify_event\\', cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n class BlittedCursor:\n    \"\"\"\n    A cross-hair cursor using blitting for faster redraw.\n    \"\"\"\n    def __init__(self, ax):\n        self.ax = ax\n        self.background = None\n        self.horizontal_line = ax.axhline(color=\\'k\\', lw=0.8, ls=\\'--\\')\n        self.vertical_line = ax.axvline(color=\\'k\\', lw=0.8, ls=\\'--\\')\n        # text location in axes coordinates\n        self.text = ax.text(0.72, 0.9, \\'\\', transform=ax.transAxes)\n        self._creating_background = False\n        ax.figure.canvas.mpl_connect(\\'draw_event\\', self.on_draw)\n\n    def on_draw(self, event):\n        self.create_new_background()\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def create_new_background(self):\n        if self._creating_background:\n            # discard calls triggered from within this function\n            return\n        self._creating_background = True\n        self.set_cross_hair_visible(False)\n        self.ax.figure.canvas.draw()\n        self.background = self.ax.figure.canvas.copy_from_bbox(self.ax.bbox)\n        self.set_cross_hair_visible(True)\n        self._creating_background = False\n\n    def on_mouse_move(self, event):\n        if self.background is None:\n            self.create_new_background()\n        if not event.inaxes:\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.restore_region(self.background)\n                self.ax.figure.canvas.blit(self.ax.bbox)\n        else:\n            self.set_cross_hair_visible(True)\n            # update the line positions\n            x, y = event.xdata, event.ydata\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f\\'x={x:1.2f}, y={y:1.2f}\\')\n\n            self.ax.figure.canvas.restore_region(self.background)\n            self.ax.draw_artist(self.horizontal_line)\n            self.ax.draw_artist(self.vertical_line)\n            self.ax.draw_artist(self.text)\n            self.ax.figure.canvas.blit(self.ax.bbox)\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title(\\'Blitted cursor\\')\nax.plot(x, y, \\'o\\')\nblitted_cursor = BlittedCursor(ax)\nfig.canvas.mpl_connect(\\'motion_notify_event\\', blitted_cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n class SnappingCursor:\n    \"\"\"\n    A cross-hair cursor that snaps to the data point of a line, which is\n    closest to the *x* position of the cursor.\n\n    For simplicity, this assumes that *x* values of the data are sorted.\n    \"\"\"\n    def __init__(self, ax, line):\n        self.ax = ax\n        self.horizontal_line = ax.axhline(color=\\'k\\', lw=0.8, ls=\\'--\\')\n        self.vertical_line = ax.axvline(color=\\'k\\', lw=0.8, ls=\\'--\\')\n        self.x, self.y = line.get_data()\n        self._last_index = None\n        # text location in axes coords\n        self.text = ax.text(0.72, 0.9, \\'\\', transform=ax.transAxes)\n\n    def set_cross_hair_visible(self, visible):\n        need_redraw = self.horizontal_line.get_visible() != visible\n        self.horizontal_line.set_visible(visible)\n        self.vertical_line.set_visible(visible)\n        self.text.set_visible(visible)\n        return need_redraw\n\n    def on_mouse_move(self, event):\n        if not event.inaxes:\n            self._last_index = None\n            need_redraw = self.set_cross_hair_visible(False)\n            if need_redraw:\n                self.ax.figure.canvas.draw()\n        else:\n            self.set_cross_hair_visible(True)\n            x, y = event.xdata, event.ydata\n            index = min(np.searchsorted(self.x, x), len(self.x) - 1)\n            if index == self._last_index:\n                return  # still on the same data point. Nothing to do.\n            self._last_index = index\n            x = self.x[index]\n            y = self.y[index]\n            # update the line positions\n            self.horizontal_line.set_ydata([y])\n            self.vertical_line.set_xdata([x])\n            self.text.set_text(f\\'x={x:1.2f}, y={y:1.2f}\\')\n            self.ax.figure.canvas.draw()\n\n\nx = np.arange(0, 1, 0.01)\ny = np.sin(2 * 2 * np.pi * x)\n\nfig, ax = plt.subplots()\nax.set_title(\\'Snapping cursor\\')\nline, = ax.plot(x, y, \\'o\\')\nsnap_cursor = SnappingCursor(ax, line)\nfig.canvas.mpl_connect(\\'motion_notify_event\\', snap_cursor.on_mouse_move)\n\n# Simulate a mouse move to (0.5, 0.5), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((0.5, 0.5))\n)._process()\n\nplt.show()\n",
    "id": 322
},
{
    "title": "Data browser#",
    "text": "Connecting data between multiple canvases. This example covers how to interact data with multiple canvases. This\nlets you select and highlight a point on one axis, and generating the\ndata of that point on the other axis. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: data_browser.py Download Jupyter notebook: data_browser.ipynb ",
    "code": "import numpy as np\n\n\nclass PointBrowser:\n    \"\"\"\n    Click on a point to select and highlight it -- the data that\n    generated the point will be shown in the lower axes.  Use the \\'n\\'\n    and \\'p\\' keys to browse through the next and previous points\n    \"\"\"\n\n    def __init__(self):\n        self.lastind = 0\n\n        self.text = ax.text(0.05, 0.95, \\'selected: none\\',\n                            transform=ax.transAxes, va=\\'top\\')\n        self.selected, = ax.plot([xs[0]], [ys[0]], \\'o\\', ms=12, alpha=0.4,\n                                 color=\\'yellow\\', visible=False)\n\n    def on_press(self, event):\n        if self.lastind is None:\n            return\n        if event.key not in (\\'n\\', \\'p\\'):\n            return\n        if event.key == \\'n\\':\n            inc = 1\n        else:\n            inc = -1\n\n        self.lastind += inc\n        self.lastind = np.clip(self.lastind, 0, len(xs) - 1)\n        self.update()\n\n    def on_pick(self, event):\n\n        if event.artist != line:\n            return True\n\n        N = len(event.ind)\n        if not N:\n            return True\n\n        # the click locations\n        x = event.mouseevent.xdata\n        y = event.mouseevent.ydata\n\n        distances = np.hypot(x - xs[event.ind], y - ys[event.ind])\n        indmin = distances.argmin()\n        dataind = event.ind[indmin]\n\n        self.lastind = dataind\n        self.update()\n\n    def update(self):\n        if self.lastind is None:\n            return\n\n        dataind = self.lastind\n\n        ax2.clear()\n        ax2.plot(X[dataind])\n\n        ax2.text(0.05, 0.9, f\\'mu={xs[dataind]:1.3f}\\\nsigma={ys[dataind]:1.3f}\\',\n                 transform=ax2.transAxes, va=\\'top\\')\n        ax2.set_ylim(-0.5, 1.5)\n        self.selected.set_visible(True)\n        self.selected.set_data(xs[dataind], ys[dataind])\n\n        self.text.set_text(\\'selected: %d\\' % dataind)\n        fig.canvas.draw()\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    X = np.random.rand(100, 200)\n    xs = np.mean(X, axis=1)\n    ys = np.std(X, axis=1)\n\n    fig, (ax, ax2) = plt.subplots(2, 1)\n    ax.set_title(\\'click on point to plot time series\\')\n    line, = ax.plot(xs, ys, \\'o\\', picker=True, pickradius=5)\n\n    browser = PointBrowser()\n\n    fig.canvas.mpl_connect(\\'pick_event\\', browser.on_pick)\n    fig.canvas.mpl_connect(\\'key_press_event\\', browser.on_press)\n\n    plt.show()\n",
    "id": 323
},
{
    "title": "Figure/Axes enter and leave events#",
    "text": "Illustrate the figure and Axes enter and leave events by changing the\nframe colors on enter and leave. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: figure_axes_enter_leave.py Download Jupyter notebook: figure_axes_enter_leave.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef on_enter_axes(event):\n    print('enter_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('yellow')\n    event.canvas.draw()\n\n\ndef on_leave_axes(event):\n    print('leave_axes', event.inaxes)\n    event.inaxes.patch.set_facecolor('white')\n    event.canvas.draw()\n\n\ndef on_enter_figure(event):\n    print('enter_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('red')\n    event.canvas.draw()\n\n\ndef on_leave_figure(event):\n    print('leave_figure', event.canvas.figure)\n    event.canvas.figure.patch.set_facecolor('grey')\n    event.canvas.draw()\n\n\nfig, axs = plt.subplots(2, 1)\nfig.suptitle('mouse hover over figure or axes to trigger events')\n\nfig.canvas.mpl_connect('figure_enter_event', on_enter_figure)\nfig.canvas.mpl_connect('figure_leave_event', on_leave_figure)\nfig.canvas.mpl_connect('axes_enter_event', on_enter_axes)\nfig.canvas.mpl_connect('axes_leave_event', on_leave_axes)\n\nplt.show()\n",
    "id": 324
},
{
    "title": "Interactive functions#",
    "text": "This provides examples of uses of interactive functions, such as ginput,\nwaitforbuttonpress and manual clabel placement. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Define a triangle by clicking three points Now contour according to distance from triangle\ncorners - just an example Now do a zoom Download Python source code: ginput_manual_clabel_sgskip.py Download Jupyter notebook: ginput_manual_clabel_sgskip.ipynb ",
    "code": "import time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef tellme(s):\n    print(s)\n    plt.title(s, fontsize=16)\n    plt.draw()\n', \"plt.figure()\nplt.xlim(0, 1)\nplt.ylim(0, 1)\n\ntellme('You will define a triangle, click to begin')\n\nplt.waitforbuttonpress()\n\nwhile True:\n    pts = []\n    while len(pts) < 3:\n        tellme('Select 3 corners with mouse')\n        pts = np.asarray(plt.ginput(3, timeout=-1))\n        if len(pts) < 3:\n            tellme('Too few points, starting over')\n            time.sleep(1)  # Wait a second\n\n    ph = plt.fill(pts[:, 0], pts[:, 1], 'r', lw=2)\n\n    tellme('Happy? Key click for yes, mouse click for no')\n\n    if plt.waitforbuttonpress():\n        break\n\n    # Get rid of fill\n    for p in ph:\n        p.remove()\n\", \"# Define a nice function of distance from individual pts\ndef f(x, y, pts):\n    z = np.zeros_like(x)\n    for p in pts:\n        z = z + 1/(np.sqrt((x - p[0])**2 + (y - p[1])**2))\n    return 1/z\n\n\nX, Y = np.meshgrid(np.linspace(-1, 1, 51), np.linspace(-1, 1, 51))\nZ = f(X, Y, pts)\n\nCS = plt.contour(X, Y, Z, 20)\n\ntellme('Use mouse to select contour label locations, middle button to finish')\nCL = plt.clabel(CS, manual=True)\n\", \"tellme('Now do a nested zoom, click to begin')\nplt.waitforbuttonpress()\n\nwhile True:\n    tellme('Select two corners of zoom, middle mouse button to finish')\n    pts = plt.ginput(2, timeout=-1)\n    if len(pts) < 2:\n        break\n    (x0, y0), (x1, y1) = pts\n    xmin, xmax = sorted([x0, x1])\n    ymin, ymax = sorted([y0, y1])\n    plt.xlim(xmin, xmax)\n    plt.ylim(ymin, ymax)\n\ntellme('All Done!')\nplt.show()\n",
    "id": 325
},
{
    "title": "Scroll event#",
    "text": "In this example a scroll wheel event is used to scroll through 2D slices of\n3D data. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: image_slices_viewer.py Download Jupyter notebook: image_slices_viewer.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass IndexTracker:\n    def __init__(self, ax, X):\n        self.index = 0\n        self.X = X\n        self.ax = ax\n        self.im = ax.imshow(self.X[:, :, self.index])\n        self.update()\n\n    def on_scroll(self, event):\n        print(event.button, event.step)\n        increment = 1 if event.button == 'up' else -1\n        max_index = self.X.shape[-1] - 1\n        self.index = np.clip(self.index + increment, 0, max_index)\n        self.update()\n\n    def update(self):\n        self.im.set_data(self.X[:, :, self.index])\n        self.ax.set_title(\n            f'Use scroll wheel to navigate\\\nindex {self.index}')\n        self.im.axes.figure.canvas.draw()\n\n\nx, y, z = np.ogrid[-10:10:100j, -10:10:100j, 1:10:20j]\nX = np.sin(x * y * z) / (x * y * z)\n\nfig, ax = plt.subplots()\n# create an IndexTracker and make sure it lives during the whole\n# lifetime of the figure by assigning it to a variable\ntracker = IndexTracker(ax, X)\n\nfig.canvas.mpl_connect('scroll_event', tracker.on_scroll)\nplt.show()\n",
    "id": 326
},
{
    "title": "Keypress event#",
    "text": "Show how to connect to keypress events. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: keypress_demo.py Download Jupyter notebook: keypress_demo.ipynb ",
    "code": "import sys\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef on_press(event):\n    print('press', event.key)\n    sys.stdout.flush()\n    if event.key == 'x':\n        visible = xl.get_visible()\n        xl.set_visible(not visible)\n        fig.canvas.draw()\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\n\nfig.canvas.mpl_connect('key_press_event', on_press)\n\nax.plot(np.random.rand(12), np.random.rand(12), 'go')\nxl = ax.set_xlabel('easy come, easy go')\nax.set_title('Press a key')\nplt.show()\n",
    "id": 327
},
{
    "title": "Lasso Demo#",
    "text": "Use a lasso to select a set of points and get the indices of the selected points.\nA callback is used to change the color of the selected points. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: lasso_demo.py Download Jupyter notebook: lasso_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import colors as mcolors\nfrom matplotlib import path\nfrom matplotlib.collections import RegularPolyCollection\nfrom matplotlib.widgets import Lasso\n\n\nclass LassoManager:\n    def __init__(self, ax, data):\n        # The information of whether a point has been selected or not is stored in the\n        # collection\\'s array (0 = out, 1 = in), which then gets colormapped to blue\n        # (out) and red (in).\n        self.collection = RegularPolyCollection(\n            6, sizes=(100,), offset_transform=ax.transData,\n            offsets=data, array=np.zeros(len(data)),\n            clim=(0, 1), cmap=mcolors.ListedColormap(tab:blue\", \"tab:red))\n        ax.add_collection(self.collection)\n        canvas = ax.figure.canvas\n        canvas.mpl_connect(\\'button_press_event\\', self.on_press)\n        canvas.mpl_connect(\\'button_release_event\\', self.on_release)\n\n    def callback(self, verts):\n        data = self.collection.get_offsets()\n        self.collection.set_array(path.Path(verts).contains_points(data))\n        canvas = self.collection.figure.canvas\n        canvas.draw_idle()\n        del self.lasso\n\n    def on_press(self, event):\n        canvas = self.collection.figure.canvas\n        if event.inaxes is not self.collection.axes or canvas.widgetlock.locked():\n            return\n        self.lasso = Lasso(event.inaxes, (event.xdata, event.ydata), self.callback)\n        canvas.widgetlock(self.lasso)  # acquire a lock on the widget drawing\n\n    def on_release(self, event):\n        canvas = self.collection.figure.canvas\n        if hasattr(self, \\'lasso\\') and canvas.widgetlock.isowner(self.lasso):\n            canvas.widgetlock.release(self.lasso)\n\n\nif __name__ == \\'__main__\\':\n    np.random.seed(19680801)\n    ax = plt.figure().add_subplot(\n        xlim=(0, 1), ylim=(0, 1), title=\\'Lasso points using left mouse button\\')\n    manager = LassoManager(ax, np.random.rand(100, 2))\n    plt.show()\n",
    "id": 328
},
{
    "title": "Legend picking#",
    "text": "Enable picking on the legend to toggle the original line on and off Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: legend_picking.py Download Jupyter notebook: legend_picking.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 1)\ny1 = 2 * np.sin(2*np.pi*t)\ny2 = 4 * np.sin(2*np.pi*2*t)\n\nfig, ax = plt.subplots()\nax.set_title('Click on legend line to toggle line on/off')\nline1, = ax.plot(t, y1, lw=2, label='1 Hz')\nline2, = ax.plot(t, y2, lw=2, label='2 Hz')\nleg = ax.legend(fancybox=True, shadow=True)\n\nlines = [line1, line2]\nlined = {}  # Will map legend lines to original lines.\nfor legline, origline in zip(leg.get_lines(), lines):\n    legline.set_picker(True)  # Enable picking on the legend line.\n    lined[legline] = origline\n\n\ndef on_pick(event):\n    # On the pick event, find the original line corresponding to the legend\n    # proxy line, and toggle its visibility.\n    legline = event.artist\n    origline = lined[legline]\n    visible = not origline.get_visible()\n    origline.set_visible(visible)\n    # Change the alpha on the line in the legend, so we can see what lines\n    # have been toggled.\n    legline.set_alpha(1.0 if visible else 0.2)\n    fig.canvas.draw()\n\nfig.canvas.mpl_connect('pick_event', on_pick)\nplt.show()\n",
    "id": 329
},
{
    "title": "Looking Glass#",
    "text": "Example using mouse events to simulate a looking glass for inspecting data. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: looking_glass.py Download Jupyter notebook: looking_glass.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx, y = np.random.rand(2, 200)\n\nfig, ax = plt.subplots()\ncirc = patches.Circle((0.5, 0.5), 0.25, alpha=0.8, fc=\\'yellow\\')\nax.add_patch(circ)\n\n\nax.plot(x, y, alpha=0.2)\nline, = ax.plot(x, y, alpha=1.0, clip_path=circ)\nax.set_title(\"Left click and drag to move looking glass\")\n\n\nclass EventHandler:\n    def __init__(self):\n        fig.canvas.mpl_connect(\\'button_press_event\\', self.on_press)\n        fig.canvas.mpl_connect(\\'button_release_event\\', self.on_release)\n        fig.canvas.mpl_connect(\\'motion_notify_event\\', self.on_move)\n        self.x0, self.y0 = circ.center\n        self.pressevent = None\n\n    def on_press(self, event):\n        if event.inaxes != ax:\n            return\n\n        if not circ.contains(event)[0]:\n            return\n\n        self.pressevent = event\n\n    def on_release(self, event):\n        self.pressevent = None\n        self.x0, self.y0 = circ.center\n\n    def on_move(self, event):\n        if self.pressevent is None or event.inaxes != self.pressevent.inaxes:\n            return\n\n        dx = event.xdata - self.pressevent.xdata\n        dy = event.ydata - self.pressevent.ydata\n        circ.center = self.x0 + dx, self.y0 + dy\n        line.set_clip_path(circ)\n        fig.canvas.draw()\n\nhandler = EventHandler()\nplt.show()\n",
    "id": 330
},
{
    "title": "Path editor#",
    "text": "Sharing events across GUIs. This example demonstrates a cross-GUI application using Matplotlib event\nhandling to interact with and modify objects on the canvas. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: path_editor.py Download Jupyter notebook: path_editor.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseButton\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\n\nfig, ax = plt.subplots()\n\npathdata = [\n    (Path.MOVETO, (1.58, -2.57)),\n    (Path.CURVE4, (0.35, -1.1)),\n    (Path.CURVE4, (-1.75, 2.0)),\n    (Path.CURVE4, (0.375, 2.0)),\n    (Path.LINETO, (0.85, 1.15)),\n    (Path.CURVE4, (2.2, 3.2)),\n    (Path.CURVE4, (3, 0.05)),\n    (Path.CURVE4, (2.0, -0.5)),\n    (Path.CLOSEPOLY, (1.58, -2.57)),\n]\n\ncodes, verts = zip(*pathdata)\npath = Path(verts, codes)\npatch = PathPatch(\n    path, facecolor=\\'green\\', edgecolor=\\'yellow\\', alpha=0.5)\nax.add_patch(patch)\n\n\nclass PathInteractor:\n    \"\"\"\n    A path editor.\n\n    Press \\'t\\' to toggle vertex markers on and off.  When vertex markers are on,\n    they can be dragged with the mouse.\n    \"\"\"\n\n    showverts = True\n    epsilon = 5  # max pixel distance to count as a vertex hit\n\n    def __init__(self, pathpatch):\n\n        self.ax = pathpatch.axes\n        canvas = self.ax.figure.canvas\n        self.pathpatch = pathpatch\n        self.pathpatch.set_animated(True)\n\n        x, y = zip(*self.pathpatch.get_path().vertices)\n\n        self.line, = ax.plot(\n            x, y, marker=\\'o\\', markerfacecolor=\\'r\\', animated=True)\n\n        self._ind = None  # the active vertex\n\n        canvas.mpl_connect(\\'draw_event\\', self.on_draw)\n        canvas.mpl_connect(\\'button_press_event\\', self.on_button_press)\n        canvas.mpl_connect(\\'key_press_event\\', self.on_key_press)\n        canvas.mpl_connect(\\'button_release_event\\', self.on_button_release)\n        canvas.mpl_connect(\\'motion_notify_event\\', self.on_mouse_move)\n        self.canvas = canvas\n\n    def get_ind_under_point(self, event):\n        \"\"\"\n        Return the index of the point closest to the event position or *None*\n        if no point is within ``self.epsilon`` to the event position.\n        \"\"\"\n        xy = self.pathpatch.get_path().vertices\n        xyt = self.pathpatch.get_transform().transform(xy)  # to display coords\n        xt, yt = xyt[:, 0], xyt[:, 1]\n        d = np.sqrt((xt - event.x)**2 + (yt - event.y)**2)\n        ind = d.argmin()\n        return ind if d[ind] < self.epsilon else None\n\n    def on_draw(self, event):\n        \"\"\"Callback for draws.\"\"\"\n        self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n        self.ax.draw_artist(self.pathpatch)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n    def on_button_press(self, event):\n        \"\"\"Callback for mouse button presses.\"\"\"\n        if (event.inaxes is None\n                or event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n        self._ind = self.get_ind_under_point(event)\n\n    def on_button_release(self, event):\n        \"\"\"Callback for mouse button releases.\"\"\"\n        if (event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n        self._ind = None\n\n    def on_key_press(self, event):\n        \"\"\"Callback for key presses.\"\"\"\n        if not event.inaxes:\n            return\n        if event.key == \\'t\\':\n            self.showverts = not self.showverts\n            self.line.set_visible(self.showverts)\n            if not self.showverts:\n                self._ind = None\n        self.canvas.draw()\n\n    def on_mouse_move(self, event):\n        \"\"\"Callback for mouse movements.\"\"\"\n        if (self._ind is None\n                or event.inaxes is None\n                or event.button != MouseButton.LEFT\n                or not self.showverts):\n            return\n\n        vertices = self.pathpatch.get_path().vertices\n\n        vertices[self._ind] = event.xdata, event.ydata\n        self.line.set_data(zip(*vertices))\n\n        self.canvas.restore_region(self.background)\n        self.ax.draw_artist(self.pathpatch)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n\ninteractor = PathInteractor(patch)\nax.set_title(\\'drag vertices to update path\\')\nax.set_xlim(-3, 4)\nax.set_ylim(-3, 4)\n\nplt.show()\n",
    "id": 331
},
{
    "title": "Pick event demo#",
    "text": "You can enable picking by setting the \"picker\" property of an artist\n(for example, a Matplotlib Line2D, Text, Patch, Polygon, AxesImage,\netc.) There are a variety of meanings of the picker property: None - picking is disabled for this artist (default) bool - if True then picking will be enabled and the artist will fire a pick\nevent if the mouse event is over the artist. Setting pickradius will add an epsilon tolerance in points and the artist\nwill fire off an event if its data is within epsilon of the mouse event. For\nsome artists like lines and patch collections, the artist may provide\nadditional data to the pick event that is generated, for example, the indices\nof the data within epsilon of the pick event function - if picker is callable, it is a user supplied function which\ndetermines whether the artist is hit by the mouse event. to determine the hit test. If the mouse event is over the artist, return\nhit=True and props is a dictionary of properties you want added to the\nPickEvent attributes. After you have enabled an artist for picking by setting the \"picker\"\nproperty, you need to connect to the figure canvas pick_event to get\npick callbacks on mouse press events. For example, The pick event (matplotlib.backend_bases.PickEvent) which is passed to\nyour callback is always fired with two attributes: the mouse event that generate the pick event. The mouse event in turn has attributes like x and y (the coordinates in\ndisplay space, such as pixels from left, bottom) and xdata, ydata (the\ncoords in data space). Additionally, you can get information about\nwhich buttons were pressed, which keys were pressed, which Axes\nthe mouse is over, etc. See matplotlib.backend_bases.MouseEvent\nfor details. the matplotlib.artist that generated the pick event. Additionally, certain artists like Line2D and PatchCollection may\nattach additional metadata like the indices into the data that meet\nthe picker criteria (for example, all the points in the line that are within\nthe specified epsilon tolerance) The examples below illustrate each of these methods. Note These examples exercises the interactive capabilities of Matplotlib, and\nthis will not appear in the static documentation. Please run this code on\nyour machine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. You can define custom pickers by setting picker to a callable function. The\nfunction has the signature: to determine the hit test. If the mouse event is over the artist, return\nhit=True and props is a dictionary of properties you want added to\nthe PickEvent attributes. A scatter plot is backed by a PathCollection. Images plotted using Axes.imshow are AxesImage\nobjects. Total running time of the script: (0 minutes 1.106 seconds) Download Python source code: pick_event_demo.py Download Jupyter notebook: pick_event_demo.ipynb ",
    "code": "hit, props = picker(artist, mouseevent)\n def pick_handler(event):\n    mouseevent = event.mouseevent\n    artist = event.artist\n    # now do something with this...\n import matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import rand\n\nfrom matplotlib.image import AxesImage\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import Rectangle\nfrom matplotlib.text import Text\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n', \"fig, (ax1, ax2) = plt.subplots(2, 1)\nax1.set_title('click on points, rectangles or text', picker=True)\nax1.set_ylabel('ylabel', picker=True, bbox=dict(facecolor='red'))\nline, = ax1.plot(rand(100), 'o', picker=True, pickradius=5)\n\n# Pick the rectangle.\nax2.bar(range(10), rand(10), picker=True)\nfor label in ax2.get_xticklabels():  # Make the xtick labels pickable.\n    label.set_picker(True)\n\n\ndef onpick1(event):\n    if isinstance(event.artist, Line2D):\n        thisline = event.artist\n        xdata = thisline.get_xdata()\n        ydata = thisline.get_ydata()\n        ind = event.ind\n        print('onpick1 line:', np.column_stack([xdata[ind], ydata[ind]]))\n    elif isinstance(event.artist, Rectangle):\n        patch = event.artist\n        print('onpick1 patch:', patch.get_path())\n    elif isinstance(event.artist, Text):\n        text = event.artist\n        print('onpick1 text:', text.get_text())\n\n\nfig.canvas.mpl_connect('pick_event', onpick1)\n\", 'hit, props = func(artist, mouseevent)\n def line_picker(line, mouseevent):\n    \"\"\"\n    Find the points within a certain distance from the mouseclick in\n    data coords and attach some extra attributes, pickx and picky\n    which are the data points that were picked.\n    \"\"\"\n    if mouseevent.xdata is None:\n        return False, dict()\n    xdata = line.get_xdata()\n    ydata = line.get_ydata()\n    maxd = 0.05\n    d = np.sqrt(\n        (xdata - mouseevent.xdata)**2 + (ydata - mouseevent.ydata)**2)\n\n    ind, = np.nonzero(d <= maxd)\n    if len(ind):\n        pickx = xdata[ind]\n        picky = ydata[ind]\n        props = dict(ind=ind, pickx=pickx, picky=picky)\n        return True, props\n    else:\n        return False, dict()\n\n\ndef onpick2(event):\n    print(\\'onpick2 line:\\', event.pickx, event.picky)\n\n\nfig, ax = plt.subplots()\nax.set_title(\\'custom picker for line data\\')\nline, = ax.plot(rand(100), rand(100), \\'o\\', picker=line_picker)\nfig.canvas.mpl_connect(\\'pick_event\\', onpick2)\n', \"x, y, c, s = rand(4, 100)\n\n\ndef onpick3(event):\n    ind = event.ind\n    print('onpick3 scatter:', ind, x[ind], y[ind])\n\n\nfig, ax = plt.subplots()\nax.scatter(x, y, 100*s, c, picker=True)\nfig.canvas.mpl_connect('pick_event', onpick3)\n\", \"fig, ax = plt.subplots()\nax.imshow(rand(10, 5), extent=(1, 2, 1, 2), picker=True)\nax.imshow(rand(5, 10), extent=(3, 4, 1, 2), picker=True)\nax.imshow(rand(20, 25), extent=(1, 2, 3, 4), picker=True)\nax.imshow(rand(30, 12), extent=(3, 4, 3, 4), picker=True)\nax.set(xlim=(0, 5), ylim=(0, 5))\n\n\ndef onpick4(event):\n    artist = event.artist\n    if isinstance(artist, AxesImage):\n        im = artist\n        A = im.get_array()\n        print('onpick4 image', A.shape)\n\n\nfig.canvas.mpl_connect('pick_event', onpick4)\n\nplt.show()\n",
    "id": 332
},
{
    "title": "Pick event demo 2#",
    "text": "Compute the mean (mu) and standard deviation (sigma) of 100 data sets and plot\nmu vs. sigma. When you click on one of the (mu, sigma) points, plot the raw\ndata from the dataset that generated this point. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: pick_event_demo2.py Download Jupyter notebook: pick_event_demo2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nX = np.random.rand(100, 1000)\nxs = np.mean(X, axis=1)\nys = np.std(X, axis=1)\n\nfig, ax = plt.subplots()\nax.set_title('click on point to plot time series')\nline, = ax.plot(xs, ys, 'o', picker=True, pickradius=5)\n\n\ndef onpick(event):\n\n    if event.artist != line:\n        return\n\n    N = len(event.ind)\n    if not N:\n        return\n\n    figi, axs = plt.subplots(N, squeeze=False)\n    for ax, dataind in zip(axs.flat, event.ind):\n        ax.plot(X[dataind])\n        ax.text(.05, .9, f'mu={xs[dataind]:1.3f}\\\nsigma={ys[dataind]:1.3f}',\n                transform=ax.transAxes, va='top')\n        ax.set_ylim(-0.5, 1.5)\n    figi.show()\n\n\nfig.canvas.mpl_connect('pick_event', onpick)\n\nplt.show()\n",
    "id": 333
},
{
    "title": "Poly Editor#",
    "text": "This is an example to show how to build cross-GUI applications using\nMatplotlib event handling to interact with objects on the canvas. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: poly_editor.py Download Jupyter notebook: poly_editor.ipynb ",
    "code": "import numpy as np\n\nfrom matplotlib.artist import Artist\nfrom matplotlib.lines import Line2D\n\n\ndef dist_point_to_segment(p, s0, s1):\n    \"\"\"\n    Get the distance from the point *p* to the segment (*s0*, *s1*), where\n    *p*, *s0*, *s1* are ``[x, y]`` arrays.\n    \"\"\"\n    s01 = s1 - s0\n    s0p = p - s0\n    if (s01 == 0).all():\n        return np.hypot(*s0p)\n    # Project onto segment, without going past segment ends.\n    p1 = s0 + np.clip((s0p @ s01) / (s01 @ s01), 0, 1) * s01\n    return np.hypot(*(p - p1))\n\n\nclass PolygonInteractor:\n    \"\"\"\n    A polygon editor.\n\n    Key-bindings\n\n      \\'t\\' toggle vertex markers on and off.  When vertex markers are on,\n          you can move them, delete them\n\n      \\'d\\' delete the vertex under point\n\n      \\'i\\' insert a vertex at point.  You must be within epsilon of the\n          line connecting two existing vertices\n\n    \"\"\"\n\n    showverts = True\n    epsilon = 5  # max pixel distance to count as a vertex hit\n\n    def __init__(self, ax, poly):\n        if poly.figure is None:\n            raise RuntimeError(\\'You must first add the polygon to a figure \\'\n                               \\'or canvas before defining the interactor\\')\n        self.ax = ax\n        canvas = poly.figure.canvas\n        self.poly = poly\n\n        x, y = zip(*self.poly.xy)\n        self.line = Line2D(x, y,\n                           marker=\\'o\\', markerfacecolor=\\'r\\',\n                           animated=True)\n        self.ax.add_line(self.line)\n\n        self.cid = self.poly.add_callback(self.poly_changed)\n        self._ind = None  # the active vert\n\n        canvas.mpl_connect(\\'draw_event\\', self.on_draw)\n        canvas.mpl_connect(\\'button_press_event\\', self.on_button_press)\n        canvas.mpl_connect(\\'key_press_event\\', self.on_key_press)\n        canvas.mpl_connect(\\'button_release_event\\', self.on_button_release)\n        canvas.mpl_connect(\\'motion_notify_event\\', self.on_mouse_move)\n        self.canvas = canvas\n\n    def on_draw(self, event):\n        self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n        self.ax.draw_artist(self.poly)\n        self.ax.draw_artist(self.line)\n        # do not need to blit here, this will fire before the screen is\n        # updated\n\n    def poly_changed(self, poly):\n        \"\"\"This method is called whenever the pathpatch object is called.\"\"\"\n        # only copy the artist props to the line (except visibility)\n        vis = self.line.get_visible()\n        Artist.update_from(self.line, poly)\n        self.line.set_visible(vis)  # don\\'t use the poly visibility state\n\n    def get_ind_under_point(self, event):\n        \"\"\"\n        Return the index of the point closest to the event position or *None*\n        if no point is within ``self.epsilon`` to the event position.\n        \"\"\"\n        # display coords\n        xy = np.asarray(self.poly.xy)\n        xyt = self.poly.get_transform().transform(xy)\n        xt, yt = xyt[:, 0], xyt[:, 1]\n        d = np.hypot(xt - event.x, yt - event.y)\n        indseq, = np.nonzero(d == d.min())\n        ind = indseq[0]\n\n        if d[ind] >= self.epsilon:\n            ind = None\n\n        return ind\n\n    def on_button_press(self, event):\n        \"\"\"Callback for mouse button presses.\"\"\"\n        if not self.showverts:\n            return\n        if event.inaxes is None:\n            return\n        if event.button != 1:\n            return\n        self._ind = self.get_ind_under_point(event)\n\n    def on_button_release(self, event):\n        \"\"\"Callback for mouse button releases.\"\"\"\n        if not self.showverts:\n            return\n        if event.button != 1:\n            return\n        self._ind = None\n\n    def on_key_press(self, event):\n        \"\"\"Callback for key presses.\"\"\"\n        if not event.inaxes:\n            return\n        if event.key == \\'t\\':\n            self.showverts = not self.showverts\n            self.line.set_visible(self.showverts)\n            if not self.showverts:\n                self._ind = None\n        elif event.key == \\'d\\':\n            ind = self.get_ind_under_point(event)\n            if ind is not None:\n                self.poly.xy = np.delete(self.poly.xy,\n                                         ind, axis=0)\n                self.line.set_data(zip(*self.poly.xy))\n        elif event.key == \\'i\\':\n            xys = self.poly.get_transform().transform(self.poly.xy)\n            p = event.x, event.y  # display coords\n            for i in range(len(xys) - 1):\n                s0 = xys[i]\n                s1 = xys[i + 1]\n                d = dist_point_to_segment(p, s0, s1)\n                if d <= self.epsilon:\n                    self.poly.xy = np.insert(\n                        self.poly.xy, i+1,\n                        [event.xdata, event.ydata],\n                        axis=0)\n                    self.line.set_data(zip(*self.poly.xy))\n                    break\n        if self.line.stale:\n            self.canvas.draw_idle()\n\n    def on_mouse_move(self, event):\n        \"\"\"Callback for mouse movements.\"\"\"\n        if not self.showverts:\n            return\n        if self._ind is None:\n            return\n        if event.inaxes is None:\n            return\n        if event.button != 1:\n            return\n        x, y = event.xdata, event.ydata\n\n        self.poly.xy[self._ind] = x, y\n        if self._ind == 0:\n            self.poly.xy[-1] = x, y\n        elif self._ind == len(self.poly.xy) - 1:\n            self.poly.xy[0] = x, y\n        self.line.set_data(zip(*self.poly.xy))\n\n        self.canvas.restore_region(self.background)\n        self.ax.draw_artist(self.poly)\n        self.ax.draw_artist(self.line)\n        self.canvas.blit(self.ax.bbox)\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    from matplotlib.patches import Polygon\n\n    theta = np.arange(0, 2*np.pi, 0.1)\n    r = 1.5\n\n    xs = r * np.cos(theta)\n    ys = r * np.sin(theta)\n\n    poly = Polygon(np.column_stack([xs, ys]), animated=True)\n\n    fig, ax = plt.subplots()\n    ax.add_patch(poly)\n    p = PolygonInteractor(ax, poly)\n\n    ax.set_title(\\'Click and drag a point to move it\\')\n    ax.set_xlim((-2, 2))\n    ax.set_ylim((-2, 2))\n    plt.show()\n",
    "id": 334
},
{
    "title": "Pong#",
    "text": "A Matplotlib based game of Pong illustrating one way to write interactive\nanimations that are easily ported to multiple backends. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: pong_sgskip.py Download Jupyter notebook: pong_sgskip.ipynb ",
    "code": "import time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import randint, randn\n\nfrom matplotlib.font_manager import FontProperties\n\ninstructions = \"\"\"\nPlayer A:       Player B:\n  \\'e\\'      up     \\'i\\'\n  \\'d\\'     down    \\'k\\'\n\npress \\'t\\' -- close these instructions\n            (animation will be much faster)\npress \\'a\\' -- add a puck\npress \\'A\\' -- remove a puck\npress \\'1\\' -- slow down all pucks\npress \\'2\\' -- speed up all pucks\npress \\'3\\' -- slow down distractors\npress \\'4\\' -- speed up distractors\npress \\' \\' -- reset the first puck\npress \\'n\\' -- toggle distractors on/off\npress \\'g\\' -- toggle the game on/off\n\n  \"\"\"\n\n\nclass Pad:\n    def __init__(self, disp, x, y, type=\\'l\\'):\n        self.disp = disp\n        self.x = x\n        self.y = y\n        self.w = .3\n        self.score = 0\n        self.xoffset = 0.3\n        self.yoffset = 0.1\n        if type == \\'r\\':\n            self.xoffset *= -1.0\n\n        if type == \\'l\\' or type == \\'r\\':\n            self.signx = -1.0\n            self.signy = 1.0\n        else:\n            self.signx = 1.0\n            self.signy = -1.0\n\n    def contains(self, loc):\n        return self.disp.get_bbox().contains(loc.x, loc.y)\n\n\nclass Puck:\n    def __init__(self, disp, pad, field):\n        self.vmax = .2\n        self.disp = disp\n        self.field = field\n        self._reset(pad)\n\n    def _reset(self, pad):\n        self.x = pad.x + pad.xoffset\n        if pad.y < 0:\n            self.y = pad.y + pad.yoffset\n        else:\n            self.y = pad.y - pad.yoffset\n        self.vx = pad.x - self.x\n        self.vy = pad.y + pad.w/2 - self.y\n        self._speedlimit()\n        self._slower()\n        self._slower()\n\n    def update(self, pads):\n        self.x += self.vx\n        self.y += self.vy\n        for pad in pads:\n            if pad.contains(self):\n                self.vx *= 1.2 * pad.signx\n                self.vy *= 1.2 * pad.signy\n        fudge = .001\n        # probably cleaner with something like...\n        if self.x < fudge:\n            pads[1].score += 1\n            self._reset(pads[0])\n            return True\n        if self.x > 7 - fudge:\n            pads[0].score += 1\n            self._reset(pads[1])\n            return True\n        if self.y < -1 + fudge or self.y > 1 - fudge:\n            self.vy *= -1.0\n            # add some randomness, just to make it interesting\n            self.vy -= (randn()/300.0 + 1/300.0) * np.sign(self.vy)\n        self._speedlimit()\n        return False\n\n    def _slower(self):\n        self.vx /= 5.0\n        self.vy /= 5.0\n\n    def _faster(self):\n        self.vx *= 5.0\n        self.vy *= 5.0\n\n    def _speedlimit(self):\n        if self.vx > self.vmax:\n            self.vx = self.vmax\n        if self.vx < -self.vmax:\n            self.vx = -self.vmax\n\n        if self.vy > self.vmax:\n            self.vy = self.vmax\n        if self.vy < -self.vmax:\n            self.vy = -self.vmax\n\n\nclass Game:\n    def __init__(self, ax):\n        # create the initial line\n        self.ax = ax\n        ax.xaxis.set_visible(False)\n        ax.set_xlim([0, 7])\n        ax.yaxis.set_visible(False)\n        ax.set_ylim([-1, 1])\n        pad_a_x = 0\n        pad_b_x = .50\n        pad_a_y = pad_b_y = .30\n        pad_b_x += 6.3\n\n        # pads\n        pA, = self.ax.barh(pad_a_y, .2,\n                           height=.3, color=\\'k\\', alpha=.5, edgecolor=\\'b\\',\n                           lw=2, label=\"Player B\",\n                           animated=True)\n        pB, = self.ax.barh(pad_b_y, .2,\n                           height=.3, left=pad_b_x, color=\\'k\\', alpha=.5,\n                           edgecolor=\\'r\\', lw=2, label=\"Player A\",\n                           animated=True)\n\n        # distractors\n        self.x = np.arange(0, 2.22*np.pi, 0.01)\n        self.line, = self.ax.plot(self.x, np.sin(self.x), \"r\",\n                                  animated=True, lw=4)\n        self.line2, = self.ax.plot(self.x, np.cos(self.x), \"g\",\n                                   animated=True, lw=4)\n        self.line3, = self.ax.plot(self.x, np.cos(self.x), \"g\",\n                                   animated=True, lw=4)\n        self.line4, = self.ax.plot(self.x, np.cos(self.x), \"r\",\n                                   animated=True, lw=4)\n\n        # center line\n        self.centerline, = self.ax.plot([3.5, 3.5], [1, -1], \\'k\\',\n                                        alpha=.5, animated=True, lw=8)\n\n        # puck (s)\n        self.puckdisp = self.ax.scatter([1], [1], label=\\'_nolegend_\\',\n                                        s=200, c=\\'g\\',\n                                        alpha=.9, animated=True)\n\n        self.canvas = self.ax.figure.canvas\n        self.background = None\n        self.cnt = 0\n        self.distract = True\n        self.res = 100.0\n        self.on = False\n        self.inst = True    # show instructions from the beginning\n        self.pads = [Pad(pA, pad_a_x, pad_a_y),\n                     Pad(pB, pad_b_x, pad_b_y, \\'r\\')]\n        self.pucks = []\n        self.i = self.ax.annotate(instructions, (.5, 0.5),\n                                  name=\\'monospace\\',\n                                  verticalalignment=\\'center\\',\n                                  horizontalalignment=\\'center\\',\n                                  multialignment=\\'left\\',\n                                  xycoords=\\'axes fraction\\',\n                                  animated=False)\n        self.canvas.mpl_connect(\\'key_press_event\\', self.on_key_press)\n\n    def draw(self):\n        draw_artist = self.ax.draw_artist\n        if self.background is None:\n            self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n\n        # restore the clean slate background\n        self.canvas.restore_region(self.background)\n\n        # show the distractors\n        if self.distract:\n            self.line.set_ydata(np.sin(self.x + self.cnt/self.res))\n            self.line2.set_ydata(np.cos(self.x - self.cnt/self.res))\n            self.line3.set_ydata(np.tan(self.x + self.cnt/self.res))\n            self.line4.set_ydata(np.tan(self.x - self.cnt/self.res))\n            draw_artist(self.line)\n            draw_artist(self.line2)\n            draw_artist(self.line3)\n            draw_artist(self.line4)\n\n        # pucks and pads\n        if self.on:\n            self.ax.draw_artist(self.centerline)\n            for pad in self.pads:\n                pad.disp.set_y(pad.y)\n                pad.disp.set_x(pad.x)\n                self.ax.draw_artist(pad.disp)\n\n            for puck in self.pucks:\n                if puck.update(self.pads):\n                    # we only get here if someone scored\n                    self.pads[0].disp.set_label(f\"   {self.pads[0].score}\")\n                    self.pads[1].disp.set_label(f\"   {self.pads[1].score}\")\n                    self.ax.legend(loc=\\'center\\', framealpha=.2,\n                                   facecolor=\\'0.5\\',\n                                   prop=FontProperties(size=\\'xx-large\\',\n                                                       weight=\\'bold\\'))\n\n                    self.background = None\n                    self.ax.figure.canvas.draw_idle()\n                    return\n                puck.disp.set_offsets([[puck.x, puck.y]])\n                self.ax.draw_artist(puck.disp)\n\n        # just redraw the axes rectangle\n        self.canvas.blit(self.ax.bbox)\n        self.canvas.flush_events()\n        if self.cnt == 50000:\n            # just so we don\\'t get carried away\n            print(\"...and you\\'ve been playing for too long!!!\")\n            plt.close()\n\n        self.cnt += 1\n\n    def on_key_press(self, event):\n        if event.key == \\'3\\':\n            self.res *= 5.0\n        if event.key == \\'4\\':\n            self.res /= 5.0\n\n        if event.key == \\'e\\':\n            self.pads[0].y += .1\n            if self.pads[0].y > 1 - .3:\n                self.pads[0].y = 1 - .3\n        if event.key == \\'d\\':\n            self.pads[0].y -= .1\n            if self.pads[0].y < -1:\n                self.pads[0].y = -1\n\n        if event.key == \\'i\\':\n            self.pads[1].y += .1\n            if self.pads[1].y > 1 - .3:\n                self.pads[1].y = 1 - .3\n        if event.key == \\'k\\':\n            self.pads[1].y -= .1\n            if self.pads[1].y < -1:\n                self.pads[1].y = -1\n\n        if event.key == \\'a\\':\n            self.pucks.append(Puck(self.puckdisp,\n                                   self.pads[randint(2)],\n                                   self.ax.bbox))\n        if event.key == \\'A\\' and len(self.pucks):\n            self.pucks.pop()\n        if event.key == \\' \\' and len(self.pucks):\n            self.pucks[0]._reset(self.pads[randint(2)])\n        if event.key == \\'1\\':\n            for p in self.pucks:\n                p._slower()\n        if event.key == \\'2\\':\n            for p in self.pucks:\n                p._faster()\n\n        if event.key == \\'n\\':\n            self.distract = not self.distract\n\n        if event.key == \\'g\\':\n            self.on = not self.on\n        if event.key == \\'t\\':\n            self.inst = not self.inst\n            self.i.set_visible(not self.i.get_visible())\n            self.background = None\n            self.canvas.draw_idle()\n        if event.key == \\'q\\':\n            plt.close()\n\n\nfig, ax = plt.subplots()\ncanvas = ax.figure.canvas\nanimation = Game(ax)\n\n# disable the default key bindings\nif fig.canvas.manager.key_press_handler_id is not None:\n    canvas.mpl_disconnect(fig.canvas.manager.key_press_handler_id)\n\n\n# reset the blitting background on redraw\ndef on_redraw(event):\n    animation.background = None\n\n\n# bootstrap after the first draw\ndef start_anim(event):\n    canvas.mpl_disconnect(start_anim.cid)\n\n    start_anim.timer.add_callback(animation.draw)\n    start_anim.timer.start()\n    canvas.mpl_connect(\\'draw_event\\', on_redraw)\n\n\nstart_anim.cid = canvas.mpl_connect(\\'draw_event\\', start_anim)\nstart_anim.timer = animation.canvas.new_timer(interval=1)\n\ntstart = time.time()\n\nplt.show()\nprint(\\'FPS: %f\\' % (animation.cnt/(time.time() - tstart)))\n",
    "id": 335
},
{
    "title": "Resampling Data#",
    "text": "Downsampling lowers the sample rate or sample size of a signal. In\nthis tutorial, the signal is downsampled when the plot is adjusted\nthrough dragging and zooming. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: resample.py Download Jupyter notebook: resample.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\n# A class that will downsample the data and recompute when zoomed.\nclass DataDisplayDownsampler:\n    def __init__(self, xdata, ydata):\n        self.origYData = ydata\n        self.origXData = xdata\n        self.max_points = 50\n        self.delta = xdata[-1] - xdata[0]\n\n    def downsample(self, xstart, xend):\n        # get the points in the view range\n        mask = (self.origXData > xstart) & (self.origXData < xend)\n        # dilate the mask by one to catch the points just outside\n        # of the view range to not truncate the line\n        mask = np.convolve([1, 1, 1], mask, mode=\\'same\\').astype(bool)\n        # sort out how many points to drop\n        ratio = max(np.sum(mask) // self.max_points, 1)\n\n        # mask data\n        xdata = self.origXData[mask]\n        ydata = self.origYData[mask]\n\n        # downsample data\n        xdata = xdata[::ratio]\n        ydata = ydata[::ratio]\n\n        print(f\"using {len(ydata)} of {np.sum(mask)} visible points\")\n\n        return xdata, ydata\n\n    def update(self, ax):\n        # Update the line\n        lims = ax.viewLim\n        if abs(lims.width - self.delta) > 1e-8:\n            self.delta = lims.width\n            xstart, xend = lims.intervalx\n            self.line.set_data(*self.downsample(xstart, xend))\n            ax.figure.canvas.draw_idle()\n\n\n# Create a signal\nxdata = np.linspace(16, 365, (365-16)*4)\nydata = np.sin(2*np.pi*xdata/153) + np.cos(2*np.pi*xdata/127)\n\nd = DataDisplayDownsampler(xdata, ydata)\n\nfig, ax = plt.subplots()\n\n# Hook up the line\nd.line, = ax.plot(xdata, ydata, \\'o-\\')\nax.set_autoscale_on(False)  # Otherwise, infinite loop\n\n# Connect for changing the view limits\nax.callbacks.connect(\\'xlim_changed\\', d.update)\nax.set_xlim(16, 365)\nplt.show()\n",
    "id": 336
},
{
    "title": "Timers#",
    "text": "Simple example of using general timer objects. This is used to update\nthe time placed in the title of the figure. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: timers.py Download Jupyter notebook: timers.ipynb ",
    "code": "from datetime import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef update_title(axes):\n    axes.set_title(datetime.now())\n    axes.figure.canvas.draw()\n\nfig, ax = plt.subplots()\n\nx = np.linspace(-3, 3)\nax.plot(x, x ** 2)\n\n# Create a new timer object. Set the interval to 100 milliseconds\n# (1000 is default) and tell the timer what function should be called.\ntimer = fig.canvas.new_timer(interval=100)\ntimer.add_callback(update_title, ax)\ntimer.start()\n\n# Or could start the timer on first figure draw:\n# def start_timer(event):\n#     timer.start()\n#     fig.canvas.mpl_disconnect(drawid)\n# drawid = fig.canvas.mpl_connect('draw_event', start_timer)\n\nplt.show()\n",
    "id": 337
},
{
    "title": "Trifinder Event Demo#",
    "text": "Example showing the use of a TriFinder object. As the mouse is moved over the\ntriangulation, the triangle under the cursor is highlighted and the index of\nthe triangle is displayed in the plot title. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: trifinder_event_demo.py Download Jupyter notebook: trifinder_event_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Polygon\nfrom matplotlib.tri import Triangulation\n\n\ndef update_polygon(tri):\n    if tri == -1:\n        points = [0, 0, 0]\n    else:\n        points = triang.triangles[tri]\n    xs = triang.x[points]\n    ys = triang.y[points]\n    polygon.set_xy(np.column_stack([xs, ys]))\n\n\ndef on_mouse_move(event):\n    if event.inaxes is None:\n        tri = -1\n    else:\n        tri = trifinder(event.xdata, event.ydata)\n    update_polygon(tri)\n    ax.set_title(f'In triangle {tri}')\n    event.canvas.draw()\n\n\n# Create a Triangulation.\nn_angles = 16\nn_radii = 5\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi / n_angles\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\ntriang = Triangulation(x, y)\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\n# Use the triangulation's default TriFinder object.\ntrifinder = triang.get_trifinder()\n\n# Setup plot and callbacks.\nfig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})\nax.triplot(triang, 'bo-')\npolygon = Polygon([[0, 0], [0, 0]], facecolor='y')  # dummy data for (xs, ys)\nupdate_polygon(-1)\nax.add_patch(polygon)\nfig.canvas.mpl_connect('motion_notify_event', on_mouse_move)\nplt.show()\n",
    "id": 338
},
{
    "title": "Viewlims#",
    "text": "Creates two identical panels. Zooming in on the right panel will show\na rectangle in the first panel, denoting the zoomed region. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: viewlims.py Download Jupyter notebook: viewlims.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Rectangle\n\n\n# We just subclass Rectangle so that it can be called with an Axes\n# instance, causing the rectangle to update its shape to match the\n# bounds of the Axes\nclass UpdatingRect(Rectangle):\n    def __call__(self, ax):\n        self.set_bounds(*ax.viewLim.bounds)\n        ax.figure.canvas.draw_idle()\n\n\n# A class that will regenerate a fractal set as we zoom in, so that you\n# can actually see the increasing detail.  A box in the left panel will show\n# the area to which we are zoomed.\nclass MandelbrotDisplay:\n    def __init__(self, h=500, w=500, niter=50, radius=2., power=2):\n        self.height = h\n        self.width = w\n        self.niter = niter\n        self.radius = radius\n        self.power = power\n\n    def compute_image(self, xstart, xend, ystart, yend):\n        self.x = np.linspace(xstart, xend, self.width)\n        self.y = np.linspace(ystart, yend, self.height).reshape(-1, 1)\n        c = self.x + 1.0j * self.y\n        threshold_time = np.zeros((self.height, self.width))\n        z = np.zeros(threshold_time.shape, dtype=complex)\n        mask = np.ones(threshold_time.shape, dtype=bool)\n        for i in range(self.niter):\n            z[mask] = z[mask]**self.power + c[mask]\n            mask = (np.abs(z) < self.radius)\n            threshold_time += mask\n        return threshold_time\n\n    def ax_update(self, ax):\n        ax.set_autoscale_on(False)  # Otherwise, infinite loop\n        # Get the number of points from the number of pixels in the window\n        self.width, self.height = \\\\\n            np.round(ax.patch.get_window_extent().size).astype(int)\n        # Get the range for the new area\n        vl = ax.viewLim\n        extent = vl.x0, vl.x1, vl.y0, vl.y1\n        # Update the image object with our new data and extent\n        im = ax.images[-1]\n        im.set_data(self.compute_image(*extent))\n        im.set_extent(extent)\n        ax.figure.canvas.draw_idle()\n\n\nmd = MandelbrotDisplay()\nZ = md.compute_image(-2., 0.5, -1.25, 1.25)\n\nfig1, (ax1, ax2) = plt.subplots(1, 2)\nax1.imshow(Z, origin=\\'lower\\',\n           extent=(md.x.min(), md.x.max(), md.y.min(), md.y.max()))\nax2.imshow(Z, origin=\\'lower\\',\n           extent=(md.x.min(), md.x.max(), md.y.min(), md.y.max()))\n\nrect = UpdatingRect(\n    [0, 0], 0, 0, facecolor=\\'none\\', edgecolor=\\'black\\', linewidth=1.0)\nrect.set_bounds(*ax2.viewLim.bounds)\nax1.add_patch(rect)\n\n# Connect for changing the view limits\nax2.callbacks.connect(\\'xlim_changed\\', rect)\nax2.callbacks.connect(\\'ylim_changed\\', rect)\n\nax2.callbacks.connect(\\'xlim_changed\\', md.ax_update)\nax2.callbacks.connect(\\'ylim_changed\\', md.ax_update)\nax2.set_title(\"Zoom here\")\n\nplt.show()\n",
    "id": 339
},
{
    "title": "Zoom Window#",
    "text": "This example shows how to connect events in one window, for example, a mouse\npress, to another figure window. If you click on a point in the first window, the z and y limits of the second\nwill be adjusted so that the center of the zoom in the second window will be\nthe (x, y) coordinates of the clicked point. Note the diameter of the circles in the scatter are defined in points**2, so\ntheir size is independent of the zoom. Note This example exercises the interactive capabilities of Matplotlib, and this\nwill not appear in the static documentation. Please run this code on your\nmachine to see the interactivity. You can copy and paste individual parts, or download the entire example\nusing the link at the bottom of the page. Download Python source code: zoom_window.py Download Jupyter notebook: zoom_window.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfigsrc, axsrc = plt.subplots(figsize=(3.7, 3.7))\nfigzoom, axzoom = plt.subplots(figsize=(3.7, 3.7))\naxsrc.set(xlim=(0, 1), ylim=(0, 1), autoscale_on=False,\n          title='Click to zoom')\naxzoom.set(xlim=(0.45, 0.55), ylim=(0.4, 0.6), autoscale_on=False,\n           title='Zoom window')\n\nx, y, s, c = np.random.rand(4, 200)\ns *= 200\n\naxsrc.scatter(x, y, s, c)\naxzoom.scatter(x, y, s, c)\n\n\ndef on_press(event):\n    if event.button != 1:\n        return\n    x, y = event.xdata, event.ydata\n    axzoom.set_xlim(x - 0.1, x + 0.1)\n    axzoom.set_ylim(y - 0.1, y + 0.1)\n    figzoom.canvas.draw()\n\nfigsrc.canvas.mpl_connect('button_press_event', on_press)\nplt.show()\n",
    "id": 340
},
{
    "title": "Anchored Artists#",
    "text": "This example illustrates the use of the anchored objects without the\nhelper classes found in mpl_toolkits.axes_grid1. This version\nof the figure is similar to the one found in\nSimple Anchored Artists, but it is\nimplemented using only the matplotlib namespace, without the help\nof additional toolkits. Download Python source code: anchored_artists.py Download Jupyter notebook: anchored_artists.ipynb ",
    "code": "from matplotlib import pyplot as plt\nfrom matplotlib.lines import Line2D\nfrom matplotlib.offsetbox import (AnchoredOffsetbox, AuxTransformBox,\n                                  DrawingArea, TextArea, VPacker)\nfrom matplotlib.patches import Circle, Ellipse\n\n\ndef draw_text(ax):\n    \"\"\"Draw a text-box anchored to the upper-left corner of the figure.\"\"\"\n    box = AnchoredOffsetbox(child=TextArea(\"Figure 1a\"),\n                            loc=\"upper left\", frameon=True)\n    box.patch.set_boxstyle(\"round,pad=0.,rounding_size=0.2\")\n    ax.add_artist(box)\n\n\ndef draw_circles(ax):\n    \"\"\"Draw circles in axes coordinates.\"\"\"\n    area = DrawingArea(width=40, height=20)\n    area.add_artist(Circle((10, 10), 10, fc=\"tab:blue\"))\n    area.add_artist(Circle((30, 10), 5, fc=\"tab:red\"))\n    box = AnchoredOffsetbox(\n        child=area, loc=\"upper right\", pad=0, frameon=False)\n    ax.add_artist(box)\n\n\ndef draw_ellipse(ax):\n    \"\"\"Draw an ellipse of width=0.1, height=0.15 in data coordinates.\"\"\"\n    aux_tr_box = AuxTransformBox(ax.transData)\n    aux_tr_box.add_artist(Ellipse((0, 0), width=0.1, height=0.15))\n    box = AnchoredOffsetbox(child=aux_tr_box, loc=\"lower left\", frameon=True)\n    ax.add_artist(box)\n\n\ndef draw_sizebar(ax):\n    \"\"\"\n    Draw a horizontal bar with length of 0.1 in data coordinates,\n    with a fixed label center-aligned underneath.\n    \"\"\"\n    size = 0.1\n    text = r\"1$^{\\\\prime}$\"\n    sizebar = AuxTransformBox(ax.transData)\n    sizebar.add_artist(Line2D([0, size], [0, 0], color=\"black\"))\n    text = TextArea(text)\n    packer = VPacker(\n        children=[sizebar, text], align=\"center\", sep=5)  # separation in points.\n    ax.add_artist(AnchoredOffsetbox(\n        child=packer, loc=\"lower center\", frameon=False,\n        pad=0.1, borderpad=0.5))  # paddings relative to the legend fontsize.\n\n\nfig, ax = plt.subplots()\nax.set_aspect(1)\n\ndraw_text(ax)\ndraw_circles(ax)\ndraw_ellipse(ax)\ndraw_sizebar(ax)\n\nplt.show()\n",
    "id": 342
},
{
    "title": "Changing colors of lines intersecting a box#",
    "text": "The lines intersecting the rectangle are colored in red, while the others\nare left as blue lines. This example showcases the intersects_bbox function. Download Python source code: bbox_intersect.py Download Jupyter notebook: bbox_intersect.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.transforms import Bbox\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nleft, bottom, width, height = (-1, -1, 2, 2)\nrect = plt.Rectangle((left, bottom), width, height,\n                     facecolor=\"black\", alpha=0.1)\n\nfig, ax = plt.subplots()\nax.add_patch(rect)\n\nbbox = Bbox.from_bounds(left, bottom, width, height)\n\nfor i in range(12):\n    vertices = (np.random.random((2, 2)) - 0.5) * 6.0\n    path = Path(vertices)\n    if path.intersects_bbox(bbox):\n        color = \\'r\\'\n    else:\n        color = \\'b\\'\n    ax.plot(vertices[:, 0], vertices[:, 1], color=color)\n\nplt.show()\n",
    "id": 343
},
{
    "title": "Manual Contour#",
    "text": "Example of displaying your own contour lines and polygons using ContourSet. Contour lines for each level are a list/tuple of polygons. Filled contours between two levels are also a list/tuple of polygons.\nPoints can be ordered clockwise or anticlockwise. Multiple filled contour lines can be specified in a single list of polygon\nvertices along with a list of vertex kinds (code types) as described in the\nPath class. This is particularly useful for polygons with holes. Download Python source code: contour_manual.py Download Jupyter notebook: contour_manual.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.cm as cm\nfrom matplotlib.contour import ContourSet\nfrom matplotlib.path import Path\n lines0 = [[[0, 0], [0, 4]]]\nlines1 = [[[2, 0], [1, 2], [1, 3]]]\nlines2 = [[[3, 0], [3, 2]], [[3, 3], [3, 4]]]  # Note two lines.\n filled01 = [[[0, 0], [0, 4], [1, 3], [1, 2], [2, 0]]]\nfilled12 = [[[2, 0], [3, 0], [3, 2], [1, 3], [1, 2]],   # Note two polygons.\n            [[1, 4], [3, 4], [3, 3]]]\n', \"fig, ax = plt.subplots()\n\n# Filled contours using filled=True.\ncs = ContourSet(ax, [0, 1, 2], [filled01, filled12], filled=True, cmap=cm.bone)\ncbar = fig.colorbar(cs)\n\n# Contour lines (non-filled).\nlines = ContourSet(\n    ax, [0, 1, 2], [lines0, lines1, lines2], cmap=cm.cool, linewidths=3)\ncbar.add_lines(lines)\n\nax.set(xlim=(-0.5, 3.5), ylim=(-0.5, 4.5),\n       title='User-specified contours')\n\", \"fig, ax = plt.subplots()\nfilled01 = [[[0, 0], [3, 0], [3, 3], [0, 3], [1, 1], [1, 2], [2, 2], [2, 1]]]\nM = Path.MOVETO\nL = Path.LINETO\nkinds01 = [[M, L, L, L, M, L, L, L]]\ncs = ContourSet(ax, [0, 1], [filled01], [kinds01], filled=True)\ncbar = fig.colorbar(cs)\n\nax.set(xlim=(-0.5, 3.5), ylim=(-0.5, 3.5),\n       title='User specified filled contours with holes')\n\nplt.show()\n",
    "id": 344
},
{
    "title": "Coords Report#",
    "text": "Override the default reporting of coords as the mouse moves over the axes\nin an interactive backend. Download Python source code: coords_report.py Download Jupyter notebook: coords_report.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef millions(x):\n    return '$%1.1fM' % (x * 1e-6)\n\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.rand(20)\ny = 1e7 * np.random.rand(20)\n\nfig, ax = plt.subplots()\nax.fmt_ydata = millions\nplt.plot(x, y, 'o')\n\nplt.show()\n",
    "id": 345
},
{
    "title": "Custom projection#",
    "text": "Showcase Hammer projection by alleviating many features of Matplotlib. Download Python source code: custom_projection.py Download Jupyter notebook: custom_projection.ipynb ",
    "code": "import numpy as np\n\nimport matplotlib\nfrom matplotlib.axes import Axes\nimport matplotlib.axis as maxis\nfrom matplotlib.patches import Circle\nfrom matplotlib.path import Path\nfrom matplotlib.projections import register_projection\nimport matplotlib.spines as mspines\nfrom matplotlib.ticker import FixedLocator, Formatter, NullLocator\nfrom matplotlib.transforms import Affine2D, BboxTransformTo, Transform\n\nrcParams = matplotlib.rcParams\n\n# This example projection class is rather long, but it is designed to\n# illustrate many features, not all of which will be used every time.\n# It is also common to factor out a lot of these methods into common\n# code used by a number of projections with similar characteristics\n# (see geo.py).\n\n\nclass GeoAxes(Axes):\n    \"\"\"\n    An abstract base class for geographic projections\n    \"\"\"\n    class ThetaFormatter(Formatter):\n        \"\"\"\n        Used to format the theta tick labels.  Converts the native\n        unit of radians into degrees and adds a degree symbol.\n        \"\"\"\n        def __init__(self, round_to=1.0):\n            self._round_to = round_to\n\n        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f\"{degrees:0.0f}\\\\N{DEGREE SIGN}\"\n\n    RESOLUTION = 75\n\n    def _init_axis(self):\n        self.xaxis = maxis.XAxis(self)\n        self.yaxis = maxis.YAxis(self)\n        # Do not register xaxis or yaxis with spines -- as done in\n        # Axes._init_axis() -- until GeoAxes.xaxis.clear() works.\n        # self.spines[\\'geo\\.register_axis(self.yaxis)\n\n    def clear(self):\n        # docstring inherited\n        super().clear()\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position(\\'none\\')\n        self.yaxis.set_ticks_position(\\'none\\')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(rcParams[\\'axes.grid\\)\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)\n\n    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n\n        # There are three important coordinate spaces going on here:\n        #\n        # 1. Data space: The space of the data itself\n        #\n        # 2. Axes space: The unit rectangle (0, 0) to (1, 1)\n        #    covering the entire plot area.\n        #\n        # 3. Display space: The coordinates of the resulting image,\n        #    often in pixels or dpi/inch.\n\n        # This function makes heavy use of the Transform classes in\n        # ``lib/matplotlib/transforms.py.`` For more information, see\n        # the inline documentation there.\n\n        # The goal of the first two transformations is to get from the\n        # data space (in this case longitude and latitude) to axes\n        # space.  It is separated into a non-affine and affine part so\n        # that the non-affine part does not have to be recomputed when\n        # a simple affine change to the figure has been made (such as\n        # resizing the window or changing the dpi).\n\n        # 1) The core transformation from data space into\n        # rectilinear space defined in the HammerTransform class.\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        # 2) The above has an output range that is not in the unit\n        # rectangle, so scale and translate it so it fits correctly\n        # within the axes.  The peculiar calculations of xscale and\n        # yscale are specific to an Aitoff-Hammer projection, so don\\'t\n        # worry about them too much.\n        self.transAffine = self._get_affine_transform()\n\n        # 3) This is the transformation from axes space to display\n        # space.\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # Now put these 3 transforms together -- from data all the way\n        # to display coordinates.  Using the \\'+\\' operator, these\n        # transforms will be applied \"in order\".  The transforms are\n        # automatically simplified, if possible, by the underlying\n        # transformation framework.\n        self.transData = \\\\\n            self.transProjection + \\\\\n            self.transAffine + \\\\\n            self.transAxes\n\n        # The main data transformation is set up.  Now deal with\n        # gridlines and tick labels.\n\n        # Longitude gridlines and ticklabels.  The input to these\n        # transforms are in display space in x and axes space in y.\n        # Therefore, the input values will be in range (-xmin, 0),\n        # (xmax, 1).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the equator.\n        self._xaxis_pretransform = \\\\\n            Affine2D() \\\\\n            .scale(1.0, self._longitude_cap * 2.0) \\\\\n            .translate(0.0, -self._longitude_cap)\n        self._xaxis_transform = \\\\\n            self._xaxis_pretransform + \\\\\n            self.transData\n        self._xaxis_text1_transform = \\\\\n            Affine2D().scale(1.0, 0.0) + \\\\\n            self.transData + \\\\\n            Affine2D().translate(0.0, 4.0)\n        self._xaxis_text2_transform = \\\\\n            Affine2D().scale(1.0, 0.0) + \\\\\n            self.transData + \\\\\n            Affine2D().translate(0.0, -4.0)\n\n        # Now set up the transforms for the latitude ticks.  The input to\n        # these transforms are in axes space in x and display space in\n        # y.  Therefore, the input values will be in range (0, -ymin),\n        # (1, ymax).  The goal of these transforms is to go from that\n        # space to display space.  The tick labels will be offset 4\n        # pixels from the edge of the axes ellipse.\n        yaxis_stretch = Affine2D().scale(np.pi*2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1.0, 1.1)\n        self._yaxis_transform = \\\\\n            yaxis_stretch + \\\\\n            self.transData\n        yaxis_text_base = \\\\\n            yaxis_stretch + \\\\\n            self.transProjection + \\\\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\\\n            yaxis_text_base + \\\\\n            Affine2D().translate(-8.0, 0.0)\n        self._yaxis_text2_transform = \\\\\n            yaxis_text_base + \\\\\n            Affine2D().translate(8.0, 0.0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which=\\'grid\\'):\n        \"\"\"\n        Override this method to provide a transformation for the\n        x-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        if which not in [\\'tick1\\', \\'tick2\\', \\'grid\\:\n            raise ValueError(\n                \"\\'which\\' must be one of \\'tick1\\', \\'tick2\\', or \\'grid\\'\")\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, \\'bottom\\', \\'center\\'\n\n    def get_xaxis_text2_transform(self, pad):\n        \"\"\"\n        Override this method to provide a transformation for the\n        secondary x-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        return self._xaxis_text2_transform, \\'top\\', \\'center\\'\n\n    def get_yaxis_transform(self, which=\\'grid\\'):\n        \"\"\"\n        Override this method to provide a transformation for the\n        y-axis grid and ticks.\n        \"\"\"\n        if which not in [\\'tick1\\', \\'tick2\\', \\'grid\\:\n            raise ValueError(\n                \"\\'which\\' must be one of \\'tick1\\', \\'tick2\\', or \\'grid\\'\")\n        return self._yaxis_transform\n\n    def get_yaxis_text1_transform(self, pad):\n        \"\"\"\n        Override this method to provide a transformation for the\n        y-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        return self._yaxis_text1_transform, \\'center\\', \\'right\\'\n\n    def get_yaxis_text2_transform(self, pad):\n        \"\"\"\n        Override this method to provide a transformation for the\n        secondary y-axis tick labels.\n\n        Returns a tuple of the form (transform, valign, halign)\n        \"\"\"\n        return self._yaxis_text2_transform, \\'center\\', \\'left\\'\n\n    def _gen_axes_patch(self):\n        \"\"\"\n        Override this method to define the shape that is used for the\n        background of the plot.  It should be a subclass of Patch.\n\n        In this case, it is a Circle (that may be warped by the axes\n        transform into an ellipse).  Any data and gridlines will be\n        clipped to this shape.\n        \"\"\"\n        return Circle((0.5, 0.5), 0.5)\n\n    def _gen_axes_spines(self):\n        return {\\'geo\\': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}\n\n    def set_yscale(self, *args, **kwargs):\n        if args[0] != \\'linear\\':\n            raise NotImplementedError\n\n    # Prevent the user from applying scales to one or both of the\n    # axes.  In this particular case, scaling the axes wouldn\\'t make\n    # sense, so we don\\'t allow it.\n    set_xscale = set_yscale\n\n    # Prevent the user from changing the axes limits.  In our case, we\n    # want to display the whole sphere all the time, so we override\n    # set_xlim and set_ylim to ignore any input.  This also applies to\n    # interactive panning and zooming in the GUI interfaces.\n    def set_xlim(self, *args, **kwargs):\n        raise TypeError(\"Changing axes limits of a geographic projection is \"\n                        \"not supported.  Please consider using Cartopy.\")\n\n    set_ylim = set_xlim\n\n    def format_coord(self, lon, lat):\n        \"\"\"\n        Override this method to change how the values are displayed in\n        the status bar.\n\n        In this case, we want them to be displayed in degrees N/S/E/W.\n        \"\"\"\n        lon, lat = np.rad2deg([lon, lat])\n        ns = \\'N\\' if lat >= 0.0 else \\'S\\'\n        ew = \\'E\\' if lon >= 0.0 else \\'W\\'\n        return (\\'%f\\\\N{DEGREE SIGN}%s, %f\\\\N{DEGREE SIGN}%s\\'\n                % (abs(lat), ns, abs(lon), ew))\n\n    def set_longitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n\n        This is an example method that is specific to this projection\n        class -- it provides a more convenient interface to set the\n        ticking than set_xticks would.\n        \"\"\"\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_latitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n\n        This is an example method that is specific to this projection\n        class -- it provides a more convenient interface than\n        set_yticks would.\n        \"\"\"\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_longitude_grid_ends(self, degrees):\n        \"\"\"\n        Set the latitude(s) at which to stop drawing the longitude grids.\n\n        Often, in geographic projections, you wouldn\\'t want to draw\n        longitude gridlines near the poles.  This allows the user to\n        specify the degree at which to stop drawing longitude grids.\n\n        This is an example method that is specific to this projection\n        class -- it provides an interface to something that has no\n        analogy in the base Axes class.\n        \"\"\"\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\\\n            .clear() \\\\\n            .scale(1.0, self._longitude_cap * 2.0) \\\\\n            .translate(0.0, -self._longitude_cap)\n\n    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.\n\n        This method should be overridden by any Axes that have a\n        fixed data ratio.\n        \"\"\"\n        return 1.0\n\n    # Interactive panning and zooming is not supported with this projection,\n    # so we override all of the following methods to disable it.\n    def can_zoom(self):\n        \"\"\"\n        Return whether this Axes supports the zoom box button functionality.\n\n        This Axes object does not support interactive zoom box.\n        \"\"\"\n        return False\n\n    def can_pan(self):\n        \"\"\"\n        Return whether this Axes supports the pan/zoom button functionality.\n\n        This Axes object does not support interactive pan/zoom.\n        \"\"\"\n        return False\n\n    def start_pan(self, x, y, button):\n        pass\n\n    def end_pan(self):\n        pass\n\n    def drag_pan(self, button, key, x, y):\n        pass\n\n\nclass HammerAxes(GeoAxes):\n    \"\"\"\n    A custom class for the Aitoff-Hammer projection, an equal-area map\n    projection.\n\n    https://en.wikipedia.org/wiki/Hammer_projection\n    \"\"\"\n\n    # The projection must specify a name. This will be used by the\n    # user to select the projection,\n    # i.e. ``subplot(projection=\\'custom_hammer\\')``.\n    name = \\'custom_hammer\\'\n\n    class HammerTransform(Transform):\n        \"\"\"The base Hammer transform.\"\"\"\n        input_dims = output_dims = 2\n\n        def __init__(self, resolution):\n            \"\"\"\n            Create a new Hammer transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Hammer space.\n            \"\"\"\n            Transform.__init__(self)\n            self._resolution = resolution\n\n        def transform_non_affine(self, ll):\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2)\n\n            alpha = np.sqrt(1 + cos_latitude * np.cos(half_long))\n            x = (2 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])\n\n        def transform_path_non_affine(self, path):\n            # vertices = path.vertices\n            ipath = path.interpolated(self._resolution)\n            return Path(self.transform(ipath.vertices), ipath.codes)\n\n        def inverted(self):\n            return HammerAxes.InvertedHammerTransform(self._resolution)\n\n    class InvertedHammerTransform(Transform):\n        input_dims = output_dims = 2\n\n        def __init__(self, resolution):\n            Transform.__init__(self)\n            self._resolution = resolution\n\n        def transform_non_affine(self, xy):\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            return HammerAxes.HammerTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        super().__init__(*args, **kwargs)\n        self.set_aspect(0.5, adjustable=\\'box\\', anchor=\\'C\\')\n        self.clear()\n\n    def _get_core_transform(self, resolution):\n        return self.HammerTransform(resolution)\n\n\n# Now register the projection with Matplotlib so the user can select it.\nregister_projection(HammerAxes)\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    # Now make a simple example using the custom projection.\n    fig, ax = plt.subplots(subplot_kw={\\'projection\\': \\'custom_hammer\\'})\n    ax.plot([-1, 1, 1], [-1, -1, 1], \"o-\")\n    ax.grid()\n\n    plt.show()\n",
    "id": 346
},
{
    "title": "Customize Rc#",
    "text": "I'm not trying to make a good-looking figure here, but just to show\nsome examples of customizing rcParams on the fly.\", 'If you like to work interactively, and need to create different sets\nof defaults for figures (e.g., one set of defaults for publication, one\nset for interactive exploration), you may want to define some\nfunctions in a custom module that set the defaults, e.g.,: Then as you are working interactively, you just need to do: Download Python source code: customize_rc.py Download Jupyter notebook: customize_rc.ipynb ",
    "code": "def set_pub():\n    rcParams.update({\n        \"font.weight\": \"bold\",  # bold fonts\n        \"tick.labelsize\": 15,   # large tick labels\n        \"lines.linewidth\": 1,   # thick lines\n        \"lines.color\": \"k\",     # black lines\n        \"grid.color\": \"0.5\",    # gray gridlines\n        \"grid.linestyle\": \"-\",  # solid gridlines\n        \"grid.linewidth\": 0.5,  # thin gridlines\n        \"savefig.dpi\": 300,     # higher resolution output.\n    })\n', \">>> set_pub()\n>>> plot([1, 2, 3])\n>>> savefig('myfig')\n>>> rcdefaults()  # restore the defaults\n\", 'import matplotlib.pyplot as plt\n\nplt.subplot(311)\nplt.plot([1, 2, 3])\n\n# the axes attributes need to be set before the call to subplot\nplt.rcParams.update({\n    \"font.weight\": \"bold\",\n    \"xtick.major.size\": 5,\n    \"xtick.major.pad\": 7,\n    \"xtick.labelsize\": 15,\n    \"grid.color\": \"0.5\",\n    \"grid.linestyle\": \"-\",\n    \"grid.linewidth\": 5,\n    \"lines.linewidth\": 2,\n    \"lines.color\": \"g\",\n})\nplt.subplot(312)\nplt.plot([1, 2, 3])\nplt.grid(True)\n\nplt.rcdefaults()\nplt.subplot(313)\nplt.plot([1, 2, 3])\nplt.grid(True)\nplt.show()\n",
    "id": 347
},
{
    "title": "AGG filter#",
    "text": "Most pixel-based backends in Matplotlib use Anti-Grain Geometry (AGG) for\nrendering. You can modify the rendering of Artists by applying a filter via\nArtist.set_agg_filter. Download Python source code: demo_agg_filter.py Download Jupyter notebook: demo_agg_filter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.artist import Artist\nimport matplotlib.cm as cm\nfrom matplotlib.colors import LightSource\nimport matplotlib.transforms as mtransforms\n\n\ndef smooth1d(x, window_len):\n    # copied from https://scipy-cookbook.readthedocs.io/items/SignalSmooth.html\n    s = np.r_[2*x[0] - x[window_len:1:-1], x, 2*x[-1] - x[-1:-window_len:-1]]\n    w = np.hanning(window_len)\n    y = np.convolve(w/w.sum(), s, mode=\\'same\\')\n    return y[window_len-1:-window_len+1]\n\n\ndef smooth2d(A, sigma=3):\n    window_len = max(int(sigma), 3) * 2 + 1\n    A = np.apply_along_axis(smooth1d, 0, A, window_len)\n    A = np.apply_along_axis(smooth1d, 1, A, window_len)\n    return A\n\n\nclass BaseFilter:\n\n    def get_pad(self, dpi):\n        return 0\n\n    def process_image(self, padded_src, dpi):\n        raise NotImplementedError(\"Should be overridden by subclasses\")\n\n    def __call__(self, im, dpi):\n        pad = self.get_pad(dpi)\n        padded_src = np.pad(im, [(pad, pad), (pad, pad), (0, 0)], \"constant\")\n        tgt_image = self.process_image(padded_src, dpi)\n        return tgt_image, -pad, -pad\n\n\nclass OffsetFilter(BaseFilter):\n\n    def __init__(self, offsets=(0, 0)):\n        self.offsets = offsets\n\n    def get_pad(self, dpi):\n        return int(max(self.offsets) / 72 * dpi)\n\n    def process_image(self, padded_src, dpi):\n        ox, oy = self.offsets\n        a1 = np.roll(padded_src, int(ox / 72 * dpi), axis=1)\n        a2 = np.roll(a1, -int(oy / 72 * dpi), axis=0)\n        return a2\n\n\nclass GaussianFilter(BaseFilter):\n    \"\"\"Simple Gaussian filter.\"\"\"\n\n    def __init__(self, sigma, alpha=0.5, color=(0, 0, 0)):\n        self.sigma = sigma\n        self.alpha = alpha\n        self.color = color\n\n    def get_pad(self, dpi):\n        return int(self.sigma*3 / 72 * dpi)\n\n    def process_image(self, padded_src, dpi):\n        tgt_image = np.empty_like(padded_src)\n        tgt_image[:, :, :3] = self.color\n        tgt_image[:, :, 3] = smooth2d(padded_src[:, :, 3] * self.alpha,\n                                      self.sigma / 72 * dpi)\n        return tgt_image\n\n\nclass DropShadowFilter(BaseFilter):\n\n    def __init__(self, sigma, alpha=0.3, color=(0, 0, 0), offsets=(0, 0)):\n        self.gauss_filter = GaussianFilter(sigma, alpha, color)\n        self.offset_filter = OffsetFilter(offsets)\n\n    def get_pad(self, dpi):\n        return max(self.gauss_filter.get_pad(dpi),\n                   self.offset_filter.get_pad(dpi))\n\n    def process_image(self, padded_src, dpi):\n        t1 = self.gauss_filter.process_image(padded_src, dpi)\n        t2 = self.offset_filter.process_image(t1, dpi)\n        return t2\n\n\nclass LightFilter(BaseFilter):\n    \"\"\"Apply LightSource filter\"\"\"\n\n    def __init__(self, sigma, fraction=1):\n        \"\"\"\n        Parameters\n        ----------\n        sigma : float\n            sigma for gaussian filter\n        fraction: number, default: 1\n            Increases or decreases the contrast of the hillshade.\n            See `matplotlib.colors.LightSource`\n\n        \"\"\"\n        self.gauss_filter = GaussianFilter(sigma, alpha=1)\n        self.light_source = LightSource()\n        self.fraction = fraction\n\n    def get_pad(self, dpi):\n        return self.gauss_filter.get_pad(dpi)\n\n    def process_image(self, padded_src, dpi):\n        t1 = self.gauss_filter.process_image(padded_src, dpi)\n        elevation = t1[:, :, 3]\n        rgb = padded_src[:, :, :3]\n        alpha = padded_src[:, :, 3:]\n        rgb2 = self.light_source.shade_rgb(rgb, elevation,\n                                           fraction=self.fraction,\n                                           blend_mode=\"overlay\")\n        return np.concatenate([rgb2, alpha], -1)\n\n\nclass GrowFilter(BaseFilter):\n    \"\"\"Enlarge the area.\"\"\"\n\n    def __init__(self, pixels, color=(1, 1, 1)):\n        self.pixels = pixels\n        self.color = color\n\n    def __call__(self, im, dpi):\n        alpha = np.pad(im[..., 3], self.pixels, \"constant\")\n        alpha2 = np.clip(smooth2d(alpha, self.pixels / 72 * dpi) * 5, 0, 1)\n        new_im = np.empty((*alpha2.shape, 4))\n        new_im[:, :, :3] = self.color\n        new_im[:, :, 3] = alpha2\n        offsetx, offsety = -self.pixels, -self.pixels\n        return new_im, offsetx, offsety\n\n\nclass FilteredArtistList(Artist):\n    \"\"\"A simple container to filter multiple artists at once.\"\"\"\n\n    def __init__(self, artist_list, filter):\n        super().__init__()\n        self._artist_list = artist_list\n        self._filter = filter\n\n    def draw(self, renderer):\n        renderer.start_rasterizing()\n        renderer.start_filter()\n        for a in self._artist_list:\n            a.draw(renderer)\n        renderer.stop_filter(self._filter)\n        renderer.stop_rasterizing()\n\n\ndef filtered_text(ax):\n    # mostly copied from contour_demo.py\n\n    # prepare image\n    delta = 0.025\n    x = np.arange(-3.0, 3.0, delta)\n    y = np.arange(-2.0, 2.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2) * 2\n\n    # draw\n    ax.imshow(Z, interpolation=\\'bilinear\\', origin=\\'lower\\',\n              cmap=cm.gray, extent=(-3, 3, -2, 2), aspect=\\'auto\\')\n    levels = np.arange(-1.2, 1.6, 0.2)\n    CS = ax.contour(Z, levels,\n                    origin=\\'lower\\',\n                    linewidths=2,\n                    extent=(-3, 3, -2, 2))\n\n    # contour label\n    cl = ax.clabel(CS, levels[1::2],  # label every second level\n                   inline=True,\n                   fmt=\\'%1.1f\\',\n                   fontsize=11)\n\n    # change clabel color to black\n    from matplotlib.patheffects import Normal\n    for t in cl:\n        t.set_color(\"k\")\n        # to force TextPath (i.e., same font in all backends)\n        t.set_path_effects([Normal()])\n\n    # Add white glows to improve visibility of labels.\n    white_glows = FilteredArtistList(cl, GrowFilter(3))\n    ax.add_artist(white_glows)\n    white_glows.set_zorder(cl[0].get_zorder() - 0.1)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef drop_shadow_line(ax):\n    # copied from examples/misc/svg_filter_line.py\n\n    # draw lines\n    l1, = ax.plot([0.1, 0.5, 0.9], [0.1, 0.9, 0.5], \"bo-\")\n    l2, = ax.plot([0.1, 0.5, 0.9], [0.5, 0.2, 0.7], \"ro-\")\n\n    gauss = DropShadowFilter(4)\n\n    for l in [l1, l2]:\n\n        # draw shadows with same lines with slight offset.\n        xx = l.get_xdata()\n        yy = l.get_ydata()\n        shadow, = ax.plot(xx, yy)\n        shadow.update_from(l)\n\n        # offset transform\n        transform = mtransforms.offset_copy(l.get_transform(), ax.figure,\n                                            x=4.0, y=-6.0, units=\\'points\\')\n        shadow.set_transform(transform)\n\n        # adjust zorder of the shadow lines so that it is drawn below the\n        # original lines\n        shadow.set_zorder(l.get_zorder() - 0.5)\n        shadow.set_agg_filter(gauss)\n        shadow.set_rasterized(True)  # to support mixed-mode renderers\n\n    ax.set_xlim(0., 1.)\n    ax.set_ylim(0., 1.)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef drop_shadow_patches(ax):\n    # Copied from barchart_demo.py\n    N = 5\n    group1_means = [20, 35, 30, 35, 27]\n\n    ind = np.arange(N)  # the x locations for the groups\n    width = 0.35  # the width of the bars\n\n    rects1 = ax.bar(ind, group1_means, width, color=\\'r\\', ec=\"w\", lw=2)\n\n    group2_means = [25, 32, 34, 20, 25]\n    rects2 = ax.bar(ind + width + 0.1, group2_means, width,\n                    color=\\'y\\', ec=\"w\", lw=2)\n\n    drop = DropShadowFilter(5, offsets=(1, 1))\n    shadow = FilteredArtistList(rects1 + rects2, drop)\n    ax.add_artist(shadow)\n    shadow.set_zorder(rects1[0].get_zorder() - 0.1)\n\n    ax.set_ylim(0, 40)\n\n    ax.xaxis.set_visible(False)\n    ax.yaxis.set_visible(False)\n\n\ndef light_filter_pie(ax):\n    fracs = [15, 30, 45, 10]\n    explode = (0.1, 0.2, 0.1, 0.1)\n    pies = ax.pie(fracs, explode=explode)\n\n    light_filter = LightFilter(9)\n    for p in pies[0]:\n        p.set_agg_filter(light_filter)\n        p.set_rasterized(True)  # to support mixed-mode renderers\n        p.set(ec=\"none\",\n              lw=2)\n\n    gauss = DropShadowFilter(9, offsets=(3, -4), alpha=0.7)\n    shadow = FilteredArtistList(pies[0], gauss)\n    ax.add_artist(shadow)\n    shadow.set_zorder(pies[0][0].get_zorder() - 0.1)\n\n\nif __name__ == \"__main__\":\n\n    fix, axs = plt.subplots(2, 2)\n\n    filtered_text(axs[0, 0])\n    drop_shadow_line(axs[0, 1])\n    drop_shadow_patches(axs[1, 0])\n    light_filter_pie(axs[1, 1])\n    axs[1, 1].set_frame_on(True)\n\n    plt.show()\n",
    "id": 348
},
{
    "title": "Ribbon Box#",
    "text": "Download Python source code: demo_ribbon_box.py Download Jupyter notebook: demo_ribbon_box.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook\nfrom matplotlib import colors as mcolors\nfrom matplotlib.image import AxesImage\nfrom matplotlib.transforms import Bbox, BboxTransformTo, TransformedBbox\n\n\nclass RibbonBox:\n\n    original_image = plt.imread(\n        cbook.get_sample_data(\"Minduka_Present_Blue_Pack.png\"))\n    cut_location = 70\n    b_and_h = original_image[:, :, 2:3]\n    color = original_image[:, :, 2:3] - original_image[:, :, 0:1]\n    alpha = original_image[:, :, 3:4]\n    nx = original_image.shape[1]\n\n    def __init__(self, color):\n        rgb = mcolors.to_rgb(color)\n        self.im = np.dstack(\n            [self.b_and_h - self.color * (1 - np.array(rgb)), self.alpha])\n\n    def get_stretched_image(self, stretch_factor):\n        stretch_factor = max(stretch_factor, 1)\n        ny, nx, nch = self.im.shape\n        ny2 = int(ny*stretch_factor)\n        return np.vstack(\n            [self.im[:self.cut_location],\n             np.broadcast_to(\n                 self.im[self.cut_location], (ny2 - ny, nx, nch)),\n             self.im[self.cut_location:]])\n\n\nclass RibbonBoxImage(AxesImage):\n    zorder = 1\n\n    def __init__(self, ax, bbox, color, *, extent=(0, 1, 0, 1), **kwargs):\n        super().__init__(ax, extent=extent, **kwargs)\n        self._bbox = bbox\n        self._ribbonbox = RibbonBox(color)\n        self.set_transform(BboxTransformTo(bbox))\n\n    def draw(self, renderer, *args, **kwargs):\n        stretch_factor = self._bbox.height / self._bbox.width\n\n        ny = int(stretch_factor*self._ribbonbox.nx)\n        if self.get_array() is None or self.get_array().shape[0] != ny:\n            arr = self._ribbonbox.get_stretched_image(stretch_factor)\n            self.set_array(arr)\n\n        super().draw(renderer, *args, **kwargs)\n\n\ndef main():\n    fig, ax = plt.subplots()\n\n    years = np.arange(2004, 2009)\n    heights = [7900, 8100, 7900, 6900, 2800]\n    box_colors = [\n        (0.8, 0.2, 0.2),\n        (0.2, 0.8, 0.2),\n        (0.2, 0.2, 0.8),\n        (0.7, 0.5, 0.8),\n        (0.3, 0.8, 0.7),\n    ]\n\n    for year, h, bc in zip(years, heights, box_colors):\n        bbox0 = Bbox.from_extents(year - 0.4, 0., year + 0.4, h)\n        bbox = TransformedBbox(bbox0, ax.transData)\n        ax.add_artist(RibbonBoxImage(ax, bbox, bc, interpolation=\"bicubic\"))\n        ax.annotate(str(h), (year, h), va=\"bottom\", ha=\"center\")\n\n    ax.set_xlim(years[0] - 0.5, years[-1] + 0.5)\n    ax.set_ylim(0, 10000)\n\n    background_gradient = np.zeros((2, 2, 4))\n    background_gradient[:, :, :3] = [1, 1, 0]\n    background_gradient[:, :, 3] = [[0.1, 0.3], [0.3, 0.5]]  # alpha channel\n    ax.imshow(background_gradient, interpolation=\"bicubic\", zorder=0.1,\n              extent=(0, 1, 0, 1), transform=ax.transAxes)\n\n    plt.show()\n\n\nmain()\n",
    "id": 349
},
{
    "title": "Adding lines to figures#",
    "text": "Adding lines to a figure without any axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.figure matplotlib.lines matplotlib.lines.Line2D Download Python source code: fig_x.py Download Jupyter notebook: fig_x.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.lines as lines\n\nfig = plt.figure()\nfig.add_artist(lines.Line2D([0, 1], [0, 1]))\nfig.add_artist(lines.Line2D([0, 1], [1, 0]))\nplt.show()\n",
    "id": 350
},
{
    "title": "Fill Spiral#",
    "text": "Download Python source code: fill_spiral.py Download Jupyter notebook: fill_spiral.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.arange(0, 8*np.pi, 0.1)\na = 1\nb = .2\n\nfor dt in np.arange(0, 2*np.pi, np.pi/2.0):\n\n    x = a*np.cos(theta + dt)*np.exp(b*theta)\n    y = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    dt = dt + np.pi/4.0\n\n    x2 = a*np.cos(theta + dt)*np.exp(b*theta)\n    y2 = a*np.sin(theta + dt)*np.exp(b*theta)\n\n    xf = np.concatenate((x, x2[::-1]))\n    yf = np.concatenate((y, y2[::-1]))\n\n    p1 = plt.fill(xf, yf)\n\nplt.show()\n",
    "id": 351
},
{
    "title": "Findobj Demo#",
    "text": "Recursively find all objects that match some criteria Download Python source code: findobj_demo.py Download Jupyter notebook: findobj_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.text as text\n\na = np.arange(0, 3, .02)\nb = np.arange(0, 3, .02)\nc = np.exp(a)\nd = c[::-1]\n\nfig, ax = plt.subplots()\nplt.plot(a, c, 'k--', a, d, 'k:', a, c + d, 'k')\nplt.legend(('Model length Data length Total message length'),\n           loc='upper center', shadow=True)\nplt.ylim([-1, 20])\nplt.grid(False)\nplt.xlabel('Model complexity --->')\nplt.ylabel('Message length --->')\nplt.title('Minimum Message Length')\n\n\n# match on arbitrary function\ndef myfunc(x):\n    return hasattr(x, 'set_color') and not hasattr(x, 'set_facecolor')\n\n\nfor o in fig.findobj(myfunc):\n    o.set_color('blue')\n\n# match on class instances\nfor o in fig.findobj(text.Text):\n    o.set_fontstyle('italic')\n\n\nplt.show()\n",
    "id": 352
},
{
    "title": "Font indexing#",
    "text": "This example shows how the font tables relate to one another. Download Python source code: font_indexing.py Download Jupyter notebook: font_indexing.ipynb ",
    "code": "(6, 0, 519, 576)\n36 57 65 86\nAV -48\nAV -49\nAV -16\nAT -19\n', \"import os\n\nimport matplotlib\nfrom matplotlib.ft2font import (KERNING_DEFAULT, KERNING_UNFITTED,\n                                KERNING_UNSCALED, FT2Font)\n\nfont = FT2Font(\n    os.path.join(matplotlib.get_data_path(), 'fonts/ttf/DejaVuSans.ttf'))\nfont.set_charmap(0)\n\ncodes = font.get_charmap().items()\n\n# make a charname to charcode and glyphind dictionary\ncoded = {}\nglyphd = {}\nfor ccode, glyphind in codes:\n    name = font.get_glyph_name(glyphind)\n    coded[name] = ccode\n    glyphd[name] = glyphind\n    # print(glyphind, ccode, hex(int(ccode)), name)\n\ncode = codedA\nglyph = font.load_char(code)\nprint(glyph.bbox)\nprint(glyphdA, glyphdV, codedA, codedV)\nprint('AV', font.get_kerning(glyphdA, glyphdV, KERNING_DEFAULT))\nprint('AV', font.get_kerning(glyphdA, glyphdV, KERNING_UNFITTED))\nprint('AV', font.get_kerning(glyphdA, glyphdV, KERNING_UNSCALED))\nprint('AT', font.get_kerning(glyphdA, glyphdT, KERNING_UNSCALED))\n",
    "id": 353
},
{
    "title": "Font properties#",
    "text": "This example lists the attributes of an FT2Font object, which describe\nglobal font properties. For individual character metrics, use the Glyph\nobject, as returned by load_char. Download Python source code: ftface_props.py Download Jupyter notebook: ftface_props.ipynb ",
    "code": "Num faces:   1\nNum glyphs:  5343\nFamily name: DejaVu Sans\nStyle name:  Oblique\nPS name:     DejaVuSans-Oblique\nNum fixed:   0\nBbox:                (-2080, -717, 3398, 2187)\nEM:                  2048\nAscender:            1901\nDescender:           -483\nHeight:              2384\nMax adv width:       3461\nMax adv height:      2384\nUnderline pos:       -175\nUnderline thickness: 90\nItalic:           True\nBold:             False\nScalable:         True\nFixed sizes:      False\nFixed width:      False\nSFNT:             False\nHorizontal:       False\nVertical:         False\nKerning:          False\nFast glyphs:      False\nMultiple masters: False\nGlyph names:      False\nExternal stream:  False\n import os\n\nimport matplotlib\nimport matplotlib.ft2font as ft\n\nfont = ft.FT2Font(\n    # Use a font shipped with Matplotlib.\n    os.path.join(matplotlib.get_data_path(),\n                 \\'fonts/ttf/DejaVuSans-Oblique.ttf\\'))\n\nprint(\\'Num faces:  \\', font.num_faces)        # number of faces in file\nprint(\\'Num glyphs: \\', font.num_glyphs)       # number of glyphs in the face\nprint(\\'Family name:\\', font.family_name)      # face family name\nprint(\\'Style name: \\', font.style_name)       # face style name\nprint(\\'PS name:    \\', font.postscript_name)  # the postscript name\nprint(\\'Num fixed:  \\', font.num_fixed_sizes)  # number of embedded bitmaps\n\n# the following are only available if face.scalable\nif font.scalable:\n    # the face global bounding box (xmin, ymin, xmax, ymax)\n    print(\\'Bbox:               \\', font.bbox)\n    # number of font units covered by the EM\n    print(\\'EM:                 \\', font.units_per_EM)\n    # the ascender in 26.6 units\n    print(\\'Ascender:           \\', font.ascender)\n    # the descender in 26.6 units\n    print(\\'Descender:          \\', font.descender)\n    # the height in 26.6 units\n    print(\\'Height:             \\', font.height)\n    # maximum horizontal cursor advance\n    print(\\'Max adv width:      \\', font.max_advance_width)\n    # same for vertical layout\n    print(\\'Max adv height:     \\', font.max_advance_height)\n    # vertical position of the underline bar\n    print(\\'Underline pos:      \\', font.underline_position)\n    # vertical thickness of the underline\n    print(\\'Underline thickness:\\', font.underline_thickness)\n\nfor style in (\\'Italic\\',\n              \\'Bold\\',\n              \\'Scalable\\',\n              \\'Fixed sizes\\',\n              \\'Fixed width\\',\n              \\'SFNT\\',\n              \\'Horizontal\\',\n              \\'Vertical\\',\n              \\'Kerning\\',\n              \\'Fast glyphs\\',\n              \\'Multiple masters\\',\n              \\'Glyph names\\',\n              \\'External stream\\'):\n    bitpos = getattr(ft, style.replace(\\' \\', \\'_\\').upper()) - 1\n    print(f\"{style+\\':\\':17}\", bool(font.style_flags & (1 << bitpos)))\n",
    "id": 354
},
{
    "title": "Building histograms using Rectangles and PolyCollections#",
    "text": "Using a path patch to draw rectangles.', \"The technique of using lots of Rectangle instances, or the faster method of\nusing PolyCollection, were implemented before we had proper paths with\nmoveto, lineto, closepoly, etc. in Matplotlib. Now that we have them, we can\ndraw collections of regularly shaped objects with homogeneous properties more\nefficiently with a PathCollection. This example makes a histogram -- it's more\nwork to set up the vertex arrays at the outset, but it should be much faster\nfor large numbers of objects.\", 'Instead of creating a three-dimensional array and using\nmake_compound_path_from_polys, we could as well create the\ncompound path directly using vertices and codes as shown below References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.patches matplotlib.patches.PathPatch matplotlib.path matplotlib.path.Path matplotlib.path.Path.make_compound_path_from_polys matplotlib.axes.Axes.add_patch matplotlib.collections.PathCollection This example shows an alternative to matplotlib.collections.PolyCollection matplotlib.axes.Axes.hist Download Python source code: histogram_path.py Download Jupyter notebook: histogram_path.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.patches as patches\nimport matplotlib.path as path\n\nfig, axs = plt.subplots(2)\n\nnp.random.seed(19680801)  # Fixing random state for reproducibility\n\n# histogram our data with numpy\ndata = np.random.randn(1000)\nn, bins = np.histogram(data, 50)\n\n# get the corners of the rectangles for the histogram\nleft = bins[:-1]\nright = bins[1:]\nbottom = np.zeros(len(left))\ntop = bottom + n\n\n# we need a (numrects x numsides x 2) numpy array for the path helper\n# function to build a compound path\nXY = np.array([[left, left, right, right], [bottom, top, top, bottom]]).T\n\n# get the Path object\nbarpath = path.Path.make_compound_path_from_polys(XY)\n\n# make a patch out of it, don't add a margin at y=0\npatch = patches.PathPatch(barpath)\npatch.sticky_edges.y[:] = [0]\naxs[0].add_patch(patch)\naxs[0].autoscale_view()\n\", \"nrects = len(left)\nnverts = nrects*(1+3+1)\nverts = np.zeros((nverts, 2))\ncodes = np.ones(nverts, int) * path.Path.LINETO\ncodes[0::5] = path.Path.MOVETO\ncodes[4::5] = path.Path.CLOSEPOLY\nverts[0::5, 0] = left\nverts[0::5, 1] = bottom\nverts[1::5, 0] = left\nverts[1::5, 1] = top\nverts[2::5, 0] = right\nverts[2::5, 1] = top\nverts[3::5, 0] = right\nverts[3::5, 1] = bottom\n\nbarpath = path.Path(verts, codes)\n\n# make a patch out of it, don't add a margin at y=0\npatch = patches.PathPatch(barpath)\npatch.sticky_edges.y[:] = [0]\naxs[1].add_patch(patch)\naxs[1].autoscale_view()\n\nplt.show()\n",
    "id": 355
},
{
    "title": "Hyperlinks#",
    "text": "This example demonstrates how to set a hyperlinks on various kinds of elements. This currently only works with the SVG backend. Download Python source code: hyperlinks_sgskip.py Download Jupyter notebook: hyperlinks_sgskip.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\n', \"fig = plt.figure()\ns = plt.scatter([1, 2, 3], [4, 5, 6])\ns.set_urls(https://www.bbc.com/news https://www.google.com/', None])\nfig.savefig('scatter.svg')\n\", \"fig = plt.figure()\ndelta = 0.025\nx = y = np.arange(-3.0, 3.0, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = np.exp(-X**2 - Y**2)\nZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\nZ = (Z1 - Z2) * 2\n\nim = plt.imshow(Z, interpolation='bilinear', cmap=cm.gray,\n                origin='lower', extent=(-3, 3, -3, 3))\n\nim.set_url('https://www.google.com/')\nfig.savefig('image.svg')\n",
    "id": 356
},
{
    "title": "Image Thumbnail#",
    "text": "You can use Matplotlib to generate thumbnails from existing images.\nMatplotlib relies on Pillow for reading images, and thus supports all formats\nsupported by Pillow. Download Python source code: image_thumbnail_sgskip.py Download Jupyter notebook: image_thumbnail_sgskip.ipynb ",
    "code": "from argparse import ArgumentParser\nfrom pathlib import Path\nimport sys\n\nimport matplotlib.image as image\n\nparser = ArgumentParser(\n    description=\"Build thumbnails of all images in a directory.\")\nparser.add_argument(\"imagedir\", type=Path)\nargs = parser.parse_args()\nif not args.imagedir.is_dir():\n    sys.exit(f\"Could not find input directory {args.imagedir}\")\n\noutdir = Path(\"thumbs\")\noutdir.mkdir(parents=True, exist_ok=True)\n\nfor path in args.imagedir.glob(\"*.png\"):\n    outpath = outdir / path.name\n    fig = image.thumbnail(path, outpath, scale=0.15)\n    print(f\"saved thumbnail of {path} to {outpath}\")\n",
    "id": 357
},
{
    "title": "Plotting with keywords#",
    "text": "Some data structures, like dict, structured numpy array\nor pandas.DataFrame provide access to labelled data via string index access\ndata[key].', \"For these data types, Matplotlib supports passing the whole datastructure via the\ndata keyword argument, and using the string names as plot function parameters,\nwhere you'd normally pass in your data.\", 'Download Python source code: keyword_plotting.py Download Jupyter notebook: keyword_plotting.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\ndata = {'a': np.arange(50),\n        'c': np.random.randint(0, 50, 50),\n        'd': np.random.randn(50)}\ndatab = dataa + 10 * np.random.randn(50)\ndatad = np.abs(datad) * 100\n\nfig, ax = plt.subplots()\nax.scatter('a b', c='c', s='d', data=data)\nax.set(xlabel='entry a', ylabel='entry b')\nplt.show()\n",
    "id": 358
},
{
    "title": "Matplotlib logo#",
    "text": "This example generates the current matplotlib logo. A large logo: A small 32px logo: A large logo including text, as used on the matplotlib website. Download Python source code: logos2.py Download Jupyter notebook: logos2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cm as cm\nimport matplotlib.font_manager\nfrom matplotlib.patches import PathPatch, Rectangle\nfrom matplotlib.text import TextPath\nimport matplotlib.transforms as mtrans\n\nMPL_BLUE = \\'#11557c\\'\n\n\ndef get_font_properties():\n    # The original font is Calibri, if that is not installed, we fall back\n    # to Carlito, which is metrically equivalent.\n    if \\'Calibri\\' in matplotlib.font_manager.findfont(\\'Calibri:bold\\'):\n        return matplotlib.font_manager.FontProperties(family=\\'Calibri\\',\n                                                      weight=\\'bold\\')\n    if \\'Carlito\\' in matplotlib.font_manager.findfont(\\'Carlito:bold\\'):\n        print(\\'Original font not found. Falling back to Carlito. \\'\n              \\'The logo text will not be in the correct font.\\')\n        return matplotlib.font_manager.FontProperties(family=\\'Carlito\\',\n                                                      weight=\\'bold\\')\n    print(\\'Original font not found. \\'\n          \\'The logo text will not be in the correct font.\\')\n    return None\n\n\ndef create_icon_axes(fig, ax_position, lw_bars, lw_grid, lw_border, rgrid):\n    \"\"\"\n    Create a polar axes containing the matplotlib radar plot.\n\n    Parameters\n    ----------\n    fig : matplotlib.figure.Figure\n        The figure to draw into.\n    ax_position : (float, float, float, float)\n        The position of the created Axes in figure coordinates as\n        (x, y, width, height).\n    lw_bars : float\n        The linewidth of the bars.\n    lw_grid : float\n        The linewidth of the grid.\n    lw_border : float\n        The linewidth of the Axes border.\n    rgrid : array-like\n        Positions of the radial grid.\n\n    Returns\n    -------\n    ax : matplotlib.axes.Axes\n        The created Axes.\n    \"\"\"\n    with plt.rc_context({\\'axes.edgecolor\\': MPL_BLUE,\n                         \\'axes.linewidth\\': lw_border}):\n        ax = fig.add_axes(ax_position, projection=\\'polar\\')\n        ax.set_axisbelow(True)\n\n        N = 7\n        arc = 2. * np.pi\n        theta = np.arange(0.0, arc, arc / N)\n        radii = np.array([2, 6, 8, 7, 4, 5, 8])\n        width = np.pi / 4 * np.array([0.4, 0.4, 0.6, 0.8, 0.2, 0.5, 0.3])\n        bars = ax.bar(theta, radii, width=width, bottom=0.0, align=\\'edge\\',\n                      edgecolor=\\'0.3\\', lw=lw_bars)\n        for r, bar in zip(radii, bars):\n            color = *cm.jet(r / 10.)[:3], 0.6  # color from jet with alpha=0.6\n            bar.set_facecolor(color)\n\n        ax.tick_params(labelbottom=False, labeltop=False,\n                       labelleft=False, labelright=False)\n\n        ax.grid(lw=lw_grid, color=\\'0.9\\')\n        ax.set_rmax(9)\n        ax.set_yticks(rgrid)\n\n        # the actual visible background - extends a bit beyond the axis\n        ax.add_patch(Rectangle((0, 0), arc, 9.58,\n                               facecolor=\\'white\\', zorder=0,\n                               clip_on=False, in_layout=False))\n        return ax\n\n\ndef create_text_axes(fig, height_px):\n    \"\"\"Create an Axes in *fig* that contains \\'matplotlib\\' as Text.\"\"\"\n    ax = fig.add_axes((0, 0, 1, 1))\n    ax.set_aspect(\"equal\")\n    ax.set_axis_off()\n\n    path = TextPath((0, 0), \"matplotlib\", size=height_px * 0.8,\n                    prop=get_font_properties())\n\n    angle = 4.25  # degrees\n    trans = mtrans.Affine2D().skew_deg(angle, 0)\n\n    patch = PathPatch(path, transform=trans + ax.transData, color=MPL_BLUE,\n                      lw=0)\n    ax.add_patch(patch)\n    ax.autoscale()\n\n\ndef make_logo(height_px, lw_bars, lw_grid, lw_border, rgrid, with_text=False):\n    \"\"\"\n    Create a full figure with the Matplotlib logo.\n\n    Parameters\n    ----------\n    height_px : int\n        Height of the figure in pixel.\n    lw_bars : float\n        The linewidth of the bar border.\n    lw_grid : float\n        The linewidth of the grid.\n    lw_border : float\n        The linewidth of icon border.\n    rgrid : sequence of float\n        The radial grid positions.\n    with_text : bool\n        Whether to draw only the icon or to include \\'matplotlib\\' as text.\n    \"\"\"\n    dpi = 100\n    height = height_px / dpi\n    figsize = (5 * height, height) if with_text else (height, height)\n    fig = plt.figure(figsize=figsize, dpi=dpi)\n    fig.patch.set_alpha(0)\n\n    if with_text:\n        create_text_axes(fig, height_px)\n    ax_pos = (0.535, 0.12, .17, 0.75) if with_text else (0.03, 0.03, .94, .94)\n    ax = create_icon_axes(fig, ax_pos, lw_bars, lw_grid, lw_border, rgrid)\n\n    return fig, ax\n make_logo(height_px=110, lw_bars=0.7, lw_grid=0.5, lw_border=1,\n          rgrid=[1, 3, 5, 7])\n make_logo(height_px=32, lw_bars=0.3, lw_grid=0.3, lw_border=0.3, rgrid=[5])\n make_logo(height_px=110, lw_bars=0.7, lw_grid=0.5, lw_border=1,\n          rgrid=[1, 3, 5, 7], with_text=True)\nplt.show()\n', \"findfont: Font family Calibri not found. Falling back to DejaVu Sans.\nOriginal font not found. Falling back to Carlito. The logo text will not be in the correct font.\n",
    "id": 359
},
{
    "title": "Multipage PDF#",
    "text": "This is a demo of creating a pdf file with several pages,\nas well as adding metadata and annotations to pdf files. If you want to use a multipage pdf file using LaTeX, you need\nto use from matplotlib.backends.backend_pgf import PdfPages.\nThis version however does not support attach_note. Download Python source code: multipage_pdf.py Download Jupyter notebook: multipage_pdf.ipynb ",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backends.backend_pdf import PdfPages\n\n# Create the PdfPages object to which we will save the pages:\n# The with statement makes sure that the PdfPages object is closed properly at\n# the end of the block, even if an Exception occurs.\nwith PdfPages(\\'multipage_pdf.pdf\\') as pdf:\n    plt.figure(figsize=(3, 3))\n    plt.plot(range(7), [3, 1, 4, 1, 5, 9, 2], \\'r-o\\')\n    plt.title(\\'Page One\\')\n    pdf.savefig()  # saves the current figure into a pdf page\n    plt.close()\n\n    # if LaTeX is not installed or error caught, change to `False`\n    plt.rcParams[\\'text.usetex\\ = True\n    plt.figure(figsize=(8, 6))\n    x = np.arange(0, 5, 0.1)\n    plt.plot(x, np.sin(x), \\'b-\\')\n    plt.title(\\'Page Two\\')\n    pdf.attach_note(\"plot of sin(x)\")  # attach metadata (as pdf note) to page\n    pdf.savefig()\n    plt.close()\n\n    plt.rcParams[\\'text.usetex\\ = False\n    fig = plt.figure(figsize=(4, 5))\n    plt.plot(x, x ** 2, \\'ko\\')\n    plt.title(\\'Page Three\\')\n    pdf.savefig(fig)  # or you can pass a Figure object to pdf.savefig\n    plt.close()\n\n    # We can also set the file\\'s metadata via the PdfPages object:\n    d = pdf.infodict()\n    d[\\'Title\\ = \\'Multipage PDF Example\\'\n    d[\\'Author\\ = \\'Jouni K. Sepp\\\\xe4nen\\'\n    d[\\'Subject\\ = \\'How to create a multipage pdf file and set its metadata\\'\n    d[\\'Keywords\\ = \\'PdfPages multipage keywords author title subject\\'\n    d[\\'CreationDate\\ = datetime.datetime(2009, 11, 13)\n    d[\\'ModDate\\ = datetime.datetime.today()\n",
    "id": 360
},
{
    "title": "Multiprocessing#",
    "text": "Demo of using multiprocessing for generating data in one process and\nplotting in another. Written by Robert Cimrman This class plots data it receives from a pipe. This class uses multiprocessing to spawn a process to run code from the\nclass above. When initialized, it creates a pipe and an instance of\nProcessPlotter which will be run in a separate process. When run from the command line, the parent process sends data to the spawned\nprocess which is then plotted via the callback function specified in\nProcessPlotter:__call__. Download Python source code: multiprocess_sgskip.py Download Jupyter notebook: multiprocess_sgskip.ipynb ",
    "code": "import multiprocessing as mp\nimport time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n', \"class ProcessPlotter:\n    def __init__(self):\n        self.x = []\n        self.y = []\n\n    def terminate(self):\n        plt.close('all')\n\n    def call_back(self):\n        while self.pipe.poll():\n            command = self.pipe.recv()\n            if command is None:\n                self.terminate()\n                return False\n            else:\n                self.x.append(command[0])\n                self.y.append(command[1])\n                self.ax.plot(self.x, self.y, 'ro')\n        self.fig.canvas.draw()\n        return True\n\n    def __call__(self, pipe):\n        print('starting plotter...')\n\n        self.pipe = pipe\n        self.fig, self.ax = plt.subplots()\n        timer = self.fig.canvas.new_timer(interval=1000)\n        timer.add_callback(self.call_back)\n        timer.start()\n\n        print('...done')\n        plt.show()\n\", 'class NBPlot:\n    def __init__(self):\n        self.plot_pipe, plotter_pipe = mp.Pipe()\n        self.plotter = ProcessPlotter()\n        self.plot_process = mp.Process(\n            target=self.plotter, args=(plotter_pipe,), daemon=True)\n        self.plot_process.start()\n\n    def plot(self, finished=False):\n        send = self.plot_pipe.send\n        if finished:\n            send(None)\n        else:\n            data = np.random.random(2)\n            send(data)\n\n\ndef main():\n    pl = NBPlot()\n    for _ in range(10):\n        pl.plot()\n        time.sleep(0.5)\n    pl.plot(finished=True)\n\n\nif __name__ == \\'__main__\\':\n    if plt.get_backend() == \"MacOSX\":\n        mp.set_start_method(\"forkserver\")\n    main()\n",
    "id": 361
},
{
    "title": "Packed-bubble chart#",
    "text": "Create a packed-bubble chart to represent scalar data.\nThe presented algorithm tries to move all bubbles as close to the center of\nmass as possible while avoiding some collisions by moving around colliding\nobjects. In this example we plot the market share of different desktop\nbrowsers.\n(source: https://gs.statcounter.com/browser-market-share/desktop/worldwidev) Download Python source code: packed_bubbles.py Download Jupyter notebook: packed_bubbles.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nbrowser_market_share = {\n    \\'browsers\\': [\\'firefox\\', \\'chrome\\', \\'safari\\', \\'edge\\', \\'ie\\', \\'opera\\,\n    \\'market_share\\': [8.61, 69.55, 8.36, 4.12, 2.76, 2.43],\n    \\'color\\': [\\'#5A69AF\\', \\'#579E65\\', \\'#F9C784\\', \\'#FC944A\\', \\'#F24C00\\', \\'#00B825\\\n}\n\n\nclass BubbleChart:\n    def __init__(self, area, bubble_spacing=0):\n        \"\"\"\n        Setup for bubble collapse.\n\n        Parameters\n        ----------\n        area : array-like\n            Area of the bubbles.\n        bubble_spacing : float, default: 0\n            Minimal spacing between bubbles after collapsing.\n\n        Notes\n        -----\n        If \"area\" is sorted, the results might look weird.\n        \"\"\"\n        area = np.asarray(area)\n        r = np.sqrt(area / np.pi)\n\n        self.bubble_spacing = bubble_spacing\n        self.bubbles = np.ones((len(area), 4))\n        self.bubbles[:, 2] = r\n        self.bubbles[:, 3] = area\n        self.maxstep = 2 * self.bubbles[:, 2].max() + self.bubble_spacing\n        self.step_dist = self.maxstep / 2\n\n        # calculate initial grid layout for bubbles\n        length = np.ceil(np.sqrt(len(self.bubbles)))\n        grid = np.arange(length) * self.maxstep\n        gx, gy = np.meshgrid(grid, grid)\n        self.bubbles[:, 0] = gx.flatten()[:len(self.bubbles)]\n        self.bubbles[:, 1] = gy.flatten()[:len(self.bubbles)]\n\n        self.com = self.center_of_mass()\n\n    def center_of_mass(self):\n        return np.average(\n            self.bubbles[:, :2], axis=0, weights=self.bubbles[:, 3]\n        )\n\n    def center_distance(self, bubble, bubbles):\n        return np.hypot(bubble[0] - bubbles[:, 0],\n                        bubble[1] - bubbles[:, 1])\n\n    def outline_distance(self, bubble, bubbles):\n        center_distance = self.center_distance(bubble, bubbles)\n        return center_distance - bubble[2] - \\\\\n            bubbles[:, 2] - self.bubble_spacing\n\n    def check_collisions(self, bubble, bubbles):\n        distance = self.outline_distance(bubble, bubbles)\n        return len(distance[distance < 0])\n\n    def collides_with(self, bubble, bubbles):\n        distance = self.outline_distance(bubble, bubbles)\n        return np.argmin(distance, keepdims=True)\n\n    def collapse(self, n_iterations=50):\n        \"\"\"\n        Move bubbles to the center of mass.\n\n        Parameters\n        ----------\n        n_iterations : int, default: 50\n            Number of moves to perform.\n        \"\"\"\n        for _i in range(n_iterations):\n            moves = 0\n            for i in range(len(self.bubbles)):\n                rest_bub = np.delete(self.bubbles, i, 0)\n                # try to move directly towards the center of mass\n                # direction vector from bubble to the center of mass\n                dir_vec = self.com - self.bubbles[i, :2]\n\n                # shorten direction vector to have length of 1\n                dir_vec = dir_vec / np.sqrt(dir_vec.dot(dir_vec))\n\n                # calculate new bubble position\n                new_point = self.bubbles[i, :2] + dir_vec * self.step_dist\n                new_bubble = np.append(new_point, self.bubbles[i, 2:4])\n\n                # check whether new bubble collides with other bubbles\n                if not self.check_collisions(new_bubble, rest_bub):\n                    self.bubbles[i, :] = new_bubble\n                    self.com = self.center_of_mass()\n                    moves += 1\n                else:\n                    # try to move around a bubble that you collide with\n                    # find colliding bubble\n                    for colliding in self.collides_with(new_bubble, rest_bub):\n                        # calculate direction vector\n                        dir_vec = rest_bub[colliding, :2] - self.bubbles[i, :2]\n                        dir_vec = dir_vec / np.sqrt(dir_vec.dot(dir_vec))\n                        # calculate orthogonal vector\n                        orth = np.array([dir_vec[1], -dir_vec[0]])\n                        # test which direction to go\n                        new_point1 = (self.bubbles[i, :2] + orth *\n                                      self.step_dist)\n                        new_point2 = (self.bubbles[i, :2] - orth *\n                                      self.step_dist)\n                        dist1 = self.center_distance(\n                            self.com, np.array([new_point1]))\n                        dist2 = self.center_distance(\n                            self.com, np.array([new_point2]))\n                        new_point = new_point1 if dist1 < dist2 else new_point2\n                        new_bubble = np.append(new_point, self.bubbles[i, 2:4])\n                        if not self.check_collisions(new_bubble, rest_bub):\n                            self.bubbles[i, :] = new_bubble\n                            self.com = self.center_of_mass()\n\n            if moves / len(self.bubbles) < 0.1:\n                self.step_dist = self.step_dist / 2\n\n    def plot(self, ax, labels, colors):\n        \"\"\"\n        Draw the bubble plot.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n        labels : list\n            Labels of the bubbles.\n        colors : list\n            Colors of the bubbles.\n        \"\"\"\n        for i in range(len(self.bubbles)):\n            circ = plt.Circle(\n                self.bubbles[i, :2], self.bubbles[i, 2], color=colors[i])\n            ax.add_patch(circ)\n            ax.text(*self.bubbles[i, :2], labels[i],\n                    horizontalalignment=\\'center\\', verticalalignment=\\'center\\')\n\n\nbubble_chart = BubbleChart(area=browser_market_share[\\'market_share\\,\n                           bubble_spacing=0.1)\n\nbubble_chart.collapse()\n\nfig, ax = plt.subplots(subplot_kw=dict(aspect=\"equal\"))\nbubble_chart.plot(\n    ax, browser_market_share[\\'browsers\\, browser_market_share[\\'color\\)\nax.axis(\"off\")\nax.relim()\nax.autoscale_view()\nax.set_title(\\'Browser market share\\')\n\nplt.show()\n",
    "id": 362
},
{
    "title": "Patheffect Demo#",
    "text": "Download Python source code: patheffect_demo.py Download Jupyter notebook: patheffect_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patheffects\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(8, 3))\nax1.imshow([[1, 2], [2, 3]])\ntxt = ax1.annotate(\"test\", (1., 1.), (0., 0),\n                   arrowprops=dict(arrowstyle=\"->\",\n                                   connectionstyle=\"angle3\", lw=2),\n                   size=20, ha=\"center\",\n                   path_effects=[patheffects.withStroke(linewidth=3,\n                                                        foreground=\"w\")])\ntxt.arrow_patch.set_path_effects([\n    patheffects.Stroke(linewidth=5, foreground=\"w\"),\n    patheffects.Normal()])\n\npe = [patheffects.withStroke(linewidth=3,\n                             foreground=\"w\")]\nax1.grid(True, linestyle=\"-\", path_effects=pe)\n\narr = np.arange(25).reshape((5, 5))\nax2.imshow(arr)\ncntr = ax2.contour(arr, colors=\"k\")\n\ncntr.set(path_effects=[patheffects.withStroke(linewidth=3, foreground=\"w\")])\n\nclbls = ax2.clabel(cntr, fmt=\"%2.0f\", use_clabeltext=True)\nplt.setp(clbls, path_effects=[\n    patheffects.withStroke(linewidth=3, foreground=\"w\")])\n\n# shadow as a path effect\np1, = ax3.plot([0, 1], [0, 1])\nleg = ax3.legend([p1], Line 1, fancybox=True, loc=\\'upper left\\')\nleg.legendPatch.set_path_effects([patheffects.withSimplePatchShadow()])\n\nplt.show()\n",
    "id": 363
},
{
    "title": "Print Stdout#",
    "text": "print png to standard out usage: python print_stdout.py > somefile.png Download Python source code: print_stdout_sgskip.py Download Jupyter notebook: print_stdout_sgskip.ipynb ",
    "code": "import sys\n\nimport matplotlib\n\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3])\nplt.savefig(sys.stdout.buffer)\n",
    "id": 364
},
{
    "title": "Rasterization for vector graphics#",
    "text": "Rasterization converts vector graphics into a raster image (pixels). It can\nspeed up rendering and produce smaller files for large data sets, but comes\nat the cost of a fixed resolution. Whether rasterization should be used can be specified per artist. This can be\nuseful to reduce the file size of large artists, while maintaining the\nadvantages of vector graphics for other artists such as the axes\nand text. For instance a complicated pcolormesh or\ncontourf can be made significantly simpler by rasterizing.\nSetting rasterization only affects vector backends such as PDF, SVG, or PS. Rasterization is disabled by default. There are two ways to enable it, which\ncan also be combined: Set set_rasterized on individual artists, or use the keyword\nargument rasterized when creating the artist. Set Axes.set_rasterization_zorder to rasterize all artists with a zorder\nless than the given value. The storage size and the resolution of the rasterized artist is determined by\nits physical size and the value of the dpi parameter passed to\nsavefig. Note The image of this example shown in the HTML documentation is not a vector\ngraphic. Therefore, it cannot illustrate the rasterization effect. Please\nrun this example locally and check the generated graphics files. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.artist.Artist.set_rasterized matplotlib.axes.Axes.set_rasterization_zorder matplotlib.axes.Axes.pcolormesh / matplotlib.pyplot.pcolormesh Total running time of the script: (0 minutes 1.776 seconds) Download Python source code: rasterization_demo.py Download Jupyter notebook: rasterization_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nd = np.arange(100).reshape(10, 10)  # the values to be color-mapped\nx, y = np.meshgrid(np.arange(11), np.arange(11))\n\ntheta = 0.25*np.pi\nxx = x*np.cos(theta) - y*np.sin(theta)  # rotate x by -theta\nyy = x*np.sin(theta) + y*np.cos(theta)  # rotate y by -theta\n\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, layout=\"constrained\")\n\n# pcolormesh without rasterization\nax1.set_aspect(1)\nax1.pcolormesh(xx, yy, d)\nax1.set_title(\"No Rasterization\")\n\n# pcolormesh with rasterization; enabled by keyword argument\nax2.set_aspect(1)\nax2.set_title(\"Rasterization\")\nax2.pcolormesh(xx, yy, d, rasterized=True)\n\n# pcolormesh with an overlaid text without rasterization\nax3.set_aspect(1)\nax3.pcolormesh(xx, yy, d)\nax3.text(0.5, 0.5, \"Text\", alpha=0.2,\n         va=\"center\", ha=\"center\", size=50, transform=ax3.transAxes)\nax3.set_title(\"No Rasterization\")\n\n# pcolormesh with an overlaid text without rasterization; enabled by zorder.\n# Setting the rasterization zorder threshold to 0 and a negative zorder on the\n# pcolormesh rasterizes it. All artists have a non-negative zorder by default,\n# so they (e.g. the text here) are not affected.\nax4.set_aspect(1)\nm = ax4.pcolormesh(xx, yy, d, zorder=-10)\nax4.text(0.5, 0.5, \"Text\", alpha=0.2,\n         va=\"center\", ha=\"center\", size=50, transform=ax4.transAxes)\nax4.set_rasterization_zorder(0)\nax4.set_title(\"Rasterization z$<-10$\")\n\n# Save files in pdf and eps format\nplt.savefig(\"test_rasterization.pdf\", dpi=150)\nplt.savefig(\"test_rasterization.eps\", dpi=150)\n\nif not plt.rcParamstext.usetex:\n    plt.savefig(\"test_rasterization.svg\", dpi=150)\n    # svg backend currently ignores the dpi\n The PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n",
    "id": 365
},
{
    "title": "Set and get properties#",
    "text": "The pyplot interface allows you to use setp and getp to\nset and get object properties respectively, as well as to do\nintrospection on the object. To set the linestyle of a line to be dashed, you use setp: If you want to know the valid types of arguments, you can provide the\nname of the property you want to set without a value: If you want to see all the properties that can be set, and their\npossible values, you can do: setp operates on a single instance or a list of instances. If you\nare in query mode introspecting the possible values, only the first\ninstance in the sequence is used. When actually setting values, all\nthe instances will be set. For example, suppose you have a list of\ntwo lines, the following will make both lines thicker and red: getp returns the value of a given attribute. You can use it to query\nthe value of a single attribute: or all the attribute/value pairs:', \"To reduce keystrokes in interactive mode, a number of properties\nhave short aliases, e.g., 'lw' for 'linewidth' and 'mec' for\n'markeredgecolor'. When calling set or get in introspection mode,\nthese properties will be listed as 'fullname' or 'aliasname'.\", 'Download Python source code: set_and_get.py Download Jupyter notebook: set_and_get.ipynb ",
    "code": ">>> line, = plt.plot([1, 2, 3])\n>>> plt.setp(line, linestyle='--')\n\", \">>> plt.setp(line, 'linestyle')\n    linestyle: {'- -- -. : ', (offset, on-off-seq), ...}\n\", '>>> plt.setp(line)\n', \">>> x = np.arange(0, 1, 0.01)\n>>> y1 = np.sin(2*np.pi*x)\n>>> y2 = np.sin(4*np.pi*x)\n>>> lines = plt.plot(x, y1, x, y2)\n>>> plt.setp(lines, linewidth=2, color='r')\n\", \">>> plt.getp(line, 'linewidth')\n    0.5\n\", '>>> plt.getp(line)\n    aa = True\n    alpha = 1.0\n    antialiased = True\n    c = b\n    clip_on = True\n    color = b\n    ... long listing skipped ...\n', \"Line setters\n  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image\n  alpha: scalar or None\n  animated: bool\n  antialiased or aa: bool\n  clip_box: `~matplotlib.transforms.BboxBase` or None\n  clip_on: bool\n  clip_path: Patch or (Path, Transform) or None\n  color or c: color\n  dash_capstyle: `.CapStyle` or {'butt projecting round'}\n  dash_joinstyle: `.JoinStyle` or {'miter round bevel'}\n  dashes: sequence of floats (on/off ink in points) or (None, None)\n  data: (2, N) array or two 1D arrays\n  drawstyle or ds: {'default steps steps-pre steps-mid steps-post'}, default: 'default'\n  figure: `~matplotlib.figure.Figure`\n  fillstyle: {'full left right bottom top none'}\n  gapcolor: color or None\n  gid: str\n  in_layout: bool\n  label: object\n  linestyle or ls: {'- -- -. : ', (offset, on-off-seq), ...}\n  linewidth or lw: float\n  marker: marker style string, `~.path.Path` or `~.markers.MarkerStyle`\n  markeredgecolor or mec: color\n  markeredgewidth or mew: float\n  markerfacecolor or mfc: color\n  markerfacecoloralt or mfcalt: color\n  markersize or ms: float\n  markevery: None or int or (int, int) or slice or list[int] or float or (float, float) or list[bool]\n  mouseover: bool\n  path_effects: list of `.AbstractPathEffect`\n  picker: float or callable[[Artist, Event], tuple[bool, dict]]\n  pickradius: float\n  rasterized: bool\n  sketch_params: (scale: float, length: float, randomness: float)\n  snap: bool or None\n  solid_capstyle: `.CapStyle` or {'butt projecting round'}\n  solid_joinstyle: `.JoinStyle` or {'miter round bevel'}\n  transform: `~matplotlib.transforms.Transform`\n  url: str\n  visible: bool\n  xdata: 1D array\n  ydata: 1D array\n  zorder: float\nLine getters\n    agg_filter = None\n    alpha = None\n    animated = False\n    antialiased or aa = True\n    bbox = Bbox(x0=0.0, y0=-1.0, x1=0.99, y1=1.0)\n    children = []\n    clip_box = TransformedBbox(     Bbox(x0=0.0, y0=0.0, x1=1.0, ...\n    clip_on = True\n    clip_path = None\n    color or c = r\n    dash_capstyle = butt\n    dash_joinstyle = round\n    data = (array([0.  , 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, ...\n    drawstyle or ds = default\n    figure = Figure(640x480)\n    fillstyle = full\n    gapcolor = None\n    gid = None\n    in_layout = True\n    label = _child0\n    linestyle or ls = --\n    linewidth or lw = 2.0\n    marker = None\n    markeredgecolor or mec = r\n    markeredgewidth or mew = 1.0\n    markerfacecolor or mfc = r\n    markerfacecoloralt or mfcalt = none\n    markersize or ms = 6.0\n    markevery = None\n    mouseover = False\n    path = Path(array([[ 0.00000000e+00,  0.00000000e+00],   ...\n    path_effects = []\n    picker = None\n    pickradius = 5\n    rasterized = False\n    sketch_params = None\n    snap = None\n    solid_capstyle = projecting\n    solid_joinstyle = round\n    tightbbox = Bbox(x0=80.0, y0=52.8, x1=571.04, y1=422.4)\n    transform = CompositeGenericTransform(     TransformWrapper(  ...\n    transformed_clip_path_and_affine = (None, None)\n    url = None\n    visible = True\n    window_extent = Bbox(x0=80.0, y0=-316.79999999999995, x1=571.04, y...\n    xdata = [0.   0.01 0.02 0.03 0.04 0.05]...\n    xydata = [[0.         0.        ]  [0.01       0.06279052] ...\n    ydata = [0.         0.06279052 0.12533323 0.18738131 0.248...\n    zorder = 2\nRectangle setters\n  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image\n  alpha: scalar or None\n  angle: unknown\n  animated: bool\n  antialiased or aa: bool or None\n  bounds: (left, bottom, width, height)\n  capstyle: `.CapStyle` or {'butt projecting round'}\n  clip_box: `~matplotlib.transforms.BboxBase` or None\n  clip_on: bool\n  clip_path: Patch or (Path, Transform) or None\n  color: color\n  edgecolor or ec: color or None\n  facecolor or fc: color or None\n  figure: `~matplotlib.figure.Figure`\n  fill: bool\n  gid: str\n  hatch: {'/ \\\\\\\\ | - + x o O . *'}\n  height: unknown\n  in_layout: bool\n  joinstyle: `.JoinStyle` or {'miter round bevel'}\n  label: object\n  linestyle or ls: {'- -- -. : ', (offset, on-off-seq), ...}\n  linewidth or lw: float or None\n  mouseover: bool\n  path_effects: list of `.AbstractPathEffect`\n  picker: None or bool or float or callable\n  rasterized: bool\n  sketch_params: (scale: float, length: float, randomness: float)\n  snap: bool or None\n  transform: `~matplotlib.transforms.Transform`\n  url: str\n  visible: bool\n  width: unknown\n  x: unknown\n  xy: (float, float)\n  y: unknown\n  zorder: float\nRectangle getters\n    agg_filter = None\n    alpha = None\n    angle = 0.0\n    animated = False\n    antialiased or aa = True\n    bbox = Bbox(x0=0.0, y0=0.0, x1=1.0, y1=1.0)\n    capstyle = butt\n    center = [0.5 0.5]\n    children = []\n    clip_box = None\n    clip_on = True\n    clip_path = None\n    corners = [[0. 0.]  [1. 0.]  [1. 1.]  [0. 1.]]\n    data_transform = BboxTransformTo(     TransformedBbox(         Bbox...\n    edgecolor or ec = (0.0, 0.0, 0.0, 0.0)\n    extents = Bbox(x0=80.0, y0=52.8, x1=576.0, y1=422.4)\n    facecolor or fc = (1.0, 1.0, 1.0, 1.0)\n    figure = Figure(640x480)\n    fill = True\n    gid = None\n    hatch = None\n    height = 1.0\n    in_layout = True\n    joinstyle = miter\n    label =\n    linestyle or ls = solid\n    linewidth or lw = 0.0\n    mouseover = False\n    patch_transform = CompositeGenericTransform(     BboxTransformTo(   ...\n    path = Path(array([[0., 0.],        [1., 0.],        [1.,...\n    path_effects = []\n    picker = None\n    rasterized = False\n    sketch_params = None\n    snap = None\n    tightbbox = Bbox(x0=80.0, y0=52.8, x1=576.0, y1=422.4)\n    transform = CompositeGenericTransform(     CompositeGenericTra...\n    transformed_clip_path_and_affine = (None, None)\n    url = None\n    verts = [[ 80.   52.8]  [576.   52.8]  [576.  422.4]  [ 80...\n    visible = True\n    width = 1.0\n    window_extent = Bbox(x0=80.0, y0=52.8, x1=576.0, y1=422.4)\n    x = 0.0\n    xy = (0.0, 0.0)\n    y = 0.0\n    zorder = 1\nText setters\n  agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image\n  alpha: scalar or None\n  animated: bool\n  antialiased: bool\n  backgroundcolor: color\n  bbox: dict with properties for `.patches.FancyBboxPatch`\n  clip_box: `~matplotlib.transforms.BboxBase` or None\n  clip_on: bool\n  clip_path: Patch or (Path, Transform) or None\n  color or c: color\n  figure: `~matplotlib.figure.Figure`\n  fontfamily or family or fontname: {FONTNAME, 'serif sans-serif cursive fantasy monospace'}\n  fontproperties or font or font_properties: `.font_manager.FontProperties` or `str` or `pathlib.Path`\n  fontsize or size: float or {'xx-small x-small small medium large x-large xx-large'}\n  fontstretch or stretch: {a numeric value in range 0-1000, 'ultra-condensed extra-condensed condensed semi-condensed normal semi-expanded expanded extra-expanded ultra-expanded'}\n  fontstyle or style: {'normal italic oblique'}\n  fontvariant or variant: {'normal small-caps'}\n  fontweight or weight: {a numeric value in range 0-1000, 'ultralight light normal regular book medium roman semibold demibold demi bold heavy extra bold black'}\n  gid: str\n  horizontalalignment or ha: {'left center right'}\n  in_layout: bool\n  label: object\n  linespacing: float (multiple of font size)\n  math_fontfamily: str\n  mouseover: bool\n  multialignment or ma: {'left right center'}\n  parse_math: bool\n  path_effects: list of `.AbstractPathEffect`\n  picker: None or bool or float or callable\n  position: (float, float)\n  rasterized: bool\n  rotation: float or {'vertical horizontal'}\n  rotation_mode: {None, 'default anchor'}\n  sketch_params: (scale: float, length: float, randomness: float)\n  snap: bool or None\n  text: object\n  transform: `~matplotlib.transforms.Transform`\n  transform_rotates_text: bool\n  url: str\n  usetex: bool or None\n  verticalalignment or va: {'bottom baseline center center_baseline top'}\n  visible: bool\n  wrap: bool\n  x: float\n  y: float\n  zorder: float\nText getters\n    agg_filter = None\n    alpha = None\n    animated = False\n    antialiased = True\n    bbox_patch = None\n    children = []\n    clip_box = None\n    clip_on = True\n    clip_path = None\n    color or c = black\n    figure = Figure(640x480)\n    fontfamily or family or fontname = sans-serif\n    fontname or name = DejaVu Sans\n    fontproperties or font or font_properties = sans\\\\-serif:style=normal:variant=normal:weight=nor...\n    fontsize or size = 12.0\n    fontstyle or style = normal\n    fontvariant or variant = normal\n    fontweight or weight = normal\n    gid = None\n    horizontalalignment or ha = center\n    in_layout = True\n    label =\n    math_fontfamily = dejavusans\n    mouseover = False\n    parse_math = True\n    path_effects = []\n    picker = None\n    position = (0.5, 1.0)\n    rasterized = False\n    rotation = 0.0\n    rotation_mode = default\n    sketch_params = None\n    snap = None\n    stretch = normal\n    text = Hi mom\n    tightbbox = Bbox(x0=295.5, y0=426.7333333333333, x1=360.5, y1=...\n    transform = CompositeGenericTransform(     BboxTransformTo(   ...\n    transform_rotates_text = False\n    transformed_clip_path_and_affine = (None, None)\n    unitless_position = (0.5, 1.0)\n    url = None\n    usetex = False\n    verticalalignment or va = baseline\n    visible = True\n    window_extent = Bbox(x0=295.5, y0=426.7333333333333, x1=360.5, y1=...\n    wrap = False\n    zorder = 3\n\", \"import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 1.0, 0.01)\ny1 = np.sin(2*np.pi*x)\ny2 = np.sin(4*np.pi*x)\nlines = plt.plot(x, y1, x, y2)\nl1, l2 = lines\nplt.setp(lines, linestyle='--')       # set both to dashed\nplt.setp(l1, linewidth=2, color='r')  # line1 is thick and red\nplt.setp(l2, linewidth=1, color='g')  # line2 is thinner and green\n\n\nprint('Line setters')\nplt.setp(l1)\nprint('Line getters')\nplt.getp(l1)\n\nprint('Rectangle setters')\nplt.setp(plt.gca().patch)\nprint('Rectangle getters')\nplt.getp(plt.gca().patch)\n\nt = plt.title('Hi mom')\nprint('Text setters')\nplt.setp(t)\nprint('Text getters')\nplt.getp(t)\n\nplt.show()\n",
    "id": 366
},
{
    "title": "SVG Filter Line#",
    "text": "Demonstrate SVG filtering effects which might be used with Matplotlib. Note that the filtering effects are only effective if your SVG renderer\nsupport it. Download Python source code: svg_filter_line.py Download Jupyter notebook: svg_filter_line.ipynb ",
    "code": "Saving 'svg_filter_line.svg'\n\", 'import io\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nimport matplotlib.transforms as mtransforms\n\nfig1 = plt.figure()\nax = fig1.add_axes([0.1, 0.1, 0.8, 0.8])\n\n# draw lines\nl1, = ax.plot([0.1, 0.5, 0.9], [0.1, 0.9, 0.5], \"bo-\",\n              mec=\"b\", lw=5, ms=10, label=\"Line 1\")\nl2, = ax.plot([0.1, 0.5, 0.9], [0.5, 0.2, 0.7], \"rs-\",\n              mec=\"r\", lw=5, ms=10, label=\"Line 2\")\n\n\nfor l in [l1, l2]:\n\n    # draw shadows with same lines with slight offset and gray colors.\n\n    xx = l.get_xdata()\n    yy = l.get_ydata()\n    shadow, = ax.plot(xx, yy)\n    shadow.update_from(l)\n\n    # adjust color\n    shadow.set_color(\"0.2\")\n    # adjust zorder of the shadow lines so that it is drawn below the\n    # original lines\n    shadow.set_zorder(l.get_zorder() - 0.5)\n\n    # offset transform\n    transform = mtransforms.offset_copy(l.get_transform(), fig1,\n                                        x=4.0, y=-6.0, units=\\'points\\')\n    shadow.set_transform(transform)\n\n    # set the id for a later use\n    shadow.set_gid(l.get_label() + \"_shadow\")\n\n\nax.set_xlim(0., 1.)\nax.set_ylim(0., 1.)\n\n# save the figure as a bytes string in the svg format.\nf = io.BytesIO()\nplt.savefig(f, format=\"svg\")\n\n\n# filter definition for a gaussian blur\nfilter_def = \"\"\"\n  <defs xmlns=\\'http://www.w3.org/2000/svg\\'\n        xmlns:xlink=\\'http://www.w3.org/1999/xlink\\'>\n    <filter id=\\'dropshadow\\' height=\\'1.2\\' width=\\'1.2\\'>\n      <feGaussianBlur result=\\'blur\\' stdDeviation=\\'3\\'/>\n    </filter>\n  </defs>\n\"\"\"\n\n\n# read in the saved svg\ntree, xmlid = ET.XMLID(f.getvalue())\n\n# insert the filter definition in the svg dom tree.\ntree.insert(0, ET.XML(filter_def))\n\nfor l in [l1, l2]:\n    # pick up the svg element with given id\n    shadow = xmlid[l.get_label() + \"_shadow\n    # apply shadow filter\n    shadow.set(\"filter\", \\'url(#dropshadow)\\')\n\nfn = \"svg_filter_line.svg\"\nprint(f\"Saving \\'{fn}\\'\")\nET.ElementTree(tree).write(fn)\n",
    "id": 367
},
{
    "title": "SVG filter pie#",
    "text": "Demonstrate SVG filtering effects which might be used with Matplotlib.\nThe pie chart drawing code is borrowed from pie_demo.py Note that the filtering effects are only effective if your SVG renderer\nsupport it. Download Python source code: svg_filter_pie.py Download Jupyter notebook: svg_filter_pie.ipynb ",
    "code": "Saving 'svg_filter_pie.svg'\n\", 'import io\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Shadow\n\n# make a square figure and axes\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n\nlabels = \\'Frogs\\', \\'Hogs\\', \\'Dogs\\', \\'Logs\\'\nfracs = [15, 30, 45, 10]\n\nexplode = (0, 0.05, 0, 0)\n\n# We want to draw the shadow for each pie, but we will not use \"shadow\"\n# option as it doesn\\'t save the references to the shadow patches.\npies = ax.pie(fracs, explode=explode, labels=labels, autopct=\\'%1.1f%%\\')\n\nfor w in pies[0]:\n    # set the id with the label.\n    w.set_gid(w.get_label())\n\n    # we don\\'t want to draw the edge of the pie\n    w.set_edgecolor(\"none\")\n\nfor w in pies[0]:\n    # create shadow patch\n    s = Shadow(w, -0.01, -0.01)\n    s.set_gid(w.get_gid() + \"_shadow\")\n    s.set_zorder(w.get_zorder() - 0.1)\n    ax.add_patch(s)\n\n\n# save\nf = io.BytesIO()\nplt.savefig(f, format=\"svg\")\n\n\n# Filter definition for shadow using a gaussian blur and lighting effect.\n# The lighting filter is copied from http://www.w3.org/TR/SVG/filters.html\n\n# I tested it with Inkscape and Firefox3. \"Gaussian blur\" is supported\n# in both, but the lighting effect only in Inkscape. Also note\n# that, Inkscape\\'s exporting also may not support it.\n\nfilter_def = \"\"\"\n  <defs xmlns=\\'http://www.w3.org/2000/svg\\'\n        xmlns:xlink=\\'http://www.w3.org/1999/xlink\\'>\n    <filter id=\\'dropshadow\\' height=\\'1.2\\' width=\\'1.2\\'>\n      <feGaussianBlur result=\\'blur\\' stdDeviation=\\'2\\'/>\n    </filter>\n\n    <filter id=\\'MyFilter\\' filterUnits=\\'objectBoundingBox\\'\n            x=\\'0\\' y=\\'0\\' width=\\'1\\' height=\\'1\\'>\n      <feGaussianBlur in=\\'SourceAlpha\\' stdDeviation=\\'4%\\' result=\\'blur\\'/>\n      <feOffset in=\\'blur\\' dx=\\'4%\\' dy=\\'4%\\' result=\\'offsetBlur\\'/>\n      <feSpecularLighting in=\\'blur\\' surfaceScale=\\'5\\' specularConstant=\\'.75\\'\n           specularExponent=\\'20\\' lighting-color=\\'#bbbbbb\\' result=\\'specOut\\'>\n        <fePointLight x=\\'-5000%\\' y=\\'-10000%\\' z=\\'20000%\\'/>\n      </feSpecularLighting>\n      <feComposite in=\\'specOut\\' in2=\\'SourceAlpha\\'\n                   operator=\\'in\\' result=\\'specOut\\'/>\n      <feComposite in=\\'SourceGraphic\\' in2=\\'specOut\\' operator=\\'arithmetic\\'\n    k1=\\'0\\' k2=\\'1\\' k3=\\'1\\' k4=\\'0\\'/>\n    </filter>\n  </defs>\n\"\"\"\n\n\ntree, xmlid = ET.XMLID(f.getvalue())\n\n# insert the filter definition in the svg dom tree.\ntree.insert(0, ET.XML(filter_def))\n\nfor i, pie_name in enumerate(labels):\n    pie = xmlid[pie_name]\n    pie.set(\"filter\", \\'url(#MyFilter)\\')\n\n    shadow = xmlid[pie_name + \"_shadow\n    shadow.set(\"filter\", \\'url(#dropshadow)\\')\n\nfn = \"svg_filter_pie.svg\"\nprint(f\"Saving \\'{fn}\\'\")\nET.ElementTree(tree).write(fn)\n",
    "id": 368
},
{
    "title": "Table Demo#",
    "text": "Demo of table function to display a table within a plot. Download Python source code: table_demo.py Download Jupyter notebook: table_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndata = [[ 66386, 174296,  75131, 577908,  32015],\n        [ 58230, 381139,  78045,  99308, 160454],\n        [ 89135,  80552, 152558, 497981, 603535],\n        [ 78415,  81858, 150656, 193263,  69638],\n        [139361, 331509, 343164, 781380,  52269]]\n\ncolumns = (\\'Freeze\\', \\'Wind\\', \\'Flood\\', \\'Quake\\', \\'Hail\\')\nrows = [\\'%d year\\' % x for x in (100, 50, 20, 10, 5)]\n\nvalues = np.arange(0, 2500, 500)\nvalue_increment = 1000\n\n# Get some pastel shades for the colors\ncolors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows)))\nn_rows = len(data)\n\nindex = np.arange(len(columns)) + 0.3\nbar_width = 0.4\n\n# Initialize the vertical-offset for the stacked bar chart.\ny_offset = np.zeros(len(columns))\n\n# Plot bars and create text labels for the table\ncell_text = []\nfor row in range(n_rows):\n    plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row])\n    y_offset = y_offset + data[row]\n    cell_text.append([\\'%1.1f\\' % (x / 1000.0) for x in y_offset])\n# Reverse colors and text labels to display the last value at the top.\ncolors = colors[::-1]\ncell_text.reverse()\n\n# Add a table at the bottom of the axes\nthe_table = plt.table(cellText=cell_text,\n                      rowLabels=rows,\n                      rowColours=colors,\n                      colLabels=columns,\n                      loc=\\'bottom\\')\n\n# Adjust layout to make room for the table:\nplt.subplots_adjust(left=0.2, bottom=0.2)\n\nplt.ylabel(f\"Loss in ${value_increment}\\'s\")\nplt.yticks(values * value_increment, [\\'%d\\' % val for val in values])\nplt.xticks([])\nplt.title(\\'Loss by Disaster\\')\n\nplt.show()\n",
    "id": 369
},
{
    "title": "TickedStroke patheffect#",
    "text": "Matplotlib's patheffects can be used to alter the way paths\nare drawn at a low enough level that they can affect almost anything.\", 'The patheffects guide\ndetails the use of patheffects. The TickedStroke patheffect illustrated here\ndraws a path with a ticked style. The spacing, length, and angle of\nticks can be controlled. See also the Lines with a ticked patheffect example. See also the Contouring the solution space of optimizations\nexample. Contour plot with objective and constraints.\nCurves generated by contour to represent a typical constraint in an\noptimization problem should be plotted with angles between zero and\n180 degrees. To change which side of the line the ticks are drawn, change the sign of the angle. Total running time of the script: (0 minutes 1.497 seconds) Download Python source code: tickedstroke_demo.py Download Jupyter notebook: tickedstroke_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n', \"import matplotlib.patches as patches\nfrom matplotlib.path import Path\nimport matplotlib.patheffects as patheffects\n\nfig, ax = plt.subplots(figsize=(6, 6))\npath = Path.unit_circle()\npatch = patches.PathPatch(path, facecolor='none', lw=2, path_effects=[\n    patheffects.withTickedStroke(angle=-90, spacing=10, length=1)])\n\nax.add_patch(patch)\nax.axis('equal')\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\nplt.show()\n\", 'fig, ax = plt.subplots(figsize=(6, 6))\nax.plot([0, 1], [0, 1], label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\nnx = 101\nx = np.linspace(0.0, 1.0, nx)\ny = 0.3*np.sin(x*8) + 0.4\nax.plot(x, y, label=\"Curve\", path_effects=[patheffects.withTickedStroke()])\n\nax.legend()\n\nplt.show()\n fig, ax = plt.subplots(figsize=(6, 6))\n\nnx = 101\nny = 105\n\n# Set up survey vectors\nxvec = np.linspace(0.001, 4.0, nx)\nyvec = np.linspace(0.001, 4.0, ny)\n\n# Set up survey matrices.  Design disk loading and gear ratio.\nx1, x2 = np.meshgrid(xvec, yvec)\n\n# Evaluate some stuff to plot\nobj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2\ng1 = -(3*x1 + x2 - 5.5)\ng2 = -(x1 + 2*x2 - 4.5)\ng3 = 0.8 + x1**-3 - x2\n\ncntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],\n                  colors=\\'black\\')\nax.clabel(cntr, fmt=\"%2.1f\", use_clabeltext=True)\n\ncg1 = ax.contour(x1, x2, g1, [0], colors=\\'sandybrown\\')\ncg1.set(path_effects=[patheffects.withTickedStroke(angle=135)])\n\ncg2 = ax.contour(x1, x2, g2, [0], colors=\\'orangered\\')\ncg2.set(path_effects=[patheffects.withTickedStroke(angle=60, length=2)])\n\ncg3 = ax.contour(x1, x2, g3, [0], colors=\\'mediumblue\\')\ncg3.set(path_effects=[patheffects.withTickedStroke(spacing=7)])\n\nax.set_xlim(0, 4)\nax.set_ylim(0, 4)\n\nplt.show()\n fig, ax = plt.subplots(figsize=(6, 6))\nline_x = line_y = [0, 1]\nax.plot(line_x, line_y, label=\"Line\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=135)])\n\nax.plot(line_x, line_y, label=\"Opposite side\",\n        path_effects=[patheffects.withTickedStroke(spacing=7, angle=-135)])\n\nax.legend()\nplt.show()\n",
    "id": 370
},
{
    "title": "transforms.offset_copy#",
    "text": "This illustrates the use of transforms.offset_copy to\nmake a transform that positions a drawing element such as\na text string at a specified offset in screen coordinates\n(dots or inches) relative to a location given in any\ncoordinates. Every Artist (Text, Line2D, etc.) has a transform that can be\nset when the Artist is created, such as by the corresponding\npyplot function. By default, this is usually the Axes.transData\ntransform, going from data units to screen pixels. We can\nuse the offset_copy function to make a modified copy of\nthis transform, where the modification consists of an\noffset. Download Python source code: transoffset.py Download Jupyter notebook: transoffset.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.transforms as mtransforms\n\nxs = np.arange(7)\nys = xs**2\n\nfig = plt.figure(figsize=(5, 10))\nax = plt.subplot(2, 1, 1)\n\n# If we want the same offset for each text instance,\n# we only need to make one transform.  To get the\n# transform argument to offset_copy, we need to make the axes\n# first; the subplot function above is one way to do this.\ntrans_offset = mtransforms.offset_copy(ax.transData, fig=fig,\n                                       x=0.05, y=0.10, units='inches')\n\nfor x, y in zip(xs, ys):\n    plt.plot(x, y, 'ro')\n    plt.text(x, y, '%d, %d' % (int(x), int(y)), transform=trans_offset)\n\n\n# offset_copy works for polar plots also.\nax = plt.subplot(2, 1, 2, projection='polar')\n\ntrans_offset = mtransforms.offset_copy(ax.transData, fig=fig,\n                                       y=6, units='dots')\n\nfor x, y in zip(xs, ys):\n    plt.polar(x, y, 'ro')\n    plt.text(x, y, '%d, %d' % (int(x), int(y)),\n             transform=trans_offset,\n             horizontalalignment='center',\n             verticalalignment='bottom')\n\nplt.show()\n",
    "id": 371
},
{
    "title": "Zorder Demo#",
    "text": "The drawing order of artists is determined by their zorder attribute, which\nis a floating point number. Artists with higher zorder are drawn on top.\nYou can change the order for individual artists by setting their zorder.\nThe default value depends on the type of the Artist: Artist Z-order Images (AxesImage, FigureImage, BboxImage) 0 Patch, PatchCollection 1 Line2D, LineCollection (including minor ticks, grid lines) 2 Major ticks 2.01 Text (including axes labels and titles) 3 Legend 5 Any call to a plotting method can set a value for the zorder of that particular\nitem explicitly. Note set_axisbelow and rcParamsaxes.axisbelow (default: \\'line\\') are convenient helpers\nfor setting the zorder of ticks and grid lines. Drawing is done per Axes at a time. If you have overlapping Axes, all\nelements of the second Axes are drawn on top of the first Axes, irrespective of\ntheir relative zorder. The following example contains a Line2D created by plot()\nand the dots (a PatchCollection) created by scatter().\nHence, by default the dots are below the line (first subplot).\nIn the second subplot, the zorder is set explicitly to move the dots\non top of the line. Many functions that create a visible object accepts a zorder parameter.\nAlternatively, you can call set_zorder() on the created object later. Download Python source code: zorder_demo.py Download Jupyter notebook: zorder_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nr = np.linspace(0.3, 1, 30)\ntheta = np.linspace(0, 4*np.pi, 30)\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n', \"fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3.2))\n\nax1.plot(x, y, 'C3', lw=3)\nax1.scatter(x, y, s=120)\nax1.set_title('Lines on top of dots')\n\nax2.plot(x, y, 'C3', lw=3)\nax2.scatter(x, y, s=120, zorder=2.5)  # move dots on top of line\nax2.set_title('Dots on top of lines')\n\nplt.tight_layout()\n\", \"x = np.linspace(0, 7.5, 100)\nplt.rcParamslines.linewidth = 5\nplt.figure()\nplt.plot(x, np.sin(x), label='zorder=2', zorder=2)  # bottom\nplt.plot(x, np.sin(x+0.5), label='zorder=3',  zorder=3)\nplt.axhline(0, label='zorder=2.5', color='lightgrey', zorder=2.5)\nplt.title('Custom order of elements')\nl = plt.legend(loc='upper right')\nl.set_zorder(2.5)  # legend between blue and orange line\nplt.show()\n",
    "id": 372
},
{
    "title": "Plot 2D data on 3D plot#",
    "text": "Demonstrates using ax.plot's zdir keyword to plot 2D data on\nselective axes of a 3D plot.\", 'Download Python source code: 2dcollections3d.py Download Jupyter notebook: 2dcollections3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Plot a sin curve using the x and y axes.\nx = np.linspace(0, 1, 100)\ny = np.sin(x * 2 * np.pi) / 2 + 0.5\nax.plot(x, y, zs=0, zdir='z', label='curve in (x, y)')\n\n# Plot scatterplot data (20 2D points per colour) on the x and z axes.\ncolors = ('r g b k')\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nx = np.random.sample(20 * len(colors))\ny = np.random.sample(20 * len(colors))\nc_list = []\nfor c in colors:\n    c_list.extend([c] * 20)\n# By using zdir='y', the y value of these points is fixed to the zs value 0\n# and the (x, y) points are plotted on the x and z axes.\nax.scatter(x, y, zs=0, zdir='y', c=c_list, label='points in (x, z)')\n\n# Make legend, set axes limits and labels\nax.legend()\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_zlim(0, 1)\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# Customize the view angle so it's easier to see that the scatter points lie\n# on the plane y=0\nax.view_init(elev=20., azim=-35, roll=0)\n\nplt.show()\n",
    "id": 374
},
{
    "title": "Demo of 3D bar charts#",
    "text": "A basic demo of how to plot 3D bars with and without shading. Download Python source code: 3d_bars.py Download Jupyter notebook: 3d_bars.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# set up the figure and axes\nfig = plt.figure(figsize=(8, 3))\nax1 = fig.add_subplot(121, projection='3d')\nax2 = fig.add_subplot(122, projection='3d')\n\n# fake data\n_x = np.arange(4)\n_y = np.arange(5)\n_xx, _yy = np.meshgrid(_x, _y)\nx, y = _xx.ravel(), _yy.ravel()\n\ntop = x + y\nbottom = np.zeros_like(top)\nwidth = depth = 1\n\nax1.bar3d(x, y, bottom, width, depth, top, shade=True)\nax1.set_title('Shaded')\n\nax2.bar3d(x, y, bottom, width, depth, top, shade=False)\nax2.set_title('Not Shaded')\n\nplt.show()\n",
    "id": 375
},
{
    "title": "Create 2D bar graphs in different planes#",
    "text": "Demonstrates making a 3D plot which has 2D bar graphs projected onto\nplanes y=0, y=1, etc. Download Python source code: bars3d.py Download Jupyter notebook: bars3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\ncolors = r g b y\nyticks = [3, 2, 1, 0]\nfor c, k in zip(colors, yticks):\n    # Generate the random data for the y=k 'layer'.\n    xs = np.arange(20)\n    ys = np.random.rand(20)\n\n    # You can provide either a single color or an array with the same length as\n    # xs and ys. To demonstrate this, we color the first bar of each set cyan.\n    cs = [c] * len(xs)\n    cs[0] = 'c'\n\n    # Plot the bar graph given by xs and ys on the plane y=k with 80% opacity.\n    ax.bar(xs, ys, zs=k, zdir='y', color=cs, alpha=0.8)\n\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# On the y-axis let's only label the discrete values that we have data for.\nax.set_yticks(yticks)\n\nplt.show()\n",
    "id": 376
},
{
    "title": "3D box surface plot#",
    "text": "Given data on a gridded volume X, Y, Z, this example plots the\ndata values on the volume surfaces. The strategy is to select the data from each surface and plot\ncontours separately using axes3d.Axes3D.contourf with appropriate\nparameters zdir and offset. Download Python source code: box3d.py Download Jupyter notebook: box3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Define dimensions\nNx, Ny, Nz = 100, 300, 500\nX, Y, Z = np.meshgrid(np.arange(Nx), np.arange(Ny), -np.arange(Nz))\n\n# Create fake data\ndata = (((X+100)**2 + (Y-20)**2 + 2*Z)/1000+1)\n\nkw = {\n    'vmin': data.min(),\n    'vmax': data.max(),\n    'levels': np.linspace(data.min(), data.max(), 10),\n}\n\n# Create a figure with 3D ax\nfig = plt.figure(figsize=(5, 4))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot contour surfaces\n_ = ax.contourf(\n    X[:, :, 0], Y[:, :, 0], data[:, :, 0],\n    zdir='z', offset=0, **kw\n)\n_ = ax.contourf(\n    X[0, :, :], data[0, :, :], Z[0, :, :],\n    zdir='y', offset=0, **kw\n)\nC = ax.contourf(\n    data[:, -1, :], Y[:, -1, :], Z[:, -1, :],\n    zdir='x', offset=X.max(), **kw\n)\n# --\n\n\n# Set limits of the plot from coord limits\nxmin, xmax = X.min(), X.max()\nymin, ymax = Y.min(), Y.max()\nzmin, zmax = Z.min(), Z.max()\nax.set(xlim=[xmin, xmax], ylim=[ymin, ymax], zlim=[zmin, zmax])\n\n# Plot edges\nedges_kw = dict(color='0.4', linewidth=1, zorder=1e3)\nax.plot([xmax, xmax], [ymin, ymax], 0, **edges_kw)\nax.plot([xmin, xmax], [ymin, ymin], 0, **edges_kw)\nax.plot([xmax, xmax], [ymin, ymin], [zmin, zmax], **edges_kw)\n\n# Set labels and zticks\nax.set(\n    xlabel='X [km]',\n    ylabel='Y [km]',\n    zlabel='Z [m]',\n    zticks=[0, -150, -300, -450],\n)\n\n# Set zoom and angle view\nax.view_init(40, -30, 0)\nax.set_box_aspect(None, zoom=0.9)\n\n# Colorbar\nfig.colorbar(C, ax=ax, fraction=0.02, pad=0.1, label='Name [units]')\n\n# Show Figure\nplt.show()\n",
    "id": 377
},
{
    "title": "Plot contour (level) curves in 3D#",
    "text": "This is like a contour plot in 2D except that the f(x, y)=c curve is\nplotted on the plane z=c. Download Python source code: contour3d.py Download Jupyter notebook: contour3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\nax.contour(X, Y, Z, cmap=cm.coolwarm)  # Plot contour curves\n\nplt.show()\n",
    "id": 378
},
{
    "title": "Plot contour (level) curves in 3D using the extend3d option#",
    "text": "This modification of the Plot contour (level) curves in 3D example uses extend3d=True to\nextend the curves vertically into 'ribbons'.\", 'Download Python source code: contour3d_2.py Download Jupyter notebook: contour3d_2.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contour(X, Y, Z, extend3d=True, cmap=cm.coolwarm)\n\nplt.show()\n",
    "id": 379
},
{
    "title": "Project contour profiles onto a graph#",
    "text": "Demonstrates displaying a 3D surface while also projecting contour 'profiles'\nonto the 'walls' of the graph.\nSee Project filled contour onto a graph for the filled version.\", 'Download Python source code: contour3d_3.py Download Jupyter notebook: contour3d_3.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph.\nax.contour(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contour(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()\n",
    "id": 380
},
{
    "title": "Filled contours#",
    "text": "Axes3D.contourf differs from Axes3D.contour in that it creates filled\ncontours, i.e. a discrete number of colours are used to shade the domain. This is like a Axes.contourf plot in 2D except that the shaded region\ncorresponding to the level c is graphed on the plane z=c. Download Python source code: contourf3d.py Download Jupyter notebook: contourf3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\nax.contourf(X, Y, Z, cmap=cm.coolwarm)\n\nplt.show()\n",
    "id": 381
},
{
    "title": "Project filled contour onto a graph#",
    "text": "Demonstrates displaying a 3D surface while also projecting filled contour\n'profiles' onto the 'walls' of the graph.\nSee Project contour profiles onto a graph for the unfilled version.\", 'Download Python source code: contourf3d_2.py Download Jupyter notebook: contourf3d_2.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nax = plt.figure().add_subplot(projection='3d')\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the 3D surface\nax.plot_surface(X, Y, Z, edgecolor='royalblue', lw=0.5, rstride=8, cstride=8,\n                alpha=0.3)\n\n# Plot projections of the contours for each dimension.  By choosing offsets\n# that match the appropriate axes limits, the projected contours will sit on\n# the 'walls' of the graph\nax.contourf(X, Y, Z, zdir='z', offset=-100, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='x', offset=-40, cmap='coolwarm')\nax.contourf(X, Y, Z, zdir='y', offset=40, cmap='coolwarm')\n\nax.set(xlim=(-40, 40), ylim=(-40, 40), zlim=(-100, 100),\n       xlabel='X', ylabel='Y', zlabel='Z')\n\nplt.show()\n",
    "id": 382
},
{
    "title": "Custom hillshading in a 3D surface plot#",
    "text": "Demonstrates using custom hillshading in a 3D surface plot. Download Python source code: custom_shaded_3d_surface.py Download Jupyter notebook: custom_shaded_3d_surface.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cbook, cm\nfrom matplotlib.colors import LightSource\n\n# Load and format data\ndem = cbook.get_sample_data(\\'jacksboro_fault_dem.npz\\')\nz = dem[\\'elevation\\\nnrows, ncols = z.shape\nx = np.linspace(dem[\\'xmin\\, dem[\\'xmax\\, ncols)\ny = np.linspace(dem[\\'ymin\\, dem[\\'ymax\\, nrows)\nx, y = np.meshgrid(x, y)\n\nregion = np.s_[5:50, 5:50]\nx, y, z = x[region], y[region], z[region]\n\n# Set up plot\nfig, ax = plt.subplots(subplot_kw=dict(projection=\\'3d\\'))\n\nls = LightSource(270, 45)\n# To use a custom hillshading mode, override the built-in shading and pass\n# in the rgb colors of the shaded surface calculated from \"shade\".\nrgb = ls.shade(z, cmap=cm.gist_earth, vert_exag=0.1, blend_mode=\\'soft\\')\nsurf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,\n                       linewidth=0, antialiased=False, shade=False)\n\nplt.show()\n",
    "id": 383
},
{
    "title": "3D errorbars#",
    "text": "An example of using errorbars with upper and lower limits in mplot3d. Download Python source code: errorbar3d.py Download Jupyter notebook: errorbar3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection=\\'3d\\')\n\n# setting up a parametric curve\nt = np.arange(0, 2*np.pi+.1, 0.01)\nx, y, z = np.sin(t), np.cos(3*t), np.sin(5*t)\n\nestep = 15\ni = np.arange(t.size)\nzuplims = (i % estep == 0) & (i // estep % 3 == 0)\nzlolims = (i % estep == 0) & (i // estep % 3 == 2)\n\nax.errorbar(x, y, z, 0.2, zuplims=zuplims, zlolims=zlolims, errorevery=estep)\n\nax.set_xlabel(\"X label\")\nax.set_ylabel(\"Y label\")\nax.set_zlabel(\"Z label\")\n\nplt.show()\n",
    "id": 384
},
{
    "title": "Create 3D histogram of 2D data#",
    "text": "Demo of a histogram for 2D data as a bar graph in 3D. Download Python source code: hist3d.py Download Jupyter notebook: hist3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection=\\'3d\\')\nx, y = np.random.rand(2, 100) * 4\nhist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]])\n\n# Construct arrays for the anchor positions of the 16 bars.\nxpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25, indexing=\"ij\")\nxpos = xpos.ravel()\nypos = ypos.ravel()\nzpos = 0\n\n# Construct arrays with the dimensions for the 16 bars.\ndx = dy = 0.5 * np.ones_like(zpos)\ndz = hist.ravel()\n\nax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort=\\'average\\')\n\nplt.show()\n",
    "id": 385
},
{
    "title": "Parametric curve#",
    "text": "This example demonstrates plotting a parametric curve in 3D. Download Python source code: lines3d.py Download Jupyter notebook: lines3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Prepare arrays x, y, z\ntheta = np.linspace(-4 * np.pi, 4 * np.pi, 100)\nz = np.linspace(-2, 2, 100)\nr = z**2 + 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\n\nax.plot(x, y, z, label='parametric curve')\nax.legend()\n\nplt.show()\n",
    "id": 386
},
{
    "title": "Lorenz attractor#",
    "text": "This is an example of plotting Edward Lorenz\\'s 1963 \"Deterministic Nonperiodic\nFlow\" in a 3-dimensional space using mplot3d. Note', \"Because this is a simple non-linear ODE, it would be more easily done using\nSciPy's ODE solver, but this approach depends only upon NumPy.\", 'Download Python source code: lorenz_attractor.py Download Jupyter notebook: lorenz_attractor.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef lorenz(xyz, *, s=10, r=28, b=2.667):\n    \"\"\"\n    Parameters\n    ----------\n    xyz : array-like, shape (3,)\n       Point of interest in three-dimensional space.\n    s, r, b : float\n       Parameters defining the Lorenz attractor.\n\n    Returns\n    -------\n    xyz_dot : array, shape (3,)\n       Values of the Lorenz attractor\\'s partial derivatives at *xyz*.\n    \"\"\"\n    x, y, z = xyz\n    x_dot = s*(y - x)\n    y_dot = r*x - y - x*z\n    z_dot = x*y - b*z\n    return np.array([x_dot, y_dot, z_dot])\n\n\ndt = 0.01\nnum_steps = 10000\n\nxyzs = np.empty((num_steps + 1, 3))  # Need one more for the initial values\nxyzs[0] = (0., 1., 1.05)  # Set initial values\n# Step through \"time\", calculating the partial derivatives at the current point\n# and using them to estimate the next point\nfor i in range(num_steps):\n    xyzs[i + 1] = xyzs[i] + lorenz(xyzs[i]) * dt\n\n# Plot\nax = plt.figure().add_subplot(projection=\\'3d\\')\n\nax.plot(*xyzs.T, lw=0.5)\nax.set_xlabel(\"X Axis\")\nax.set_ylabel(\"Y Axis\")\nax.set_zlabel(\"Z Axis\")\nax.set_title(\"Lorenz Attractor\")\n\nplt.show()\n",
    "id": 387
},
{
    "title": "2D and 3D axes in same figure#",
    "text": "This example shows a how to plot a 2D and a 3D plot on the same figure. Download Python source code: mixed_subplots.py Download Jupyter notebook: mixed_subplots.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef f(t):\n    return np.cos(2*np.pi*t) * np.exp(-t)\n\n\n# Set up a figure twice as tall as it is wide\nfig = plt.figure(figsize=plt.figaspect(2.))\nfig.suptitle('A tale of 2 subplots')\n\n# First subplot\nax = fig.add_subplot(2, 1, 1)\n\nt1 = np.arange(0.0, 5.0, 0.1)\nt2 = np.arange(0.0, 5.0, 0.02)\nt3 = np.arange(0.0, 2.0, 0.01)\n\nax.plot(t1, f(t1), 'bo',\n        t2, f(t2), 'k--', markerfacecolor='green')\nax.grid(True)\nax.set_ylabel('Damped oscillation')\n\n# Second subplot\nax = fig.add_subplot(2, 1, 2, projection='3d')\n\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1, 1)\n\nplt.show()\n",
    "id": 388
},
{
    "title": "Automatic text offsetting#",
    "text": "This example demonstrates mplot3d\\'s offset text display.\nAs one rotates the 3D figure, the offsets should remain oriented the\nsame way as the axis label, and should also be located \"away\"\nfrom the center of the plot. This demo triggers the display of the offset text for the x- and\ny-axis by adding 1e5 to X and Y. Anything less would not\nautomatically trigger it. Download Python source code: offset.py Download Jupyter notebook: offset.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection=\\'3d\\')\n\nX, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25]\nZ = np.sqrt(np.abs(np.cos(X) + np.cos(Y)))\n\nax.plot_surface(X + 1e5, Y + 1e5, Z, cmap=\\'autumn\\', cstride=2, rstride=2)\n\nax.set_xlabel(\"X label\")\nax.set_ylabel(\"Y label\")\nax.set_zlabel(\"Z label\")\nax.set_zlim(0, 2)\n\nplt.show()\n",
    "id": 389
},
{
    "title": "Draw flat objects in 3D plot#",
    "text": "Demonstrate using pathpatch_2d_to_3d to 'draw' shapes and text on a 3D plot.\", 'Download Python source code: pathpatch3d.py Download Jupyter notebook: pathpatch3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, PathPatch\nfrom matplotlib.text import TextPath\nfrom matplotlib.transforms import Affine2D\nimport mpl_toolkits.mplot3d.art3d as art3d\n\n\ndef text3d(ax, xyz, s, zdir=\"z\", size=None, angle=0, usetex=False, **kwargs):\n    \"\"\"\n    Plots the string *s* on the axes *ax*, with position *xyz*, size *size*,\n    and rotation angle *angle*. *zdir* gives the axis which is to be treated as\n    the third dimension. *usetex* is a boolean indicating whether the string\n    should be run through a LaTeX subprocess or not.  Any additional keyword\n    arguments are forwarded to `.transform_path`.\n\n    Note: zdir affects the interpretation of xyz.\n    \"\"\"\n    x, y, z = xyz\n    if zdir == \"y\":\n        xy1, z1 = (x, z), y\n    elif zdir == \"x\":\n        xy1, z1 = (y, z), x\n    else:\n        xy1, z1 = (x, y), z\n\n    text_path = TextPath((0, 0), s, size=size, usetex=usetex)\n    trans = Affine2D().rotate(angle).translate(xy1[0], xy1[1])\n\n    p1 = PathPatch(trans.transform_path(text_path), **kwargs)\n    ax.add_patch(p1)\n    art3d.pathpatch_2d_to_3d(p1, z=z1, zdir=zdir)\n\n\nfig = plt.figure()\nax = fig.add_subplot(projection=\\'3d\\')\n\n# Draw a circle on the x=0 \\'wall\\'\np = Circle((5, 5), 3)\nax.add_patch(p)\nart3d.pathpatch_2d_to_3d(p, z=0, zdir=\"x\")\n\n# Manually label the axes\ntext3d(ax, (4, -2, 0), \"X-axis\", zdir=\"z\", size=.5, usetex=False,\n       ec=\"none\", fc=\"k\")\ntext3d(ax, (12, 4, 0), \"Y-axis\", zdir=\"z\", size=.5, usetex=False,\n       angle=np.pi / 2, ec=\"none\", fc=\"k\")\ntext3d(ax, (12, 10, 4), \"Z-axis\", zdir=\"y\", size=.5, usetex=False,\n       angle=np.pi / 2, ec=\"none\", fc=\"k\")\n\n# Write a Latex formula on the z=0 \\'floor\\'\ntext3d(ax, (1, 5, 0),\n       r\"$\\\\displaystyle G_{\\\\mu\\\nu} + \\\\Lambda g_{\\\\mu\\\nu} = \"\n       r\"\\\\frac{8\\\\pi G}{c^4} T_{\\\\mu\\\nu}  $\",\n       zdir=\"z\", size=1, usetex=True,\n       ec=\"none\", fc=\"k\")\n\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\n\nplt.show()\n",
    "id": 390
},
{
    "title": "Generate polygons to fill under 3D line graph#",
    "text": "Demonstrate how to create polygons which fill the space under a line\ngraph. In this example polygons are semi-transparent, creating a sort\nof 'jagged stained glass' effect.\", 'Download Python source code: polys3d.py Download Jupyter notebook: polys3d.ipynb ",
    "code": "import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.collections import PolyCollection\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef polygon_under_graph(x, y):\n    \"\"\"\n    Construct the vertex list which defines the polygon filling the space under\n    the (x, y) line graph. This assumes x is in ascending order.\n    \"\"\"\n    return [(x[0], 0.), *zip(x, y), (x[-1], 0.)]\n\n\nax = plt.figure().add_subplot(projection=\\'3d\\')\n\nx = np.linspace(0., 10., 31)\nlambdas = range(1, 9)\n\n# verts[i] is a list of (x, y) pairs defining polygon i.\ngamma = np.vectorize(math.gamma)\nverts = [polygon_under_graph(x, l**x * np.exp(-l) / gamma(x + 1))\n         for l in lambdas]\nfacecolors = plt.colormaps[\\'viridis_r\\(np.linspace(0, 1, len(verts)))\n\npoly = PolyCollection(verts, facecolors=facecolors, alpha=.7)\nax.add_collection3d(poly, zs=lambdas, zdir=\\'y\\')\n\nax.set(xlim=(0, 10), ylim=(1, 9), zlim=(0, 0.35),\n       xlabel=\\'x\\', ylabel=r\\'$\\\\lambda$\\', zlabel=\\'probability\\')\n\nplt.show()\n",
    "id": 391
},
{
    "title": "3D plot projection types#",
    "text": "Demonstrates the different camera projections for 3D plots, and the effects of\nchanging the focal length for a perspective projection. Note that Matplotlib\ncorrects for the 'zoom' effect of changing the focal length.\", 'The default focal length of 1 corresponds to a Field of View (FOV) of 90 deg.\nAn increased focal length between 1 and infinity \"flattens\" the image, while a\ndecreased focal length between 1 and 0 exaggerates the perspective and gives\nthe image more apparent depth. In the limiting case, a focal length of\ninfinity corresponds to an orthographic projection after correction of the\nzoom effect. You can calculate focal length from a FOV via the equation: Or vice versa: Download Python source code: projections.py Download Jupyter notebook: projections.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, axs = plt.subplots(1, 3, subplot_kw={\\'projection\\': \\'3d\\'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot the data\nfor ax in axs:\n    ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the orthographic projection.\naxs[0].set_proj_type(\\'ortho\\')  # FOV = 0 deg\naxs[0].set_title(\"\\'ortho\\'\\\nfocal_length = \u221e\", fontsize=10)\n\n# Set the perspective projections\naxs[1].set_proj_type(\\'persp\\')  # FOV = 90 deg\naxs[1].set_title(\"\\'persp\\'\\\nfocal_length = 1 (default)\", fontsize=10)\n\naxs[2].set_proj_type(\\'persp\\', focal_length=0.2)  # FOV = 157.4 deg\naxs[2].set_title(\"\\'persp\\'\\\nfocal_length = 0.2\", fontsize=10)\n\nplt.show()\n",
    "id": 392
},
{
    "title": "3D quiver plot#",
    "text": "Demonstrates plotting directional arrows at points on a 3D meshgrid. Download Python source code: quiver3d.py Download Jupyter notebook: quiver3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make the grid\nx, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.2),\n                      np.arange(-0.8, 1, 0.8))\n\n# Make the direction data for the arrows\nu = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)\nv = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)\nw = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) *\n     np.sin(np.pi * z))\n\nax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)\n\nplt.show()\n",
    "id": 393
},
{
    "title": "Rotating a 3D plot#",
    "text": "A very simple animation of a rotating 3D plot about all three axes. See Animate a 3D wireframe plot for another example of animating a 3D plot. (This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run) Download Python source code: rotate_axes3d_sgskip.py Download Jupyter notebook: rotate_axes3d_sgskip.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some example data and plot a basic wireframe.\nX, Y, Z = axes3d.get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n# Set the axis labels\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\n\n# Rotate the axes and update\nfor angle in range(0, 360*4 + 1):\n    # Normalize the angle to the range [-180, 180] for display\n    angle_norm = (angle + 180) % 360 - 180\n\n    # Cycle through a full rotation of elevation, then azimuth, roll, and all\n    elev = azim = roll = 0\n    if angle <= 360:\n        elev = angle_norm\n    elif angle <= 360*2:\n        azim = angle_norm\n    elif angle <= 360*3:\n        roll = angle_norm\n    else:\n        elev = azim = roll = angle_norm\n\n    # Update the axis view and title\n    ax.view_init(elev, azim, roll)\n    plt.title('Elevation: %d\u00b0, Azimuth: %d\u00b0, Roll: %d\u00b0' % (elev, azim, roll))\n\n    plt.draw()\n    plt.pause(.001)\n",
    "id": 394
},
{
    "title": "3D scatterplot#",
    "text": "Demonstration of a basic scatterplot in 3D. Download Python source code: scatter3d.py Download Jupyter notebook: scatter3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\ndef randrange(n, vmin, vmax):\n    \"\"\"\n    Helper function to make an array of random numbers having shape (n, )\n    with each number distributed Uniform(vmin, vmax).\n    \"\"\"\n    return (vmax - vmin)*np.random.rand(n) + vmin\n\nfig = plt.figure()\nax = fig.add_subplot(projection=\\'3d\\')\n\nn = 100\n\n# For each set of style and range settings, plot n random points in the box\n# defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh].\nfor m, zlow, zhigh in [(\\'o\\', -50, -25), (\\'^\\', -30, -5)]:\n    xs = randrange(n, 23, 32)\n    ys = randrange(n, 0, 100)\n    zs = randrange(n, zlow, zhigh)\n    ax.scatter(xs, ys, zs, marker=m)\n\nax.set_xlabel(\\'X Label\\')\nax.set_ylabel(\\'Y Label\\')\nax.set_zlabel(\\'Z Label\\')\n\nplt.show()\n",
    "id": 395
},
{
    "title": "3D stem#",
    "text": "Demonstration of a stem plot in 3D, which plots vertical lines from a baseline\nto the z-coordinate and places a marker at the tip. The position of the baseline can be adapted using bottom. The parameters\nlinefmt, markerfmt, and basefmt control basic format properties of the\nplot. However, in contrast to plot not all properties are\nconfigurable via keyword arguments. For more advanced control adapt the line\nobjects returned by stem. The orientation of the stems and baseline can be changed using orientation.\nThis determines in which direction the stems are projected from the head\npoints, towards the bottom baseline.', \"For examples, by setting orientation='x', the stems are projected along\nthe x-direction, and the baseline is in the yz-plane.\", 'Total running time of the script: (0 minutes 1.176 seconds) Download Python source code: stem3d_demo.py Download Jupyter notebook: stem3d_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ntheta = np.linspace(0, 2*np.pi)\nx = np.cos(theta - np.pi/2)\ny = np.sin(theta - np.pi/2)\nz = theta\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nax.stem(x, y, z)\n\nplt.show()\n\", \"fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(\n    x, y, z, linefmt='grey', markerfmt='D', bottom=np.pi)\nmarkerline.set_markerfacecolor('none')\n\nplt.show()\n\", \"fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nmarkerline, stemlines, baseline = ax.stem(x, y, z, bottom=-1, orientation='x')\nax.set(xlabel='x', ylabel='y', zlabel='z')\n\nplt.show()\n",
    "id": 396
},
{
    "title": "3D plots as subplots#",
    "text": "Demonstrate including 3D plots as subplots. Download Python source code: subplot3d.py Download Jupyter notebook: subplot3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d.axes3d import get_test_data\n\n# set up a figure twice as wide as it is tall\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# =============\n# First subplot\n# =============\n# set up the axes for the first plot\nax = fig.add_subplot(1, 2, 1, projection='3d')\n\n# plot a 3D surface like in the example mplot3d/surface3d_demo\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\nsurf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\nax.set_zlim(-1.01, 1.01)\nfig.colorbar(surf, shrink=0.5, aspect=10)\n\n# ==============\n# Second subplot\n# ==============\n# set up the axes for the second plot\nax = fig.add_subplot(1, 2, 2, projection='3d')\n\n# plot a 3D wireframe like in the example mplot3d/wire3d_demo\nX, Y, Z = get_test_data(0.05)\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()\n",
    "id": 397
},
{
    "title": "3D surface (colormap)#",
    "text": "Demonstrates plotting a 3D surface colored with the coolwarm colormap.\nThe surface is made opaque by using antialiased=False. Also demonstrates using the LinearLocator and custom formatting for the\nz axis tick labels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_major_locator matplotlib.ticker.LinearLocator matplotlib.ticker.StrMethodFormatter Download Python source code: surface3d.py Download Jupyter notebook: surface3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import cm\nfrom matplotlib.ticker import LinearLocator\n\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nY = np.arange(-5, 5, 0.25)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Plot the surface.\nsurf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\n\n# Customize the z axis.\nax.set_zlim(-1.01, 1.01)\nax.zaxis.set_major_locator(LinearLocator(10))\n# A StrMethodFormatter is used automatically\nax.zaxis.set_major_formatter(\\'{x:.02f}\\')\n\n# Add a color bar which maps values to colors.\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nplt.show()\n",
    "id": 398
},
{
    "title": "3D surface (solid color)#",
    "text": "Demonstrates a very basic plot of a 3D surface using a solid color. Download Python source code: surface3d_2.py Download Jupyter notebook: surface3d_2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make data\nu = np.linspace(0, 2 * np.pi, 100)\nv = np.linspace(0, np.pi, 100)\nx = 10 * np.outer(np.cos(u), np.sin(v))\ny = 10 * np.outer(np.sin(u), np.sin(v))\nz = 10 * np.outer(np.ones(np.size(u)), np.cos(v))\n\n# Plot the surface\nax.plot_surface(x, y, z)\n\n# Set an equal aspect ratio\nax.set_aspect('equal')\n\nplt.show()\n",
    "id": 399
},
{
    "title": "3D surface (checkerboard)#",
    "text": "Demonstrates plotting a 3D surface colored in a checkerboard pattern. Download Python source code: surface3d_3.py Download Jupyter notebook: surface3d_3.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import LinearLocator\n\nax = plt.figure().add_subplot(projection='3d')\n\n# Make data.\nX = np.arange(-5, 5, 0.25)\nxlen = len(X)\nY = np.arange(-5, 5, 0.25)\nylen = len(Y)\nX, Y = np.meshgrid(X, Y)\nR = np.sqrt(X**2 + Y**2)\nZ = np.sin(R)\n\n# Create an empty array of strings with the same shape as the meshgrid, and\n# populate it with two colors in a checkerboard pattern.\ncolortuple = ('y b')\ncolors = np.empty(X.shape, dtype=str)\nfor y in range(ylen):\n    for x in range(xlen):\n        colors[y, x] = colortuple[(x + y) % len(colortuple)]\n\n# Plot the surface with face colors taken from the array we made.\nsurf = ax.plot_surface(X, Y, Z, facecolors=colors, linewidth=0)\n\n# Customize the z axis.\nax.set_zlim(-1, 1)\nax.zaxis.set_major_locator(LinearLocator(6))\n\nplt.show()\n",
    "id": 400
},
{
    "title": "3D surface with polar coordinates#",
    "text": "Demonstrates plotting a surface defined in polar coordinates.\nUses the reversed version of the YlGnBu colormap.\nAlso demonstrates writing axis labels with latex math mode. Example contributed by Armin Moser. Download Python source code: surface3d_radial.py Download Jupyter notebook: surface3d_radial.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Create the mesh in polar coordinates and compute corresponding Z.\nr = np.linspace(0, 1.25, 50)\np = np.linspace(0, 2*np.pi, 50)\nR, P = np.meshgrid(r, p)\nZ = ((R**2 - 1)**2)\n\n# Express the mesh in the cartesian system.\nX, Y = R*np.cos(P), R*np.sin(P)\n\n# Plot the surface.\nax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r)\n\n# Tweak the limits and add latex math labels.\nax.set_zlim(0, 1)\nax.set_xlabel(r'$\\\\phi_\\\\mathrm{real}$')\nax.set_ylabel(r'$\\\\phi_\\\\mathrm{im}$')\nax.set_zlabel(r'$V(\\\\phi)$')\n\nplt.show()\n",
    "id": 401
},
{
    "title": "Text annotations in 3D#",
    "text": "Demonstrates the placement of text annotations on a 3D plot. Functionality shown:', \"Using the text function with three types of zdir values: None,\nan axis name (ex. 'x'), or a direction tuple (ex. (1, 1, 0)).\", 'Using the text function with the color keyword. Using the text2D function to place text on a fixed position on the ax\nobject. Download Python source code: text3d.py Download Jupyter notebook: text3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nax = plt.figure().add_subplot(projection=\\'3d\\')\n\n# Demo 1: zdir\nzdirs = (None, \\'x\\', \\'y\\', \\'z\\', (1, 1, 0), (1, 1, 1))\nxs = (1, 4, 4, 9, 4, 1)\nys = (2, 5, 8, 10, 1, 2)\nzs = (10, 3, 8, 9, 1, 8)\n\nfor zdir, x, y, z in zip(zdirs, xs, ys, zs):\n    label = \\'(%d, %d, %d), dir=%s\\' % (x, y, z, zdir)\n    ax.text(x, y, z, label, zdir)\n\n# Demo 2: color\nax.text(9, 0, 0, \"red\", color=\\'red\\')\n\n# Demo 3: text2D\n# Placement 0, 0 would be the bottom left, 1, 1 would be the top right.\nax.text2D(0.05, 0.95, \"2D Text\", transform=ax.transAxes)\n\n# Tweaking display region and labels\nax.set_xlim(0, 10)\nax.set_ylim(0, 10)\nax.set_zlim(0, 10)\nax.set_xlabel(\\'X axis\\')\nax.set_ylabel(\\'Y axis\\')\nax.set_zlabel(\\'Z axis\\')\n\nplt.show()\n",
    "id": 402
},
{
    "title": "Triangular 3D contour plot#",
    "text": "Contour plots of unstructured triangular grids. The data used is the same as in the second plot of More triangular 3D surfaces.\nTriangular 3D filled contour plot shows the filled version of this example. Download Python source code: tricontour3d.py Download Jupyter notebook: tricontour3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontour(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n",
    "id": 403
},
{
    "title": "Triangular 3D filled contour plot#",
    "text": "Filled contour plots of unstructured triangular grids. The data used is the same as in the second plot of More triangular 3D surfaces.\nTriangular 3D contour plot shows the unfilled version of this example. Download Python source code: tricontourf3d.py Download Jupyter notebook: tricontourf3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as tri\n\n# First create the x, y, z coordinates of the points.\nn_angles = 48\nn_radii = 8\nmin_radius = 0.25\n\n# Create the mesh in polar coordinates and compute x, y, z.\nradii = np.linspace(min_radius, 0.95, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create a custom triangulation.\ntriang = tri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\ntriang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),\n                         y[triang.triangles].mean(axis=1))\n                < min_radius)\n\nax = plt.figure().add_subplot(projection='3d')\nax.tricontourf(triang, z, cmap=plt.cm.CMRmap)\n\n# Customize the view angle so it's easier to understand the plot.\nax.view_init(elev=45.)\n\nplt.show()\n",
    "id": 404
},
{
    "title": "Triangular 3D surfaces#",
    "text": "Plot a 3D surface with a triangular mesh. Download Python source code: trisurf3d.py Download Jupyter notebook: trisurf3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nn_radii = 8\nn_angles = 36\n\n# Make radii and angles spaces (radius r=0 omitted to eliminate duplication).\nradii = np.linspace(0.125, 1.0, n_radii)\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)[..., np.newaxis]\n\n# Convert polar (radii, angles) coords to cartesian (x, y) coords.\n# (0, 0) is manually added at this stage,  so there will be no duplicate\n# points in the (x, y) plane.\nx = np.append(0, (radii*np.cos(angles)).flatten())\ny = np.append(0, (radii*np.sin(angles)).flatten())\n\n# Compute z to make the pringle surface.\nz = np.sin(-x*y)\n\nax = plt.figure().add_subplot(projection='3d')\n\nax.plot_trisurf(x, y, z, linewidth=0.2, antialiased=True)\n\nplt.show()\n",
    "id": 405
},
{
    "title": "More triangular 3D surfaces#",
    "text": "Two additional examples of plotting surfaces with triangular mesh.', \"The first demonstrates use of plot_trisurf's triangles argument, and the\nsecond sets a Triangulation object's mask and passes the object directly\nto plot_trisurf.\", 'Download Python source code: trisurf3d_2.py Download Jupyter notebook: trisurf3d_2.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.tri as mtri\n\nfig = plt.figure(figsize=plt.figaspect(0.5))\n\n# ==========\n# First plot\n# ==========\n\n# Make a mesh in the space of parameterisation variables u and v\nu = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)\nv = np.linspace(-0.5, 0.5, endpoint=True, num=10)\nu, v = np.meshgrid(u, v)\nu, v = u.flatten(), v.flatten()\n\n# This is the Mobius mapping, taking a u, v pair and returning an x, y, z\n# triple\nx = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)\ny = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)\nz = 0.5 * v * np.sin(u / 2.0)\n\n# Triangulate parameter space to determine the triangles\ntri = mtri.Triangulation(u, v)\n\n# Plot the surface.  The triangles in parameter space determine which x, y, z\n# points are connected by an edge.\nax = fig.add_subplot(1, 2, 1, projection='3d')\nax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=plt.cm.Spectral)\nax.set_zlim(-1, 1)\n\n\n# ===========\n# Second plot\n# ===========\n\n# Make parameter spaces radii and angles.\nn_angles = 36\nn_radii = 8\nmin_radius = 0.25\nradii = np.linspace(min_radius, 0.95, n_radii)\n\nangles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)\nangles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)\nangles[:, 1::2] += np.pi/n_angles\n\n# Map radius, angle pairs to x, y, z points.\nx = (radii*np.cos(angles)).flatten()\ny = (radii*np.sin(angles)).flatten()\nz = (np.cos(radii)*np.cos(3*angles)).flatten()\n\n# Create the Triangulation; no triangles so Delaunay triangulation created.\ntriang = mtri.Triangulation(x, y)\n\n# Mask off unwanted triangles.\nxmid = x[triang.triangles].mean(axis=1)\nymid = y[triang.triangles].mean(axis=1)\nmask = xmid**2 + ymid**2 < min_radius**2\ntriang.set_mask(mask)\n\n# Plot the surface.\nax = fig.add_subplot(1, 2, 2, projection='3d')\nax.plot_trisurf(triang, z, cmap=plt.cm.CMRmap)\n\n\nplt.show()\n",
    "id": 406
},
{
    "title": "Primary 3D view planes#",
    "text": "This example generates an \"unfolded\" 3D plot that shows each of the primary 3D\nview planes. The elevation, azimuth, and roll angles required for each view are\nlabeled. You could print out this image and fold it into a box where each plane\nforms a side of the box. Download Python source code: view_planes_3d.py Download Jupyter notebook: view_planes_3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef annotate_axes(ax, text, fontsize=18):\n    ax.text(x=0.5, y=0.5, z=0.5, s=text,\n            va=\"center\", ha=\"center\", fontsize=fontsize, color=\"black\")\n\n# (plane, (elev, azim, roll))\nviews = [(\\'XY\\',   (90, -90, 0)),\n         (\\'XZ\\',    (0, -90, 0)),\n         (\\'YZ\\',    (0,   0, 0)),\n         (\\'-XY\\', (-90,  90, 0)),\n         (\\'-XZ\\',   (0,  90, 0)),\n         (\\'-YZ\\',   (0, 180, 0))]\n\nlayout = [[\\'XY\\',  \\'.\\',   \\'L\\',   \\'.\\,\n          [\\'XZ\\', \\'YZ\\', \\'-XZ\\', \\'-YZ\\,\n          [\\'.\\',   \\'.\\', \\'-XY\\',   \\'.\\]\nfig, axd = plt.subplot_mosaic(layout, subplot_kw={\\'projection\\': \\'3d\\'},\n                              figsize=(12, 8.5))\nfor plane, angles in views:\n    axd[plane].set_xlabel(\\'x\\')\n    axd[plane].set_ylabel(\\'y\\')\n    axd[plane].set_zlabel(\\'z\\')\n    axd[plane].set_proj_type(\\'ortho\\')\n    axd[plane].view_init(elev=angles[0], azim=angles[1], roll=angles[2])\n    axd[plane].set_box_aspect(None, zoom=1.25)\n\n    label = f\\'{plane}\\\n{angles}\\'\n    annotate_axes(axd[plane], label, fontsize=14)\n\nfor plane in (\\'XY\\', \\'-XY\\'):\n    axd[plane].set_zticklabels([])\n    axd[plane].set_zlabel(\\'\\')\nfor plane in (\\'XZ\\', \\'-XZ\\'):\n    axd[plane].set_yticklabels([])\n    axd[plane].set_ylabel(\\'\\')\nfor plane in (\\'YZ\\', \\'-YZ\\'):\n    axd[plane].set_xticklabels([])\n    axd[plane].set_xlabel(\\'\\')\n\nlabel = \\'mplot3d primary view planes\\\n\\' + \\'ax.view_init(elev, azim, roll)\\'\nannotate_axes(axd[\\'L\\, label, fontsize=18)\naxd[\\'L\\.set_axis_off()\n\nplt.show()\n",
    "id": 407
},
{
    "title": "3D voxel / volumetric plot#",
    "text": "Demonstrates plotting 3D volumetric objects with Axes3D.voxels. Download Python source code: voxels.py Download Jupyter notebook: voxels.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# prepare some coordinates\nx, y, z = np.indices((8, 8, 8))\n\n# draw cuboids in the top left and bottom right corners, and a link between\n# them\ncube1 = (x < 3) & (y < 3) & (z < 3)\ncube2 = (x >= 5) & (y >= 5) & (z >= 5)\nlink = abs(x - y) + abs(y - z) + abs(z - x) <= 2\n\n# combine the objects into a single boolean array\nvoxelarray = cube1 | cube2 | link\n\n# set the colors of each object\ncolors = np.empty(voxelarray.shape, dtype=object)\ncolors[link] = 'red'\ncolors[cube1] = 'blue'\ncolors[cube2] = 'green'\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(voxelarray, facecolors=colors, edgecolor='k')\n\nplt.show()\n",
    "id": 408
},
{
    "title": "3D voxel plot of the NumPy logo#",
    "text": "Demonstrates using Axes3D.voxels with uneven coordinates. Download Python source code: voxels_numpy_logo.py Download Jupyter notebook: voxels_numpy_logo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef explode(data):\n    size = np.array(data.shape)*2\n    data_e = np.zeros(size - 1, dtype=data.dtype)\n    data_e[::2, ::2, ::2] = data\n    return data_e\n\n# build up the numpy logo\nn_voxels = np.zeros((4, 3, 4), dtype=bool)\nn_voxels[0, 0, :] = True\nn_voxels[-1, 0, :] = True\nn_voxels[1, 0, 2] = True\nn_voxels[2, 0, 1] = True\nfacecolors = np.where(n_voxels, '#FFD65DC0 #7A88CCC0')\nedgecolors = np.where(n_voxels, '#BFAB6E #7D84A6')\nfilled = np.ones(n_voxels.shape)\n\n# upscale the above voxel image, leaving gaps\nfilled_2 = explode(filled)\nfcolors_2 = explode(facecolors)\necolors_2 = explode(edgecolors)\n\n# Shrink the gaps\nx, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2\nx[0::2, :, :] += 0.05\ny[:, 0::2, :] += 0.05\nz[:, :, 0::2] += 0.05\nx[1::2, :, :] += 0.95\ny[:, 1::2, :] += 0.95\nz[:, :, 1::2] += 0.95\n\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2)\nax.set_aspect('equal')\n\nplt.show()\n",
    "id": 409
},
{
    "title": "3D voxel / volumetric plot with RGB colors#",
    "text": "Demonstrates using Axes3D.voxels to visualize parts of a color space. Total running time of the script: (0 minutes 1.252 seconds) Download Python source code: voxels_rgb.py Download Jupyter notebook: voxels_rgb.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef midpoints(x):\n    sl = ()\n    for _ in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, g, b = np.indices((17, 17, 17)) / 16.0\nrc = midpoints(r)\ngc = midpoints(g)\nbc = midpoints(b)\n\n# define a sphere about [0.5, 0.5, 0.5]\nsphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2\n\n# combine the color components\ncolors = np.zeros(sphere.shape + (3,))\ncolors[..., 0] = rc\ncolors[..., 1] = gc\ncolors[..., 2] = bc\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(r, g, b, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\nax.set(xlabel='r', ylabel='g', zlabel='b')\nax.set_aspect('equal')\n\nplt.show()\n",
    "id": 410
},
{
    "title": "3D voxel / volumetric plot with cylindrical coordinates#",
    "text": "Demonstrates using the x, y, z parameters of Axes3D.voxels. Download Python source code: voxels_torus.py Download Jupyter notebook: voxels_torus.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.colors\n\n\ndef midpoints(x):\n    sl = ()\n    for i in range(x.ndim):\n        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0\n        sl += np.index_exp[:]\n    return x\n\n# prepare some coordinates, and attach rgb values to each\nr, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j]\nx = r*np.cos(theta)\ny = r*np.sin(theta)\n\nrc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z)\n\n# define a wobbly torus about [0.7, *, 0]\nsphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 < 0.2**2\n\n# combine the color components\nhsv = np.zeros(sphere.shape + (3,))\nhsv[..., 0] = thetac / (np.pi*2)\nhsv[..., 1] = rc\nhsv[..., 2] = zc + 0.5\ncolors = matplotlib.colors.hsv_to_rgb(hsv)\n\n# and plot everything\nax = plt.figure().add_subplot(projection='3d')\nax.voxels(x, y, z, sphere,\n          facecolors=colors,\n          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter\n          linewidth=0.5)\n\nplt.show()\n",
    "id": 411
},
{
    "title": "3D wireframe plot#",
    "text": "A very basic demonstration of a wireframe plot. Download Python source code: wire3d.py Download Jupyter notebook: wire3d.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Grab some test data.\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot a basic wireframe.\nax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\nplt.show()\n",
    "id": 412
},
{
    "title": "Animate a 3D wireframe plot#",
    "text": "A very simple \"animation\" of a 3D plot. See also Rotating a 3D plot. (This example is skipped when building the documentation gallery because it\nintentionally takes a long time to run.) Download Python source code: wire3d_animation_sgskip.py Download Jupyter notebook: wire3d_animation_sgskip.ipynb ",
    "code": "import time\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Make the X, Y meshgrid.\nxs = np.linspace(-1, 1, 50)\nys = np.linspace(-1, 1, 50)\nX, Y = np.meshgrid(xs, ys)\n\n# Set the z axis limits, so they aren't recalculated each frame.\nax.set_zlim(-1, 1)\n\n# Begin plotting.\nwframe = None\ntstart = time.time()\nfor phi in np.linspace(0, 180. / np.pi, 100):\n    # If a line collection is already remove it before drawing.\n    if wframe:\n        wframe.remove()\n    # Generate data.\n    Z = np.cos(2 * np.pi * X + phi) * (1 - np.hypot(X, Y))\n    # Plot the new wireframe and pause briefly before continuing.\n    wframe = ax.plot_wireframe(X, Y, Z, rstride=2, cstride=2)\n    plt.pause(.001)\n\nprint('Average FPS: %f' % (100 / (time.time() - tstart)))\n",
    "id": 413
},
{
    "title": "3D wireframe plots in one direction#",
    "text": "Demonstrates that setting rstride or cstride to 0 causes wires to not be\ngenerated in the corresponding direction. Total running time of the script: (0 minutes 1.274 seconds) Download Python source code: wire3d_zero_stride.py Download Jupyter notebook: wire3d_zero_stride.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig, (ax1, ax2) = plt.subplots(\n    2, 1, figsize=(8, 12), subplot_kw={\\'projection\\': \\'3d\\'})\n\n# Get the test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Give the first plot only wireframes of the type y = c\nax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0)\nax1.set_title(\"Column (x) stride set to 0\")\n\n# Give the second plot only wireframes of the type x = c\nax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10)\nax2.set_title(\"Row (y) stride set to 0\")\n\nplt.tight_layout()\nplt.show()\n",
    "id": 414
},
{
    "title": "Asinh Demo#",
    "text": "Illustration of the asinh axis scaling,\nwhich uses the transformation For coordinate values close to zero (i.e. much smaller than\nthe \"linear width\" \\\\(a_0\\\\)), this leaves values essentially unchanged: but for larger values (i.e. \\\\(|a| \\\\gg a_0\\\\), this is asymptotically As with the symlog scaling,\nthis allows one to plot quantities\nthat cover a very wide dynamic range that includes both positive\nand negative values. However, symlog involves a transformation\nthat has discontinuities in its gradient because it is built\nfrom separate linear and logarithmic transformations.\nThe asinh scaling uses a transformation that is smooth\nfor all (finite) values, which is both mathematically cleaner\nand reduces visual artifacts associated with an abrupt\ntransition between linear and logarithmic regions of the plot. Note scale.AsinhScale is experimental, and the API may change. See AsinhScale, SymmetricalLogScale. Compare \"symlog\" and \"asinh\" behaviour on sample y=x graph,\nwhere there is a discontinuous gradient in \"symlog\" near y=2: Compare \"asinh\" graphs with different scale parameter \"linear_width\": Compare \"symlog\" and \"asinh\" scalings\non 2D Cauchy-distributed random numbers,\nwhere one may be able to see more subtle artifacts near y=2\ndue to the gradient-discontinuity in \"symlog\": References matplotlib.scale.AsinhScale matplotlib.ticker.AsinhLocator matplotlib.scale.SymmetricalLogScale Total running time of the script: (0 minutes 1.808 seconds) Download Python source code: asinh_demo.py Download Jupyter notebook: asinh_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Prepare sample values for variations on y=x graph:\nx = np.linspace(-3, 6, 500)\n', \"fig1 = plt.figure()\nax0, ax1 = fig1.subplots(1, 2, sharex=True)\n\nax0.plot(x, x)\nax0.set_yscale('symlog')\nax0.grid()\nax0.set_title('symlog')\n\nax1.plot(x, x)\nax1.set_yscale('asinh')\nax1.grid()\nax1.set_title('asinh')\n\", \"fig2 = plt.figure(layout='constrained')\naxs = fig2.subplots(1, 3, sharex=True)\nfor ax, (a0, base) in zip(axs, ((0.2, 2), (1.0, 0), (5.0, 10))):\n    ax.set_title(f'linear_width={a0:.3g}')\n    ax.plot(x, x, label='y=x')\n    ax.plot(x, 10*x, label='y=10x')\n    ax.plot(x, 100*x, label='y=100x')\n    ax.set_yscale('asinh', linear_width=a0, base=base)\n    ax.grid()\n    ax.legend(loc='best', fontsize='small')\n\", \"fig3 = plt.figure()\nax = fig3.subplots(1, 1)\nr = 3 * np.tan(np.random.uniform(-np.pi / 2.02, np.pi / 2.02,\n                                 size=(5000,)))\nth = np.random.uniform(0, 2*np.pi, size=r.shape)\n\nax.scatter(r * np.cos(th), r * np.sin(th), s=4, alpha=0.5)\nax.set_xscale('asinh')\nax.set_yscale('symlog')\nax.set_xlabel('asinh')\nax.set_ylabel('symlog')\nax.set_title('2D Cauchy random deviates')\nax.set_xlim(-50, 50)\nax.set_ylim(-50, 50)\nax.grid()\n\nplt.show()\n",
    "id": 416
},
{
    "title": "Loglog Aspect#",
    "text": "Download Python source code: aspect_loglog.py Download Jupyter notebook: aspect_loglog.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nax1.set_xscale(\"log\")\nax1.set_yscale(\"log\")\nax1.set_xlim(1e1, 1e3)\nax1.set_ylim(1e2, 1e3)\nax1.set_aspect(1)\nax1.set_title(\"adjustable = box\")\n\nax2.set_xscale(\"log\")\nax2.set_yscale(\"log\")\nax2.set_adjustable(\"datalim\")\nax2.plot([1, 3, 10], [1, 9, 100], \"o-\")\nax2.set_xlim(1e-1, 1e2)\nax2.set_ylim(1e-1, 1e3)\nax2.set_aspect(1)\nax2.set_title(\"adjustable = datalim\")\n\nplt.show()\n",
    "id": 417
},
{
    "title": "Custom scale#",
    "text": "Create a custom scale, by implementing the scaling use for latitude data in a\nMercator Projection.', \"Unless you are making special use of the Transform class, you probably\ndon't need to use this verbose method, and instead can use FuncScale\nand the 'function' option of set_xscale and set_yscale.\nSee the last example in Scales.\", 'Download Python source code: custom_scale.py Download Jupyter notebook: custom_scale.ipynb ",
    "code": "import numpy as np\nfrom numpy import ma\n\nfrom matplotlib import scale as mscale\nfrom matplotlib import transforms as mtransforms\nfrom matplotlib.ticker import FixedLocator, FuncFormatter\n\n\nclass MercatorLatitudeScale(mscale.ScaleBase):\n    \"\"\"\n    Scales data in range -pi/2 to pi/2 (-90 to 90 degrees) using\n    the system used to scale latitudes in a Mercator__ projection.\n\n    The scale function:\n      ln(tan(y) + sec(y))\n\n    The inverse scale function:\n      atan(sinh(y))\n\n    Since the Mercator scale tends to infinity at +/- 90 degrees,\n    there is user-defined threshold, above and below which nothing\n    will be plotted.  This defaults to +/- 85 degrees.\n\n    __ https://en.wikipedia.org/wiki/Mercator_projection\n    \"\"\"\n\n    # The scale class must have a member ``name`` that defines the string used\n    # to select the scale.  For example, ``ax.set_yscale(\"mercator\")`` would be\n    # used to select this scale.\n    name = \\'mercator\\'\n\n    def __init__(self, axis, *, thresh=np.deg2rad(85), **kwargs):\n        \"\"\"\n        Any keyword arguments passed to ``set_xscale`` and ``set_yscale`` will\n        be passed along to the scale\\'s constructor.\n\n        thresh: The degree above which to crop the data.\n        \"\"\"\n        super().__init__(axis)\n        if thresh >= np.pi / 2:\n            raise ValueError(\"thresh must be less than pi/2\")\n        self.thresh = thresh\n\n    def get_transform(self):\n        \"\"\"\n        Override this method to return a new instance that does the\n        actual transformation of the data.\n\n        The MercatorLatitudeTransform class is defined below as a\n        nested class of this one.\n        \"\"\"\n        return self.MercatorLatitudeTransform(self.thresh)\n\n    def set_default_locators_and_formatters(self, axis):\n        \"\"\"\n        Override to set up the locators and formatters to use with the\n        scale.  This is only required if the scale requires custom\n        locators and formatters.  Writing custom locators and\n        formatters is rather outside the scope of this example, but\n        there are many helpful examples in :mod:`.ticker`.\n\n        In our case, the Mercator example uses a fixed locator from -90 to 90\n        degrees and a custom formatter to convert the radians to degrees and\n        put a degree symbol after the value.\n        \"\"\"\n        fmt = FuncFormatter(\n            lambda x, pos=None: f\"{np.degrees(x):.0f}\\\\N{DEGREE SIGN}\")\n        axis.set(major_locator=FixedLocator(np.radians(range(-90, 90, 10))),\n                 major_formatter=fmt, minor_formatter=fmt)\n\n    def limit_range_for_scale(self, vmin, vmax, minpos):\n        \"\"\"\n        Override to limit the bounds of the axis to the domain of the\n        transform.  In the case of Mercator, the bounds should be\n        limited to the threshold that was passed in.  Unlike the\n        autoscaling provided by the tick locators, this range limiting\n        will always be adhered to, whether the axis range is set\n        manually, determined automatically or changed through panning\n        and zooming.\n        \"\"\"\n        return max(vmin, -self.thresh), min(vmax, self.thresh)\n\n    class MercatorLatitudeTransform(mtransforms.Transform):\n        # There are two value members that must be defined.\n        # ``input_dims`` and ``output_dims`` specify number of input\n        # dimensions and output dimensions to the transformation.\n        # These are used by the transformation framework to do some\n        # error checking and prevent incompatible transformations from\n        # being connected together.  When defining transforms for a\n        # scale, which are, by definition, separable and have only one\n        # dimension, these members should always be set to 1.\n        input_dims = output_dims = 1\n\n        def __init__(self, thresh):\n            mtransforms.Transform.__init__(self)\n            self.thresh = thresh\n\n        def transform_non_affine(self, a):\n            \"\"\"\n            This transform takes a numpy array and returns a transformed copy.\n            Since the range of the Mercator scale is limited by the\n            user-specified threshold, the input array must be masked to\n            contain only valid values.  Matplotlib will handle masked arrays\n            and remove the out-of-range data from the plot.  However, the\n            returned array *must* have the same shape as the input array, since\n            these values need to remain synchronized with values in the other\n            dimension.\n            \"\"\"\n            masked = ma.masked_where((a < -self.thresh) | (a > self.thresh), a)\n            if masked.mask.any():\n                return ma.log(np.abs(ma.tan(masked) + 1 / ma.cos(masked)))\n            else:\n                return np.log(np.abs(np.tan(a) + 1 / np.cos(a)))\n\n        def inverted(self):\n            \"\"\"\n            Override this method so Matplotlib knows how to get the\n            inverse transform for this transform.\n            \"\"\"\n            return MercatorLatitudeScale.InvertedMercatorLatitudeTransform(\n                self.thresh)\n\n    class InvertedMercatorLatitudeTransform(mtransforms.Transform):\n        input_dims = output_dims = 1\n\n        def __init__(self, thresh):\n            mtransforms.Transform.__init__(self)\n            self.thresh = thresh\n\n        def transform_non_affine(self, a):\n            return np.arctan(np.sinh(a))\n\n        def inverted(self):\n            return MercatorLatitudeScale.MercatorLatitudeTransform(self.thresh)\n\n\n# Now that the Scale class has been defined, it must be registered so\n# that Matplotlib can find it.\nmscale.register_scale(MercatorLatitudeScale)\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    t = np.arange(-180.0, 180.0, 0.1)\n    s = np.radians(t)/2.\n\n    plt.plot(t, s, \\'-\\', lw=2)\n    plt.yscale(\\'mercator\\')\n\n    plt.xlabel(\\'Longitude\\')\n    plt.ylabel(\\'Latitude\\')\n    plt.title(\\'Mercator projection\\')\n    plt.grid(True)\n\n    plt.show()\n",
    "id": 418
},
{
    "title": "Log Bar#",
    "text": "Plotting a bar chart with a logarithmic y-axis. Download Python source code: log_bar.py Download Jupyter notebook: log_bar.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndata = ((3, 1000), (10, 3), (100, 30), (500, 800), (50, 1))\n\ndim = len(data[0])\nw = 0.75\ndimw = w / dim\n\nfig, ax = plt.subplots()\nx = np.arange(len(data))\nfor i in range(len(data[0])):\n    y = [d[i] for d in data]\n    b = ax.bar(x + i * dimw, y, dimw, bottom=0.001)\n\nax.set_xticks(x + dimw / 2, labels=map(str, x))\nax.set_yscale('log')\n\nax.set_xlabel('x')\nax.set_ylabel('y')\n\nplt.show()\n",
    "id": 419
},
{
    "title": "Log Demo#",
    "text": "Examples of plots with logarithmic axes. Total running time of the script: (0 minutes 1.172 seconds) Download Python source code: log_demo.py Download Jupyter notebook: log_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Data for plotting\nt = np.arange(0.01, 20.0, 0.01)\n\n# Create figure\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n\n# log y axis\nax1.semilogy(t, np.exp(-t / 5.0))\nax1.set(title=\\'semilogy\\')\nax1.grid()\n\n# log x axis\nax2.semilogx(t, np.sin(2 * np.pi * t))\nax2.set(title=\\'semilogx\\')\nax2.grid()\n\n# log x and y axis\nax3.loglog(t, 20 * np.exp(-t / 10.0))\nax3.set_xscale(\\'log\\', base=2)\nax3.set(title=\\'loglog base 2 on x\\')\nax3.grid()\n\n# With errorbars: clip non-positive values\n# Use new data for plotting\nx = 10.0**np.linspace(0.0, 2.0, 20)\ny = x**2.0\n\nax4.set_xscale(\"log\", nonpositive=\\'clip\\')\nax4.set_yscale(\"log\", nonpositive=\\'clip\\')\nax4.set(title=\\'Errorbars go negative\\')\nax4.errorbar(x, y, xerr=0.1 * x, yerr=5.0 + 0.75 * y)\n# ylim must be set after errorbar to allow errorbar to autoscale limits\nax4.set_ylim(bottom=0.1)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 420
},
{
    "title": "Logit Demo#",
    "text": "Examples of plots with logit axes. Total running time of the script: (0 minutes 1.635 seconds) Download Python source code: logit_demo.py Download Jupyter notebook: logit_demo.ipynb ",
    "code": "import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nxmax = 10\nx = np.linspace(-xmax, xmax, 10000)\ncdf_norm = [math.erf(w / np.sqrt(2)) / 2 + 1 / 2 for w in x]\ncdf_laplacian = np.where(x < 0, 1 / 2 * np.exp(x), 1 - 1 / 2 * np.exp(-x))\ncdf_cauchy = np.arctan(x) / np.pi + 1 / 2\n\nfig, axs = plt.subplots(nrows=3, ncols=2, figsize=(6.4, 8.5))\n\n# Common part, for the example, we will do the same plots on all graphs\nfor i in range(3):\n    for j in range(2):\n        axs[i, j].plot(x, cdf_norm, label=r\"$\\\\mathcal{N}$\")\n        axs[i, j].plot(x, cdf_laplacian, label=r\"$\\\\mathcal{L}$\")\n        axs[i, j].plot(x, cdf_cauchy, label=\"Cauchy\")\n        axs[i, j].legend()\n        axs[i, j].grid()\n\n# First line, logitscale, with standard notation\naxs[0, 0].set(title=\"logit scale\")\naxs[0, 0].set_yscale(\"logit\")\naxs[0, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[0, 1].set(title=\"logit scale\")\naxs[0, 1].set_yscale(\"logit\")\naxs[0, 1].set_xlim(0, xmax)\naxs[0, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Second line, logitscale, with survival notation (with `use_overline`), and\n# other format display 1/2\naxs[1, 0].set(title=\"logit scale\")\naxs[1, 0].set_yscale(\"logit\", one_half=\"1/2\", use_overline=True)\naxs[1, 0].set_ylim(1e-5, 1 - 1e-5)\n\naxs[1, 1].set(title=\"logit scale\")\naxs[1, 1].set_yscale(\"logit\", one_half=\"1/2\", use_overline=True)\naxs[1, 1].set_xlim(0, xmax)\naxs[1, 1].set_ylim(0.8, 1 - 5e-3)\n\n# Third line, linear scale\naxs[2, 0].set(title=\"linear scale\")\naxs[2, 0].set_ylim(0, 1)\n\naxs[2, 1].set(title=\"linear scale\")\naxs[2, 1].set_xlim(0, xmax)\naxs[2, 1].set_ylim(0.8, 1)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 421
},
{
    "title": "Exploring normalizations#",
    "text": "Various normalization on a multivariate normal distribution. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colors matplotlib.colors.PowerNorm matplotlib.axes.Axes.hist2d matplotlib.pyplot.hist2d Download Python source code: power_norm.py Download Jupyter notebook: power_norm.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy.random import multivariate_normal\n\nimport matplotlib.colors as mcolors\n\n# Fixing random state for reproducibility.\nnp.random.seed(19680801)\n\ndata = np.vstack([\n    multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),\n    multivariate_normal([30, 20], [[3, 1], [1, 3]], size=1000)\n])\n\ngammas = [0.8, 0.5, 0.3]\n\nfig, axs = plt.subplots(nrows=2, ncols=2)\n\naxs[0, 0].set_title('Linear normalization')\naxs[0, 0].hist2d(data[:, 0], data[:, 1], bins=100)\n\nfor ax, gamma in zip(axs.flat[1:], gammas):\n    ax.set_title(r'Power law $(\\\\gamma=%1.1f)$' % gamma)\n    ax.hist2d(data[:, 0], data[:, 1], bins=100, norm=mcolors.PowerNorm(gamma))\n\nfig.tight_layout()\n\nplt.show()\n",
    "id": 422
},
{
    "title": "Scales#",
    "text": "Illustrate the scale transformations applied to axes, e.g. log, symlog, logit.', \"The last two examples are examples of using the 'function' scale by\nsupplying forward and inverse functions for the scale transformation.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.set_xscale matplotlib.axes.Axes.set_yscale matplotlib.axis.Axis.set_major_locator matplotlib.scale.LinearScale matplotlib.scale.LogScale matplotlib.scale.SymmetricalLogScale matplotlib.scale.LogitScale matplotlib.scale.FuncScale Total running time of the script: (0 minutes 1.508 seconds) Download Python source code: scales.py Download Jupyter notebook: scales.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import FixedLocator, NullFormatter\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# make up some data in the interval ]0, 1[\ny = np.random.normal(loc=0.5, scale=0.4, size=1000)\ny = y[(y > 0) & (y < 1)]\ny.sort()\nx = np.arange(len(y))\n\n# plot with various axes scales\nfig, axs = plt.subplots(3, 2, figsize=(6, 8), layout='constrained')\n\n# linear\nax = axs[0, 0]\nax.plot(x, y)\nax.set_yscale('linear')\nax.set_title('linear')\nax.grid(True)\n\n\n# log\nax = axs[0, 1]\nax.plot(x, y)\nax.set_yscale('log')\nax.set_title('log')\nax.grid(True)\n\n\n# symmetric log\nax = axs[1, 1]\nax.plot(x, y - y.mean())\nax.set_yscale('symlog', linthresh=0.02)\nax.set_title('symlog')\nax.grid(True)\n\n# logit\nax = axs[1, 0]\nax.plot(x, y)\nax.set_yscale('logit')\nax.set_title('logit')\nax.grid(True)\n\n\n# Function x**(1/2)\ndef forward(x):\n    return x**(1/2)\n\n\ndef inverse(x):\n    return x**2\n\n\nax = axs[2, 0]\nax.plot(x, y)\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: $x^{1/2}$')\nax.grid(True)\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 1, 0.2)**2))\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 1, 0.2)))\n\n\n# Function Mercator transform\ndef forward(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.log(np.abs(np.tan(a) + 1.0 / np.cos(a))))\n\n\ndef inverse(a):\n    a = np.deg2rad(a)\n    return np.rad2deg(np.arctan(np.sinh(a)))\n\nax = axs[2, 1]\n\nt = np.arange(0, 170.0, 0.1)\ns = t / 2.\n\nax.plot(t, s, '-', lw=2)\n\nax.set_yscale('function', functions=(forward, inverse))\nax.set_title('function: Mercator')\nax.grid(True)\nax.set_xlim([0, 180])\nax.yaxis.set_minor_formatter(NullFormatter())\nax.yaxis.set_major_locator(FixedLocator(np.arange(0, 90, 10)))\n\nplt.show()\n",
    "id": 423
},
{
    "title": "Log Axis#",
    "text": "This is an example of assigning a log-scale for the x-axis using\nsemilogx. Download Python source code: semilogx_demo.py Download Jupyter notebook: semilogx_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n\ndt = 0.01\nt = np.arange(dt, 20.0, dt)\n\nax.semilogx(t, np.exp(-t / 5.0))\nax.grid()\n\nplt.show()\n",
    "id": 424
},
{
    "title": "Symlog Demo#",
    "text": "Example use of symlog (symmetric log) axis scaling. It should be noted that the coordinate transform used by symlog\nhas a discontinuous gradient at the transition between its linear\nand logarithmic regions. The asinh axis scale is an alternative\ntechnique that may avoid visual artifacts caused by these discontinuities. References matplotlib.scale.SymmetricalLogScale matplotlib.ticker.SymmetricalLogLocator matplotlib.scale.AsinhScale Download Python source code: symlog_demo.py Download Jupyter notebook: symlog_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndt = 0.01\nx = np.arange(-50.0, 50.0, dt)\ny = np.arange(0, 100.0, dt)\n\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3)\n\nax0.plot(x, y)\nax0.set_xscale('symlog')\nax0.set_ylabel('symlogx')\nax0.grid()\nax0.xaxis.grid(which='minor')  # minor grid on too\n\nax1.plot(y, x)\nax1.set_yscale('symlog')\nax1.set_ylabel('symlogy')\n\nax2.plot(x, np.sin(x / 3.0))\nax2.set_xscale('symlog')\nax2.set_yscale('symlog', linthresh=0.015)\nax2.grid()\nax2.set_ylabel('symlog both')\n\nfig.tight_layout()\nplt.show()\n",
    "id": 425
},
{
    "title": "Hillshading#",
    "text": "Demonstrates a few common tricks with shaded plots. Total running time of the script: (0 minutes 2.251 seconds) Download Python source code: advanced_hillshading.py Download Jupyter notebook: advanced_hillshading.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.colors import LightSource, Normalize\n\n\ndef display_colorbar():\n    \"\"\"Display a correct numeric colorbar for a shaded plot.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.cm.copper\n    ls = LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation=\\'bilinear\\')\n\n    # Use a proxy artist for the colorbar...\n    im = ax.imshow(z, cmap=cmap)\n    im.remove()\n    fig.colorbar(im, ax=ax)\n\n    ax.set_title(\\'Using a colorbar with a shaded plot\\', size=\\'x-large\\')\n\n\ndef avoid_outliers():\n    \"\"\"Use a custom norm to control the displayed z-range of a shaded plot.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    # Add some outliers...\n    z[100, 105] = 2000\n    z[120, 110] = -9000\n\n    ls = LightSource(315, 45)\n    fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4.5))\n\n    rgb = ls.shade(z, plt.cm.copper)\n    ax1.imshow(rgb, interpolation=\\'bilinear\\')\n    ax1.set_title(\\'Full range of data\\')\n\n    rgb = ls.shade(z, plt.cm.copper, vmin=-10, vmax=10)\n    ax2.imshow(rgb, interpolation=\\'bilinear\\')\n    ax2.set_title(\\'Manually set range\\')\n\n    fig.suptitle(\\'Avoiding Outliers in Shaded Plots\\', size=\\'x-large\\')\n\n\ndef shade_other_data():\n    \"\"\"Demonstrates displaying different variables through shade and color.\"\"\"\n    y, x = np.mgrid[-4:2:200j, -4:2:200j]\n    z1 = np.sin(x**2)  # Data to hillshade\n    z2 = np.cos(x**2 + y**2)  # Data to color\n\n    norm = Normalize(z2.min(), z2.max())\n    cmap = plt.cm.RdBu\n\n    ls = LightSource(315, 45)\n    rgb = ls.shade_rgb(cmap(norm(z2)), z1)\n\n    fig, ax = plt.subplots()\n    ax.imshow(rgb, interpolation=\\'bilinear\\')\n    ax.set_title(\\'Shade by one variable, color by another\\', size=\\'x-large\\')\n\ndisplay_colorbar()\navoid_outliers()\nshade_other_data()\nplt.show()\n",
    "id": 427
},
{
    "title": "Anscombe's quartet#",
    "text": "Anscombe's quartet is a group of datasets (x, y) that have the same mean,\nstandard deviation, and regression line, but which are qualitatively different.\", 'It is often used to illustrate the importance of looking at a set of data\ngraphically and not only relying on basic statistic properties. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.axline / matplotlib.pyplot.axline matplotlib.axes.Axes.text / matplotlib.pyplot.text matplotlib.axes.Axes.tick_params / matplotlib.pyplot.tick_params` Download Python source code: anscombe.py Download Jupyter notebook: anscombe.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\ny2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74]\ny3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73]\nx4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8]\ny4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89]\n\ndatasets = {\n    'I': (x, y1),\n    'II': (x, y2),\n    'III': (x, y3),\n    'IV': (x4, y4)\n}\n\nfig, axs = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 6),\n                        gridspec_kw={'wspace': 0.08, 'hspace': 0.08})\naxs[0, 0].set(xlim=(0, 20), ylim=(2, 14))\naxs[0, 0].set(xticks=(0, 10, 20), yticks=(4, 8, 12))\n\nfor ax, (label, (x, y)) in zip(axs.flat, datasets.items()):\n    ax.text(0.1, 0.9, label, fontsize=20, transform=ax.transAxes, va='top')\n    ax.tick_params(direction='in', top=True, right=True)\n    ax.plot(x, y, 'o')\n\n    # linear regression\n    p1, p0 = np.polyfit(x, y, deg=1)  # slope, intercept\n    ax.axline(xy1=(0, p0), slope=p1, color='r', lw=2)\n\n    # add text box for the statistics\n    stats = (f'$\\\\\\\\mu$ = {np.mean(y):.2f}\\\n'\n             f'$\\\\\\\\sigma$ = {np.std(y):.2f}\\\n'\n             f'$r$ = {np.corrcoef(x, y)[0][1]:.2f}')\n    bbox = dict(boxstyle='round', fc='blanchedalmond', ec='orange', alpha=0.5)\n    ax.text(0.95, 0.07, stats, fontsize=9, bbox=bbox,\n            transform=ax.transAxes, horizontalalignment='right')\n\nplt.show()\n",
    "id": 428
},
{
    "title": "Hinton diagrams#",
    "text": "Hinton diagrams are useful for visualizing the values of a 2D array (e.g.\na weight matrix): Positive and negative values are represented by white and\nblack squares, respectively, and the size of each square represents the\nmagnitude of each value. Initial idea from David Warde-Farley on the SciPy Cookbook Download Python source code: hinton_demo.py Download Jupyter notebook: hinton_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef hinton(matrix, max_weight=None, ax=None):\n    \"\"\"Draw Hinton diagram for visualizing a weight matrix.\"\"\"\n    ax = ax if ax is not None else plt.gca()\n\n    if not max_weight:\n        max_weight = 2 ** np.ceil(np.log2(np.abs(matrix).max()))\n\n    ax.patch.set_facecolor(\\'gray\\')\n    ax.set_aspect(\\'equal\\', \\'box\\')\n    ax.xaxis.set_major_locator(plt.NullLocator())\n    ax.yaxis.set_major_locator(plt.NullLocator())\n\n    for (x, y), w in np.ndenumerate(matrix):\n        color = \\'white\\' if w > 0 else \\'black\\'\n        size = np.sqrt(abs(w) / max_weight)\n        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,\n                             facecolor=color, edgecolor=color)\n        ax.add_patch(rect)\n\n    ax.autoscale_view()\n    ax.invert_yaxis()\n\n\nif __name__ == \\'__main__\\':\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    hinton(np.random.rand(20, 20) - 0.5)\n    plt.show()\n",
    "id": 429
},
{
    "title": "Ishikawa Diagram#",
    "text": "Ishikawa Diagrams, fishbone diagrams, herringbone diagrams, or cause-and-effect\ndiagrams are used to identify problems in a system by showing how causes and\neffects are linked.\nSource: https://en.wikipedia.org/wiki/Ishikawa_diagram Total running time of the script: (0 minutes 1.068 seconds) Download Python source code: ishikawa_diagram.py Download Jupyter notebook: ishikawa_diagram.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.patches import Polygon, Wedge\n\n# Create the fishbone diagram\nfig, ax = plt.subplots(figsize=(10, 6), layout=\\'constrained\\')\nax.set_xlim(-5, 5)\nax.set_ylim(-5, 5)\nax.axis(\\'off\\')\n\n\ndef problems(data: str,\n             problem_x: float, problem_y: float,\n             prob_angle_x: float, prob_angle_y: float):\n    \"\"\"\n    Draw each problem section of the Ishikawa plot.\n\n    Parameters\n    ----------\n    data : str\n        The category name.\n    problem_x, problem_y : float, optional\n        The `X` and `Y` positions of the problem arrows (`Y` defaults to zero).\n    prob_angle_x, prob_angle_y : float, optional\n        The angle of the problem annotations. They are angled towards\n        the tail of the plot.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    ax.annotate(str.upper(data), xy=(problem_x, problem_y),\n                xytext=(prob_angle_x, prob_angle_y),\n                fontsize=\\'10\\',\n                color=\\'white\\',\n                weight=\\'bold\\',\n                xycoords=\\'data\\',\n                verticalalignment=\\'center\\',\n                horizontalalignment=\\'center\\',\n                textcoords=\\'offset fontsize\\',\n                arrowprops=dict(arrowstyle=\"->\", facecolor=\\'black\\'),\n                bbox=dict(boxstyle=\\'square\\',\n                          facecolor=\\'tab:blue\\',\n                          pad=0.8))\n\n\ndef causes(data: list, cause_x: float, cause_y: float,\n           cause_xytext=(-9, -0.3), top: bool = True):\n    \"\"\"\n    Place each cause to a position relative to the problems\n    annotations.\n\n    Parameters\n    ----------\n    data : indexable object\n        The input data. IndexError is\n        raised if more than six arguments are passed.\n    cause_x, cause_y : float\n        The `X` and `Y` position of the cause annotations.\n    cause_xytext : tuple, optional\n        Adjust to set the distance of the cause text from the problem\n        arrow in fontsize units.\n    top : bool\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    for index, cause in enumerate(data):\n        # First cause annotation is placed in the middle of the problems arrow\n        # and each subsequent cause is plotted above or below it in succession.\n\n        # [<x pos>, [<y pos top>, <y pos bottom>]]\n        coords = [[0, [0, 0]],\n                  [0.23, [0.5, -0.5]],\n                  [-0.46, [-1, 1]],\n                  [0.69, [1.5, -1.5]],\n                  [-0.92, [-2, 2]],\n                  [1.15, [2.5, -2.5]]]\n        if top:\n            cause_y += coords[index][1][0]\n        else:\n            cause_y += coords[index][1][1]\n        cause_x -= coords[index][0]\n\n        ax.annotate(cause, xy=(cause_x, cause_y),\n                    horizontalalignment=\\'center\\',\n                    xytext=cause_xytext,\n                    fontsize=\\'9\\',\n                    xycoords=\\'data\\',\n                    textcoords=\\'offset fontsize\\',\n                    arrowprops=dict(arrowstyle=\"->\",\n                                    facecolor=\\'black\\'))\n\n\ndef draw_body(data: dict):\n    \"\"\"\n    Place each section in its correct place by changing\n    the coordinates on each loop.\n\n    Parameters\n    ----------\n    data : dict\n        The input data (can be list or tuple). ValueError is\n        raised if more than six arguments are passed.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    second_sections = []\n    third_sections = []\n    # Resize diagram to automatically scale in response to the number\n    # of problems in the input data.\n    if len(data) == 1 or len(data) == 2:\n        spine_length = (-2.1, 2)\n        head_pos = (2, 0)\n        tail_pos = ((-2.8, 0.8), (-2.8, -0.8), (-2.0, -0.01))\n        first_section = [1.6, 0.8]\n    elif len(data) == 3 or len(data) == 4:\n        spine_length = (-3.1, 3)\n        head_pos = (3, 0)\n        tail_pos = ((-3.8, 0.8), (-3.8, -0.8), (-3.0, -0.01))\n        first_section = [2.6, 1.8]\n        second_sections = [-0.4, -1.2]\n    else:  # len(data) == 5 or 6\n        spine_length = (-4.1, 4)\n        head_pos = (4, 0)\n        tail_pos = ((-4.8, 0.8), (-4.8, -0.8), (-4.0, -0.01))\n        first_section = [3.5, 2.7]\n        second_sections = [1, 0.2]\n        third_sections = [-1.5, -2.3]\n\n    # Change the coordinates of the annotations on each loop.\n    for index, problem in enumerate(data.values()):\n        top_row = True\n        cause_arrow_y = 1.7\n        if index % 2 != 0:  # Plot problems below the spine.\n            top_row = False\n            y_prob_angle = -16\n            cause_arrow_y = -1.7\n        else:  # Plot problems above the spine.\n            y_prob_angle = 16\n        # Plot the 3 sections in pairs along the main spine.\n        if index in (0, 1):\n            prob_arrow_x = first_section[0]\n            cause_arrow_x = first_section[1]\n        elif index in (2, 3):\n            prob_arrow_x = second_sections[0]\n            cause_arrow_x = second_sections[1]\n        else:\n            prob_arrow_x = third_sections[0]\n            cause_arrow_x = third_sections[1]\n        if index > 5:\n            raise ValueError(f\\'Maximum number of problems is 6, you have entered \\'\n                             f\\'{len(data)}\\')\n\n        # draw main spine\n        ax.plot(spine_length, [0, 0], color=\\'tab:blue\\', linewidth=2)\n        # draw fish head\n        ax.text(head_pos[0] + 0.1, head_pos[1] - 0.05, \\'PROBLEM\\', fontsize=10,\n                weight=\\'bold\\', color=\\'white\\')\n        semicircle = Wedge(head_pos, 1, 270, 90, fc=\\'tab:blue\\')\n        ax.add_patch(semicircle)\n        # draw fishtail\n        triangle = Polygon(tail_pos, fc=\\'tab:blue\\')\n        ax.add_patch(triangle)\n        # Pass each category name to the problems function as a string on each loop.\n        problems(list(data.keys())[index], prob_arrow_x, 0, -12, y_prob_angle)\n        # Start the cause function with the first annotation being plotted at\n        # the cause_arrow_x, cause_arrow_y coordinates.\n        causes(problem, cause_arrow_x, cause_arrow_y, top=top_row)\n\n\n# Input data\ncategories = {\n    \\'Method\\': [\\'Time consumption\\', \\'Cost\\', \\'Procedures\\', \\'Inefficient process\\',\n               \\'Sampling\\,\n    \\'Machine\\': [\\'Faulty equipment\\', \\'Compatibility\\,\n    \\'Material\\': [\\'Poor-quality input\\', \\'Raw materials\\', \\'Supplier\\',\n                 \\'Shortage\\,\n    \\'Measurement\\': [\\'Calibration\\', \\'Performance\\', \\'Wrong measurements\\,\n    \\'Environment\\': [\\'Bad conditions\\,\n    \\'People\\': [\\'Lack of training\\', \\'Managers\\', \\'Labor shortage\\',\n               \\'Procedures\\', \\'Sales strategy\\\n}\n\ndraw_body(categories)\nplt.show()\n",
    "id": 430
},
{
    "title": "Left ventricle bullseye#",
    "text": "This example demonstrates how to create the 17 segment model for the left\nventricle recommended by the American Heart Association (AHA). See also the Nested pie charts example. Total running time of the script: (0 minutes 1.731 seconds) Download Python source code: leftventricle_bullseye.py Download Jupyter notebook: leftventricle_bullseye.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib as mpl\n\n\ndef bullseye_plot(ax, data, seg_bold=None, cmap=\"viridis\", norm=None):\n    \"\"\"\n    Bullseye representation for the left ventricle.\n\n    Parameters\n    ----------\n    ax : axes\n    data : list[float]\n        The intensity values for each of the 17 segments.\n    seg_bold : list[int], optional\n        A list with the segments to highlight.\n    cmap : colormap, default: \"viridis\"\n        Colormap for the data.\n    norm : Normalize or None, optional\n        Normalizer for the data.\n\n    Notes\n    -----\n    This function creates the 17 segment model for the left ventricle according\n    to the American Heart Association (AHA) [1]_\n\n    References\n    ----------\n    .. [1] M. D. Cerqueira, N. J. Weissman, V. Dilsizian, A. K. Jacobs,\n        S. Kaul, W. K. Laskey, D. J. Pennell, J. A. Rumberger, T. Ryan,\n        and M. S. Verani, \"Standardized myocardial segmentation and\n        nomenclature for tomographic imaging of the heart\",\n        Circulation, vol. 105, no. 4, pp. 539-542, 2002.\n    \"\"\"\n\n    data = np.ravel(data)\n    if seg_bold is None:\n        seg_bold = []\n    if norm is None:\n        norm = mpl.colors.Normalize(vmin=data.min(), vmax=data.max())\n\n    r = np.linspace(0.2, 1, 4)\n\n    ax.set(ylim=[0, 1], xticklabels=[], yticklabels=[])\n    ax.grid(False)  # Remove grid\n\n    # Fill segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n            (16, 17, 0, r[0]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               color=cmap(norm(data[start:stop])))\n\n    # Now, draw the segment borders.  In order for the outer bold borders not\n    # to be covered by inner segments, the borders are all drawn separately\n    # after the segments have all been filled.  We also disable clipping, which\n    # would otherwise affect the outermost segment edges.\n    # Draw edges of segments 1-6, 7-12, 13-16.\n    for start, stop, r_in, r_out in [\n            (0, 6, r[2], r[3]),\n            (6, 12, r[1], r[2]),\n            (12, 16, r[0], r[1]),\n    ]:\n        n = stop - start\n        dtheta = 2*np.pi / n\n        ax.bar(np.arange(n) * dtheta + np.pi/2, r_out - r_in, dtheta, r_in,\n               clip_on=False, color=\"none\", edgecolor=\"k\", linewidth=[\n                   4 if i + 1 in seg_bold else 2 for i in range(start, stop)])\n    # Draw edge of segment 17 -- here; the edge needs to be drawn differently,\n    # using plot().\n    ax.plot(np.linspace(0, 2*np.pi), np.linspace(r[0], r[0]), \"k\",\n            linewidth=(4 if 17 in seg_bold else 2))\n\n\n# Create the fake data\ndata = np.arange(17) + 1\n\n\n# Make a figure and axes with dimensions as desired.\nfig = plt.figure(figsize=(10, 5), layout=\"constrained\")\nfig.get_layout_engine().set(wspace=.1, w_pad=.2)\naxs = fig.subplots(1, 3, subplot_kw=dict(projection=\\'polar\\'))\nfig.canvas.manager.set_window_title(\\'Left Ventricle Bulls Eyes (AHA)\\')\n\n\n# Set the colormap and norm to correspond to the data for which\n# the colorbar will be used.\ncmap = mpl.cm.viridis\nnorm = mpl.colors.Normalize(vmin=1, vmax=17)\n# Create an empty ScalarMappable to set the colorbar\\'s colormap and norm.\n# The following gives a basic continuous colorbar with ticks and labels.\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap, norm=norm),\n             cax=axs[0].inset_axes([0, -.15, 1, .1]),\n             orientation=\\'horizontal\\', label=\\'Some units\\')\n\n\n# And again for the second colorbar.\ncmap2 = mpl.cm.cool\nnorm2 = mpl.colors.Normalize(vmin=1, vmax=17)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap2, norm=norm2),\n             cax=axs[1].inset_axes([0, -.15, 1, .1]),\n             orientation=\\'horizontal\\', label=\\'Some other units\\')\n\n\n# The second example illustrates the use of a ListedColormap, a\n# BoundaryNorm, and extended ends to show the \"over\" and \"under\"\n# value colors.\ncmap3 = (mpl.colors.ListedColormap([\\'r\\', \\'g\\', \\'b\\', \\'c\\)\n         .with_extremes(over=\\'0.35\\', under=\\'0.75\\'))\n# If a ListedColormap is used, the length of the bounds array must be\n# one greater than the length of the color list.  The bounds must be\n# monotonically increasing.\nbounds = [2, 3, 7, 9, 15]\nnorm3 = mpl.colors.BoundaryNorm(bounds, cmap3.N)\nfig.colorbar(mpl.cm.ScalarMappable(cmap=cmap3, norm=norm3),\n             cax=axs[2].inset_axes([0, -.15, 1, .1]),\n             extend=\\'both\\',\n             ticks=bounds,  # optional\n             spacing=\\'proportional\\',\n             orientation=\\'horizontal\\',\n             label=\\'Discrete intervals, some other units\\')\n\n\n# Create the 17 segment model\nbullseye_plot(axs[0], data, cmap=cmap, norm=norm)\naxs[0].set_title(\\'Bulls Eye (AHA)\\')\n\nbullseye_plot(axs[1], data, cmap=cmap2, norm=norm2)\naxs[1].set_title(\\'Bulls Eye (AHA)\\')\n\nbullseye_plot(axs[2], data, seg_bold=[3, 5, 6, 11, 12, 16],\n              cmap=cmap3, norm=norm3)\naxs[2].set_title(\\'Segments [3, 5, 6, 11, 12, 16] in bold\\')\n\nplt.show()\n",
    "id": 431
},
{
    "title": "MRI with EEG#",
    "text": "Displays a set of subplots with an MRI image, its intensity\nhistogram and some EEG traces. Download Python source code: mri_with_eeg.py Download Jupyter notebook: mri_with_eeg.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\n\nfig, axd = plt.subplot_mosaic(\n    [image\", \"density,\n     EEG\", \"EEG],\n    layout=\"constrained\",\n    # \"image\" will contain a square image. We fine-tune the width so that\n    # there is no excess horizontal or vertical margin around the image.\n    width_ratios=[1.05, 2],\n)\n\n# Load the MRI data (256x256 16-bit integers)\nwith cbook.get_sample_data(\\'s1045.ima.gz\\') as dfile:\n    im = np.frombuffer(dfile.read(), np.uint16).reshape((256, 256))\n\n# Plot the MRI image\naxdimage.imshow(im, cmap=\"gray\")\naxdimage.axis(\\'off\\')\n\n# Plot the histogram of MRI intensity\nim = im[im.nonzero()]  # Ignore the background\naxddensity.hist(im, bins=np.arange(0, 2**16+1, 512))\naxddensity.set(xlabel=\\'Intensity (a.u.)\\', xlim=(0, 2**16),\n                   ylabel=\\'MRI density\\', yticks=[])\naxddensity.minorticks_on()\n\n# Load the EEG data\nn_samples, n_rows = 800, 4\nwith cbook.get_sample_data(\\'eeg.dat\\') as eegfile:\n    data = np.fromfile(eegfile, dtype=float).reshape((n_samples, n_rows))\nt = 10 * np.arange(n_samples) / n_samples\n\n# Plot the EEG\naxdEEG.set_xlabel(\\'Time (s)\\')\naxdEEG.set_xlim(0, 10)\ndy = (data.min() - data.max()) * 0.7  # Crowd them a bit.\naxdEEG.set_ylim(-dy, n_rows * dy)\naxdEEG.set_yticks([0, dy, 2*dy, 3*dy], labels=[\\'PG3\\', \\'PG5\\', \\'PG7\\', \\'PG9\\)\n\nfor i, data_col in enumerate(data.T):\n    axdEEG.plot(t, data_col + i*dy, color=\"C0\")\n\nplt.show()\n",
    "id": 432
},
{
    "title": "Radar chart (aka spider or star chart)#",
    "text": "This example creates a radar chart, also known as a spider or star chart [1].', \"Although this example allows a frame of either 'circle' or 'polygon', polygon\nframes don't have proper gridlines (the lines are circles instead of polygons).\nIt's possible to get a polygon grid by setting GRIDLINE_INTERPOLATION_STEPS in\nmatplotlib.axis to the desired number of vertices, but the orientation of the\npolygon is not aligned with the radial axes.\", 'https://en.wikipedia.org/wiki/Radar_chart References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.path matplotlib.path.Path matplotlib.spines matplotlib.spines.Spine matplotlib.projections matplotlib.projections.polar matplotlib.projections.polar.PolarAxes matplotlib.projections.register_projection Total running time of the script: (0 minutes 1.206 seconds) Download Python source code: radar_chart.py Download Jupyter notebook: radar_chart.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Circle, RegularPolygon\nfrom matplotlib.path import Path\nfrom matplotlib.projections import register_projection\nfrom matplotlib.projections.polar import PolarAxes\nfrom matplotlib.spines import Spine\nfrom matplotlib.transforms import Affine2D\n\n\ndef radar_factory(num_vars, frame=\\'circle\\'):\n    \"\"\"\n    Create a radar chart with `num_vars` axes.\n\n    This function creates a RadarAxes projection and registers it.\n\n    Parameters\n    ----------\n    num_vars : int\n        Number of variables for radar chart.\n    frame : {\\'circle\\', \\'polygon\\'}\n        Shape of frame surrounding axes.\n\n    \"\"\"\n    # calculate evenly-spaced axis angles\n    theta = np.linspace(0, 2*np.pi, num_vars, endpoint=False)\n\n    class RadarTransform(PolarAxes.PolarTransform):\n\n        def transform_path_non_affine(self, path):\n            # Paths with non-unit interpolation steps correspond to gridlines,\n            # in which case we force interpolation (to defeat PolarTransform\\'s\n            # autoconversion to circular arcs).\n            if path._interpolation_steps > 1:\n                path = path.interpolated(num_vars)\n            return Path(self.transform(path.vertices), path.codes)\n\n    class RadarAxes(PolarAxes):\n\n        name = \\'radar\\'\n        PolarTransform = RadarTransform\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            # rotate plot such that the first axis is at the top\n            self.set_theta_zero_location(\\'N\\')\n\n        def fill(self, *args, closed=True, **kwargs):\n            \"\"\"Override fill so that line is closed by default\"\"\"\n            return super().fill(closed=closed, *args, **kwargs)\n\n        def plot(self, *args, **kwargs):\n            \"\"\"Override plot so that line is closed by default\"\"\"\n            lines = super().plot(*args, **kwargs)\n            for line in lines:\n                self._close_line(line)\n\n        def _close_line(self, line):\n            x, y = line.get_data()\n            # FIXME: markers at x[0], y[0] get doubled-up\n            if x[0] != x[-1]:\n                x = np.append(x, x[0])\n                y = np.append(y, y[0])\n                line.set_data(x, y)\n\n        def set_varlabels(self, labels):\n            self.set_thetagrids(np.degrees(theta), labels)\n\n        def _gen_axes_patch(self):\n            # The Axes patch must be centered at (0.5, 0.5) and of radius 0.5\n            # in axes coordinates.\n            if frame == \\'circle\\':\n                return Circle((0.5, 0.5), 0.5)\n            elif frame == \\'polygon\\':\n                return RegularPolygon((0.5, 0.5), num_vars,\n                                      radius=.5, edgecolor=\"k\")\n            else:\n                raise ValueError(\"Unknown value for \\'frame\\': %s\" % frame)\n\n        def _gen_axes_spines(self):\n            if frame == \\'circle\\':\n                return super()._gen_axes_spines()\n            elif frame == \\'polygon\\':\n                # spine_type must be \\'left\\'/\\'right\\'/\\'top\\'/\\'bottom\\'/\\'circle\\'.\n                spine = Spine(axes=self,\n                              spine_type=\\'circle\\',\n                              path=Path.unit_regular_polygon(num_vars))\n                # unit_regular_polygon gives a polygon of radius 1 centered at\n                # (0, 0) but we want a polygon of radius 0.5 centered at (0.5,\n                # 0.5) in axes coordinates.\n                spine.set_transform(Affine2D().scale(.5).translate(.5, .5)\n                                    + self.transAxes)\n                return {\\'polar\\': spine}\n            else:\n                raise ValueError(\"Unknown value for \\'frame\\': %s\" % frame)\n\n    register_projection(RadarAxes)\n    return theta\n\n\ndef example_data():\n    # The following data is from the Denver Aerosol Sources and Health study.\n    # See doi:10.1016/j.atmosenv.2008.12.017\n    #\n    # The data are pollution source profile estimates for five modeled\n    # pollution sources (e.g., cars, wood-burning, etc) that emit 7-9 chemical\n    # species. The radar charts are experimented with here to see if we can\n    # nicely visualize how the modeled source profiles change across four\n    # scenarios:\n    #  1) No gas-phase species present, just seven particulate counts on\n    #     Sulfate\n    #     Nitrate\n    #     Elemental Carbon (EC)\n    #     Organic Carbon fraction 1 (OC)\n    #     Organic Carbon fraction 2 (OC2)\n    #     Organic Carbon fraction 3 (OC3)\n    #     Pyrolyzed Organic Carbon (OP)\n    #  2)Inclusion of gas-phase specie carbon monoxide (CO)\n    #  3)Inclusion of gas-phase specie ozone (O3).\n    #  4)Inclusion of both gas-phase species is present...\n    data = [\n        [\\'Sulfate\\', \\'Nitrate\\', \\'EC\\', \\'OC1\\', \\'OC2\\', \\'OC3\\', \\'OP\\', \\'CO\\', \\'O3\\,\n        (\\'Basecase\\', [\n            [0.88, 0.01, 0.03, 0.03, 0.00, 0.06, 0.01, 0.00, 0.00],\n            [0.07, 0.95, 0.04, 0.05, 0.00, 0.02, 0.01, 0.00, 0.00],\n            [0.01, 0.02, 0.85, 0.19, 0.05, 0.10, 0.00, 0.00, 0.00],\n            [0.02, 0.01, 0.07, 0.01, 0.21, 0.12, 0.98, 0.00, 0.00],\n            [0.01, 0.01, 0.02, 0.71, 0.74, 0.70, 0.00, 0.00, 0.00]]),\n        (\\'With CO\\', [\n            [0.88, 0.02, 0.02, 0.02, 0.00, 0.05, 0.00, 0.05, 0.00],\n            [0.08, 0.94, 0.04, 0.02, 0.00, 0.01, 0.12, 0.04, 0.00],\n            [0.01, 0.01, 0.79, 0.10, 0.00, 0.05, 0.00, 0.31, 0.00],\n            [0.00, 0.02, 0.03, 0.38, 0.31, 0.31, 0.00, 0.59, 0.00],\n            [0.02, 0.02, 0.11, 0.47, 0.69, 0.58, 0.88, 0.00, 0.00]]),\n        (\\'With O3\\', [\n            [0.89, 0.01, 0.07, 0.00, 0.00, 0.05, 0.00, 0.00, 0.03],\n            [0.07, 0.95, 0.05, 0.04, 0.00, 0.02, 0.12, 0.00, 0.00],\n            [0.01, 0.02, 0.86, 0.27, 0.16, 0.19, 0.00, 0.00, 0.00],\n            [0.01, 0.03, 0.00, 0.32, 0.29, 0.27, 0.00, 0.00, 0.95],\n            [0.02, 0.00, 0.03, 0.37, 0.56, 0.47, 0.87, 0.00, 0.00]]),\n        (\\'CO & O3\\', [\n            [0.87, 0.01, 0.08, 0.00, 0.00, 0.04, 0.00, 0.00, 0.01],\n            [0.09, 0.95, 0.02, 0.03, 0.00, 0.01, 0.13, 0.06, 0.00],\n            [0.01, 0.02, 0.71, 0.24, 0.13, 0.16, 0.00, 0.50, 0.00],\n            [0.01, 0.03, 0.00, 0.28, 0.24, 0.23, 0.00, 0.44, 0.88],\n            [0.02, 0.00, 0.18, 0.45, 0.64, 0.55, 0.86, 0.00, 0.16]])\n    ]\n    return data\n\n\nif __name__ == \\'__main__\\':\n    N = 9\n    theta = radar_factory(N, frame=\\'polygon\\')\n\n    data = example_data()\n    spoke_labels = data.pop(0)\n\n    fig, axs = plt.subplots(figsize=(9, 9), nrows=2, ncols=2,\n                            subplot_kw=dict(projection=\\'radar\\'))\n    fig.subplots_adjust(wspace=0.25, hspace=0.20, top=0.85, bottom=0.05)\n\n    colors = [\\'b\\', \\'r\\', \\'g\\', \\'m\\', \\'y\\\n    # Plot the four cases from the example data on separate axes\n    for ax, (title, case_data) in zip(axs.flat, data):\n        ax.set_rgrids([0.2, 0.4, 0.6, 0.8])\n        ax.set_title(title, weight=\\'bold\\', size=\\'medium\\', position=(0.5, 1.1),\n                     horizontalalignment=\\'center\\', verticalalignment=\\'center\\')\n        for d, color in zip(case_data, colors):\n            ax.plot(theta, d, color=color)\n            ax.fill(theta, d, facecolor=color, alpha=0.25, label=\\'_nolegend_\\')\n        ax.set_varlabels(spoke_labels)\n\n    # add legend relative to top-left plot\n    labels = (\\'Factor 1\\', \\'Factor 2\\', \\'Factor 3\\', \\'Factor 4\\', \\'Factor 5\\')\n    legend = axs[0, 0].legend(labels, loc=(0.9, .95),\n                              labelspacing=0.1, fontsize=\\'small\\')\n\n    fig.text(0.5, 0.965, \\'5-Factor Solution Profiles Across Four Scenarios\\',\n             horizontalalignment=\\'center\\', color=\\'black\\', weight=\\'bold\\',\n             size=\\'large\\')\n\n    plt.show()\n",
    "id": 433
},
{
    "title": "The Sankey class#",
    "text": "Demonstrate the Sankey class by producing three basic diagrams. Example 1 -- Mostly defaults This demonstrates how to create a simple diagram by implicitly calling the\nSankey.add() method and by appending finish() to the call to the class. Notice:', \"Axes weren't provided when Sankey() was instantiated, so they were\ncreated automatically.\", \"The scale argument wasn't necessary since the data was already\nnormalized.\", 'By default, the lengths of the paths are justified. Example 2 This demonstrates: Setting one path longer than the others Placing a label in the middle of the diagram Using the scale argument to normalize the flows Implicitly passing keyword arguments to PathPatch() Changing the angle of the arrow heads Changing the offset between the tips of the paths and their labels Formatting the numbers in the path labels and the associated unit Changing the appearance of the patch and the labels after the figure is\ncreated Notice:', \"Since the sum of the flows is nonzero, the width of the trunk isn't\nuniform. The matplotlib logging system logs this at the DEBUG level.\", \"The second flow doesn't appear because its value is zero. Again, this is\nlogged at the DEBUG level.\", 'Example 3 This demonstrates: Connecting two systems Turning off the labels of the quantities Adding a legend Notice that only one connection is specified, but the systems form a\ncircuit since: (1) the lengths of the paths are justified and (2) the\norientation and ordering of the flows is mirrored. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.sankey matplotlib.sankey.Sankey matplotlib.sankey.Sankey.add matplotlib.sankey.Sankey.finish Download Python source code: sankey_basics.py Download Jupyter notebook: sankey_basics.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n Sankey(flows=[0.25, 0.15, 0.60, -0.20, -0.15, -0.05, -0.50, -0.10],\n       labels=[\\'\\', \\'\\', \\'\\', \\'First\\', \\'Second\\', \\'Third\\', \\'Fourth\\', \\'Fifth\\,\n       orientations=[-1, 1, 0, 1, 1, 1, 0, -1]).finish()\nplt.title(\"The default settings produce a diagram like this.\")\n fig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Flow Diagram of a Widget\")\nsankey = Sankey(ax=ax, scale=0.01, offset=0.2, head_angle=180,\n                format=\\'%.0f\\', unit=\\'%\\')\nsankey.add(flows=[25, 0, 60, -10, -20, -5, -15, -10, -40],\n           labels=[\\'\\', \\'\\', \\'\\', \\'First\\', \\'Second\\', \\'Third\\', \\'Fourth\\',\n                   \\'Fifth\\', \\'Hurray!\\,\n           orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0],\n           pathlengths=[0.25, 0.25, 0.25, 0.25, 0.25, 0.6, 0.25, 0.25,\n                        0.25],\n           patchlabel=\"Widget\\\nA\")  # Arguments to matplotlib.patches.PathPatch\ndiagrams = sankey.finish()\ndiagrams[0].texts[-1].set_color(\\'r\\')\ndiagrams[0].text.set_fontweight(\\'bold\\')\n fig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[], title=\"Two Systems\")\nflows = [0.25, 0.15, 0.60, -0.10, -0.05, -0.25, -0.15, -0.10, -0.35]\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=flows, label=\\'one\\',\n           orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0])\nsankey.add(flows=[-0.25, 0.15, 0.1], label=\\'two\\',\n           orientations=[-1, -1, -1], prior=0, connect=(0, 0))\ndiagrams = sankey.finish()\ndiagrams[-1].patch.set_hatch(\\'/\\')\nplt.legend()\n plt.show()\n",
    "id": 434
},
{
    "title": "Long chain of connections using Sankey#",
    "text": "Demonstrate/test the Sankey class by producing a long chain of connections. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.sankey matplotlib.sankey.Sankey matplotlib.sankey.Sankey.add matplotlib.sankey.Sankey.finish Download Python source code: sankey_links.py Download Jupyter notebook: sankey_links.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nlinks_per_side = 6\n\n\ndef side(sankey, n=1):\n    \"\"\"Generate a side chain.\"\"\"\n    prior = len(sankey.diagrams)\n    for i in range(0, 2*n, 2):\n        sankey.add(flows=[1, -1], orientations=[-1, -1],\n                   patchlabel=str(prior + i),\n                   prior=prior + i - 1, connect=(1, 0), alpha=0.5)\n        sankey.add(flows=[1, -1], orientations=[1, 1],\n                   patchlabel=str(prior + i + 1),\n                   prior=prior + i, connect=(1, 0), alpha=0.5)\n\n\ndef corner(sankey):\n    \"\"\"Generate a corner link.\"\"\"\n    prior = len(sankey.diagrams)\n    sankey.add(flows=[1, -1], orientations=[0, 1],\n               patchlabel=str(prior), facecolor=\\'k\\',\n               prior=prior - 1, connect=(1, 0), alpha=0.5)\n\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Why would you want to do this?\\\n(But you could.)\")\nsankey = Sankey(ax=ax, unit=None)\nsankey.add(flows=[1, -1], orientations=[0, 1],\n           patchlabel=\"0\", facecolor=\\'k\\',\n           rotation=45)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\ncorner(sankey)\nside(sankey, n=links_per_side)\nsankey.finish()\n# Notice:\n# 1. The alignment doesn\\'t drift significantly (if at all; with 16007\n#    subdiagrams there is still closure).\n# 2. The first diagram is rotated 45 deg, so all other diagrams are rotated\n#    accordingly.\n\nplt.show()\n",
    "id": 435
},
{
    "title": "Rankine power cycle#",
    "text": "Demonstrate the Sankey class with a practical example of a Rankine power cycle. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.sankey matplotlib.sankey.Sankey matplotlib.sankey.Sankey.add matplotlib.sankey.Sankey.finish Download Python source code: sankey_rankine.py Download Jupyter notebook: sankey_rankine.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.sankey import Sankey\n\nfig = plt.figure(figsize=(8, 9))\nax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],\n                     title=\"Rankine Power Cycle: Example 8.6 from Moran and \"\n                     \"Shapiro\\\n\\\\x22Fundamentals of Engineering Thermodynamics \"\n                     \"\\\\x22, 6th ed., 2008\")\nHdot = [260.431, 35.078, 180.794, 221.115, 22.700,\n        142.361, 10.193, 10.210, 43.670, 44.312,\n        68.631, 10.758, 10.758, 0.017, 0.642,\n        232.121, 44.559, 100.613, 132.168]  # MW\nsankey = Sankey(ax=ax, format=\\'%.3G\\', unit=\\' MW\\', gap=0.5, scale=1.0/Hdot[0])\nsankey.add(patchlabel=\\'\\\n\\\nPump 1\\', rotation=90, facecolor=\\'#37c959\\',\n           flows=[Hdot[13], Hdot[6], -Hdot[7]],\n           labels=[\\'Shaft power\\', \\'\\', None],\n           pathlengths=[0.4, 0.883, 0.25],\n           orientations=[1, -1, 0])\nsankey.add(patchlabel=\\'\\\n\\\nOpen\\\nheater\\', facecolor=\\'#37c959\\',\n           flows=[Hdot[11], Hdot[7], Hdot[4], -Hdot[8]],\n           labels=[None, \\'\\', None, None],\n           pathlengths=[0.25, 0.25, 1.93, 0.25],\n           orientations=[1, 0, -1, 0], prior=0, connect=(2, 1))\nsankey.add(patchlabel=\\'\\\n\\\nPump 2\\', facecolor=\\'#37c959\\',\n           flows=[Hdot[14], Hdot[8], -Hdot[9]],\n           labels=[\\'Shaft power\\', \\'\\', None],\n           pathlengths=[0.4, 0.25, 0.25],\n           orientations=[1, 0, 0], prior=1, connect=(3, 1))\nsankey.add(patchlabel=\\'Closed\\\nheater\\', trunklength=2.914, fc=\\'#37c959\\',\n           flows=[Hdot[9], Hdot[1], -Hdot[11], -Hdot[10]],\n           pathlengths=[0.25, 1.543, 0.25, 0.25],\n           labels=[\\'\\', \\'\\', None, None],\n           orientations=[0, -1, 1, -1], prior=2, connect=(2, 0))\nsankey.add(patchlabel=\\'Trap\\', facecolor=\\'#37c959\\', trunklength=5.102,\n           flows=[Hdot[11], -Hdot[12]],\n           labels=[\\'\\\n\\', None],\n           pathlengths=[1.0, 1.01],\n           orientations=[1, 1], prior=3, connect=(2, 0))\nsankey.add(patchlabel=\\'Steam\\\ngenerator\\', facecolor=\\'#ff5555\\',\n           flows=[Hdot[15], Hdot[10], Hdot[2], -Hdot[3], -Hdot[0]],\n           labels=[\\'Heat rate\\', \\'\\', \\'\\', None, None],\n           pathlengths=0.25,\n           orientations=[1, 0, -1, -1, -1], prior=3, connect=(3, 1))\nsankey.add(patchlabel=\\'\\\n\\\n\\\nTurbine 1\\', facecolor=\\'#37c959\\',\n           flows=[Hdot[0], -Hdot[16], -Hdot[1], -Hdot[2]],\n           labels=[\\'\\', None, None, None],\n           pathlengths=[0.25, 0.153, 1.543, 0.25],\n           orientations=[0, 1, -1, -1], prior=5, connect=(4, 0))\nsankey.add(patchlabel=\\'\\\n\\\n\\\nReheat\\', facecolor=\\'#37c959\\',\n           flows=[Hdot[2], -Hdot[2]],\n           labels=[None, None],\n           pathlengths=[0.725, 0.25],\n           orientations=[-1, 0], prior=6, connect=(3, 0))\nsankey.add(patchlabel=\\'Turbine 2\\', trunklength=3.212, facecolor=\\'#37c959\\',\n           flows=[Hdot[3], Hdot[16], -Hdot[5], -Hdot[4], -Hdot[17]],\n           labels=[None, \\'Shaft power\\', None, \\'\\', \\'Shaft power\\,\n           pathlengths=[0.751, 0.15, 0.25, 1.93, 0.25],\n           orientations=[0, -1, 0, -1, 1], prior=6, connect=(1, 1))\nsankey.add(patchlabel=\\'Condenser\\', facecolor=\\'#58b1fa\\', trunklength=1.764,\n           flows=[Hdot[5], -Hdot[18], -Hdot[6]],\n           labels=[\\'\\', \\'Heat rate\\', None],\n           pathlengths=[0.45, 0.25, 0.883],\n           orientations=[-1, 1, 0], prior=8, connect=(2, 0))\ndiagrams = sankey.finish()\nfor diagram in diagrams:\n    diagram.text.set_fontweight(\\'bold\\')\n    diagram.text.set_fontsize(\\'10\\')\n    for text in diagram.texts:\n        text.set_fontsize(\\'10\\')\n# Notice that the explicit connections are handled automatically, but the\n# implicit ones currently are not.  The lengths of the paths and the trunks\n# must be adjusted manually, and that is a bit tricky.\n\nplt.show()\n",
    "id": 436
},
{
    "title": "SkewT-logP diagram: using transforms and custom projections#",
    "text": "This serves as an intensive exercise of Matplotlib's transforms and custom\nprojection API. This example produces a so-called SkewT-logP diagram, which is\na common plot in meteorology for displaying vertical profiles of temperature.\nAs far as Matplotlib is concerned, the complexity comes from having X and Y\naxes that are not orthogonal. This is handled by including a skew component to\nthe basic Axes transforms. Additional complexity comes in handling the fact\nthat the upper and lower X-axes have different data ranges, which necessitates\na bunch of custom classes for ticks, spines, and axis to handle this.\", 'References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.transforms matplotlib.spines matplotlib.spines.Spine matplotlib.spines.Spine.register_axis matplotlib.projections matplotlib.projections.register_projection Download Python source code: skewt.py Download Jupyter notebook: skewt.ipynb ",
    "code": "from contextlib import ExitStack\n\nfrom matplotlib.axes import Axes\nimport matplotlib.axis as maxis\nfrom matplotlib.projections import register_projection\nimport matplotlib.spines as mspines\nimport matplotlib.transforms as transforms\n\n\n# The sole purpose of this class is to look at the upper, lower, or total\n# interval as appropriate and see what parts of the tick to draw, if any.\nclass SkewXTick(maxis.XTick):\n    def draw(self, renderer):\n        # When adding the callbacks with `stack.callback`, we fetch the current\n        # visibility state of the artist with `get_visible`; the ExitStack will\n        # restore these states (`set_visible`) at the end of the block (after\n        # the draw).\n        with ExitStack() as stack:\n            for artist in [self.gridline, self.tick1line, self.tick2line,\n                           self.label1, self.label2]:\n                stack.callback(artist.set_visible, artist.get_visible())\n            needs_lower = transforms.interval_contains(\n                self.axes.lower_xlim, self.get_loc())\n            needs_upper = transforms.interval_contains(\n                self.axes.upper_xlim, self.get_loc())\n            self.tick1line.set_visible(\n                self.tick1line.get_visible() and needs_lower)\n            self.label1.set_visible(\n                self.label1.get_visible() and needs_lower)\n            self.tick2line.set_visible(\n                self.tick2line.get_visible() and needs_upper)\n            self.label2.set_visible(\n                self.label2.get_visible() and needs_upper)\n            super().draw(renderer)\n\n    def get_view_interval(self):\n        return self.axes.xaxis.get_view_interval()\n\n\n# This class exists to provide two separate sets of intervals to the tick,\n# as well as create instances of the custom tick\nclass SkewXAxis(maxis.XAxis):\n    def _get_tick(self, major):\n        return SkewXTick(self.axes, None, major=major)\n\n    def get_view_interval(self):\n        return self.axes.upper_xlim[0], self.axes.lower_xlim[1]\n\n\n# This class exists to calculate the separate data range of the\n# upper X-axis and draw the spine there. It also provides this range\n# to the X-axis artist for ticking and gridlines\nclass SkewSpine(mspines.Spine):\n    def _adjust_location(self):\n        pts = self._path.vertices\n        if self.spine_type == \\'top\\':\n            pts[:, 0] = self.axes.upper_xlim\n        else:\n            pts[:, 0] = self.axes.lower_xlim\n\n\n# This class handles registration of the skew-xaxes as a projection as well\n# as setting up the appropriate transformations. It also overrides standard\n# spines and axes instances as appropriate.\nclass SkewXAxes(Axes):\n    # The projection must specify a name.  This will be used be the\n    # user to select the projection, i.e. ``subplot(projection=\\'skewx\\')``.\n    name = \\'skewx\\'\n\n    def _init_axis(self):\n        # Taken from Axes and modified to use our modified X-axis\n        self.xaxis = SkewXAxis(self)\n        self.spines.top.register_axis(self.xaxis)\n        self.spines.bottom.register_axis(self.xaxis)\n        self.yaxis = maxis.YAxis(self)\n        self.spines.left.register_axis(self.yaxis)\n        self.spines.right.register_axis(self.yaxis)\n\n    def _gen_axes_spines(self):\n        spines = {\\'top\\': SkewSpine.linear_spine(self, \\'top\\'),\n                  \\'bottom\\': mspines.Spine.linear_spine(self, \\'bottom\\'),\n                  \\'left\\': mspines.Spine.linear_spine(self, \\'left\\'),\n                  \\'right\\': mspines.Spine.linear_spine(self, \\'right\\')}\n        return spines\n\n    def _set_lim_and_transforms(self):\n        \"\"\"\n        This is called once when the plot is created to set up all the\n        transforms for the data, text and grids.\n        \"\"\"\n        rot = 30\n\n        # Get the standard transform setup from the Axes base class\n        super()._set_lim_and_transforms()\n\n        # Need to put the skew in the middle, after the scale and limits,\n        # but before the transAxes. This way, the skew is done in Axes\n        # coordinates thus performing the transform around the proper origin\n        # We keep the pre-transAxes transform around for other users, like the\n        # spines for finding bounds\n        self.transDataToAxes = (\n            self.transScale\n            + self.transLimits\n            + transforms.Affine2D().skew_deg(rot, 0)\n        )\n        # Create the full transform from Data to Pixels\n        self.transData = self.transDataToAxes + self.transAxes\n\n        # Blended transforms like this need to have the skewing applied using\n        # both axes, in axes coords like before.\n        self._xaxis_transform = (\n            transforms.blended_transform_factory(\n                self.transScale + self.transLimits,\n                transforms.IdentityTransform())\n            + transforms.Affine2D().skew_deg(rot, 0)\n            + self.transAxes\n        )\n\n    @property\n    def lower_xlim(self):\n        return self.axes.viewLim.intervalx\n\n    @property\n    def upper_xlim(self):\n        pts = [[0., 1.], [1., 1.]]\n        return self.transDataToAxes.inverted().transform(pts)[:, 0]\n\n\n# Now register the projection with matplotlib so the user can select it.\nregister_projection(SkewXAxes)\n\nif __name__ == \\'__main__\\':\n    # Now make a simple example using the custom projection.\n    from io import StringIO\n\n    import matplotlib.pyplot as plt\n    import numpy as np\n\n    from matplotlib.ticker import (MultipleLocator, NullFormatter,\n                                   ScalarFormatter)\n\n    # Some example data.\n    data_txt = \\'\\'\\'\n        978.0    345    7.8    0.8\n        971.0    404    7.2    0.2\n        946.7    610    5.2   -1.8\n        944.0    634    5.0   -2.0\n        925.0    798    3.4   -2.6\n        911.8    914    2.4   -2.7\n        906.0    966    2.0   -2.7\n        877.9   1219    0.4   -3.2\n        850.0   1478   -1.3   -3.7\n        841.0   1563   -1.9   -3.8\n        823.0   1736    1.4   -0.7\n        813.6   1829    4.5    1.2\n        809.0   1875    6.0    2.2\n        798.0   1988    7.4   -0.6\n        791.0   2061    7.6   -1.4\n        783.9   2134    7.0   -1.7\n        755.1   2438    4.8   -3.1\n        727.3   2743    2.5   -4.4\n        700.5   3048    0.2   -5.8\n        700.0   3054    0.2   -5.8\n        698.0   3077    0.0   -6.0\n        687.0   3204   -0.1   -7.1\n        648.9   3658   -3.2  -10.9\n        631.0   3881   -4.7  -12.7\n        600.7   4267   -6.4  -16.7\n        592.0   4381   -6.9  -17.9\n        577.6   4572   -8.1  -19.6\n        555.3   4877  -10.0  -22.3\n        536.0   5151  -11.7  -24.7\n        533.8   5182  -11.9  -25.0\n        500.0   5680  -15.9  -29.9\n        472.3   6096  -19.7  -33.4\n        453.0   6401  -22.4  -36.0\n        400.0   7310  -30.7  -43.7\n        399.7   7315  -30.8  -43.8\n        387.0   7543  -33.1  -46.1\n        382.7   7620  -33.8  -46.8\n        342.0   8398  -40.5  -53.5\n        320.4   8839  -43.7  -56.7\n        318.0   8890  -44.1  -57.1\n        310.0   9060  -44.7  -58.7\n        306.1   9144  -43.9  -57.9\n        305.0   9169  -43.7  -57.7\n        300.0   9280  -43.5  -57.5\n        292.0   9462  -43.7  -58.7\n        276.0   9838  -47.1  -62.1\n        264.0  10132  -47.5  -62.5\n        251.0  10464  -49.7  -64.7\n        250.0  10490  -49.7  -64.7\n        247.0  10569  -48.7  -63.7\n        244.0  10649  -48.9  -63.9\n        243.3  10668  -48.9  -63.9\n        220.0  11327  -50.3  -65.3\n        212.0  11569  -50.5  -65.5\n        210.0  11631  -49.7  -64.7\n        200.0  11950  -49.9  -64.9\n        194.0  12149  -49.9  -64.9\n        183.0  12529  -51.3  -66.3\n        164.0  13233  -55.3  -68.3\n        152.0  13716  -56.5  -69.5\n        150.0  13800  -57.1  -70.1\n        136.0  14414  -60.5  -72.5\n        132.0  14600  -60.1  -72.1\n        131.4  14630  -60.2  -72.2\n        128.0  14792  -60.9  -72.9\n        125.0  14939  -60.1  -72.1\n        119.0  15240  -62.2  -73.8\n        112.0  15616  -64.9  -75.9\n        108.0  15838  -64.1  -75.1\n        107.8  15850  -64.1  -75.1\n        105.0  16010  -64.7  -75.7\n        103.0  16128  -62.9  -73.9\n        100.0  16310  -62.5  -73.5\n    \\'\\'\\'\n\n    # Parse the data\n    sound_data = StringIO(data_txt)\n    p, h, T, Td = np.loadtxt(sound_data, unpack=True)\n\n    # Create a new figure. The dimensions here give a good aspect ratio\n    fig = plt.figure(figsize=(6.5875, 6.2125))\n    ax = fig.add_subplot(projection=\\'skewx\\')\n\n    plt.grid(True)\n\n    # Plot the data using normal plotting functions, in this case using\n    # log scaling in Y, as dictated by the typical meteorological plot\n    ax.semilogy(T, p, color=\\'C3\\')\n    ax.semilogy(Td, p, color=\\'C2\\')\n\n    # An example of a slanted line at constant X\n    l = ax.axvline(0, color=\\'C0\\')\n\n    # Disables the log-formatting that comes with semilogy\n    ax.yaxis.set_major_formatter(ScalarFormatter())\n    ax.yaxis.set_minor_formatter(NullFormatter())\n    ax.set_yticks(np.linspace(100, 1000, 10))\n    ax.set_ylim(1050, 100)\n\n    ax.xaxis.set_major_locator(MultipleLocator(10))\n    ax.set_xlim(-50, 50)\n\n    plt.show()\n",
    "id": 437
},
{
    "title": "Topographic hillshading#",
    "text": "Demonstrates the visual effect of varying blend mode and vertical exaggeration\non \"hillshaded\" plots. Note that the \"overlay\" and \"soft\" blend modes work well for complex surfaces\nsuch as this example, while the default \"hsv\" blend mode works best for smooth\nsurfaces such as many mathematical functions. In most cases, hillshading is used purely for visual purposes, and dx/dy\ncan be safely ignored. In that case, you can tweak vert_exag (vertical\nexaggeration) by trial and error to give the desired visual effect. However,\nthis example demonstrates how to use the dx and dy keyword arguments to\nensure that the vert_exag parameter is the true vertical exaggeration. Total running time of the script: (0 minutes 1.734 seconds) Download Python source code: topographic_hillshading.py Download Jupyter notebook: topographic_hillshading.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.cbook import get_sample_data\nfrom matplotlib.colors import LightSource\n\ndem = get_sample_data('jacksboro_fault_dem.npz')\nz = demelevation\n# -- Optional dx and dy for accurate vertical exaggeration --------------------\n# If you need topographically accurate vertical exaggeration, or you don't want\n# to guess at what *vert_exag* should be, you'll need to specify the cellsize\n# of the grid (i.e. the *dx* and *dy* parameters).  Otherwise, any *vert_exag*\n# value you specify will be relative to the grid spacing of your input data\n# (in other words, *dx* and *dy* default to 1.0, and *vert_exag* is calculated\n# relative to those parameters).  Similarly, *dx* and *dy* are assumed to be in\n# the same units as your input z-values.  Therefore, we'll need to convert the\n# given dx and dy from decimal degrees to meters.\ndx, dy = demdx, demdy\ndy = 111200 * dy\ndx = 111200 * dx * np.cos(np.radians(demymin))\n# -----------------------------------------------------------------------------\n\n# Shade from the northwest, with the sun 45 degrees from horizontal\nls = LightSource(azdeg=315, altdeg=45)\ncmap = plt.cm.gist_earth\n\nfig, axs = plt.subplots(nrows=4, ncols=3, figsize=(8, 9))\nplt.setp(axs.flat, xticks=[], yticks=[])\n\n# Vary vertical exaggeration and blend mode and plot all combinations\nfor col, ve in zip(axs.T, [0.1, 1, 10]):\n    # Show the hillshade intensity image in the first row\n    col[0].imshow(ls.hillshade(z, vert_exag=ve, dx=dx, dy=dy), cmap='gray')\n\n    # Place hillshaded plots with different blend modes in the rest of the rows\n    for ax, mode in zip(col[1:], hsv overlay soft):\n        rgb = ls.shade(z, cmap=cmap, blend_mode=mode,\n                       vert_exag=ve, dx=dx, dy=dy)\n        ax.imshow(rgb)\n\n# Label rows and columns\nfor ax, ve in zip(axs[0], [0.1, 1, 10]):\n    ax.set_title(f'{ve}', size=18)\nfor ax, mode in zip(axs[:, 0], Hillshade hsv overlay soft):\n    ax.set_ylabel(mode, size=18)\n\n# Group labels...\naxs[0, 1].annotate('Vertical Exaggeration', (0.5, 1), xytext=(0, 30),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='center', va='bottom', size=20)\naxs[2, 0].annotate('Blend Mode', (0, 0.5), xytext=(-30, 0),\n                   textcoords='offset points', xycoords='axes fraction',\n                   ha='right', va='center', size=20, rotation=90)\nfig.subplots_adjust(bottom=0.05, right=0.95)\n\nplt.show()\n",
    "id": 438
},
{
    "title": "Spines#",
    "text": "This demo compares: normal Axes, with spines on all four sides; an Axes with spines only on the left and bottom; an Axes using custom bounds to limit the extent of the spine. Each axes.Axes has a list of Spine objects, accessible\nvia the container ax.spines. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.artist.Artist.set_visible matplotlib.spines.Spine.set_bounds Download Python source code: spines.py Download Jupyter notebook: spines.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 2 * np.pi, 100)\ny = 2 * np.sin(x)\n\n# Constrained layout makes sure the labels don't overlap the axes.\nfig, (ax0, ax1, ax2) = plt.subplots(nrows=3, layout='constrained')\n\nax0.plot(x, y)\nax0.set_title('normal spines')\n\nax1.plot(x, y)\nax1.set_title('bottom-left spines')\n\n# Hide the right and top spines\nax1.spines.right.set_visible(False)\nax1.spines.top.set_visible(False)\n\nax2.plot(x, y)\nax2.set_title('spines with bounds limited to data range')\n\n# Only draw spines for the data range, not in the margins\nax2.spines.bottom.set_bounds(x.min(), x.max())\nax2.spines.left.set_bounds(y.min(), y.max())\n# Hide the right and top spines\nax2.spines.right.set_visible(False)\nax2.spines.top.set_visible(False)\n\nplt.show()\n",
    "id": 440
},
{
    "title": "Spine placement#",
    "text": "The position of the axis spines can be influenced using set_position. Note: If you want to obtain arrow heads at the ends of the axes, also check\nout the Centered spines with arrows example. Download Python source code: spine_placement_demo.py Download Jupyter notebook: spine_placement_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n x = np.linspace(0, 2*np.pi, 100)\ny = 2 * np.sin(x)\n\nfig, ax_dict = plt.subplot_mosaic(\n    [[\\'center\\', \\'zero\\,\n     [\\'axes\\', \\'data\\]\n)\nfig.suptitle(\\'Spine positions\\')\n\n\nax = ax_dict[\\'center\\\nax.set_title(\"\\'center\\'\")\nax.plot(x, y)\nax.spines[[\\'left\\', \\'bottom\\].set_position(\\'center\\')\nax.spines[[\\'top\\', \\'right\\].set_visible(False)\n\nax = ax_dict[\\'zero\\\nax.set_title(\"\\'zero\\'\")\nax.plot(x, y)\nax.spines[[\\'left\\', \\'bottom\\].set_position(\\'zero\\')\nax.spines[[\\'top\\', \\'right\\].set_visible(False)\n\nax = ax_dict[\\'axes\\\nax.set_title(\"\\'axes\\' (0.2, 0.2)\")\nax.plot(x, y)\nax.spines.left.set_position((\\'axes\\', 0.2))\nax.spines.bottom.set_position((\\'axes\\', 0.2))\nax.spines[[\\'top\\', \\'right\\].set_visible(False)\n\nax = ax_dict[\\'data\\\nax.set_title(\"\\'data\\' (1, 2)\")\nax.plot(x, y)\nax.spines.left.set_position((\\'data\\', 1))\nax.spines.bottom.set_position((\\'data\\', 2))\nax.spines[[\\'top\\', \\'right\\].set_visible(False)\n\nplt.show()\n",
    "id": 441
},
{
    "title": "Dropped spines#",
    "text": "Demo of spines offset from the axes (a.k.a. \"dropped spines\"). Download Python source code: spines_dropped.py Download Jupyter notebook: spines_dropped.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef adjust_spines(ax, visible_spines):\n    ax.label_outer(remove_inner_ticks=True)\n    ax.grid(color='0.9')\n\n    for loc, spine in ax.spines.items():\n        if loc in visible_spines:\n            spine.set_position(('outward', 10))  # outward by 10 points\n        else:\n            spine.set_visible(False)\n\n\nx = np.linspace(0, 2 * np.pi, 100)\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].plot(x, np.sin(x))\naxs[0, 1].plot(x, np.cos(x))\naxs[1, 0].plot(x, -np.cos(x))\naxs[1, 1].plot(x, -np.sin(x))\n\nadjust_spines(axs[0, 0], left)\nadjust_spines(axs[0, 1], [])\nadjust_spines(axs[1, 0], left bottom)\nadjust_spines(axs[1, 1], bottom)\n\nplt.show()\n",
    "id": 442
},
{
    "title": "Multiple y-axis with Spines#",
    "text": "Create multiple y axes with a shared x-axis. This is done by creating\na twinx axes, turning all spines but the right one invisible\nand offset its position using set_position. Note that this approach uses matplotlib.axes.Axes and their\nSpines. Alternative approaches using non-standard axes\nare shown in the Parasite Axes demo and\nParasite axis demo examples. Download Python source code: multiple_yaxis_with_spines.py Download Jupyter notebook: multiple_yaxis_with_spines.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(right=0.75)\n\ntwin1 = ax.twinx()\ntwin2 = ax.twinx()\n\n# Offset the right spine of twin2.  The ticks and label have already been\n# placed on the right by twinx above.\ntwin2.spines.right.set_position((\"axes\", 1.2))\n\np1, = ax.plot([0, 1, 2], [0, 1, 2], \"C0\", label=\"Density\")\np2, = twin1.plot([0, 1, 2], [0, 3, 2], \"C1\", label=\"Temperature\")\np3, = twin2.plot([0, 1, 2], [50, 30, 15], \"C2\", label=\"Velocity\")\n\nax.set(xlim=(0, 2), ylim=(0, 2), xlabel=\"Distance\", ylabel=\"Density\")\ntwin1.set(ylim=(0, 4), ylabel=\"Temperature\")\ntwin2.set(ylim=(1, 65), ylabel=\"Velocity\")\n\nax.yaxis.label.set_color(p1.get_color())\ntwin1.yaxis.label.set_color(p2.get_color())\ntwin2.yaxis.label.set_color(p3.get_color())\n\nax.tick_params(axis=\\'y\\', colors=p1.get_color())\ntwin1.tick_params(axis=\\'y\\', colors=p2.get_color())\ntwin2.tick_params(axis=\\'y\\', colors=p3.get_color())\n\nax.legend(handles=[p1, p2, p3])\n\nplt.show()\n",
    "id": 443
},
{
    "title": "Centered spines with arrows#",
    "text": "This example shows a way to draw a \"math textbook\" style plot, where the\nspines (\"axes lines\") are drawn at x = 0 and y = 0, and have arrows at\ntheir ends. Download Python source code: centered_spines_with_arrows.py Download Jupyter notebook: centered_spines_with_arrows.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots()\n# Move the left and bottom spines to x = 0 and y = 0, respectively.\nax.spines[left\", \"bottom].set_position((\"data\", 0))\n# Hide the top and right spines.\nax.spines[top\", \"right].set_visible(False)\n\n# Draw arrows (as black triangles: \">k\"/\"^k\") at the end of the axes.  In each\n# case, one of the coordinates (0) is a data coordinate (i.e., y = 0 or x = 0,\n# respectively) and the other one (1) is an axes coordinate (i.e., at the very\n# right/top of the axes).  Also, disable clipping (clip_on=False) as the marker\n# actually spills out of the axes.\nax.plot(1, 0, \">k\", transform=ax.get_yaxis_transform(), clip_on=False)\nax.plot(0, 1, \"^k\", transform=ax.get_xaxis_transform(), clip_on=False)\n\n# Some sample data.\nx = np.linspace(-0.5, 1., 100)\nax.plot(x, np.sin(x*np.pi))\n\nplt.show()\n",
    "id": 444
},
{
    "title": "Automatically setting tick positions#",
    "text": "Setting the behavior of tick auto-placement. By default, Matplotlib will choose the number of ticks and tick positions so\nthat there is a reasonable number of ticks on the axis and they are located\nat \"round\" numbers. As a result, there may be no ticks on the edges of the plot. If you want to keep ticks at round numbers, and also have ticks at the edges\nyou can switch rcParamsaxes.autolimit_mode (default: \\'data\\') to \\'round_numbers\\'. This expands the\naxis limits to the next round number. The round numbers autolimit_mode is still respected if you set an additional\nmargin around the data using Axes.set_xmargin / Axes.set_ymargin: Download Python source code: auto_ticks.py Download Jupyter notebook: auto_ticks.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\ndots = np.linspace(0.3, 1.2, 10)\nX, Y = np.meshgrid(dots, dots)\nx, y = X.ravel(), Y.ravel()\nax.scatter(x, y, c=x+y)\nplt.show()\n', \"plt.rcParamsaxes.autolimit_mode = 'round_numbers'\n\n# Note: The limits are calculated at draw-time. Therefore, when using\n# :rc:`axes.autolimit_mode` in a context manager, it is important that\n# the ``show()`` command is within the context.\n\nfig, ax = plt.subplots()\nax.scatter(x, y, c=x+y)\nplt.show()\n\", 'fig, ax = plt.subplots()\nax.scatter(x, y, c=x+y)\nax.set_xmargin(0.8)\nplt.show()\n",
    "id": 446
},
{
    "title": "Centering labels between ticks#",
    "text": "Ticklabels are aligned relative to their associated tick. The alignment\n'center left', or 'right' can be controlled using the horizontal alignment\nproperty:\", 'However, there is no direct way to center the labels between ticks. To fake\nthis behavior, one can place a label on the minor ticks in between the major\nticks, and hide the major tick labels and minor ticks. Here is an example that labels the months, centered between the ticks. Download Python source code: centered_ticklabels.py Download Jupyter notebook: centered_ticklabels.ipynb ",
    "code": "for label in ax.get_xticklabels():\n    label.set_horizontalalignment('right')\n\", 'import matplotlib.pyplot as plt\n\nimport matplotlib.cbook as cbook\nimport matplotlib.dates as dates\nimport matplotlib.ticker as ticker\n\n# Load some financial data; Google\\'s stock price\nr = cbook.get_sample_data(\\'goog.npz\\')[\\'price_data\\\nr = r[-250:]  # get the last 250 days\n\nfig, ax = plt.subplots()\nax.plot(rdate, radj_close)\n\nax.xaxis.set_major_locator(dates.MonthLocator())\n# 16 is a slight approximation since months differ in number of days.\nax.xaxis.set_minor_locator(dates.MonthLocator(bymonthday=16))\n\nax.xaxis.set_major_formatter(ticker.NullFormatter())\nax.xaxis.set_minor_formatter(dates.DateFormatter(\\'%b\\'))\n\n# Remove the tick lines\nax.tick_params(axis=\\'x\\', which=\\'minor\\', tick1On=False, tick2On=False)\n\n# Align the minor tick label\nfor label in ax.get_xticklabels(minor=True):\n    label.set_horizontalalignment(\\'center\\')\nimid = len(r) // 2\nax.set_xlabel(str(rdate[imid].item().year))\nplt.show()\n",
    "id": 447
},
{
    "title": "Colorbar Tick Labelling#",
    "text": "Vertical colorbars have ticks, tick labels, and labels visible on the y axis,\nhorizontal colorbars on the x axis. The ticks parameter can be used to\nset the ticks and the format parameter can be used to format the tick labels\nof the visible colorbar axes. For further adjustments, the yaxis or\nxaxis axes of the colorbar can be retrieved using its ax property. Make plot with vertical (default) colorbar Make plot with horizontal colorbar References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.colorbar.Colorbar.set_ticks matplotlib.figure.Figure.colorbar / matplotlib.pyplot.colorbar Total running time of the script: (0 minutes 1.015 seconds) Download Python source code: colorbar_tick_labelling_demo.py Download Jupyter notebook: colorbar_tick_labelling_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as mticker\n\n# Fixing random state for reproducibility\nrng = np.random.default_rng(seed=19680801)\n', \"fig, ax = plt.subplots()\n\ndata = rng.standard_normal((250, 250))\n\ncax = ax.imshow(data, vmin=-1, vmax=1, cmap='coolwarm')\nax.set_title('Gaussian noise with vertical colorbar')\n\n# Add colorbar, make sure to specify tick locations to match desired ticklabels\ncbar = fig.colorbar(cax,\n                    ticks=[-1, 0, 1],\n                    format=mticker.FixedFormatter(< -1 0 > 1),\n                    extend='both'\n                    )\nlabels = cbar.ax.get_yticklabels()\nlabels[0].set_verticalalignment('top')\nlabels[-1].set_verticalalignment('bottom')\n\", \"fig, ax = plt.subplots()\n\ndata = np.clip(data, -1, 1)\n\ncax = ax.imshow(data, cmap='afmhot')\nax.set_title('Gaussian noise with horizontal colorbar')\n\n# Add colorbar and adjust ticks afterwards\ncbar = fig.colorbar(cax, orientation='horizontal')\ncbar.set_ticks(ticks=[-1, 0, 1], labels=Low Medium High)\n\nplt.show()\n",
    "id": 448
},
{
    "title": "Custom Ticker#",
    "text": "The matplotlib.ticker module defines many preset tickers, but was\nprimarily designed for extensibility, i.e., to support user customized ticking. In this example, a user defined function is used to format the ticks in\nmillions of dollars on the y-axis. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axis.Axis.set_major_formatter Download Python source code: custom_ticker1.py Download Jupyter notebook: custom_ticker1.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef millions(x, pos):\n    \"\"\"The two arguments are the value and tick position.\"\"\"\n    return f\\'${x*1e-6:1.1f}M\\'\n\n\nfig, ax = plt.subplots()\n# set_major_formatter internally creates a FuncFormatter from the callable.\nax.yaxis.set_major_formatter(millions)\nmoney = [1.5e5, 2.5e6, 5.5e6, 2.0e7]\nax.bar([\\'Bill\\', \\'Fred\\', \\'Mary\\', \\'Sue\\, money)\nplt.show()\n",
    "id": 449
},
{
    "title": "Formatting date ticks using ConciseDateFormatter#",
    "text": "Finding good tick values and formatting the ticks for an axis that\nhas date data is often a challenge. ConciseDateFormatter is\nmeant to improve the strings chosen for the ticklabels, and to minimize\nthe strings used in those tick labels as much as possible. Note This formatter is a candidate to become the default date tick formatter\nin future versions of Matplotlib. Please report any issues or\nsuggestions for improvement to the GitHub repository or mailing list. First, the default formatter. The default date formatter is quite verbose, so we have the option of\nusing ConciseDateFormatter, as shown below. Note that\nfor this example the labels do not need to be rotated as they do for the\ndefault formatter because the labels are as small as possible. If all calls to axes that have dates are to be made using this converter,\nit is probably most convenient to use the units registry where you do\nimports: Dates formats can be localized if the default formats are not desirable by\nmanipulating one of three lists of strings. The formatter.formats list of formats is for the normal tick labels,\nThere are six levels: years, months, days, hours, minutes, seconds.\nThe formatter.offset_formats is how the \"offset\" string on the right\nof the axis is formatted. This is usually much more verbose than the tick\nlabels. Finally, the formatter.zero_formats are the formats of the\nticks that are \"zeros\". These are tick values that are either the first of\nthe year, month, or day of month, or the zeroth hour, minute, or second.\nThese are usually the same as the format of\nthe ticks a level above. For example if the axis limits mean the ticks are\nmostly days, then we label 1 Mar 2005 simply with a \"Mar\". If the axis\nlimits are mostly hours, we label Feb 4 00:00 as simply \"Feb-4\". Note that these format lists can also be passed to ConciseDateFormatter\nas optional keyword arguments. Here we modify the labels to be \"day month year\", instead of the ISO\n\"year month day\":', \"ConciseDateFormatter doesn't have rcParams entries, but localization can\nbe accomplished by passing keyword arguments to ConciseDateConverter and\nregistering the datatypes you will use with the units registry:\", 'Total running time of the script: (0 minutes 3.303 seconds) Download Python source code: date_concise_formatter.py Download Jupyter notebook: date_concise_formatter.ipynb ",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n', \"base = datetime.datetime(2005, 2, 1)\ndates = [base + datetime.timedelta(hours=(2 * i)) for i in range(732)]\nN = len(dates)\nnp.random.seed(19680801)\ny = np.cumsum(np.random.randn(N))\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nlims = [(np.datetime64('2005-02'), np.datetime64('2005-04')),\n        (np.datetime64('2005-02-03'), np.datetime64('2005-02-15')),\n        (np.datetime64('2005-02-03 11:00'), np.datetime64('2005-02-04 13:20'))]\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\n    # rotate_labels...\n    for label in ax.get_xticklabels():\n        label.set_rotation(40)\n        label.set_horizontalalignment('right')\naxs[0].set_title('Default Date Formatter')\nplt.show()\n\", \"fig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nfor nn, ax in enumerate(axs):\n    locator = mdates.AutoDateLocator(minticks=3, maxticks=7)\n    formatter = mdates.ConciseDateFormatter(locator)\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\", \"import matplotlib.units as munits\n\nconverter = mdates.ConciseDateConverter()\nmunits.registry[np.datetime64] = converter\nmunits.registry[datetime.date] = converter\nmunits.registry[datetime.datetime] = converter\n\nfig, axs = plt.subplots(3, 1, figsize=(6, 6), layout='constrained')\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\", \"fig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\n\nfor nn, ax in enumerate(axs):\n    locator = mdates.AutoDateLocator()\n    formatter = mdates.ConciseDateFormatter(locator)\n    formatter.formats = %y',  # ticks are mostly years\n                         '%b',       # ticks are mostly months\n                         '%d',       # ticks are mostly days\n                         '%H:%M',    # hrs\n                         '%H:%M',    # min\n                         '%S.%f', ]  # secs\n    # these are mostly just the level above...\n    formatter.zero_formats =  + formatter.formats[:-1]\n    # ...except for ticks that are mostly hours, then it is nice to have\n    # month-day:\n    formatter.zero_formats[3] = '%d-%b'\n\n    formatter.offset_formats = ',\n                                '%Y',\n                                '%b %Y',\n                                '%d %b %Y',\n                                '%d %b %Y',\n                                '%d %b %Y %H:%M', ]\n    ax.xaxis.set_major_locator(locator)\n    ax.xaxis.set_major_formatter(formatter)\n\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter')\n\nplt.show()\n\", \"import datetime\n\nformats = %y',          # ticks are mostly years\n           '%b',     # ticks are mostly months\n           '%d',     # ticks are mostly days\n           '%H:%M',  # hrs\n           '%H:%M',  # min\n           '%S.%f', ]  # secs\n# these can be the same, except offset by one level....\nzero_formats =  + formats[:-1]\n# ...except for ticks that are mostly hours, then it's nice to have month-day\nzero_formats[3] = '%d-%b'\noffset_formats = ',\n                  '%Y',\n                  '%b %Y',\n                  '%d %b %Y',\n                  '%d %b %Y',\n                  '%d %b %Y %H:%M', ]\n\nconverter = mdates.ConciseDateConverter(\n    formats=formats, zero_formats=zero_formats, offset_formats=offset_formats)\n\nmunits.registry[np.datetime64] = converter\nmunits.registry[datetime.date] = converter\nmunits.registry[datetime.datetime] = converter\n\nfig, axs = plt.subplots(3, 1, layout='constrained', figsize=(6, 6))\nfor nn, ax in enumerate(axs):\n    ax.plot(dates, y)\n    ax.set_xlim(lims[nn])\naxs[0].set_title('Concise Date Formatter registered non-default')\n\nplt.show()\n",
    "id": 450
},
{
    "title": "Date Demo Convert#",
    "text": "Download Python source code: date_demo_convert.py Download Jupyter notebook: date_demo_convert.ipynb ",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import DateFormatter, DayLocator, HourLocator, drange\n\ndate1 = datetime.datetime(2000, 3, 2)\ndate2 = datetime.datetime(2000, 3, 6)\ndelta = datetime.timedelta(hours=6)\ndates = drange(date1, date2, delta)\n\ny = np.arange(len(dates))\n\nfig, ax = plt.subplots()\nax.plot(dates, y**2, 'o')\n\n# this is superfluous, since the autoscaler should get it right, but\n# use date2num and num2date to convert between dates and floats if\n# you want; both date2num and num2date convert an instance or sequence\nax.set_xlim(dates[0], dates[-1])\n\n# The hour locator takes the hour or sequence of hours you want to\n# tick, not the base multiple\n\nax.xaxis.set_major_locator(DayLocator())\nax.xaxis.set_minor_locator(HourLocator(range(0, 25, 6)))\nax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))\n\nax.fmt_xdata = DateFormatter('%Y-%m-%d %H:%M:%S')\nfig.autofmt_xdate()\n\nplt.show()\n",
    "id": 451
},
{
    "title": "Placing date ticks using recurrence rules#",
    "text": "The iCalender RFC specifies recurrence rules (rrules), that define\ndate sequences. You can use rrules in Matplotlib to place date ticks. This example sets custom date ticks on every 5th easter. See https://dateutil.readthedocs.io/en/stable/rrule.html for help with rrules. Download Python source code: date_demo_rrule.py Download Jupyter notebook: date_demo_rrule.ipynb ",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (YEARLY, DateFormatter, RRuleLocator, drange,\n                              rrulewrapper)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n\n# tick every 5th easter\nrule = rrulewrapper(YEARLY, byeaster=1, interval=5)\nloc = RRuleLocator(rule)\nformatter = DateFormatter('%m/%d/%y')\ndate1 = datetime.date(1952, 1, 1)\ndate2 = datetime.date(2004, 4, 12)\ndelta = datetime.timedelta(days=100)\n\ndates = drange(date1, date2, delta)\ns = np.random.rand(len(dates))  # make up some random y values\n\n\nfig, ax = plt.subplots()\nplt.plot(dates, s, 'o')\nax.xaxis.set_major_locator(loc)\nax.xaxis.set_major_formatter(formatter)\nax.xaxis.set_tick_params(rotation=30, labelsize=10)\n\nplt.show()\n",
    "id": 452
},
{
    "title": "Date tick locators and formatters#",
    "text": "This example illustrates the usage and effect of the various date locators and\nformatters. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.dates.AutoDateLocator matplotlib.dates.YearLocator matplotlib.dates.MonthLocator matplotlib.dates.DayLocator matplotlib.dates.WeekdayLocator matplotlib.dates.HourLocator matplotlib.dates.MinuteLocator matplotlib.dates.SecondLocator matplotlib.dates.MicrosecondLocator matplotlib.dates.RRuleLocator matplotlib.dates.rrulewrapper matplotlib.dates.DateFormatter matplotlib.dates.AutoDateFormatter matplotlib.dates.ConciseDateFormatter Total running time of the script: (0 minutes 1.758 seconds) Download Python source code: date_formatters_locators.py Download Jupyter notebook: date_formatters_locators.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.dates import (FR, MO, MONTHLY, SA, SU, TH, TU, WE,\n                              AutoDateFormatter, AutoDateLocator,\n                              ConciseDateFormatter, DateFormatter, DayLocator,\n                              HourLocator, MicrosecondLocator, MinuteLocator,\n                              MonthLocator, RRuleLocator, SecondLocator,\n                              WeekdayLocator, YearLocator, rrulewrapper)\nimport matplotlib.ticker as ticker\n\n\ndef plot_axis(ax, locator=None, xmax=\\'2002-02-01\\', fmt=None, formatter=None):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    ax.spines[[\\'left\\', \\'right\\', \\'top\\].set_visible(False)\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.tick_params(which=\\'major\\', width=1.00, length=5)\n    ax.tick_params(which=\\'minor\\', width=0.75, length=2.5)\n    ax.set_xlim(np.datetime64(\\'2000-02-01\\'), np.datetime64(xmax))\n    if locator:\n        ax.xaxis.set_major_locator(eval(locator))\n        ax.xaxis.set_major_formatter(DateFormatter(fmt))\n    else:\n        ax.xaxis.set_major_formatter(eval(formatter))\n    ax.text(0.0, 0.2, locator or formatter, transform=ax.transAxes,\n            fontsize=14, fontname=\\'Monospace\\', color=\\'tab:blue\\')\n', \"locators = [\n    # locator as str, xmax, fmt\n    ('AutoDateLocator(maxticks=8) 2003-02-01 %Y-%m'),\n    ('YearLocator(month=4) 2003-02-01 %Y-%m'),\n    ('MonthLocator(bymonth=[4, 8, 12]) 2003-02-01 %Y-%m'),\n    ('DayLocator(interval=180) 2003-02-01 %Y-%m-%d'),\n    ('WeekdayLocator(byweekday=SU, interval=4) 2000-07-01 %a %Y-%m-%d'),\n    ('HourLocator(byhour=range(0, 24, 6)) 2000-02-04 %H h'),\n    ('MinuteLocator(interval=15) 2000-02-01 02:00 %H:%M'),\n    ('SecondLocator(bysecond=(0, 30)) 2000-02-01 00:02 %H:%M:%S'),\n    ('MicrosecondLocator(interval=1000) 2000-02-01 00:00:00.005 %S.%f'),\n    ('RRuleLocator(rrulewrapper(freq=MONTHLY, \\\nbyweekday=(MO, TU, WE, TH, FR), '\n     'bysetpos=-1)) 2000-07-01 %Y-%m-%d'),\n]\n\nfig, axs = plt.subplots(len(locators), 1, figsize=(8, len(locators) * .8),\n                        layout='constrained')\nfig.suptitle('Date Locators')\nfor ax, (locator, xmax, fmt) in zip(axs, locators):\n    plot_axis(ax, locator, xmax, fmt)\n\", 'formatters = [\n    \\'AutoDateFormatter(ax.xaxis.get_major_locator())\\',\n    \\'ConciseDateFormatter(ax.xaxis.get_major_locator())\\',\n    \\'DateFormatter(\"%b %Y\")\\',\n]\n\nfig, axs = plt.subplots(len(formatters), 1, figsize=(8, len(formatters) * .8),\n                        layout=\\'constrained\\')\nfig.suptitle(\\'Date Formatters\\')\nfor ax, fmt in zip(axs, formatters):\n    plot_axis(ax, formatter=fmt)\n",
    "id": 453
},
{
    "title": "Custom tick formatter for time series#",
    "text": "When plotting daily data, e.g., financial time series, one often wants\nto leave out days on which there is no data, for instance weekends, so that\nthe data are plotted at regular intervals without extra spaces for the days\nwith no data.\nThe example shows how to use an 'index formatter' to achieve the desired plot.\", 'Instead of passing a function into Axis.set_major_formatter you can use\nany other callable, e.g. an instance of a class that implements __call__: Download Python source code: date_index_formatter.py Download Jupyter notebook: date_index_formatter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.cbook as cbook\nfrom matplotlib.dates import DateFormatter, DayLocator\nimport matplotlib.lines as ml\nfrom matplotlib.ticker import Formatter\n\n# Load a structured numpy array from yahoo csv data with fields date, open, high,\n# low, close, volume, adj_close from the mpl-data/sample_data directory. The\n# record array stores the date as an np.datetime64 with a day unit (\\'D\\') in\n# the date column (``r[\\'date\\``).\nr = cbook.get_sample_data(\\'goog.npz\\')[\\'price_data\\\nr = r[:9]  # get the first 9 days\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 6), layout=\\'constrained\\')\nfig.get_layout_engine().set(hspace=0.15)\n\n# First we\\'ll do it the default way, with gaps on weekends\nax1.plot(rdate, radj_close, \\'o-\\')\n\n# Highlight gaps in daily data\ngaps = np.flatnonzero(np.diff(rdate) > np.timedelta64(1, \\'D\\'))\nfor gap in r[[\\'date\\', \\'adj_close\\][np.stack((gaps, gaps + 1)).T]:\n    ax1.plot(gap[\\'date\\, gap[\\'adj_close\\, \\'w--\\', lw=2)\nax1.legend(handles=[ml.Line2D([], [], ls=\\'--\\', label=\\'Gaps in daily data\\')])\n\nax1.set_title(\"Plot y at x Coordinates\")\nax1.xaxis.set_major_locator(DayLocator())\nax1.xaxis.set_major_formatter(DateFormatter(\\'%a\\'))\n\n\n# Next we\\'ll write a custom index formatter. Below we will plot\n# the data against an index that goes from 0, 1,  ... len(data).  Instead of\n# formatting the tick marks as integers, we format as times.\ndef format_date(x, _):\n    try:\n        # convert datetime64 to datetime, and use datetime\\'s strftime:\n        return rdate[round(x)].item().strftime(\\'%a\\')\n    except IndexError:\n        pass\n\n# Create an index plot (x defaults to range(len(y)) if omitted)\nax2.plot(radj_close, \\'o-\\')\n\nax2.set_title(\"Plot y at Index Coordinates Using Custom Formatter\")\nax2.xaxis.set_major_formatter(format_date)  # internally creates FuncFormatter\n class MyFormatter(Formatter):\n    def __init__(self, dates, fmt=\\'%a\\'):\n        self.dates = dates\n        self.fmt = fmt\n\n    def __call__(self, x, pos=0):\n        \"\"\"Return the label for time x at position pos.\"\"\"\n        try:\n            return self.dates[round(x)].item().strftime(self.fmt)\n        except IndexError:\n            pass\n\n\nax2.xaxis.set_major_formatter(MyFormatter(rdate, \\'%a\\'))\n\nplt.show()\n",
    "id": 454
},
{
    "title": "Date Precision and Epochs#",
    "text": "Matplotlib can handle datetime objects and numpy.datetime64 objects using\na unit converter that recognizes these dates and converts them to floating\npoint numbers. Before Matplotlib 3.3, the default for this conversion returns a float that was\ndays since \"0000-12-31T00:00:00\". As of Matplotlib 3.3, the default is\ndays from \"1970-01-01T00:00:00\". This allows more resolution for modern\ndates. \"2020-01-01\" with the old epoch converted to 730120, and a 64-bit\nfloating point number has a resolution of 2^{-52}, or approximately\n14 microseconds, so microsecond precision was lost. With the new default\nepoch \"2020-01-01\" is 10957.0, so the achievable resolution is 0.21\nmicroseconds. Python datetime objects have microsecond resolution, so with the\nold default matplotlib dates could not round-trip full-resolution datetime\nobjects. Note this is only a round-off error, and there is no problem for\ndates closer to the old epoch: If a user wants to use modern dates at microsecond precision, they\ncan change the epoch using set_epoch. However, the epoch has to be\nset before any date operations to prevent confusion between different\nepochs. Trying to change the epoch later will raise a RuntimeError. For this tutorial, we reset the sentinel using a private method, but users\nshould just set the epoch once, if at all. numpy.datetime64 objects have microsecond precision for a much larger\ntimespace than datetime objects. However, currently Matplotlib time is\nonly converted back to datetime objects, which have microsecond resolution,\nand years that only span 0000 to 9999. This all of course has an effect on plotting. With the old default epoch\nthe times were rounded during the internal date2num conversion, leading\nto jumps in the data: For dates plotted using the more recent epoch, the plot is smooth: References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.dates.num2date matplotlib.dates.date2num matplotlib.dates.set_epoch Download Python source code: date_precision_and_epochs.py Download Jupyter notebook: date_precision_and_epochs.ipynb ",
    "code": "import datetime\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.dates as mdates\n\n\ndef _reset_epoch_for_tutorial():\n    \"\"\"\n    Users (and downstream libraries) should not use the private method of\n    resetting the epoch.\n    \"\"\"\n    mdates._reset_epoch_test_example()\n', \"old_epoch = '0000-12-31T00:00:00'\nnew_epoch = '1970-01-01T00:00:00'\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)  # old epoch (pre MPL 3.3)\n\ndate1 = datetime.datetime(2000, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\", 'Before Roundtrip:  2000-01-01 00:10:00.000012+00:00 Matplotlib date: 730120.0069444446\nAfter Roundtrip:   2000-01-01 00:10:00.000020+00:00\n', \"date1 = datetime.datetime(10, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\", 'Before Roundtrip:  0010-01-01 00:10:00.000012+00:00 Matplotlib date: 3288.006944444583\nAfter Roundtrip:   0010-01-01 00:10:00.000012+00:00\n', \"try:\n    mdates.set_epoch(new_epoch)  # this is the new MPL 3.3 default.\nexcept RuntimeError as e:\n    print('RuntimeError:', str(e))\n\", 'RuntimeError: set_epoch must be called before dates plotted.\n', \"_reset_epoch_for_tutorial()  # Just being done for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = datetime.datetime(2020, 1, 1, 0, 10, 0, 12,\n                          tzinfo=datetime.timezone.utc)\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\", 'Before Roundtrip:  2020-01-01 00:10:00.000012+00:00 Matplotlib date: 18262.006944444583\nAfter Roundtrip:   2020-01-01 00:10:00.000012+00:00\n', \"_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\ndate1 = np.datetime64('2000-01-01T00:10:00.000012')\nmdate1 = mdates.date2num(date1)\nprint('Before Roundtrip: ', date1, 'Matplotlib date:', mdate1)\ndate2 = mdates.num2date(mdate1)\nprint('After Roundtrip:  ', date2)\n\", 'Before Roundtrip:  2000-01-01T00:10:00.000012 Matplotlib date: 10957.006944444583\nAfter Roundtrip:   2000-01-01 00:10:00.000012+00:00\n', \"_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(old_epoch)\n\nx = np.arange('2000-01-01T00:00:00.0 2000-01-01T00:00:00.000100',\n              dtype='datetime64[us]')\n# simulate the plot being made using the old epoch\nxold = np.array([mdates.num2date(mdates.date2num(d)) for d in x])\ny = np.arange(0, len(x))\n\n# resetting the Epoch so plots are comparable\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\nmdates.set_epoch(new_epoch)\n\nfig, ax = plt.subplots(layout='constrained')\nax.plot(xold, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\", \"fig, ax = plt.subplots(layout='constrained')\nax.plot(x, y)\nax.set_title('Epoch: ' + mdates.get_epoch())\nax.xaxis.set_tick_params(rotation=40)\nplt.show()\n\n_reset_epoch_for_tutorial()  # Don't do this.  Just for this tutorial.\n",
    "id": 455
},
{
    "title": "Dollar ticks#",
    "text": "Use a FormatStrFormatter to prepend dollar signs on y-axis labels. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_tick_params matplotlib.axis.Tick matplotlib.ticker.StrMethodFormatter Download Python source code: dollar_ticks.py Download Jupyter notebook: dollar_ticks.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots()\nax.plot(100*np.random.rand(20))\n\n# Use automatic StrMethodFormatter\nax.yaxis.set_major_formatter('${x:1.2f}')\n\nax.yaxis.set_tick_params(which='major', labelcolor='green',\n                         labelleft=False, labelright=True)\n\nplt.show()\n",
    "id": 456
},
{
    "title": "Fig Axes Customize Simple#",
    "text": "Customize the background, labels and ticks of a simple plot. pyplot.figure creates a matplotlib.figure.Figure instance. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axis.Axis.get_ticklabels matplotlib.axis.Axis.get_ticklines matplotlib.text.Text.set_rotation matplotlib.text.Text.set_fontsize matplotlib.text.Text.set_color matplotlib.lines.Line2D matplotlib.lines.Line2D.set_markeredgecolor matplotlib.lines.Line2D.set_markersize matplotlib.lines.Line2D.set_markeredgewidth matplotlib.patches.Patch.set_facecolor Download Python source code: fig_axes_customize_simple.py Download Jupyter notebook: fig_axes_customize_simple.ipynb ",
    "code": "import matplotlib.pyplot as plt\n', \"fig = plt.figure()\nrect = fig.patch  # a rectangle instance\nrect.set_facecolor('lightgoldenrodyellow')\n\nax1 = fig.add_axes([0.1, 0.3, 0.4, 0.4])\nrect = ax1.patch\nrect.set_facecolor('lightslategray')\n\nax1.tick_params(axis='x', labelcolor='tab:red', labelrotation=45, labelsize=16)\nax1.tick_params(axis='y', color='tab:green', size=25, width=3)\n\nplt.show()\n",
    "id": 457
},
{
    "title": "Major and minor ticks#",
    "text": "Demonstrate how to use major and minor tickers. The two relevant classes are Locators and Formatters. Locators\ndetermine where the ticks are, and formatters control the formatting of tick\nlabels. Minor ticks are off by default (using NullLocator and NullFormatter).\nMinor ticks can be turned on without labels by setting the minor locator.\nMinor tick labels can be turned on by setting the minor formatter.', \"MultipleLocator places ticks on multiples of some base.\nStrMethodFormatter uses a format string (e.g., '{x:d}' or '{x:1.2f}'\nor '{x:1.1f} cm') to format the tick labels (the variable in the format\nstring must be 'x'). For a StrMethodFormatter, the string can be passed\ndirectly to Axis.set_major_formatter or\nAxis.set_minor_formatter. An appropriate StrMethodFormatter will\nbe created and used automatically.\", 'pyplot.grid changes the grid settings of the major ticks of the x- and\ny-axis together. If you want to control the grid of the minor ticks for a\ngiven axis, use for example Note that a given locator or formatter instance can only be used on a single\naxis (because the locator stores references to the axis data and view limits). Automatic tick selection for major and minor ticks. Use interactive pan and zoom to see how the tick intervals change. There will\nbe either 4 or 5 minor tick intervals per major interval, depending on the\nmajor interval. One can supply an argument to AutoMinorLocator to specify a fixed number\nof minor intervals per major interval, e.g. AutoMinorLocator(2) would\nlead to a single minor tick between major ticks. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_major_locator matplotlib.axis.Axis.set_minor_locator matplotlib.ticker.AutoMinorLocator matplotlib.ticker.MultipleLocator matplotlib.ticker.StrMethodFormatter Download Python source code: major_minor_demo.py Download Jupyter notebook: major_minor_demo.ipynb ",
    "code": "ax.xaxis.grid(True, which='minor')\n\", \"import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\n\nt = np.arange(0.0, 100.0, 0.1)\ns = np.sin(0.1 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n# Make a plot with major ticks that are multiples of 20 and minor ticks that\n# are multiples of 5.  Label major ticks with '.0f' formatting but don't label\n# minor ticks.  The string is used directly, the `StrMethodFormatter` is\n# created automatically.\nax.xaxis.set_major_locator(MultipleLocator(20))\nax.xaxis.set_major_formatter('{x:.0f}')\n\n# For the minor ticks, use no labels; default NullFormatter.\nax.xaxis.set_minor_locator(MultipleLocator(5))\n\nplt.show()\n\", \"t = np.arange(0.0, 100.0, 0.01)\ns = np.sin(2 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\nax.xaxis.set_minor_locator(AutoMinorLocator())\n\nax.tick_params(which='both', width=2)\nax.tick_params(which='major', length=7)\nax.tick_params(which='minor', length=4, color='r')\n\nplt.show()\n",
    "id": 458
},
{
    "title": "The default tick formatter#",
    "text": "By default, tick labels are formatted using a ScalarFormatter, which can be\nconfigured via ticklabel_format. This example illustrates some\npossible configurations: Default. useMathText=True: Fancy formatting of mathematical expressions. useOffset=False: Do not use offset notation; see\nScalarFormatter.set_useOffset. Total running time of the script: (0 minutes 1.477 seconds) Download Python source code: scalarformatter.py Download Jupyter notebook: scalarformatter.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.arange(0, 1, .01)\nfig, axs = plt.subplots(\n    3, 3, figsize=(9, 9), layout=\"constrained\", gridspec_kw={\"hspace\": 0.1})\n\nfor col in axs.T:\n    col[0].plot(x * 1e5 + 1e10, x * 1e-10 + 1e-5)\n    col[1].plot(x * 1e5, x * 1e-4)\n    col[2].plot(-x * 1e5 - 1e10, -x * 1e-5 - 1e-10)\n\nfor ax in axs[:, 1]:\n    ax.ticklabel_format(useMathText=True)\nfor ax in axs[:, 2]:\n    ax.ticklabel_format(useOffset=False)\n\nplt.rcParams.update({\"axes.titleweight\": \"bold\", \"axes.titley\": 1.1})\naxs[0, 0].set_title(\"default settings\")\naxs[0, 1].set_title(\"useMathText=True\")\naxs[0, 2].set_title(\"useOffset=False\")\n\nplt.show()\n",
    "id": 459
},
{
    "title": "Tick formatters#",
    "text": "Tick formatters define how the numeric value associated with a tick on an axis\nis formatted as a string. This example illustrates the usage and effect of the most common formatters. The tick format is configured via the function set_major_formatter\nor set_minor_formatter. It accepts: a format string, which implicitly creates a StrMethodFormatter. a function, implicitly creates a FuncFormatter. an instance of a Formatter subclass. The most common are NullFormatter: No labels on the ticks. StrMethodFormatter: Use string str.format method. FormatStrFormatter: Use %-style formatting. FuncFormatter: Define labels through a function. FixedFormatter: Set the label strings explicitly. ScalarFormatter: Default formatter for scalars: auto-pick the format string. PercentFormatter: Format labels as a percentage. See Tick formatting for a complete list. Total running time of the script: (0 minutes 1.165 seconds) Download Python source code: tick-formatters.py Download Jupyter notebook: tick-formatters.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib import ticker\n\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[[\\'left\\', \\'right\\', \\'top\\].set_visible(False)\n\n    # define tick positions\n    ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00))\n    ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25))\n\n    ax.xaxis.set_ticks_position(\\'bottom\\')\n    ax.tick_params(which=\\'major\\', width=1.00, length=5)\n    ax.tick_params(which=\\'minor\\', width=0.75, length=2.5, labelsize=10)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname=\\'Monospace\\', color=\\'tab:blue\\')\n\n\nfig = plt.figure(figsize=(8, 8), layout=\\'constrained\\')\nfig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5])\n\nfig0.suptitle(\\'String Formatting\\', fontsize=16, x=0, ha=\\'left\\')\nax0 = fig0.subplots()\n\nsetup(ax0, title=\"\\'{x} km\\'\")\nax0.xaxis.set_major_formatter(\\'{x} km\\')\n\n\nfig1.suptitle(\\'Function Formatting\\', fontsize=16, x=0, ha=\\'left\\')\nax1 = fig1.subplots()\n\nsetup(ax1, title=\"def(x, pos): return str(x-5)\")\nax1.xaxis.set_major_formatter(lambda x, pos: str(x-5))\n\n\nfig2.suptitle(\\'Formatter Object Formatting\\', fontsize=16, x=0, ha=\\'left\\')\naxs2 = fig2.subplots(7, 1)\n\nsetup(axs2[0], title=\"NullFormatter()\")\naxs2[0].xaxis.set_major_formatter(ticker.NullFormatter())\n\nsetup(axs2[1], title=\"StrMethodFormatter(\\'{x:.3f}\\')\")\naxs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:.3f}\"))\n\nsetup(axs2[2], title=\"FormatStrFormatter(\\'#%d\\')\")\naxs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter(\"#%d\"))\n\n\ndef fmt_two_digits(x, pos):\n    return f\\'[{x:.2f}]\\'\n\n\nsetup(axs2[3], title=\\'FuncFormatter(\"[{:.2f}]\".format)\\')\naxs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits))\n\nsetup(axs2[4], title=\"FixedFormatter([\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\)\")\n# FixedFormatter should only be used together with FixedLocator.\n# Otherwise, one cannot be sure where the labels will end up.\npositions = [0, 1, 2, 3, 4, 5]\nlabels = [\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\\naxs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions))\naxs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels))\n\nsetup(axs2[5], title=\"ScalarFormatter()\")\naxs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))\n\nsetup(axs2[6], title=\"PercentFormatter(xmax=5)\")\naxs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5))\n\nplt.show()\n",
    "id": 460
},
{
    "title": "Tick locators#",
    "text": "Tick locators define the position of the ticks. This example illustrates the usage and effect of the most common locators. References The following functions, methods, classes and modules are used in this example: matplotlib.axis.Axis.set_major_locator matplotlib.axis.Axis.set_minor_locator matplotlib.ticker.NullLocator matplotlib.ticker.MultipleLocator matplotlib.ticker.FixedLocator matplotlib.ticker.LinearLocator matplotlib.ticker.IndexLocator matplotlib.ticker.AutoLocator matplotlib.ticker.MaxNLocator matplotlib.ticker.LogLocator Download Python source code: tick-locators.py Download Jupyter notebook: tick-locators.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\n\n\ndef setup(ax, title):\n    \"\"\"Set up common parameters for the Axes in the example.\"\"\"\n    # only show the bottom spine\n    ax.yaxis.set_major_locator(ticker.NullLocator())\n    ax.spines[[\\'left\\', \\'right\\', \\'top\\].set_visible(False)\n\n    ax.xaxis.set_ticks_position(\\'bottom\\')\n    ax.tick_params(which=\\'major\\', width=1.00, length=5)\n    ax.tick_params(which=\\'minor\\', width=0.75, length=2.5)\n    ax.set_xlim(0, 5)\n    ax.set_ylim(0, 1)\n    ax.text(0.0, 0.2, title, transform=ax.transAxes,\n            fontsize=14, fontname=\\'Monospace\\', color=\\'tab:blue\\')\n\n\nfig, axs = plt.subplots(8, 1, figsize=(8, 6))\n\n# Null Locator\nsetup(axs[0], title=\"NullLocator()\")\naxs[0].xaxis.set_major_locator(ticker.NullLocator())\naxs[0].xaxis.set_minor_locator(ticker.NullLocator())\n\n# Multiple Locator\nsetup(axs[1], title=\"MultipleLocator(0.5, offset=0.2)\")\naxs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5, offset=0.2))\naxs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1))\n\n# Fixed Locator\nsetup(axs[2], title=\"FixedLocator([0, 1, 5])\")\naxs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5]))\naxs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4)))\n\n# Linear Locator\nsetup(axs[3], title=\"LinearLocator(numticks=3)\")\naxs[3].xaxis.set_major_locator(ticker.LinearLocator(3))\naxs[3].xaxis.set_minor_locator(ticker.LinearLocator(31))\n\n# Index Locator\nsetup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\")\naxs[4].plot([0]*5, color=\\'white\\')\naxs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25))\n\n# Auto Locator\nsetup(axs[5], title=\"AutoLocator()\")\naxs[5].xaxis.set_major_locator(ticker.AutoLocator())\naxs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator())\n\n# MaxN Locator\nsetup(axs[6], title=\"MaxNLocator(n=4)\")\naxs[6].xaxis.set_major_locator(ticker.MaxNLocator(4))\naxs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40))\n\n# Log Locator\nsetup(axs[7], title=\"LogLocator(base=10, numticks=15)\")\naxs[7].set_xlim(10**3, 10**10)\naxs[7].set_xscale(\\'log\\')\naxs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15))\n\nplt.tight_layout()\nplt.show()\n",
    "id": 461
},
{
    "title": "Set default y-axis tick labels on the right#",
    "text": "We can use rcParamsytick.labelright (default: False), rcParamsytick.right (default: False), rcParamsytick.labelleft (default: True),\nand rcParamsytick.left (default: True) to control where on the axes ticks and their labels\nappear. These properties can also be set in .matplotlib/matplotlibrc. Download Python source code: tick_label_right.py Download Jupyter notebook: tick_label_right.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParamsytick.right = plt.rcParamsytick.labelright = True\nplt.rcParamsytick.left = plt.rcParamsytick.labelleft = False\n\nx = np.arange(10)\n\nfig, (ax0, ax1) = plt.subplots(2, 1, sharex=True, figsize=(6, 6))\n\nax0.plot(x)\nax0.yaxis.tick_left()\n\n# use default parameter in rcParams, not calling tick_right()\nax1.plot(x)\n\nplt.show()\n",
    "id": 462
},
{
    "title": "Setting tick labels from a list of values#",
    "text": "Using Axes.set_xticks causes the tick labels to be set on the currently\nchosen ticks. However, you may want to allow matplotlib to dynamically\nchoose the number of ticks and their spacing. In this case it may be better to determine the tick label from the\nvalue at the tick. The following example shows how to do this. NB: The ticker.MaxNLocator is used here to ensure that the tick values\ntake integer values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.pyplot.subplots matplotlib.axis.Axis.set_major_formatter matplotlib.axis.Axis.set_major_locator matplotlib.ticker.FuncFormatter matplotlib.ticker.MaxNLocator Download Python source code: tick_labels_from_values.py Download Jupyter notebook: tick_labels_from_values.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.ticker import MaxNLocator\n\nfig, ax = plt.subplots()\nxs = range(26)\nys = range(26)\nlabels = list('abcdefghijklmnopqrstuvwxyz')\n\n\ndef format_fn(tick_val, tick_pos):\n    if int(tick_val) in xs:\n        return labels[int(tick_val)]\n    else:\n        return ''\n\n\n# A FuncFormatter is created automatically.\nax.xaxis.set_major_formatter(format_fn)\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nax.plot(xs, ys)\nplt.show()\n",
    "id": 463
},
{
    "title": "Move x-axis tick labels to the top#",
    "text": "tick_params can be used to configure the ticks. top and\nlabeltop control the visibility tick lines and labels at the top x-axis.\nTo move x-axis ticks from bottom to top, we have to activate the top ticks\nand deactivate the bottom ticks: Note If the change should be made for all future plots and not only the current\nAxes, you can adapt the respective config parameters rcParamsxtick.top (default: False) rcParamsxtick.labeltop (default: False) rcParamsxtick.bottom (default: True) rcParamsxtick.labelbottom (default: True) Download Python source code: tick_xlabel_top.py Download Jupyter notebook: tick_xlabel_top.ipynb ",
    "code": "ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)\n', \"import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)\nax.set_title('x-ticks moved to the top')\n\nplt.show()\n",
    "id": 464
},
{
    "title": "Rotating custom tick labels#",
    "text": "Demo of custom tick-labels with user-defined rotation. Download Python source code: ticklabels_rotation.py Download Jupyter notebook: ticklabels_rotation.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [1, 4, 9, 6]\nlabels = Frogs Hogs Bogs Slogs\n\nplt.plot(x, y)\n# You can specify a rotation for the tick labels in degrees or with keywords.\nplt.xticks(x, labels, rotation='vertical')\n# Pad margins so that markers don't get clipped by the axes\nplt.margins(0.2)\n# Tweak spacing to prevent clipping of tick-labels\nplt.subplots_adjust(bottom=0.15)\nplt.show()\n",
    "id": 465
},
{
    "title": "Fixing too many ticks#",
    "text": "One common cause for unexpected tick behavior is passing a list of strings\ninstead of numbers or datetime objects. This can easily happen without notice\nwhen reading in a comma-delimited text file. Matplotlib treats lists of strings\nas categorical variables\n(Plotting categorical variables), and by default\nputs one tick per category, and plots them in the order in which they are\nsupplied. If this is not desired, the solution is to convert the strings to\na numeric type as in the following examples. If x has 100 elements, all strings, then we would have 100 (unreadable)\nticks, and again the solution is to convert the strings to floats: A common case is when dates are read from a CSV file, they need to be\nconverted from strings to datetime objects to get the proper date locators\nand formatters. Total running time of the script: (0 minutes 1.113 seconds) Download Python source code: ticks_too_many.py Download Jupyter notebook: ticks_too_many.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2.5))\nx = 1 5 2 3\ny = [1, 4, 2, 3]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', color='r', labelcolor='r')\nax[0].set_xlabel('Categories')\nax[0].set_title('Ticks seem out of order / misplaced')\n\n# convert to numbers:\nx = np.asarray(x, dtype='float')\nax[1].plot(x, y, 'd')\nax[1].set_xlabel('Floats')\nax[1].set_title('Ticks as expected')\n\", \"fig, ax = plt.subplots(1, 2, figsize=(6, 2.5))\nx = [f'{xx}' for xx in np.arange(100)]\ny = np.arange(100)\nax[0].plot(x, y)\nax[0].tick_params(axis='x', color='r', labelcolor='r')\nax[0].set_title('Too many ticks')\nax[0].set_xlabel('Categories')\n\nax[1].plot(np.asarray(x, float), y)\nax[1].set_title('x converted to numbers')\nax[1].set_xlabel('Floats')\n\", \"fig, ax = plt.subplots(1, 2, layout='constrained', figsize=(6, 2.75))\nx = 2021-10-01 2021-11-02 2021-12-03 2021-09-01\ny = [0, 2, 3, 1]\nax[0].plot(x, y, 'd')\nax[0].tick_params(axis='x', labelrotation=90, color='r', labelcolor='r')\nax[0].set_title('Dates out of order')\n\n# convert to datetime64\nx = np.asarray(x, dtype='datetime64[s]')\nax[1].plot(x, y, 'd')\nax[1].tick_params(axis='x', labelrotation=90)\nax[1].set_title('x converted to datetimes')\n\nplt.show()\n",
    "id": 466
},
{
    "title": "Annotation with units#",
    "text": "The example illustrates how to create text and arrow\nannotations using a centimeter-scale plot. This example requires basic_units.py Download Python source code: annotate_with_units.py Download Jupyter notebook: annotate_with_units.ipynb ",
    "code": "from basic_units import cm\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.annotate(\"Note 01\", [0.5*cm, 0.5*cm])\n\n# xy and text both unitized\nax.annotate(\\'local max\\', xy=(3*cm, 1*cm), xycoords=\\'data\\',\n            xytext=(0.8*cm, 0.95*cm), textcoords=\\'data\\',\n            arrowprops=dict(facecolor=\\'black\\', shrink=0.05),\n            horizontalalignment=\\'right\\', verticalalignment=\\'top\\')\n\n# mixing units w/ nonunits\nax.annotate(\\'local max\\', xy=(3*cm, 1*cm), xycoords=\\'data\\',\n            xytext=(0.8, 0.95), textcoords=\\'axes fraction\\',\n            arrowprops=dict(facecolor=\\'black\\', shrink=0.05),\n            horizontalalignment=\\'right\\', verticalalignment=\\'top\\')\n\n\nax.set_xlim(0*cm, 4*cm)\nax.set_ylim(0*cm, 4*cm)\nplt.show()\n",
    "id": 468
},
{
    "title": "Artist tests#",
    "text": "Test unit support with each of the Matplotlib primitive artist types. The axis handles unit conversions and the artists keep a pointer to their axis\nparent. You must initialize the artists with the axis instance if you want to\nuse them with unit data, or else they will not know how to convert the units\nto scalars. This example requires basic_units.py Download Python source code: artist_tests.py Download Jupyter notebook: artist_tests.ipynb ",
    "code": "import random\n\nfrom basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.collections as collections\nimport matplotlib.lines as lines\nimport matplotlib.patches as patches\nimport matplotlib.text as text\n\nfig, ax = plt.subplots()\nax.xaxis.set_units(cm)\nax.yaxis.set_units(cm)\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nif 0:\n    # test a line collection\n    # Not supported at present.\n    verts = []\n    for i in range(10):\n        # a random line segment in inches\n        verts.append(zip(*inch*10*np.random.rand(2, random.randint(2, 15))))\n    lc = collections.LineCollection(verts, axes=ax)\n    ax.add_collection(lc)\n\n# test a plain-ol-line\nline = lines.Line2D([0*cm, 1.5*cm], [0*cm, 2.5*cm],\n                    lw=2, color=\\'black\\', axes=ax)\nax.add_line(line)\n\nif 0:\n    # test a patch\n    # Not supported at present.\n    rect = patches.Rectangle((1*cm, 1*cm), width=5*cm, height=2*cm,\n                             alpha=0.2, axes=ax)\n    ax.add_patch(rect)\n\n\nt = text.Text(3*cm, 2.5*cm, \\'text label\\', ha=\\'left\\', va=\\'bottom\\', axes=ax)\nax.add_artist(t)\n\nax.set_xlim(-1*cm, 10*cm)\nax.set_ylim(-1*cm, 10*cm)\n# ax.xaxis.set_units(inch)\nax.grid(True)\nax.set_title(\"Artists with units\")\nplt.show()\n",
    "id": 469
},
{
    "title": "Bar demo with units#",
    "text": "A plot using a variety of centimetre and inch conversions. This example shows\nhow default unit introspection works (ax1), how various keywords can be used to\nset the x and y units to override the defaults (ax2, ax3, ax4) and how one can\nset the xlimits using scalars (ax3, current units assumed) or units\n(conversions applied to get the numbers to current units). This example requires basic_units.py Download Python source code: bar_demo2.py Download Jupyter notebook: bar_demo2.ipynb ",
    "code": "from basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncms = cm * np.arange(0, 10, 2)\nbottom = 0 * cm\nwidth = 0.8 * cm\n\nfig, axs = plt.subplots(2, 2)\n\naxs[0, 0].bar(cms, cms, bottom=bottom)\n\naxs[0, 1].bar(cms, cms, bottom=bottom, width=width, xunits=cm, yunits=inch)\n\naxs[1, 0].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=cm)\naxs[1, 0].set_xlim(2, 6)  # scalars are interpreted in current units\n\naxs[1, 1].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=inch)\naxs[1, 1].set_xlim(2 * cm, 6 * cm)  # cm are converted to inches\n\nfig.tight_layout()\nplt.show()\n",
    "id": 470
},
{
    "title": "Group barchart with units#",
    "text": "This is the same example as\nthe barchart in\ncentimeters. This example requires basic_units.py Download Python source code: bar_unit_demo.py Download Jupyter notebook: bar_unit_demo.ipynb ",
    "code": "from basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN = 5\ntea_means = [15*cm, 10*cm, 8*cm, 12*cm, 5*cm]\ntea_std = [2*cm, 1*cm, 1*cm, 4*cm, 2*cm]\n\nfig, ax = plt.subplots()\nax.yaxis.set_units(inch)\n\nind = np.arange(N)    # the x locations for the groups\nwidth = 0.35         # the width of the bars\nax.bar(ind, tea_means, width, bottom=0*cm, yerr=tea_std, label='Tea')\n\ncoffee_means = (14*cm, 19*cm, 7*cm, 5*cm, 10*cm)\ncoffee_std = (3*cm, 5*cm, 2*cm, 1*cm, 2*cm)\nax.bar(ind + width, coffee_means, width, bottom=0*cm, yerr=coffee_std,\n       label='Coffee')\n\nax.set_title('Cup height by group and beverage choice')\nax.set_xticks(ind + width / 2, labels=G1 G2 G3 G4 G5)\n\nax.legend()\nax.autoscale_view()\n\nplt.show()\n",
    "id": 471
},
{
    "title": "Basic Units#",
    "text": "Download Python source code: basic_units.py Download Jupyter notebook: basic_units.ipynb ",
    "code": "import math\n\nfrom packaging.version import parse as parse_version\n\nimport numpy as np\n\nimport matplotlib.ticker as ticker\nimport matplotlib.units as units\n\n\nclass ProxyDelegate:\n    def __init__(self, fn_name, proxy_type):\n        self.proxy_type = proxy_type\n        self.fn_name = fn_name\n\n    def __get__(self, obj, objtype=None):\n        return self.proxy_type(self.fn_name, obj)\n\n\nclass TaggedValueMeta(type):\n    def __init__(self, name, bases, dict):\n        for fn_name in self._proxies:\n            if not hasattr(self, fn_name):\n                setattr(self, fn_name,\n                        ProxyDelegate(fn_name, self._proxies[fn_name]))\n\n\nclass PassThroughProxy:\n    def __init__(self, fn_name, obj):\n        self.fn_name = fn_name\n        self.target = obj.proxy_target\n\n    def __call__(self, *args):\n        fn = getattr(self.target, self.fn_name)\n        ret = fn(*args)\n        return ret\n\n\nclass ConvertArgsProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        converted_args = []\n        for a in args:\n            try:\n                converted_args.append(a.convert_to(self.unit))\n            except AttributeError:\n                converted_args.append(TaggedValue(a, self.unit))\n        converted_args = tuple([c.get_value() for c in converted_args])\n        return super().__call__(*converted_args)\n\n\nclass ConvertReturnProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        ret = super().__call__(*args)\n        return (NotImplemented if ret is NotImplemented\n                else TaggedValue(ret, self.unit))\n\n\nclass ConvertAllProxy(PassThroughProxy):\n    def __init__(self, fn_name, obj):\n        super().__init__(fn_name, obj)\n        self.unit = obj.unit\n\n    def __call__(self, *args):\n        converted_args = []\n        arg_units = [self.unit]\n        for a in args:\n            if hasattr(a, \\'get_unit\\') and not hasattr(a, \\'convert_to\\'):\n                # If this argument has a unit type but no conversion ability,\n                # this operation is prohibited.\n                return NotImplemented\n\n            if hasattr(a, \\'convert_to\\'):\n                try:\n                    a = a.convert_to(self.unit)\n                except Exception:\n                    pass\n                arg_units.append(a.get_unit())\n                converted_args.append(a.get_value())\n            else:\n                converted_args.append(a)\n                if hasattr(a, \\'get_unit\\'):\n                    arg_units.append(a.get_unit())\n                else:\n                    arg_units.append(None)\n        converted_args = tuple(converted_args)\n        ret = super().__call__(*converted_args)\n        if ret is NotImplemented:\n            return NotImplemented\n        ret_unit = unit_resolver(self.fn_name, arg_units)\n        if ret_unit is NotImplemented:\n            return NotImplemented\n        return TaggedValue(ret, ret_unit)\n\n\nclass TaggedValue(metaclass=TaggedValueMeta):\n\n    _proxies = {\\'__add__\\': ConvertAllProxy,\n                \\'__sub__\\': ConvertAllProxy,\n                \\'__mul__\\': ConvertAllProxy,\n                \\'__rmul__\\': ConvertAllProxy,\n                \\'__cmp__\\': ConvertAllProxy,\n                \\'__lt__\\': ConvertAllProxy,\n                \\'__gt__\\': ConvertAllProxy,\n                \\'__len__\\': PassThroughProxy}\n\n    def __new__(cls, value, unit):\n        # generate a new subclass for value\n        value_class = type(value)\n        try:\n            subcls = type(f\\'TaggedValue_of_{value_class.__name__}\\',\n                          (cls, value_class), {})\n            return object.__new__(subcls)\n        except TypeError:\n            return object.__new__(cls)\n\n    def __init__(self, value, unit):\n        self.value = value\n        self.unit = unit\n        self.proxy_target = self.value\n\n    def __copy__(self):\n        return TaggedValue(self.value, self.unit)\n\n    def __getattribute__(self, name):\n        if name.startswith(\\'__\\'):\n            return object.__getattribute__(self, name)\n        variable = object.__getattribute__(self, \\'value\\')\n        if hasattr(variable, name) and name not in self.__class__.__dict__:\n            return getattr(variable, name)\n        return object.__getattribute__(self, name)\n\n    def __array__(self, dtype=object):\n        return np.asarray(self.value, dtype)\n\n    def __array_wrap__(self, array, context):\n        return TaggedValue(array, self.unit)\n\n    def __repr__(self):\n        return f\\'TaggedValue({self.value!r}, {self.unit!r})\\'\n\n    def __str__(self):\n        return f\"{self.value} in {self.unit}\"\n\n    def __len__(self):\n        return len(self.value)\n\n    if parse_version(np.__version__) >= parse_version(\\'1.20\\'):\n        def __getitem__(self, key):\n            return TaggedValue(self.value[key], self.unit)\n\n    def __iter__(self):\n        # Return a generator expression rather than use `yield`, so that\n        # TypeError is raised by iter(self) if appropriate when checking for\n        # iterability.\n        return (TaggedValue(inner, self.unit) for inner in self.value)\n\n    def get_compressed_copy(self, mask):\n        new_value = np.ma.masked_array(self.value, mask=mask).compressed()\n        return TaggedValue(new_value, self.unit)\n\n    def convert_to(self, unit):\n        if unit == self.unit or not unit:\n            return self\n        try:\n            new_value = self.unit.convert_value_to(self.value, unit)\n        except AttributeError:\n            new_value = self\n        return TaggedValue(new_value, unit)\n\n    def get_value(self):\n        return self.value\n\n    def get_unit(self):\n        return self.unit\n\n\nclass BasicUnit:\n    def __init__(self, name, fullname=None):\n        self.name = name\n        if fullname is None:\n            fullname = name\n        self.fullname = fullname\n        self.conversions = dict()\n\n    def __repr__(self):\n        return f\\'BasicUnit({self.name})\\'\n\n    def __str__(self):\n        return self.fullname\n\n    def __call__(self, value):\n        return TaggedValue(value, self)\n\n    def __mul__(self, rhs):\n        value = rhs\n        unit = self\n        if hasattr(rhs, \\'get_unit\\'):\n            value = rhs.get_value()\n            unit = rhs.get_unit()\n            unit = unit_resolver(\\'__mul__\\', (self, unit))\n        if unit is NotImplemented:\n            return NotImplemented\n        return TaggedValue(value, unit)\n\n    def __rmul__(self, lhs):\n        return self*lhs\n\n    def __array_wrap__(self, array, context):\n        return TaggedValue(array, self)\n\n    def __array__(self, t=None, context=None):\n        ret = np.array(1)\n        if t is not None:\n            return ret.astype(t)\n        else:\n            return ret\n\n    def add_conversion_factor(self, unit, factor):\n        def convert(x):\n            return x*factor\n        self.conversions[unit] = convert\n\n    def add_conversion_fn(self, unit, fn):\n        self.conversions[unit] = fn\n\n    def get_conversion_fn(self, unit):\n        return self.conversions[unit]\n\n    def convert_value_to(self, value, unit):\n        conversion_fn = self.conversions[unit]\n        ret = conversion_fn(value)\n        return ret\n\n    def get_unit(self):\n        return self\n\n\nclass UnitResolver:\n    def addition_rule(self, units):\n        for unit_1, unit_2 in zip(units[:-1], units[1:]):\n            if unit_1 != unit_2:\n                return NotImplemented\n        return units[0]\n\n    def multiplication_rule(self, units):\n        non_null = [u for u in units if u]\n        if len(non_null) > 1:\n            return NotImplemented\n        return non_null[0]\n\n    op_dict = {\n        \\'__mul__\\': multiplication_rule,\n        \\'__rmul__\\': multiplication_rule,\n        \\'__add__\\': addition_rule,\n        \\'__radd__\\': addition_rule,\n        \\'__sub__\\': addition_rule,\n        \\'__rsub__\\': addition_rule}\n\n    def __call__(self, operation, units):\n        if operation not in self.op_dict:\n            return NotImplemented\n\n        return self.op_dict[operation](self, units)\n\n\nunit_resolver = UnitResolver()\n\ncm = BasicUnit(\\'cm\\', \\'centimeters\\')\ninch = BasicUnit(\\'inch\\', \\'inches\\')\ninch.add_conversion_factor(cm, 2.54)\ncm.add_conversion_factor(inch, 1/2.54)\n\nradians = BasicUnit(\\'rad\\', \\'radians\\')\ndegrees = BasicUnit(\\'deg\\', \\'degrees\\')\nradians.add_conversion_factor(degrees, 180.0/np.pi)\ndegrees.add_conversion_factor(radians, np.pi/180.0)\n\nsecs = BasicUnit(\\'s\\', \\'seconds\\')\nhertz = BasicUnit(\\'Hz\\', \\'Hertz\\')\nminutes = BasicUnit(\\'min\\', \\'minutes\\')\n\nsecs.add_conversion_fn(hertz, lambda x: 1./x)\nsecs.add_conversion_factor(minutes, 1/60.0)\n\n\n# radians formatting\ndef rad_fn(x, pos=None):\n    if x >= 0:\n        n = int((x / np.pi) * 2.0 + 0.25)\n    else:\n        n = int((x / np.pi) * 2.0 - 0.25)\n\n    if n == 0:\n        return \\'0\\'\n    elif n == 1:\n        return r\\'$\\\\pi/2$\\'\n    elif n == 2:\n        return r\\'$\\\\pi$\\'\n    elif n == -1:\n        return r\\'$-\\\\pi/2$\\'\n    elif n == -2:\n        return r\\'$-\\\\pi$\\'\n    elif n % 2 == 0:\n        return fr\\'${n//2}\\\\pi$\\'\n    else:\n        return fr\\'${n}\\\\pi/2$\\'\n\n\nclass BasicUnitConverter(units.ConversionInterface):\n    @staticmethod\n    def axisinfo(unit, axis):\n        \"\"\"Return AxisInfo instance for x and unit.\"\"\"\n\n        if unit == radians:\n            return units.AxisInfo(\n                majloc=ticker.MultipleLocator(base=np.pi/2),\n                majfmt=ticker.FuncFormatter(rad_fn),\n                label=unit.fullname,\n            )\n        elif unit == degrees:\n            return units.AxisInfo(\n                majloc=ticker.AutoLocator(),\n                majfmt=ticker.FormatStrFormatter(r\\'$%i^\\\\circ$\\'),\n                label=unit.fullname,\n            )\n        elif unit is not None:\n            if hasattr(unit, \\'fullname\\'):\n                return units.AxisInfo(label=unit.fullname)\n            elif hasattr(unit, \\'unit\\'):\n                return units.AxisInfo(label=unit.unit.fullname)\n        return None\n\n    @staticmethod\n    def convert(val, unit, axis):\n        if np.iterable(val):\n            if isinstance(val, np.ma.MaskedArray):\n                val = val.astype(float).filled(np.nan)\n            out = np.empty(len(val))\n            for i, thisval in enumerate(val):\n                if np.ma.is_masked(thisval):\n                    out[i] = np.nan\n                else:\n                    try:\n                        out[i] = thisval.convert_to(unit).get_value()\n                    except AttributeError:\n                        out[i] = thisval\n            return out\n        if np.ma.is_masked(val):\n            return np.nan\n        else:\n            return val.convert_to(unit).get_value()\n\n    @staticmethod\n    def default_units(x, axis):\n        \"\"\"Return the default unit for x or None.\"\"\"\n        if np.iterable(x):\n            for thisx in x:\n                return thisx.unit\n        return x.unit\n\n\ndef cos(x):\n    if np.iterable(x):\n        return [math.cos(val.convert_to(radians).get_value()) for val in x]\n    else:\n        return math.cos(x.convert_to(radians).get_value())\n\n\nunits.registry[BasicUnit] = units.registry[TaggedValue] = BasicUnitConverter()\n",
    "id": 472
},
{
    "title": "Ellipse with units#",
    "text": "Compare the ellipse generated with arcs versus a polygonal approximation. This example requires basic_units.py Download Python source code: ellipse_with_units.py Download Jupyter notebook: ellipse_with_units.ipynb ",
    "code": "from basic_units import cm\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib import patches\n\nxcenter, ycenter = 0.38*cm, 0.52*cm\nwidth, height = 1e-1*cm, 3e-1*cm\nangle = -30\n\ntheta = np.deg2rad(np.arange(0.0, 360.0, 1.0))\nx = 0.5 * width * np.cos(theta)\ny = 0.5 * height * np.sin(theta)\n\nrtheta = np.radians(angle)\nR = np.array([\n    [np.cos(rtheta), -np.sin(rtheta)],\n    [np.sin(rtheta),  np.cos(rtheta)],\n    ])\n\n\nx, y = np.dot(R, [x, y])\nx += xcenter\ny += ycenter\n', \"fig = plt.figure()\nax = fig.add_subplot(211, aspect='auto')\nax.fill(x, y, alpha=0.2, facecolor='yellow',\n        edgecolor='yellow', linewidth=1, zorder=1)\n\ne1 = patches.Ellipse((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\nax.add_patch(e1)\n\nax = fig.add_subplot(212, aspect='equal')\nax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\ne2 = patches.Ellipse((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n\nax.add_patch(e2)\nfig.savefig('ellipse_compare')\n\", \"fig = plt.figure()\nax = fig.add_subplot(211, aspect='auto')\nax.fill(x, y, alpha=0.2, facecolor='yellow',\n        edgecolor='yellow', linewidth=1, zorder=1)\n\ne1 = patches.Arc((xcenter, ycenter), width, height,\n                 angle=angle, linewidth=2, fill=False, zorder=2)\n\nax.add_patch(e1)\n\nax = fig.add_subplot(212, aspect='equal')\nax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\ne2 = patches.Arc((xcenter, ycenter), width, height,\n                 angle=angle, linewidth=2, fill=False, zorder=2)\n\n\nax.add_patch(e2)\nfig.savefig('arc_compare')\n\nplt.show()\n",
    "id": 473
},
{
    "title": "Evans test#",
    "text": "A mockup \"Foo\" units class which supports conversion and different tick\nformatting depending on the \"unit\". Here the \"unit\" is just a scalar\nconversion factor, but this example shows that Matplotlib is entirely agnostic\nto what kind of units client packages use. Download Python source code: evans_test.py Download Jupyter notebook: evans_test.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.ticker as ticker\nimport matplotlib.units as units\n\n\nclass Foo:\n    def __init__(self, val, unit=1.0):\n        self.unit = unit\n        self._val = val * unit\n\n    def value(self, unit):\n        if unit is None:\n            unit = self.unit\n        return self._val / unit\n\n\nclass FooConverter(units.ConversionInterface):\n    @staticmethod\n    def axisinfo(unit, axis):\n        \"\"\"Return the Foo AxisInfo.\"\"\"\n        if unit == 1.0 or unit == 2.0:\n            return units.AxisInfo(\n                majloc=ticker.IndexLocator(8, 0),\n                majfmt=ticker.FormatStrFormatter(\"VAL: %s\"),\n                label=\\'foo\\',\n                )\n\n        else:\n            return None\n\n    @staticmethod\n    def convert(obj, unit, axis):\n        \"\"\"\n        Convert *obj* using *unit*.\n\n        If *obj* is a sequence, return the converted sequence.\n        \"\"\"\n        if np.iterable(obj):\n            return [o.value(unit) for o in obj]\n        else:\n            return obj.value(unit)\n\n    @staticmethod\n    def default_units(x, axis):\n        \"\"\"Return the default unit for *x* or None.\"\"\"\n        if np.iterable(x):\n            for thisx in x:\n                return thisx.unit\n        else:\n            return x.unit\n\n\nunits.registry[Foo] = FooConverter()\n\n# create some Foos\nx = [Foo(val, 1.0) for val in range(0, 50, 2)]\n# and some arbitrary y data\ny = [i for i in range(len(x))]\n\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.suptitle(\"Custom units\")\nfig.subplots_adjust(bottom=0.2)\n\n# plot specifying units\nax2.plot(x, y, \\'o\\', xunits=2.0)\nax2.set_title(\"xunits = 2.0\")\nplt.setp(ax2.get_xticklabels(), rotation=30, ha=\\'right\\')\n\n# plot without specifying units; will use the None branch for axisinfo\nax1.plot(x, y)  # uses default units\nax1.set_title(\\'default units\\')\nplt.setp(ax1.get_xticklabels(), rotation=30, ha=\\'right\\')\n\nplt.show()\n",
    "id": 474
},
{
    "title": "Radian ticks#",
    "text": "Plot with radians from the basic_units mockup example package. This example shows how the unit class can determine the tick locating,\nformatting and axis labeling. This example requires basic_units.py Download Python source code: radian_demo.py Download Jupyter notebook: radian_demo.ipynb ",
    "code": "from basic_units import cos, degrees, radians\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = [val*radians for val in np.arange(0, 15, 0.01)]\n\nfig, axs = plt.subplots(2)\n\naxs[0].plot(x, cos(x), xunits=radians)\naxs[1].plot(x, cos(x), xunits=degrees)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 475
},
{
    "title": "Inches and Centimeters#",
    "text": "The example illustrates the ability to override default x and y units (ax1) to\ninches and centimeters using the xunits and yunits parameters for the\nplot function. Note that conversions are applied to get numbers\nto correct units. This example requires basic_units.py Download Python source code: units_sample.py Download Jupyter notebook: units_sample.ipynb ",
    "code": "from basic_units import cm, inch\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncms = cm * np.arange(0, 10, 2)\n\nfig, axs = plt.subplots(2, 2, layout='constrained')\n\naxs[0, 0].plot(cms, cms)\n\naxs[0, 1].plot(cms, cms, xunits=cm, yunits=inch)\n\naxs[1, 0].plot(cms, cms, xunits=inch, yunits=cm)\naxs[1, 0].set_xlim(-1, 4)  # scalars are interpreted in current units\n\naxs[1, 1].plot(cms, cms, xunits=inch, yunits=inch)\naxs[1, 1].set_xlim(3*cm, 6*cm)  # cm are converted to inches\n\nplt.show()\n",
    "id": 476
},
{
    "title": "Unit handling#",
    "text": "The example below shows support for unit conversions over masked\narrays. This example requires basic_units.py Download Python source code: units_scatter.py Download Jupyter notebook: units_scatter.ipynb ",
    "code": "from basic_units import hertz, minutes, secs\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# create masked array\ndata = (1, 2, 3, 4, 5, 6, 7, 8)\nmask = (1, 0, 1, 0, 0, 0, 1, 0)\nxsecs = secs * np.ma.MaskedArray(data, mask, float)\n\nfig, (ax1, ax2, ax3) = plt.subplots(nrows=3, sharex=True)\n\nax1.scatter(xsecs, xsecs)\nax1.yaxis.set_units(secs)\nax2.scatter(xsecs, xsecs, yunits=hertz)\nax3.scatter(xsecs, xsecs, yunits=minutes)\n\nfig.tight_layout()\nplt.show()\n",
    "id": 477
},
{
    "title": "CanvasAgg demo#",
    "text": "This example shows how to use the agg backend directly to create images, which\nmay be of use to web application developers who want full control over their\ncode without using the pyplot interface to manage figures, figure closing etc. Note It is not necessary to avoid using the pyplot interface in order to\ncreate figures without a graphical front-end - simply setting\nthe backend to \"Agg\" would be sufficient. In this example, we show how to save the contents of the agg canvas to a file,\nand how to extract them to a numpy array, which can in turn be passed off\nto Pillow. The latter functionality allows e.g. to use Matplotlib inside a\ncgi-script without needing to write a figure to disk, and to write images in\nany format supported by Pillow. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.backends.backend_agg.FigureCanvasAgg matplotlib.figure.Figure matplotlib.figure.Figure.add_subplot matplotlib.figure.Figure.savefig / matplotlib.pyplot.savefig matplotlib.axes.Axes.plot / matplotlib.pyplot.plot Download Python source code: canvasagg.py Download Jupyter notebook: canvasagg.ipynb ",
    "code": "from PIL import Image\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\nfrom matplotlib.figure import Figure\n\nfig = Figure(figsize=(5, 4), dpi=100)\n# A canvas must be manually attached to the figure (pyplot would automatically\n# do it).  This is done by instantiating the canvas with the figure as\n# argument.\ncanvas = FigureCanvasAgg(fig)\n\n# Do some plotting.\nax = fig.add_subplot()\nax.plot([1, 2, 3])\n\n# Option 1: Save the figure to a file; can also be a file-like object (BytesIO,\n# etc.).\nfig.savefig(\"test.png\")\n\n# Option 2: Retrieve a memoryview on the renderer buffer, and convert it to a\n# numpy array.\ncanvas.draw()\nrgba = np.asarray(canvas.buffer_rgba())\n# ... and pass it to PIL.\nim = Image.fromarray(rgba)\n# This image can then be saved to any format supported by Pillow, e.g.:\nim.save(\"test.bmp\")\n\n# Uncomment this line to display the image using ImageMagick\\'s `display` tool.\n# im.show()\n",
    "id": 479
},
{
    "title": "Embedding in GTK3 with a navigation toolbar#",
    "text": "Demonstrate NavigationToolbar with GTK3 accessed via pygobject. Download Python source code: embedding_in_gtk3_panzoom_sgskip.py Download Jupyter notebook: embedding_in_gtk3_panzoom_sgskip.ipynb ",
    "code": "import gi\n\ngi.require_version(\\'Gtk\\', \\'3.0\\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3 import \\\\\n    NavigationToolbar2GTK3 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk3agg import \\\\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect(\"delete-event\", Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title(\"Embedding in GTK3\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot(1, 1, 1)\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nvbox = Gtk.VBox()\nwin.add(vbox)\n\n# Add canvas to vbox\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\nvbox.pack_start(canvas, True, True, 0)\n\n# Create toolbar\ntoolbar = NavigationToolbar(canvas)\nvbox.pack_start(toolbar, False, False, 0)\n\nwin.show_all()\nGtk.main()\n",
    "id": 480
},
{
    "title": "Embedding in GTK3#",
    "text": "Demonstrate adding a FigureCanvasGTK3Agg widget to a Gtk.ScrolledWindow using\nGTK3 accessed via pygobject. Download Python source code: embedding_in_gtk3_sgskip.py Download Jupyter notebook: embedding_in_gtk3_sgskip.ipynb ",
    "code": "import gi\n\ngi.require_version(\\'Gtk\\', \\'3.0\\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nwin = Gtk.Window()\nwin.connect(\"delete-event\", Gtk.main_quit)\nwin.set_default_size(400, 300)\nwin.set_title(\"Embedding in GTK3\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nax = fig.add_subplot()\nt = np.arange(0.0, 3.0, 0.01)\ns = np.sin(2*np.pi*t)\nax.plot(t, s)\n\nsw = Gtk.ScrolledWindow()\nwin.add(sw)\n# A scrolled window border goes outside the scrollbars and viewport\nsw.set_border_width(10)\n\ncanvas = FigureCanvas(fig)  # a Gtk.DrawingArea\ncanvas.set_size_request(800, 600)\nsw.add(canvas)\n\nwin.show_all()\nGtk.main()\n",
    "id": 481
},
{
    "title": "Embedding in GTK4 with a navigation toolbar#",
    "text": "Demonstrate NavigationToolbar with GTK4 accessed via pygobject. Download Python source code: embedding_in_gtk4_panzoom_sgskip.py Download Jupyter notebook: embedding_in_gtk4_panzoom_sgskip.ipynb ",
    "code": "import gi\n\ngi.require_version(\\'Gtk\\', \\'4.0\\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk4 import \\\\\n    NavigationToolbar2GTK4 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk4agg import \\\\\n    FigureCanvasGTK4Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\ndef on_activate(app):\n    win = Gtk.ApplicationWindow(application=app)\n    win.set_default_size(400, 300)\n    win.set_title(\"Embedding in GTK4\")\n\n    fig = Figure(figsize=(5, 4), dpi=100)\n    ax = fig.add_subplot(1, 1, 1)\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    ax.plot(t, s)\n\n    vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)\n    win.set_child(vbox)\n\n    # Add canvas to vbox\n    canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n    canvas.set_hexpand(True)\n    canvas.set_vexpand(True)\n    vbox.append(canvas)\n\n    # Create toolbar\n    toolbar = NavigationToolbar(canvas)\n    vbox.append(toolbar)\n\n    win.show()\n\n\napp = Gtk.Application(\n    application_id=\\'org.matplotlib.examples.EmbeddingInGTK4PanZoom\\')\napp.connect(\\'activate\\', on_activate)\napp.run(None)\n",
    "id": 482
},
{
    "title": "Embedding in GTK4#",
    "text": "Demonstrate adding a FigureCanvasGTK4Agg widget to a Gtk.ScrolledWindow using\nGTK4 accessed via pygobject. Download Python source code: embedding_in_gtk4_sgskip.py Download Jupyter notebook: embedding_in_gtk4_sgskip.ipynb ",
    "code": "import gi\n\ngi.require_version(\\'Gtk\\', \\'4.0\\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk4agg import \\\\\n    FigureCanvasGTK4Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\ndef on_activate(app):\n    win = Gtk.ApplicationWindow(application=app)\n    win.set_default_size(400, 300)\n    win.set_title(\"Embedding in GTK4\")\n\n    fig = Figure(figsize=(5, 4), dpi=100)\n    ax = fig.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    ax.plot(t, s)\n\n    # A scrolled margin goes outside the scrollbars and viewport.\n    sw = Gtk.ScrolledWindow(margin_top=10, margin_bottom=10,\n                            margin_start=10, margin_end=10)\n    win.set_child(sw)\n\n    canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.set_child(canvas)\n\n    win.show()\n\n\napp = Gtk.Application(application_id=\\'org.matplotlib.examples.EmbeddingInGTK4\\')\napp.connect(\\'activate\\', on_activate)\napp.run(None)\n",
    "id": 483
},
{
    "title": "Embedding in Qt#",
    "text": "Simple Qt application embedding Matplotlib canvases. This program will work\nequally well using any Qt binding (PyQt6, PySide6, PyQt5, PySide2). The\nbinding can be selected by setting the QT_API environment variable to\nthe binding name, or by first importing it. Download Python source code: embedding_in_qt_sgskip.py Download Jupyter notebook: embedding_in_qt_sgskip.ipynb ",
    "code": "import sys\nimport time\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_qtagg import FigureCanvas\nfrom matplotlib.backends.backend_qtagg import \\\\\n    NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.backends.qt_compat import QtWidgets\nfrom matplotlib.figure import Figure\n\n\nclass ApplicationWindow(QtWidgets.QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self._main = QtWidgets.QWidget()\n        self.setCentralWidget(self._main)\n        layout = QtWidgets.QVBoxLayout(self._main)\n\n        static_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        # Ideally one would use self.addToolBar here, but it is slightly\n        # incompatible between PyQt6 and other bindings, so we just add the\n        # toolbar as a plain widget instead.\n        layout.addWidget(NavigationToolbar(static_canvas, self))\n        layout.addWidget(static_canvas)\n\n        dynamic_canvas = FigureCanvas(Figure(figsize=(5, 3)))\n        layout.addWidget(dynamic_canvas)\n        layout.addWidget(NavigationToolbar(dynamic_canvas, self))\n\n        self._static_ax = static_canvas.figure.subplots()\n        t = np.linspace(0, 10, 501)\n        self._static_ax.plot(t, np.tan(t), \".\")\n\n        self._dynamic_ax = dynamic_canvas.figure.subplots()\n        t = np.linspace(0, 10, 101)\n        # Set up a Line2D.\n        self._line, = self._dynamic_ax.plot(t, np.sin(t + time.time()))\n        self._timer = dynamic_canvas.new_timer(50)\n        self._timer.add_callback(self._update_canvas)\n        self._timer.start()\n\n    def _update_canvas(self):\n        t = np.linspace(0, 10, 101)\n        # Shift the sinusoid as a function of time.\n        self._line.set_data(t, np.sin(t + time.time()))\n        self._line.figure.canvas.draw()\n\n\nif __name__ == \"__main__\":\n    # Check whether there is already a running QApplication (e.g., if running\n    # from an IDE).\n    qapp = QtWidgets.QApplication.instance()\n    if not qapp:\n        qapp = QtWidgets.QApplication(sys.argv)\n\n    app = ApplicationWindow()\n    app.show()\n    app.activateWindow()\n    app.raise_()\n    qapp.exec()\n",
    "id": 484
},
{
    "title": "Embedding in Tk#",
    "text": "Download Python source code: embedding_in_tk_sgskip.py Download Jupyter notebook: embedding_in_tk_sgskip.ipynb ",
    "code": "import tkinter\n\nimport numpy as np\n\n# Implement the default Matplotlib key bindings.\nfrom matplotlib.backend_bases import key_press_handler\nfrom matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,\n                                               NavigationToolbar2Tk)\nfrom matplotlib.figure import Figure\n\nroot = tkinter.Tk()\nroot.wm_title(\"Embedding in Tk\")\n\nfig = Figure(figsize=(5, 4), dpi=100)\nt = np.arange(0, 3, .01)\nax = fig.add_subplot()\nline, = ax.plot(t, 2 * np.sin(2 * np.pi * t))\nax.set_xlabel(\"time [s]\")\nax.set_ylabel(\"f(t)\")\n\ncanvas = FigureCanvasTkAgg(fig, master=root)  # A tk.DrawingArea.\ncanvas.draw()\n\n# pack_toolbar=False will make it easier to use a layout manager later on.\ntoolbar = NavigationToolbar2Tk(canvas, root, pack_toolbar=False)\ntoolbar.update()\n\ncanvas.mpl_connect(\n    \"key_press_event\", lambda event: print(f\"you pressed {event.key}\"))\ncanvas.mpl_connect(\"key_press_event\", key_press_handler)\n\nbutton_quit = tkinter.Button(master=root, text=\"Quit\", command=root.destroy)\n\n\ndef update_frequency(new_val):\n    # retrieve frequency\n    f = float(new_val)\n\n    # update data\n    y = 2 * np.sin(2 * np.pi * f * t)\n    line.set_data(t, y)\n\n    # required to update canvas and attached toolbar!\n    canvas.draw()\n\n\nslider_update = tkinter.Scale(root, from_=1, to=5, orient=tkinter.HORIZONTAL,\n                              command=update_frequency, label=\"Frequency [Hz]\")\n\n# Packing order is important. Widgets are processed sequentially and if there\n# is no space left, because the window is too small, they are not displayed.\n# The canvas is rather flexible in its size, so we pack it last which makes\n# sure the UI controls are displayed as long as possible.\nbutton_quit.pack(side=tkinter.BOTTOM)\nslider_update.pack(side=tkinter.BOTTOM)\ntoolbar.pack(side=tkinter.BOTTOM, fill=tkinter.X)\ncanvas.get_tk_widget().pack(side=tkinter.TOP, fill=tkinter.BOTH, expand=True)\n\ntkinter.mainloop()\n",
    "id": 485
},
{
    "title": "Embedding in wx #2#",
    "text": "An example of how to use wxagg in an application with the new\ntoolbar - comment out the add_toolbar line for no toolbar. Download Python source code: embedding_in_wx2_sgskip.py Download Jupyter notebook: embedding_in_wx2_sgskip.ipynb ",
    "code": "import wx\nimport wx.lib.mixins.inspection as WIT\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, \\'CanvasFrame\\', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.add_toolbar()  # comment this out for no toolbar\n\n    def add_toolbar(self):\n        self.toolbar = NavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n\n# Alternatively you could use:\n# class App(wx.App):\nclass App(WIT.InspectableApp):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        self.Init()\n        frame = CanvasFrame()\n        frame.Show(True)\n\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n",
    "id": 486
},
{
    "title": "Embedding in wx #3#",
    "text": "Copyright (C) 2003-2004 Andrew Straw, Jeremy O'Donoghue and others\", 'License: This work is licensed under the PSF. A copy should be included\nwith this source code, and is also available at\nhttps://docs.python.org/3/license.html This is yet another example of using matplotlib with wx. Hopefully\nthis is pretty full-featured: both matplotlib toolbar and WX buttons manipulate plot full wxApp framework, including widget interaction XRC (XML wxWidgets resource) file to create GUI (made with XRCed) This was derived from embedding_in_wx and dynamic_image_wxagg. Thanks to matplotlib and wx teams for creating such great software! Download Python source code: embedding_in_wx3_sgskip.py Download Jupyter notebook: embedding_in_wx3_sgskip.ipynb ",
    "code": "import wx\nimport wx.xrc as xrc\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nimport matplotlib.cbook as cbook\nimport matplotlib.cm as cm\nfrom matplotlib.figure import Figure\n\nERR_TOL = 1e-5  # floating point slop for peak-detection\n\n\nclass PlotPanel(wx.Panel):\n    def __init__(self, parent):\n        super().__init__(parent, -1)\n\n        self.fig = Figure((5, 4), 75)\n        self.canvas = FigureCanvas(self, -1, self.fig)\n        self.toolbar = NavigationToolbar(self.canvas)  # matplotlib toolbar\n        self.toolbar.Realize()\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        # Best to allow the toolbar to resize!\n        sizer.Add(self.toolbar, 0, wx.GROW)\n        self.SetSizer(sizer)\n        self.Fit()\n\n    def init_plot_data(self):\n        ax = self.fig.add_subplot()\n\n        x = np.arange(120.0) * 2 * np.pi / 60.0\n        y = np.arange(100.0) * 2 * np.pi / 50.0\n        self.x, self.y = np.meshgrid(x, y)\n        z = np.sin(self.x) + np.cos(self.y)\n        self.im = ax.imshow(z, cmap=cm.RdBu, origin=\\'lower\\')\n\n        zmax = np.max(z) - ERR_TOL\n        ymax_i, xmax_i = np.nonzero(z >= zmax)\n        if self.im.origin == \\'upper\\':\n            ymax_i = z.shape[0] - ymax_i\n        self.lines = ax.plot(xmax_i, ymax_i, \\'ko\\')\n\n        self.toolbar.update()  # Not sure why this is needed - ADS\n\n    def GetToolBar(self):\n        # You will need to override GetToolBar if you are using an\n        # unmanaged toolbar in your frame\n        return self.toolbar\n\n    def OnWhiz(self, event):\n        self.x += np.pi / 15\n        self.y += np.pi / 20\n        z = np.sin(self.x) + np.cos(self.y)\n        self.im.set_array(z)\n\n        zmax = np.max(z) - ERR_TOL\n        ymax_i, xmax_i = np.nonzero(z >= zmax)\n        if self.im.origin == \\'upper\\':\n            ymax_i = z.shape[0] - ymax_i\n        self.lines[0].set_data(xmax_i, ymax_i)\n\n        self.canvas.draw()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        xrcfile = cbook.get_sample_data(\\'embedding_in_wx3.xrc\\',\n                                        asfileobj=False)\n        print(\\'loading\\', xrcfile)\n\n        self.res = xrc.XmlResource(xrcfile)\n\n        # main frame and panel ---------\n\n        self.frame = self.res.LoadFrame(None, \"MainFrame\")\n        self.panel = xrc.XRCCTRL(self.frame, \"MainPanel\")\n\n        # matplotlib panel -------------\n\n        # container for matplotlib panel (I like to make a container\n        # panel for our panel so I know where it\\'ll go when in XRCed.)\n        plot_container = xrc.XRCCTRL(self.frame, \"plot_container_panel\")\n        sizer = wx.BoxSizer(wx.VERTICAL)\n\n        # matplotlib panel itself\n        self.plotpanel = PlotPanel(plot_container)\n        self.plotpanel.init_plot_data()\n\n        # wx boilerplate\n        sizer.Add(self.plotpanel, 1, wx.EXPAND)\n        plot_container.SetSizer(sizer)\n\n        # whiz button ------------------\n        whiz_button = xrc.XRCCTRL(self.frame, \"whiz_button\")\n        whiz_button.Bind(wx.EVT_BUTTON, self.plotpanel.OnWhiz)\n\n        # bang button ------------------\n        bang_button = xrc.XRCCTRL(self.frame, \"bang_button\")\n        bang_button.Bind(wx.EVT_BUTTON, self.OnBang)\n\n        # final setup ------------------\n        self.frame.Show()\n\n        self.SetTopWindow(self.frame)\n\n        return True\n\n    def OnBang(self, event):\n        bang_count = xrc.XRCCTRL(self.frame, \"bang_count\")\n        bangs = bang_count.GetValue()\n        bangs = int(bangs) + 1\n        bang_count.SetValue(str(bangs))\n\n\nif __name__ == \\'__main__\\':\n    app = MyApp()\n    app.MainLoop()\n",
    "id": 487
},
{
    "title": "Embedding in wx #4#",
    "text": "An example of how to use wxagg in a wx application with a custom toolbar. Download Python source code: embedding_in_wx4_sgskip.py Download Jupyter notebook: embedding_in_wx4_sgskip.ipynb ",
    "code": "import wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass MyNavigationToolbar(NavigationToolbar):\n    \"\"\"Extend the default wx toolbar with your own event handlers.\"\"\"\n\n    def __init__(self, canvas):\n        super().__init__(canvas)\n        # We use a stock wx bitmap, but you could also use your own image file.\n        bmp = wx.ArtProvider.GetBitmap(wx.ART_CROSS_MARK, wx.ART_TOOLBAR)\n        tool = self.AddTool(wx.ID_ANY, \\'Click me\\', bmp,\n                            \\'Activate custom control\\')\n        self.Bind(wx.EVT_TOOL, self._on_custom, id=tool.GetId())\n\n    def _on_custom(self, event):\n        # add some text to the axes in a random location in axes coords with a\n        # random color\n        ax = self.canvas.figure.axes[0]\n        x, y = np.random.rand(2)  # generate a random location\n        rgb = np.random.rand(3)  # generate a random color\n        ax.text(x, y, \\'You clicked me\\', transform=ax.transAxes, color=rgb)\n        self.canvas.draw()\n        event.Skip()\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self):\n        super().__init__(None, -1, \\'CanvasFrame\\', size=(550, 350))\n\n        self.figure = Figure(figsize=(5, 4), dpi=100)\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2 * np.pi * t)\n\n        self.axes.plot(t, s)\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n\n        self.toolbar = MyNavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        frame.Show(True)\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n",
    "id": 488
},
{
    "title": "Embedding in wx #5#",
    "text": "Download Python source code: embedding_in_wx5_sgskip.py Download Jupyter notebook: embedding_in_wx5_sgskip.ipynb ",
    "code": "import wx\nimport wx.lib.agw.aui as aui\nimport wx.lib.mixins.inspection as wit\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.backends.backend_wxagg import \\\\\n    NavigationToolbar2WxAgg as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n\nclass Plot(wx.Panel):\n    def __init__(self, parent, id=-1, dpi=None, **kwargs):\n        super().__init__(parent, id=id, **kwargs)\n        self.figure = Figure(dpi=dpi, figsize=(2, 2))\n        self.canvas = FigureCanvas(self, -1, self.figure)\n        self.toolbar = NavigationToolbar(self.canvas)\n        self.toolbar.Realize()\n\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.SetSizer(sizer)\n\n\nclass PlotNotebook(wx.Panel):\n    def __init__(self, parent, id=-1):\n        super().__init__(parent, id=id)\n        self.nb = aui.AuiNotebook(self)\n        sizer = wx.BoxSizer()\n        sizer.Add(self.nb, 1, wx.EXPAND)\n        self.SetSizer(sizer)\n\n    def add(self, name=\"plot\"):\n        page = Plot(self.nb)\n        self.nb.AddPage(page, name)\n        return page.figure\n\n\ndef demo():\n    # Alternatively you could use:\n    # app = wx.App()\n    # InspectableApp is a great debug tool, see:\n    # http://wiki.wxpython.org/Widget%20Inspection%20Tool\n    app = wit.InspectableApp()\n    frame = wx.Frame(None, -1, \\'Plotter\\')\n    plotter = PlotNotebook(frame)\n    axes1 = plotter.add(\\'figure 1\\').add_subplot()\n    axes1.plot([1, 2, 3], [2, 1, 4])\n    axes2 = plotter.add(\\'figure 2\\').add_subplot()\n    axes2.plot([1, 2, 3, 4, 5], [2, 1, 4, 2, 3])\n    frame.Show()\n    app.MainLoop()\n\nif __name__ == \"__main__\":\n    demo()\n",
    "id": 489
},
{
    "title": "Embedding WebAgg#",
    "text": "This example demonstrates how to embed Matplotlib WebAgg interactive plotting\nin your own web application and framework. It is not necessary to do all this\nif you merely want to display a plot in a browser or use Matplotlib\\'s built-in\nTornado-based server \"on the side\". The framework being used must support web sockets. Download Python source code: embedding_webagg_sgskip.py Download Jupyter notebook: embedding_webagg_sgskip.ipynb ",
    "code": "import argparse\nimport io\nimport json\nimport mimetypes\nfrom pathlib import Path\nimport signal\nimport socket\n\ntry:\n    import tornado\nexcept ImportError as err:\n    raise RuntimeError(\"This example requires tornado.\") from err\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\n\nimport numpy as np\n\nimport matplotlib as mpl\nfrom matplotlib.backends.backend_webagg import (\n    FigureManagerWebAgg, new_figure_manager_given_figure)\nfrom matplotlib.figure import Figure\n\n\ndef create_figure():\n    \"\"\"\n    Creates a simple example figure.\n    \"\"\"\n    fig = Figure()\n    ax = fig.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2 * np.pi * t)\n    ax.plot(t, s)\n    return fig\n\n\n# The following is the content of the web page.  You would normally\n# generate this using some sort of template facility in your web\n# framework, but here we just use Python string formatting.\nhtml_content = \"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <!-- TODO: There should be a way to include all of the required javascript\n               and CSS so matplotlib can add to the set in the future if it\n               needs to. -->\n    <link rel=\"stylesheet\" href=\"_static/css/page.css\" type=\"text/css\">\n    <link rel=\"stylesheet\" href=\"_static/css/boilerplate.css\" type=\"text/css\">\n    <link rel=\"stylesheet\" href=\"_static/css/fbm.css\" type=\"text/css\">\n    <link rel=\"stylesheet\" href=\"_static/css/mpl.css\" type=\"text/css\">\n    <script src=\"mpl.js\"></script>\n\n    <script>\n      /* This is a callback that is called when the user saves\n         (downloads) a file.  Its purpose is really to map from a\n         figure and file format to a url in the application. */\n      function ondownload(figure, format) {\n        window.open(\\'download.\\' + format, \\'_blank\\');\n      };\n\n      function ready(fn) {\n        if (document.readyState != \"loading\") {\n          fn();\n        } else {\n          document.addEventListener(\"DOMContentLoaded\", fn);\n        }\n      }\n\n      ready(\n        function() {\n          /* It is up to the application to provide a websocket that the figure\n             will use to communicate to the server.  This websocket object can\n             also be a \"fake\" websocket that underneath multiplexes messages\n             from multiple figures, if necessary. */\n          var websocket_type = mpl.get_websocket_type();\n          var websocket = new websocket_type(\"%(ws_uri)sws\");\n\n          // mpl.figure creates a new figure on the webpage.\n          var fig = new mpl.figure(\n              // A unique numeric identifier for the figure\n              %(fig_id)s,\n              // A websocket object (or something that behaves like one)\n              websocket,\n              // A function called when a file type is selected for download\n              ondownload,\n              // The HTML element in which to place the figure\n              document.getElementById(\"figure\"));\n        }\n      );\n    </script>\n\n    <title>matplotlib</title>\n  </head>\n\n  <body>\n    <div id=\"figure\">\n    </div>\n  </body>\n</html>\n\"\"\"\n\n\nclass MyApplication(tornado.web.Application):\n    class MainPage(tornado.web.RequestHandler):\n        \"\"\"\n        Serves the main HTML page.\n        \"\"\"\n\n        def get(self):\n            manager = self.application.manager\n            ws_uri = f\"ws://{self.request.host}/\"\n            content = html_content % {\n                \"ws_uri\": ws_uri, \"fig_id\": manager.num}\n            self.write(content)\n\n    class MplJs(tornado.web.RequestHandler):\n        \"\"\"\n        Serves the generated matplotlib javascript file.  The content\n        is dynamically generated based on which toolbar functions the\n        user has defined.  Call `FigureManagerWebAgg` to get its\n        content.\n        \"\"\"\n\n        def get(self):\n            self.set_header(\\'Content-Type\\', \\'application/javascript\\')\n            js_content = FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)\n\n    class Download(tornado.web.RequestHandler):\n        \"\"\"\n        Handles downloading of the figure in various file formats.\n        \"\"\"\n\n        def get(self, fmt):\n            manager = self.application.manager\n            self.set_header(\n                \\'Content-Type\\', mimetypes.types_map.get(fmt, \\'binary\\'))\n            buff = io.BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())\n\n    class WebSocket(tornado.websocket.WebSocketHandler):\n        \"\"\"\n        A websocket for interactive communication between the plot in\n        the browser and the server.\n\n        In addition to the methods required by tornado, it is required to\n        have two callback methods:\n\n            - ``send_json(json_content)`` is called by matplotlib when\n              it needs to send json to the browser.  `json_content` is\n              a JSON tree (Python dictionary), and it is the responsibility\n              of this implementation to encode it as a string to send over\n              the socket.\n\n            - ``send_binary(blob)`` is called to send binary image data\n              to the browser.\n        \"\"\"\n        supports_binary = True\n\n        def open(self):\n            # Register the websocket with the FigureManager.\n            manager = self.application.manager\n            manager.add_web_socket(self)\n            if hasattr(self, \\'set_nodelay\\'):\n                self.set_nodelay(True)\n\n        def on_close(self):\n            # When the socket is closed, deregister the websocket with\n            # the FigureManager.\n            manager = self.application.manager\n            manager.remove_web_socket(self)\n\n        def on_message(self, message):\n            # The \\'supports_binary\\' message is relevant to the\n            # websocket itself.  The other messages get passed along\n            # to matplotlib as-is.\n\n            # Every message has a \"type\" and a \"figure_id\".\n            message = json.loads(message)\n            if message[\\'type\\ == \\'supports_binary\\':\n                self.supports_binary = message[\\'value\\\n            else:\n                manager = self.application.manager\n                manager.handle_json(message)\n\n        def send_json(self, content):\n            self.write_message(json.dumps(content))\n\n        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = (\"data:image/png;base64,\" +\n                            blob.encode(\\'base64\\').replace(\\'\\\n\\', \\'\\'))\n                self.write_message(data_uri)\n\n    def __init__(self, figure):\n        self.figure = figure\n        self.manager = new_figure_manager_given_figure(id(figure), figure)\n\n        super().__init__([\n            # Static files for the CSS and JS\n            (r\\'/_static/(.*)\\',\n             tornado.web.StaticFileHandler,\n             {\\'path\\': FigureManagerWebAgg.get_static_file_path()}),\n\n            # Static images for the toolbar\n            (r\\'/_images/(.*)\\',\n             tornado.web.StaticFileHandler,\n             {\\'path\\': Path(mpl.get_data_path(), \\'images\\')}),\n\n            # The page that contains all of the pieces\n            (\\'/\\', self.MainPage),\n\n            (\\'/mpl.js\\', self.MplJs),\n\n            # Sends images and events to the browser, and receives\n            # events from the browser\n            (\\'/ws\\', self.WebSocket),\n\n            # Handles the downloading (i.e., saving) of static images\n            (r\\'/download.([a-z0-9.]+)\\', self.Download),\n        ])\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\\'-p\\', \\'--port\\', type=int, default=8080,\n                        help=\\'Port to listen on (0 for a random port).\\')\n    args = parser.parse_args()\n\n    figure = create_figure()\n    application = MyApplication(figure)\n\n    http_server = tornado.httpserver.HTTPServer(application)\n    sockets = tornado.netutil.bind_sockets(args.port, \\'\\')\n    http_server.add_sockets(sockets)\n\n    for s in sockets:\n        addr, port = s.getsockname()[:2]\n        if s.family is socket.AF_INET6:\n            addr = f\\'[{addr}]\\'\n        print(f\"Listening on http://{addr}:{port}/\")\n    print(\"Press Ctrl+C to quit\")\n\n    ioloop = tornado.ioloop.IOLoop.instance()\n\n    def shutdown():\n        ioloop.stop()\n        print(\"Server stopped\")\n\n    old_handler = signal.signal(\n        signal.SIGINT,\n        lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n\n    try:\n        ioloop.start()\n    finally:\n        signal.signal(signal.SIGINT, old_handler)\n",
    "id": 490
},
{
    "title": "Fourier Demo WX#",
    "text": "Download Python source code: fourier_demo_wx_sgskip.py Download Jupyter notebook: fourier_demo_wx_sgskip.ipynb ",
    "code": "import wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Knob:\n    \"\"\"\n    Knob - simple class with a \"setKnob\" method.\n    A Knob instance is attached to a Param instance, e.g., param.attach(knob)\n    Base class is for documentation purposes.\n    \"\"\"\n\n    def setKnob(self, value):\n        pass\n\n\nclass Param:\n    \"\"\"\n    The idea of the \"Param\" class is that some parameter in the GUI may have\n    several knobs that both control it and reflect the parameter\\'s state, e.g.\n    a slider, text, and dragging can all change the value of the frequency in\n    the waveform of this example.\n    The class allows a cleaner way to update/\"feedback\" to the other knobs when\n    one is being changed.  Also, this class handles min/max constraints for all\n    the knobs.\n    Idea - knob list - in \"set\" method, knob object is passed as well\n      - the other knobs in the knob list have a \"set\" method which gets\n        called for the others.\n    \"\"\"\n\n    def __init__(self, initialValue=None, minimum=0., maximum=1.):\n        self.minimum = minimum\n        self.maximum = maximum\n        if initialValue != self.constrain(initialValue):\n            raise ValueError(\\'illegal initial value\\')\n        self.value = initialValue\n        self.knobs = []\n\n    def attach(self, knob):\n        self.knobs += [knob]\n\n    def set(self, value, knob=None):\n        self.value = value\n        self.value = self.constrain(value)\n        for feedbackKnob in self.knobs:\n            if feedbackKnob != knob:\n                feedbackKnob.setKnob(self.value)\n        return self.value\n\n    def constrain(self, value):\n        if value <= self.minimum:\n            value = self.minimum\n        if value >= self.maximum:\n            value = self.maximum\n        return value\n\n\nclass SliderGroup(Knob):\n    def __init__(self, parent, label, param):\n        self.sliderLabel = wx.StaticText(parent, label=label)\n        self.sliderText = wx.TextCtrl(parent, -1, style=wx.TE_PROCESS_ENTER)\n        self.slider = wx.Slider(parent, -1)\n        # self.slider.SetMax(param.maximum*1000)\n        self.slider.SetRange(0, int(param.maximum * 1000))\n        self.setKnob(param.value)\n\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.Add(self.sliderLabel, 0,\n                  wx.EXPAND | wx.ALL,\n                  border=2)\n        sizer.Add(self.sliderText, 0,\n                  wx.EXPAND | wx.ALL,\n                  border=2)\n        sizer.Add(self.slider, 1, wx.EXPAND)\n        self.sizer = sizer\n\n        self.slider.Bind(wx.EVT_SLIDER, self.sliderHandler)\n        self.sliderText.Bind(wx.EVT_TEXT_ENTER, self.sliderTextHandler)\n\n        self.param = param\n        self.param.attach(self)\n\n    def sliderHandler(self, event):\n        value = event.GetInt() / 1000.\n        self.param.set(value)\n\n    def sliderTextHandler(self, event):\n        value = float(self.sliderText.GetValue())\n        self.param.set(value)\n\n    def setKnob(self, value):\n        self.sliderText.SetValue(f\\'{value:g}\\')\n        self.slider.SetValue(int(value * 1000))\n\n\nclass FourierDemoFrame(wx.Frame):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        panel = wx.Panel(self)\n\n        # create the GUI elements\n        self.createCanvas(panel)\n        self.createSliders(panel)\n\n        # place them in a sizer for the Layout\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.canvas, 1, wx.EXPAND)\n        sizer.Add(self.frequencySliderGroup.sizer, 0,\n                  wx.EXPAND | wx.ALL, border=5)\n        sizer.Add(self.amplitudeSliderGroup.sizer, 0,\n                  wx.EXPAND | wx.ALL, border=5)\n        panel.SetSizer(sizer)\n\n    def createCanvas(self, parent):\n        self.lines = []\n        self.figure = Figure()\n        self.canvas = FigureCanvas(parent, -1, self.figure)\n        self.canvas.callbacks.connect(\\'button_press_event\\', self.mouseDown)\n        self.canvas.callbacks.connect(\\'motion_notify_event\\', self.mouseMotion)\n        self.canvas.callbacks.connect(\\'button_release_event\\', self.mouseUp)\n        self.state = \\'\\'\n        self.mouseInfo = (None, None, None, None)\n        self.f0 = Param(2., minimum=0., maximum=6.)\n        self.A = Param(1., minimum=0.01, maximum=2.)\n        self.createPlots()\n\n        # Not sure I like having two params attached to the same Knob,\n        # but that is what we have here... it works but feels kludgy -\n        # although maybe it\\'s not too bad since the knob changes both params\n        # at the same time (both f0 and A are affected during a drag)\n        self.f0.attach(self)\n        self.A.attach(self)\n\n    def createSliders(self, panel):\n        self.frequencySliderGroup = SliderGroup(\n            panel,\n            label=\\'Frequency f0:\\',\n            param=self.f0)\n        self.amplitudeSliderGroup = SliderGroup(panel, label=\\' Amplitude a:\\',\n                                                param=self.A)\n\n    def mouseDown(self, event):\n        if self.lines[0].contains(event)[0]:\n            self.state = \\'frequency\\'\n        elif self.lines[1].contains(event)[0]:\n            self.state = \\'time\\'\n        else:\n            self.state = \\'\\'\n        self.mouseInfo = (event.xdata, event.ydata,\n                          max(self.f0.value, .1),\n                          self.A.value)\n\n    def mouseMotion(self, event):\n        if self.state == \\'\\':\n            return\n        x, y = event.xdata, event.ydata\n        if x is None:  # outside the axes\n            return\n        x0, y0, f0Init, AInit = self.mouseInfo\n        self.A.set(AInit + (AInit * (y - y0) / y0), self)\n        if self.state == \\'frequency\\':\n            self.f0.set(f0Init + (f0Init * (x - x0) / x0))\n        elif self.state == \\'time\\':\n            if (x - x0) / x0 != -1.:\n                self.f0.set(1. / (1. / f0Init + (1. / f0Init * (x - x0) / x0)))\n\n    def mouseUp(self, event):\n        self.state = \\'\\'\n\n    def createPlots(self):\n        # This method creates the subplots, waveforms and labels.\n        # Later, when the waveforms or sliders are dragged, only the\n        # waveform data will be updated (not here, but below in setKnob).\n        self.subplot1, self.subplot2 = self.figure.subplots(2)\n        x1, y1, x2, y2 = self.compute(self.f0.value, self.A.value)\n        color = (1., 0., 0.)\n        self.lines += self.subplot1.plot(x1, y1, color=color, linewidth=2)\n        self.lines += self.subplot2.plot(x2, y2, color=color, linewidth=2)\n        # Set some plot attributes\n        self.subplot1.set_title(\n            \"Click and drag waveforms to change frequency and amplitude\",\n            fontsize=12)\n        self.subplot1.set_ylabel(\"Frequency Domain Waveform X(f)\", fontsize=8)\n        self.subplot1.set_xlabel(\"frequency f\", fontsize=8)\n        self.subplot2.set_ylabel(\"Time Domain Waveform x(t)\", fontsize=8)\n        self.subplot2.set_xlabel(\"time t\", fontsize=8)\n        self.subplot1.set_xlim([-6, 6])\n        self.subplot1.set_ylim([0, 1])\n        self.subplot2.set_xlim([-2, 2])\n        self.subplot2.set_ylim([-2, 2])\n        self.subplot1.text(0.05, .95,\n                           r\\'$X(f) = \\\\mathcal{F}\\\\{x(t)\\\\}$\\',\n                           verticalalignment=\\'top\\',\n                           transform=self.subplot1.transAxes)\n        self.subplot2.text(0.05, .95,\n                           r\\'$x(t) = a \\\\cdot \\\\cos(2\\\\pi f_0 t) e^{-\\\\pi t^2}$\\',\n                           verticalalignment=\\'top\\',\n                           transform=self.subplot2.transAxes)\n\n    def compute(self, f0, A):\n        f = np.arange(-6., 6., 0.02)\n        t = np.arange(-2., 2., 0.01)\n        x = A * np.cos(2 * np.pi * f0 * t) * np.exp(-np.pi * t ** 2)\n        X = A / 2 * \\\\\n            (np.exp(-np.pi * (f - f0) ** 2) + np.exp(-np.pi * (f + f0) ** 2))\n        return f, X, t, x\n\n    def setKnob(self, value):\n        # Note, we ignore value arg here and just go by state of the params\n        x1, y1, x2, y2 = self.compute(self.f0.value, self.A.value)\n        # update the data of the two waveforms\n        self.lines[0].set(xdata=x1, ydata=y1)\n        self.lines[1].set(xdata=x2, ydata=y2)\n        # make the canvas draw its contents again with the new data\n        self.canvas.draw()\n\n\nclass App(wx.App):\n    def OnInit(self):\n        self.frame1 = FourierDemoFrame(parent=None, title=\"Fourier Demo\",\n                                       size=(640, 480))\n        self.frame1.Show()\n        return True\n\n\nif __name__ == \"__main__\":\n    app = App()\n    app.MainLoop()\n",
    "id": 491
},
{
    "title": "GTK3 spreadsheet#",
    "text": "Example of embedding Matplotlib in an application and interacting with a\ntreeview to store data. Double-click on an entry to update plot data. Download Python source code: gtk3_spreadsheet_sgskip.py Download Jupyter notebook: gtk3_spreadsheet_sgskip.ipynb ",
    "code": "import gi\n\ngi.require_version('Gtk 3.0')\ngi.require_version('Gdk 3.0')\nfrom gi.repository import Gdk, Gtk\n\nfrom numpy.random import random\n\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvas  # or gtk3cairo.\nfrom matplotlib.figure import Figure\n\n\nclass DataManager(Gtk.Window):\n    num_rows, num_cols = 20, 10\n\n    data = random((num_rows, num_cols))\n\n    def __init__(self):\n        super().__init__()\n        self.set_default_size(600, 600)\n        self.connect('destroy', lambda win: Gtk.main_quit())\n\n        self.set_title('GtkListStore demo')\n        self.set_border_width(8)\n\n        vbox = Gtk.VBox(homogeneous=False, spacing=8)\n        self.add(vbox)\n\n        label = Gtk.Label(label='Double click a row to plot the data')\n\n        vbox.pack_start(label, False, False, 0)\n\n        sw = Gtk.ScrolledWindow()\n        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)\n        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        vbox.pack_start(sw, True, True, 0)\n\n        model = self.create_model()\n\n        self.treeview = Gtk.TreeView(model=model)\n\n        # Matplotlib stuff\n        fig = Figure(figsize=(6, 4))\n\n        self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n        vbox.pack_start(self.canvas, True, True, 0)\n        ax = fig.add_subplot()\n        self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row\n\n        self.treeview.connect('row-activated', self.plot_row)\n        sw.add(self.treeview)\n\n        self.add_columns()\n\n        self.add_events(Gdk.EventMask.BUTTON_PRESS_MASK |\n                        Gdk.EventMask.KEY_PRESS_MASK |\n                        Gdk.EventMask.KEY_RELEASE_MASK)\n\n    def plot_row(self, treeview, path, view_column):\n        ind, = path  # get the index into data\n        points = self.data[ind, :]\n        self.line.set_ydata(points)\n        self.canvas.draw()\n\n    def add_columns(self):\n        for i in range(self.num_cols):\n            column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)\n            self.treeview.append_column(column)\n\n    def create_model(self):\n        types = [float] * self.num_cols\n        store = Gtk.ListStore(*types)\n        for row in self.data:\n            store.append(tuple(row))\n        return store\n\n\nmanager = DataManager()\nmanager.show_all()\nGtk.main()\n",
    "id": 492
},
{
    "title": "GTK4 spreadsheet#",
    "text": "Example of embedding Matplotlib in an application and interacting with a\ntreeview to store data. Double-click on an entry to update plot data. Download Python source code: gtk4_spreadsheet_sgskip.py Download Jupyter notebook: gtk4_spreadsheet_sgskip.ipynb ",
    "code": "import gi\n\ngi.require_version('Gtk 4.0')\ngi.require_version('Gdk 4.0')\nfrom gi.repository import Gtk\n\nfrom numpy.random import random\n\nfrom matplotlib.backends.backend_gtk4agg import FigureCanvas  # or gtk4cairo.\nfrom matplotlib.figure import Figure\n\n\nclass DataManager(Gtk.ApplicationWindow):\n    num_rows, num_cols = 20, 10\n\n    data = random((num_rows, num_cols))\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_default_size(600, 600)\n\n        self.set_title('GtkListStore demo')\n\n        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, homogeneous=False,\n                       spacing=8)\n        self.set_child(vbox)\n\n        label = Gtk.Label(label='Double click a row to plot the data')\n        vbox.append(label)\n\n        sw = Gtk.ScrolledWindow()\n        sw.set_has_frame(True)\n        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        sw.set_hexpand(True)\n        sw.set_vexpand(True)\n        vbox.append(sw)\n\n        model = self.create_model()\n        self.treeview = Gtk.TreeView(model=model)\n        self.treeview.connect('row-activated', self.plot_row)\n        sw.set_child(self.treeview)\n\n        # Matplotlib stuff\n        fig = Figure(figsize=(6, 4), layout='constrained')\n\n        self.canvas = FigureCanvas(fig)  # a Gtk.DrawingArea\n        self.canvas.set_hexpand(True)\n        self.canvas.set_vexpand(True)\n        vbox.append(self.canvas)\n        ax = fig.add_subplot()\n        self.line, = ax.plot(self.data[0, :], 'go')  # plot the first row\n\n        self.add_columns()\n\n    def plot_row(self, treeview, path, view_column):\n        ind, = path  # get the index into data\n        points = self.data[ind, :]\n        self.line.set_ydata(points)\n        self.canvas.draw()\n\n    def add_columns(self):\n        for i in range(self.num_cols):\n            column = Gtk.TreeViewColumn(str(i), Gtk.CellRendererText(), text=i)\n            self.treeview.append_column(column)\n\n    def create_model(self):\n        types = [float] * self.num_cols\n        store = Gtk.ListStore(*types)\n        for row in self.data:\n            # Gtk.ListStore.append is broken in PyGObject, so insert manually.\n            it = store.insert(-1)\n            store.set(it, {i: val for i, val in enumerate(row)})\n        return store\n\n\ndef on_activate(app):\n    manager = DataManager(application=app)\n    manager.show()\n\n\napp = Gtk.Application(application_id='org.matplotlib.examples.GTK4Spreadsheet')\napp.connect('activate', on_activate)\napp.run()\n",
    "id": 493
},
{
    "title": "Display mathtext in WX#",
    "text": "Demonstrates how to convert (math)text to a wx.Bitmap for display in various\ncontrols on wxPython. Download Python source code: mathtext_wx_sgskip.py Download Jupyter notebook: mathtext_wx_sgskip.ipynb ",
    "code": "from io import BytesIO\n\nimport wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\nIS_WIN = \\'wxMSW\\' in wx.PlatformInfo\n\n\ndef mathtext_to_wxbitmap(s):\n    # We draw the text at position (0, 0) but then rely on\n    # ``facecolor=\"none\"`` and ``bbox_inches=\"tight\", pad_inches=0`` to get a\n    # transparent mask that is then loaded into a wx.Bitmap.\n    fig = Figure(facecolor=\"none\")\n    text_color = (\n        np.array(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)) / 255)\n    fig.text(0, 0, s, fontsize=10, color=text_color)\n    buf = BytesIO()\n    fig.savefig(buf, format=\"png\", dpi=150, bbox_inches=\"tight\", pad_inches=0)\n    s = buf.getvalue()\n    return wx.Bitmap.NewFromPNGData(s, len(s))\n\n\nfunctions = [\n    (r\\'$\\\\sin(2 \\\\pi x)$\\', lambda x: np.sin(2*np.pi*x)),\n    (r\\'$\\\\frac{4}{3}\\\\pi x^3$\\', lambda x: (4/3)*np.pi*x**3),\n    (r\\'$\\\\cos(2 \\\\pi x)$\\', lambda x: np.cos(2*np.pi*x)),\n    (r\\'$\\\\log(x)$\\', lambda x: np.log(x))\n]\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, parent, title):\n        super().__init__(parent, -1, title, size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n\n        self.canvas = FigureCanvas(self, -1, self.figure)\n\n        self.change_plot(0)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.add_buttonbar()\n        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.add_toolbar()  # comment this out for no toolbar\n\n        menuBar = wx.MenuBar()\n\n        # File Menu\n        menu = wx.Menu()\n        m_exit = menu.Append(\n            wx.ID_EXIT, \"E&xit\\\\tAlt-X\", \"Exit this simple sample\")\n        menuBar.Append(menu, \"&File\")\n        self.Bind(wx.EVT_MENU, self.OnClose, m_exit)\n\n        if IS_WIN:\n            # Equation Menu\n            menu = wx.Menu()\n            for i, (mt, func) in enumerate(functions):\n                bm = mathtext_to_wxbitmap(mt)\n                item = wx.MenuItem(menu, 1000 + i, \" \")\n                item.SetBitmap(bm)\n                menu.Append(item)\n                self.Bind(wx.EVT_MENU, self.OnChangePlot, item)\n            menuBar.Append(menu, \"&Functions\")\n\n        self.SetMenuBar(menuBar)\n\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n    def add_buttonbar(self):\n        self.button_bar = wx.Panel(self)\n        self.button_bar_sizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.sizer.Add(self.button_bar, 0, wx.LEFT | wx.TOP | wx.GROW)\n\n        for i, (mt, func) in enumerate(functions):\n            bm = mathtext_to_wxbitmap(mt)\n            button = wx.BitmapButton(self.button_bar, 1000 + i, bm)\n            self.button_bar_sizer.Add(button, 1, wx.GROW)\n            self.Bind(wx.EVT_BUTTON, self.OnChangePlot, button)\n\n        self.button_bar.SetSizer(self.button_bar_sizer)\n\n    def add_toolbar(self):\n        \"\"\"Copied verbatim from embedding_wx2.py\"\"\"\n        self.toolbar = NavigationToolbar2Wx(self.canvas)\n        self.toolbar.Realize()\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version.\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        # update the axes menu on the toolbar\n        self.toolbar.update()\n\n    def OnChangePlot(self, event):\n        self.change_plot(event.GetId() - 1000)\n\n    def change_plot(self, plot_number):\n        t = np.arange(1.0, 3.0, 0.01)\n        s = functions[plot_number][1](t)\n        self.axes.clear()\n        self.axes.plot(t, s)\n        self.canvas.draw()\n\n    def OnClose(self, event):\n        self.Destroy()\n\n\nclass MyApp(wx.App):\n    def OnInit(self):\n        frame = CanvasFrame(None, \"wxPython mathtext demo app\")\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == \"__main__\":\n    app = MyApp()\n    app.MainLoop()\n",
    "id": 494
},
{
    "title": "Matplotlib with Glade 3#",
    "text": "Download Python source code: mpl_with_glade3_sgskip.py Download Jupyter notebook: mpl_with_glade3_sgskip.ipynb ",
    "code": "from pathlib import Path\n\nimport gi\n\ngi.require_version(\\'Gtk\\', \\'3.0\\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_gtk3agg import \\\\\n    FigureCanvasGTK3Agg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass Window1Signals:\n    def on_window1_destroy(self, widget):\n        Gtk.main_quit()\n\n\ndef main():\n    builder = Gtk.Builder()\n    builder.add_objects_from_file(\n        str(Path(__file__).parent / \"mpl_with_glade3.glade\"),\n        (\"window1\", \"\"))\n    builder.connect_signals(Window1Signals())\n    window = builder.get_object(\"window1\")\n    sw = builder.get_object(\"scrolledwindow1\")\n\n    # Start of Matplotlib specific code\n    figure = Figure(figsize=(8, 6), dpi=71)\n    axis = figure.add_subplot()\n    t = np.arange(0.0, 3.0, 0.01)\n    s = np.sin(2*np.pi*t)\n    axis.plot(t, s)\n\n    axis.set_xlabel(\\'time [s]\\')\n    axis.set_ylabel(\\'voltage [V]\\')\n\n    canvas = FigureCanvas(figure)  # a Gtk.DrawingArea\n    canvas.set_size_request(800, 600)\n    sw.add(canvas)\n    # End of Matplotlib specific code\n\n    window.show_all()\n    Gtk.main()\n\nif __name__ == \"__main__\":\n    main()\n",
    "id": 495
},
{
    "title": "mplcvd -- an example of figure hook#",
    "text": "To use this hook, ensure that this module is in your PYTHONPATH, and set\nrcParamsfigure.hooks = mplcvd:setup. This hook depends on\nthe colorspacious third-party module. Download Python source code: mplcvd.py Download Jupyter notebook: mplcvd.ipynb ",
    "code": "import functools\nfrom pathlib import Path\n\nimport colorspacious\n\nimport numpy as np\n\n_BUTTON_NAME = \"Filter\"\n_BUTTON_HELP = \"Simulate color vision deficiencies\"\n_MENU_ENTRIES = {\n    \"None\": None,\n    \"Greyscale\": \"greyscale\",\n    \"Deuteranopia\": \"deuteranomaly\",\n    \"Protanopia\": \"protanomaly\",\n    \"Tritanopia\": \"tritanomaly\",\n}\n\n\ndef _get_color_filter(name):\n    \"\"\"\n    Given a color filter name, create a color filter function.\n\n    Parameters\n    ----------\n    name : str\n        The color filter name, one of the following:\n\n        - ``\"none\"``: ...\n        - ``\"greyscale\"``: Convert the input to luminosity.\n        - ``\"deuteranopia\"``: Simulate the most common form of red-green\n          colorblindness.\n        - ``\"protanopia\"``: Simulate a rarer form of red-green colorblindness.\n        - ``\"tritanopia\"``: Simulate the rare form of blue-yellow\n          colorblindness.\n\n        Color conversions use `colorspacious`_.\n\n    Returns\n    -------\n    callable\n        A color filter function that has the form:\n\n        def filter(input: np.ndarray[M, N, D])-> np.ndarray[M, N, D]\n\n        where (M, N) are the image dimensions, and D is the color depth (3 for\n        RGB, 4 for RGBA). Alpha is passed through unchanged and otherwise\n        ignored.\n    \"\"\"\n    if name not in _MENU_ENTRIES:\n        raise ValueError(f\"Unsupported filter name: {name!r}\")\n    name = _MENU_ENTRIES[name]\n\n    if name is None:\n        return None\n\n    elif name == \"greyscale\":\n        rgb_to_jch = colorspacious.cspace_converter(\"sRGB1\", \"JCh\")\n        jch_to_rgb = colorspacious.cspace_converter(\"JCh\", \"sRGB1\")\n\n        def convert(im):\n            greyscale_JCh = rgb_to_jch(im)\n            greyscale_JCh[..., 1] = 0\n            im = jch_to_rgb(greyscale_JCh)\n            return im\n\n    else:\n        cvd_space = {\"name\": \"sRGB1+CVD\", \"cvd_type\": name, \"severity\": 100}\n        convert = colorspacious.cspace_converter(cvd_space, \"sRGB1\")\n\n    def filter_func(im, dpi):\n        alpha = None\n        if im.shape[-1] == 4:\n            im, alpha = im[..., :3], im[..., 3]\n        im = convert(im)\n        if alpha is not None:\n            im = np.dstack((im, alpha))\n        return np.clip(im, 0, 1), 0, 0\n\n    return filter_func\n\n\ndef _set_menu_entry(tb, name):\n    tb.canvas.figure.set_agg_filter(_get_color_filter(name))\n    tb.canvas.draw_idle()\n\n\ndef setup(figure):\n    tb = figure.canvas.toolbar\n    if tb is None:\n        return\n    for cls in type(tb).__mro__:\n        pkg = cls.__module__.split(\".\")[0]\n        if pkg != \"matplotlib\":\n            break\n    if pkg == \"gi\":\n        _setup_gtk(tb)\n    elif pkg in (\"PyQt5\", \"PySide2\", \"PyQt6\", \"PySide6\"):\n        _setup_qt(tb)\n    elif pkg == \"tkinter\":\n        _setup_tk(tb)\n    elif pkg == \"wx\":\n        _setup_wx(tb)\n    else:\n        raise NotImplementedError(\"The current backend is not supported\")\n\n\ndef _setup_gtk(tb):\n    from gi.repository import Gio, GLib, Gtk\n\n    for idx in range(tb.get_n_items()):\n        children = tb.get_nth_item(idx).get_children()\n        if children and isinstance(children[0], Gtk.Label):\n            break\n\n    toolitem = Gtk.SeparatorToolItem()\n    tb.insert(toolitem, idx)\n\n    image = Gtk.Image.new_from_gicon(\n        Gio.Icon.new_for_string(\n            str(Path(__file__).parent / \"images/eye-symbolic.svg\")),\n        Gtk.IconSize.LARGE_TOOLBAR)\n\n    # The type of menu is progressively downgraded depending on GTK version.\n    if Gtk.check_version(3, 6, 0) is None:\n\n        group = Gio.SimpleActionGroup.new()\n        action = Gio.SimpleAction.new_stateful(\"cvdsim\",\n                                               GLib.VariantType(\"s\"),\n                                               GLib.Variant(\"s\", \"none\"))\n        group.add_action(action)\n\n        @functools.partial(action.connect, \"activate\")\n        def set_filter(action, parameter):\n            _set_menu_entry(tb, parameter.get_string())\n            action.set_state(parameter)\n\n        menu = Gio.Menu()\n        for name in _MENU_ENTRIES:\n            menu.append(name, f\"local.cvdsim::{name}\")\n\n        button = Gtk.MenuButton.new()\n        button.remove(button.get_children()[0])\n        button.add(image)\n        button.insert_action_group(\"local\", group)\n        button.set_menu_model(menu)\n        button.get_style_context().add_class(\"flat\")\n\n        item = Gtk.ToolItem()\n        item.add(button)\n        tb.insert(item, idx + 1)\n\n    else:\n\n        menu = Gtk.Menu()\n        group = []\n        for name in _MENU_ENTRIES:\n            item = Gtk.RadioMenuItem.new_with_label(group, name)\n            item.set_active(name == \"None\")\n            item.connect(\n                \"activate\", lambda item: _set_menu_entry(tb, item.get_label()))\n            group.append(item)\n            menu.append(item)\n        menu.show_all()\n\n        tbutton = Gtk.MenuToolButton.new(image, _BUTTON_NAME)\n        tbutton.set_menu(menu)\n        tb.insert(tbutton, idx + 1)\n\n    tb.show_all()\n\n\ndef _setup_qt(tb):\n    from matplotlib.backends.qt_compat import QtGui, QtWidgets\n\n    menu = QtWidgets.QMenu()\n    try:\n        QActionGroup = QtGui.QActionGroup  # Qt6\n    except AttributeError:\n        QActionGroup = QtWidgets.QActionGroup  # Qt5\n    group = QActionGroup(menu)\n    group.triggered.connect(lambda action: _set_menu_entry(tb, action.text()))\n\n    for name in _MENU_ENTRIES:\n        action = menu.addAction(name)\n        action.setCheckable(True)\n        action.setActionGroup(group)\n        action.setChecked(name == \"None\")\n\n    actions = tb.actions()\n    before = next(\n        (action for action in actions\n         if isinstance(tb.widgetForAction(action), QtWidgets.QLabel)), None)\n\n    tb.insertSeparator(before)\n    button = QtWidgets.QToolButton()\n    # FIXME: _icon needs public API.\n    button.setIcon(tb._icon(str(Path(__file__).parent / \"images/eye.png\")))\n    button.setText(_BUTTON_NAME)\n    button.setToolTip(_BUTTON_HELP)\n    button.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)\n    button.setMenu(menu)\n    tb.insertWidget(before, button)\n\n\ndef _setup_tk(tb):\n    import tkinter as tk\n\n    tb._Spacer()  # FIXME: _Spacer needs public API.\n\n    button = tk.Menubutton(master=tb, relief=\"raised\")\n    button._image_file = str(Path(__file__).parent / \"images/eye.png\")\n    # FIXME: _set_image_for_button needs public API (perhaps like _icon).\n    tb._set_image_for_button(button)\n    button.pack(side=tk.LEFT)\n\n    menu = tk.Menu(master=button, tearoff=False)\n    for name in _MENU_ENTRIES:\n        menu.add(\"radiobutton\", label=name,\n                 command=lambda _name=name: _set_menu_entry(tb, _name))\n    menu.invoke(0)\n    button.config(menu=menu)\n\n\ndef _setup_wx(tb):\n    import wx\n\n    idx = next(idx for idx in range(tb.ToolsCount)\n               if tb.GetToolByPos(idx).IsStretchableSpace())\n    tb.InsertSeparator(idx)\n    tool = tb.InsertTool(\n        idx + 1, -1, _BUTTON_NAME,\n        # FIXME: _icon needs public API.\n        tb._icon(str(Path(__file__).parent / \"images/eye.png\")),\n        # FIXME: ITEM_DROPDOWN is not supported on macOS.\n        kind=wx.ITEM_DROPDOWN, shortHelp=_BUTTON_HELP)\n\n    menu = wx.Menu()\n    for name in _MENU_ENTRIES:\n        item = menu.AppendRadioItem(-1, name)\n        menu.Bind(\n            wx.EVT_MENU,\n            lambda event, _name=name: _set_menu_entry(tb, _name),\n            id=item.Id,\n        )\n    tb.SetDropdownMenu(tool.Id, menu)\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    from matplotlib import cbook\n\n    plt.rcParams[\\'figure.hooks\\.append(\\'mplcvd:setup\\')\n\n    fig, axd = plt.subplot_mosaic(\n        [\n            [\\'viridis\\', \\'turbo\\,\n            [\\'photo\\', \\'lines\\\n        ]\n    )\n\n    delta = 0.025\n    x = y = np.arange(-3.0, 3.0, delta)\n    X, Y = np.meshgrid(x, y)\n    Z1 = np.exp(-X**2 - Y**2)\n    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\n    Z = (Z1 - Z2) * 2\n\n    imv = axd[\\'viridis\\.imshow(\n        Z, interpolation=\\'bilinear\\',\n        origin=\\'lower\\', extent=[-3, 3, -3, 3],\n        vmax=abs(Z).max(), vmin=-abs(Z).max()\n    )\n    fig.colorbar(imv)\n    imt = axd[\\'turbo\\.imshow(\n        Z, interpolation=\\'bilinear\\', cmap=\\'turbo\\',\n        origin=\\'lower\\', extent=[-3, 3, -3, 3],\n        vmax=abs(Z).max(), vmin=-abs(Z).max()\n    )\n    fig.colorbar(imt)\n\n    # A sample image\n    with cbook.get_sample_data(\\'grace_hopper.jpg\\') as image_file:\n        photo = plt.imread(image_file)\n    axd[\\'photo\\.imshow(photo)\n\n    th = np.linspace(0, 2*np.pi, 1024)\n    for j in [1, 2, 4, 6]:\n        axd[\\'lines\\.plot(th, np.sin(th * j), label=f\\'$\\\\\\\\omega={j}$\\')\n    axd[\\'lines\\.legend(ncols=2, loc=\\'upper right\\')\n    plt.show()\n",
    "id": 496
},
{
    "title": "pyplot with GTK3#",
    "text": "An example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets. Download Python source code: pylab_with_gtk3_sgskip.py Download Jupyter notebook: pylab_with_gtk3_sgskip.ipynb ",
    "code": "import matplotlib\n\nmatplotlib.use(\\'GTK3Agg\\')  # or \\'GTK3Cairo\\'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version(\\'Gtk\\', \\'3.0\\')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], \\'ro-\\', label=\\'easy as 1 2 3\\')\nax.plot([1, 4, 9], \\'gs--\\', label=\\'easy as 1 2 3 squared\\')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let\\'s add a button to the toolbar\nbutton = Gtk.Button(label=\\'Click me\\')\nbutton.show()\nbutton.connect(\\'clicked\\', lambda button: print(\\'hi mom\\'))\n\ntoolitem = Gtk.ToolItem()\ntoolitem.show()\ntoolitem.set_tooltip_text(\\'Click me for fun and profit\\')\ntoolitem.add(button)\n\npos = 8  # where to insert this in the toolbar\ntoolbar.insert(toolitem, pos)\n\n# now let\\'s add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup(\\'Drag mouse over axes for position\\')\nlabel.show()\nvbox.pack_start(label, False, False, 0)\nvbox.reorder_child(toolbar, -1)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup(\\'Drag mouse over axes for position\\')\n    else:\n        label.set_markup(\n            f\\'<span color=\"#ef0000\">x,y=({event.xdata}, {event.ydata})</span>\\')\n\n\nfig.canvas.mpl_connect(\\'motion_notify_event\\', update)\n\nplt.show()\n",
    "id": 497
},
{
    "title": "pyplot with GTK4#",
    "text": "An example of how to use pyplot to manage your figure windows, but modify the\nGUI by accessing the underlying GTK widgets. Download Python source code: pylab_with_gtk4_sgskip.py Download Jupyter notebook: pylab_with_gtk4_sgskip.ipynb ",
    "code": "import matplotlib\n\nmatplotlib.use(\\'GTK4Agg\\')  # or \\'GTK4Cairo\\'\nimport gi\n\nimport matplotlib.pyplot as plt\n\ngi.require_version(\\'Gtk\\', \\'4.0\\')\nfrom gi.repository import Gtk\n\nfig, ax = plt.subplots()\nax.plot([1, 2, 3], \\'ro-\\', label=\\'easy as 1 2 3\\')\nax.plot([1, 4, 9], \\'gs--\\', label=\\'easy as 1 2 3 squared\\')\nax.legend()\n\nmanager = fig.canvas.manager\n# you can access the window or vbox attributes this way\ntoolbar = manager.toolbar\nvbox = manager.vbox\n\n# now let\\'s add a button to the toolbar\nbutton = Gtk.Button(label=\\'Click me\\')\nbutton.connect(\\'clicked\\', lambda button: print(\\'hi mom\\'))\nbutton.set_tooltip_text(\\'Click me for fun and profit\\')\ntoolbar.append(button)\n\n# now let\\'s add a widget to the vbox\nlabel = Gtk.Label()\nlabel.set_markup(\\'Drag mouse over axes for position\\')\nvbox.insert_child_after(label, fig.canvas)\n\n\ndef update(event):\n    if event.xdata is None:\n        label.set_markup(\\'Drag mouse over axes for position\\')\n    else:\n        label.set_markup(\n            f\\'<span color=\"#ef0000\">x,y=({event.xdata}, {event.ydata})</span>\\')\n\n\nfig.canvas.mpl_connect(\\'motion_notify_event\\', update)\n\nplt.show()\n",
    "id": 498
},
{
    "title": "SVG Histogram#",
    "text": "Demonstrate how to create an interactive histogram, in which bars\nare hidden or shown by clicking on legend markers. The interactivity is encoded in ecmascript (javascript) and inserted in\nthe SVG code in a post-processing step. To render the image, open it in\na web browser. SVG is supported in most web browsers used by Linux and\nOSX users. Windows IE9 supports SVG, but earlier versions do not. The matplotlib backend lets us assign ids to each object. This is the\nmechanism used here to relate matplotlib objects created in python and\nthe corresponding SVG constructs that are parsed in the second step.\nWhile flexible, ids are cumbersome to use for large collection of\nobjects. Two mechanisms could be used to simplify things: systematic grouping of objects into SVG <g> tags, assigning classes to each SVG object according to its origin. For example, instead of modifying the properties of each individual bar,\nthe bars from the hist function could either be grouped in\na PatchCollection, or be assigned a class=\"hist_##\" attribute. CSS could also be used more extensively to replace repetitive markup\nthroughout the generated SVG. Author: david.huard@gmail.com Download Python source code: svg_histogram_sgskip.py Download Jupyter notebook: svg_histogram_sgskip.ipynb ",
    "code": "from io import BytesIO\nimport json\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.rcParams[\\'svg.fonttype\\ = \\'none\\'\n\n# Apparently, this `register_namespace` method is necessary to avoid garbling\n# the XML namespace with ns0.\nET.register_namespace(\"\", \"http://www.w3.org/2000/svg\")\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\n# --- Create histogram, legend and title ---\nplt.figure()\nr = np.random.randn(100)\nr1 = r + 1\nlabels = [\\'Rabbits\\', \\'Frogs\\\nH = plt.hist([r, r1], label=labels)\ncontainers = H[-1]\nleg = plt.legend(frameon=False)\nplt.title(\"From a web browser, click on the legend\\\n\"\n          \"marker to toggle the corresponding histogram.\")\n\n\n# --- Add ids to the svg objects we\\'ll modify\n\nhist_patches = {}\nfor ic, c in enumerate(containers):\n    hist_patches[f\\'hist_{ic}\\ = []\n    for il, element in enumerate(c):\n        element.set_gid(f\\'hist_{ic}_patch_{il}\\')\n        hist_patches[f\\'hist_{ic}\\.append(f\\'hist_{ic}_patch_{il}\\')\n\n# Set ids for the legend patches\nfor i, t in enumerate(leg.get_patches()):\n    t.set_gid(f\\'leg_patch_{i}\\')\n\n# Set ids for the text patches\nfor i, t in enumerate(leg.get_texts()):\n    t.set_gid(f\\'leg_text_{i}\\')\n\n# Save SVG in a fake file object.\nf = BytesIO()\nplt.savefig(f, format=\"svg\")\n\n# Create XML tree from the SVG file.\ntree, xmlid = ET.XMLID(f.getvalue())\n\n\n# --- Add interactivity ---\n\n# Add attributes to the patch objects.\nfor i, t in enumerate(leg.get_patches()):\n    el = xmlid[f\\'leg_patch_{i}\\\n    el.set(\\'cursor\\', \\'pointer\\')\n    el.set(\\'onclick\\', \"toggle_hist(this)\")\n\n# Add attributes to the text objects.\nfor i, t in enumerate(leg.get_texts()):\n    el = xmlid[f\\'leg_text_{i}\\\n    el.set(\\'cursor\\', \\'pointer\\')\n    el.set(\\'onclick\\', \"toggle_hist(this)\")\n\n# Create script defining the function `toggle_hist`.\n# We create a global variable `container` that stores the patches id\n# belonging to each histogram. Then a function \"toggle_element\" sets the\n# visibility attribute of all patches of each histogram and the opacity\n# of the marker itself.\n\nscript = \"\"\"\n<script type=\"text/ecmascript\">\n<![CDATA[\nvar container = %s\n\nfunction toggle(oid, attribute, values) {\n    /* Toggle the style attribute of an object between two values.\n\n    Parameters\n    ----------\n    oid : str\n      Object identifier.\n    attribute : str\n      Name of style attribute.\n    values : [on state, off state]\n      The two values that are switched between.\n    */\n    var obj = document.getElementById(oid);\n    var a = obj.style[attribute];\n\n    a = (a == values[0] || a == \"\") ? values[1] : values[0];\n    obj.style[attribute] = a;\n    }\n\nfunction toggle_hist(obj) {\n\n    var num = obj.id.slice(-1);\n\n    toggle(\\'leg_patch_\\' + num, \\'opacity\\', [1, 0.3]);\n    toggle(\\'leg_text_\\' + num, \\'opacity\\', [1, 0.5]);\n\n    var names = container[\\'hist_\\'+num]\n\n    for (var i=0; i < names.length; i++) {\n        toggle(names[i], \\'opacity\\', [1, 0])\n    };\n    }\n]]>\n</script>\n\"\"\" % json.dumps(hist_patches)\n\n# Add a transition effect\ncss = tree.find(\\'.//{http://www.w3.org/2000/svg}style\\')\ncss.text = css.text + \"g {-webkit-transition:opacity 0.4s ease-out;\" + \\\\\n    \"-moz-transition:opacity 0.4s ease-out;}\"\n\n# Insert the script and save to file.\ntree.insert(0, ET.XML(script))\n\nET.ElementTree(tree).write(\"svg_histogram.svg\")\n",
    "id": 499
},
{
    "title": "SVG Tooltip#",
    "text": "This example shows how to create a tooltip that will show up when\nhovering over a matplotlib patch. Although it is possible to create the tooltip from CSS or javascript,\nhere we create it in matplotlib and simply toggle its visibility on\nwhen hovering over the patch. This approach provides total control over\nthe tooltip placement and appearance, at the expense of more code up\nfront. The alternative approach would be to put the tooltip content in title\nattributes of SVG objects. Then, using an existing js/CSS library, it\nwould be relatively straightforward to create the tooltip in the\nbrowser. The content would be dictated by the title attribute, and\nthe appearance by the CSS. David Huard Download Python source code: svg_tooltip_sgskip.py Download Jupyter notebook: svg_tooltip_sgskip.ipynb ",
    "code": "from io import BytesIO\nimport xml.etree.ElementTree as ET\n\nimport matplotlib.pyplot as plt\n\nET.register_namespace(\"\", \"http://www.w3.org/2000/svg\")\n\nfig, ax = plt.subplots()\n\n# Create patches to which tooltips will be assigned.\nrect1 = plt.Rectangle((10, -20), 10, 5, fc=\\'blue\\')\nrect2 = plt.Rectangle((-20, 15), 10, 5, fc=\\'green\\')\n\nshapes = [rect1, rect2]\nlabels = [\\'This is a blue rectangle.\\', \\'This is a green rectangle\\\n\nfor i, (item, label) in enumerate(zip(shapes, labels)):\n    patch = ax.add_patch(item)\n    annotate = ax.annotate(labels[i], xy=item.get_xy(), xytext=(0, 0),\n                           textcoords=\\'offset points\\', color=\\'w\\', ha=\\'center\\',\n                           fontsize=8, bbox=dict(boxstyle=\\'round, pad=.5\\',\n                                                 fc=(.1, .1, .1, .92),\n                                                 ec=(1., 1., 1.), lw=1,\n                                                 zorder=1))\n\n    ax.add_patch(patch)\n    patch.set_gid(f\\'mypatch_{i:03d}\\')\n    annotate.set_gid(f\\'mytooltip_{i:03d}\\')\n\n# Save the figure in a fake file object\nax.set_xlim(-30, 30)\nax.set_ylim(-30, 30)\nax.set_aspect(\\'equal\\')\n\nf = BytesIO()\nplt.savefig(f, format=\"svg\")\n\n# --- Add interactivity ---\n\n# Create XML tree from the SVG file.\ntree, xmlid = ET.XMLID(f.getvalue())\ntree.set(\\'onload\\', \\'init(event)\\')\n\nfor i in shapes:\n    # Get the index of the shape\n    index = shapes.index(i)\n    # Hide the tooltips\n    tooltip = xmlid[f\\'mytooltip_{index:03d}\\\n    tooltip.set(\\'visibility\\', \\'hidden\\')\n    # Assign onmouseover and onmouseout callbacks to patches.\n    mypatch = xmlid[f\\'mypatch_{index:03d}\\\n    mypatch.set(\\'onmouseover\\', \"ShowTooltip(this)\")\n    mypatch.set(\\'onmouseout\\', \"HideTooltip(this)\")\n\n# This is the script defining the ShowTooltip and HideTooltip functions.\nscript = \"\"\"\n    <script type=\"text/ecmascript\">\n    <![CDATA[\n\n    function init(event) {\n        if ( window.svgDocument == null ) {\n            svgDocument = event.target.ownerDocument;\n            }\n        }\n\n    function ShowTooltip(obj) {\n        var cur = obj.id.split(\"_\")[1];\n        var tip = svgDocument.getElementById(\\'mytooltip_\\' + cur);\n        tip.setAttribute(\\'visibility\\', \"visible\")\n        }\n\n    function HideTooltip(obj) {\n        var cur = obj.id.split(\"_\")[1];\n        var tip = svgDocument.getElementById(\\'mytooltip_\\' + cur);\n        tip.setAttribute(\\'visibility\\', \"hidden\")\n        }\n\n    ]]>\n    </script>\n    \"\"\"\n\n# Insert the script at the top of the file and save it.\ntree.insert(0, ET.XML(script))\nET.ElementTree(tree).write(\\'svg_tooltip.svg\\')\n",
    "id": 500
},
{
    "title": "Tool Manager#",
    "text": "This example demonstrates how to modify the Toolbar create tools add tools remove tools using matplotlib.backend_managers.ToolManager. Download Python source code: toolmanager_sgskip.py Download Jupyter notebook: toolmanager_sgskip.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import ToolBase, ToolToggleBase\n\nplt.rcParams[\\'toolbar\\ = \\'toolmanager\\'\n\n\nclass ListTools(ToolBase):\n    \"\"\"List all the tools controlled by the `ToolManager`.\"\"\"\n    default_keymap = \\'m\\'  # keyboard shortcut\n    description = \\'List Tools\\'\n\n    def trigger(self, *args, **kwargs):\n        print(\\'_\\' * 80)\n        fmt_tool = \"{:12} {:45} {}\".format\n        print(fmt_tool(\\'Name (id)\\', \\'Tool description\\', \\'Keymap\\'))\n        print(\\'-\\' * 80)\n        tools = self.toolmanager.tools\n        for name in sorted(tools):\n            if not tools[name].description:\n                continue\n            keys = \\', \\'.join(sorted(self.toolmanager.get_tool_keymap(name)))\n            print(fmt_tool(name, tools[name].description, keys))\n        print(\\'_\\' * 80)\n        fmt_active_toggle = \"{!s:12} {!s:45}\".format\n        print(\"Active Toggle tools\")\n        print(fmt_active_toggle(\"Group\", \"Active\"))\n        print(\\'-\\' * 80)\n        for group, active in self.toolmanager.active_toggle.items():\n            print(fmt_active_toggle(group, active))\n\n\nclass GroupHideTool(ToolToggleBase):\n    \"\"\"Show lines with a given gid.\"\"\"\n    default_keymap = \\'S\\'\n    description = \\'Show by gid\\'\n    default_toggled = True\n\n    def __init__(self, *args, gid, **kwargs):\n        self.gid = gid\n        super().__init__(*args, **kwargs)\n\n    def enable(self, *args):\n        self.set_lines_visibility(True)\n\n    def disable(self, *args):\n        self.set_lines_visibility(False)\n\n    def set_lines_visibility(self, state):\n        for ax in self.figure.get_axes():\n            for line in ax.get_lines():\n                if line.get_gid() == self.gid:\n                    line.set_visible(state)\n        self.figure.canvas.draw()\n\n\nfig = plt.figure()\nplt.plot([1, 2, 3], gid=\\'mygroup\\')\nplt.plot([2, 3, 4], gid=\\'unknown\\')\nplt.plot([3, 2, 1], gid=\\'mygroup\\')\n\n# Add the custom tools that we created\nfig.canvas.manager.toolmanager.add_tool(\\'List\\', ListTools)\nfig.canvas.manager.toolmanager.add_tool(\\'Show\\', GroupHideTool, gid=\\'mygroup\\')\n\n# Add an existing tool to new group `foo`.\n# It can be added as many times as we want\nfig.canvas.manager.toolbar.add_tool(\\'zoom\\', \\'foo\\')\n\n# Remove the forward button\nfig.canvas.manager.toolmanager.remove_tool(\\'forward\\')\n\n# To add a custom tool to the toolbar at specific location inside\n# the navigation group\nfig.canvas.manager.toolbar.add_tool(\\'Show\\', \\'navigation\\', 1)\n\nplt.show()\n",
    "id": 501
},
{
    "title": "Embedding in a web application server (Flask)#",
    "text": "When using Matplotlib in a web server it is strongly recommended to not use\npyplot (pyplot maintains references to the opened figures to make\nshow work, but this will cause memory leaks unless the\nfigures are properly closed). Since Matplotlib 3.1, one can directly create figures using the Figure\nconstructor and save them to in-memory buffers. In older versions, it was\nnecessary to explicitly instantiate an Agg canvas (see e.g.\nCanvasAgg demo). The following example uses Flask, but other frameworks work similarly: Since the above code is a Flask application, it should be run using the\nflask command-line tool\nAssuming that the working directory contains this script: Unix-like systems Windows Andrew Dalke of Dalke Scientific\nhas written a nice article\non how to make html click maps with Matplotlib agg PNGs. We would\nalso like to add this functionality to SVG. If you are interested in\ncontributing to these efforts that would be great. Download Python source code: web_application_server_sgskip.py Download Jupyter notebook: web_application_server_sgskip.ipynb ",
    "code": "import base64\nfrom io import BytesIO\n\nfrom flask import Flask\n\nfrom matplotlib.figure import Figure\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef hello():\n    # Generate the figure **without using pyplot**.\n    fig = Figure()\n    ax = fig.subplots()\n    ax.plot([1, 2])\n    # Save it to a temporary buffer.\n    buf = BytesIO()\n    fig.savefig(buf, format=\"png\")\n    # Embed the result in the html output.\n    data = base64.b64encode(buf.getbuffer()).decode(\"ascii\")\n    return f\"<img src=\\'data:image/png;base64,{data}\\'/>\"\n FLASK_APP=web_application_server_sgskip flask run\n set FLASK_APP=web_application_server_sgskip\nflask run\n",
    "id": 502
},
{
    "title": "Adding a cursor in WX#",
    "text": "Example to draw a cursor and report the data coords in wx. Download Python source code: wxcursor_demo_sgskip.py Download Jupyter notebook: wxcursor_demo_sgskip.ipynb ",
    "code": "import wx\n\nimport numpy as np\n\nfrom matplotlib.backends.backend_wx import NavigationToolbar2Wx\nfrom matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas\nfrom matplotlib.figure import Figure\n\n\nclass CanvasFrame(wx.Frame):\n    def __init__(self, ):\n        super().__init__(None, -1, \\'CanvasFrame\\', size=(550, 350))\n\n        self.figure = Figure()\n        self.axes = self.figure.add_subplot()\n        t = np.arange(0.0, 3.0, 0.01)\n        s = np.sin(2*np.pi*t)\n\n        self.axes.plot(t, s)\n        self.axes.set_xlabel(\\'t\\')\n        self.axes.set_ylabel(\\'sin(t)\\')\n        self.figure_canvas = FigureCanvas(self, -1, self.figure)\n\n        # Note that event is a MplEvent\n        self.figure_canvas.mpl_connect(\n            \\'motion_notify_event\\', self.UpdateStatusBar)\n        self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)\n\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.statusBar = wx.StatusBar(self, -1)\n        self.SetStatusBar(self.statusBar)\n\n        self.toolbar = NavigationToolbar2Wx(self.figure_canvas)\n        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.toolbar.Show()\n\n    def ChangeCursor(self, event):\n        self.figure_canvas.SetCursor(wx.Cursor(wx.CURSOR_BULLSEYE))\n\n    def UpdateStatusBar(self, event):\n        if event.inaxes:\n            self.statusBar.SetStatusText(f\"x={event.xdata}  y={event.ydata}\")\n\n\nclass App(wx.App):\n    def OnInit(self):\n        \"\"\"Create the main window and insert the custom frame.\"\"\"\n        frame = CanvasFrame()\n        self.SetTopWindow(frame)\n        frame.Show(True)\n        return True\n\n\nif __name__ == \\'__main__\\':\n    app = App()\n    app.MainLoop()\n",
    "id": 503
},
{
    "title": "Annotated cursor#",
    "text": "Display a data cursor including a text box, which shows the plot point close\nto the mouse pointer. The new cursor inherits from Cursor and demonstrates the\ncreation of new widgets and their event callbacks. See also the cross hair cursor, which implements a cursor tracking the\nplotted data, but without using inheritance and without displaying the\ncurrently tracked coordinates. Note The figure related to this example does not show the cursor, because that\nfigure is automatically created in a build queue, where the first mouse\nmovement, which triggers the cursor creation, is missing. A call demonstrating problems with the dataaxis=y parameter.\nThe text now looks up the matching x value for the current cursor y position\ninstead of vice versa. Hover your cursor to y=4. There are two x values\nproducing this y value: -2 and 2. The function is only unique,\nbut not biunique. Only one value is shown in the text. Download Python source code: annotated_cursor.py Download Jupyter notebook: annotated_cursor.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.backend_bases import MouseEvent\nfrom matplotlib.widgets import Cursor\n\n\nclass AnnotatedCursor(Cursor):\n    \"\"\"\n    A crosshair cursor like `~matplotlib.widgets.Cursor` with a text showing \\\\\n    the current coordinates.\n\n    For the cursor to remain responsive you must keep a reference to it.\n    The data of the axis specified as *dataaxis* must be in ascending\n    order. Otherwise, the `numpy.searchsorted` call might fail and the text\n    disappears. You can satisfy the requirement by sorting the data you plot.\n    Usually the data is already sorted (if it was created e.g. using\n    `numpy.linspace`), but e.g. scatter plots might cause this problem.\n    The cursor sticks to the plotted line.\n\n    Parameters\n    ----------\n    line : `matplotlib.lines.Line2D`\n        The plot line from which the data coordinates are displayed.\n\n    numberformat : `python format string <https://docs.python.org/3/\\\\\n    library/string.html#formatstrings>`_, optional, default: \"{0:.4g};{1:.4g}\"\n        The displayed text is created by calling *format()* on this string\n        with the two coordinates.\n\n    offset : (float, float) default: (5, 5)\n        The offset in display (pixel) coordinates of the text position\n        relative to the cross-hair.\n\n    dataaxis : {\"x\", \"y\"}, optional, default: \"x\"\n        If \"x\" is specified, the vertical cursor line sticks to the mouse\n        pointer. The horizontal cursor line sticks to *line*\n        at that x value. The text shows the data coordinates of *line*\n        at the pointed x value. If you specify \"y\", it works in the opposite\n        manner. But: For the \"y\" value, where the mouse points to, there might\n        be multiple matching x values, if the plotted function is not biunique.\n        Cursor and text coordinate will always refer to only one x value.\n        So if you use the parameter value \"y\", ensure that your function is\n        biunique.\n\n    Other Parameters\n    ----------------\n    textprops : `matplotlib.text` properties as dictionary\n        Specifies the appearance of the rendered text object.\n\n    **cursorargs : `matplotlib.widgets.Cursor` properties\n        Arguments passed to the internal `~matplotlib.widgets.Cursor` instance.\n        The `matplotlib.axes.Axes` argument is mandatory! The parameter\n        *useblit* can be set to *True* in order to achieve faster rendering.\n\n    \"\"\"\n\n    def __init__(self, line, numberformat=\"{0:.4g};{1:.4g}\", offset=(5, 5),\n                 dataaxis=\\'x\\', textprops=None, **cursorargs):\n        if textprops is None:\n            textprops = {}\n        # The line object, for which the coordinates are displayed\n        self.line = line\n        # The format string, on which .format() is called for creating the text\n        self.numberformat = numberformat\n        # Text position offset\n        self.offset = np.array(offset)\n        # The axis in which the cursor position is looked up\n        self.dataaxis = dataaxis\n\n        # First call baseclass constructor.\n        # Draws cursor and remembers background for blitting.\n        # Saves ax as class attribute.\n        super().__init__(**cursorargs)\n\n        # Default value for position of text.\n        self.set_position(self.line.get_xdata()[0], self.line.get_ydata()[0])\n        # Create invisible animated text\n        self.text = self.ax.text(\n            self.ax.get_xbound()[0],\n            self.ax.get_ybound()[0],\n            \"0, 0\",\n            animated=bool(self.useblit),\n            visible=False, **textprops)\n        # The position at which the cursor was last drawn\n        self.lastdrawnplotpoint = None\n\n    def onmove(self, event):\n        \"\"\"\n        Overridden draw callback for cursor. Called when moving the mouse.\n        \"\"\"\n\n        # Leave method under the same conditions as in overridden method\n        if self.ignore(event):\n            self.lastdrawnplotpoint = None\n            return\n        if not self.canvas.widgetlock.available(self):\n            self.lastdrawnplotpoint = None\n            return\n\n        # If the mouse left drawable area, we now make the text invisible.\n        # Baseclass will redraw complete canvas after, which makes both text\n        # and cursor disappear.\n        if event.inaxes != self.ax:\n            self.lastdrawnplotpoint = None\n            self.text.set_visible(False)\n            super().onmove(event)\n            return\n\n        # Get the coordinates, which should be displayed as text,\n        # if the event coordinates are valid.\n        plotpoint = None\n        if event.xdata is not None and event.ydata is not None:\n            # Get plot point related to current x position.\n            # These coordinates are displayed in text.\n            plotpoint = self.set_position(event.xdata, event.ydata)\n            # Modify event, such that the cursor is displayed on the\n            # plotted line, not at the mouse pointer,\n            # if the returned plot point is valid\n            if plotpoint is not None:\n                event.xdata = plotpoint[0]\n                event.ydata = plotpoint[1]\n\n        # If the plotpoint is given, compare to last drawn plotpoint and\n        # return if they are the same.\n        # Skip even the call of the base class, because this would restore the\n        # background, draw the cursor lines and would leave us the job to\n        # re-draw the text.\n        if plotpoint is not None and plotpoint == self.lastdrawnplotpoint:\n            return\n\n        # Baseclass redraws canvas and cursor. Due to blitting,\n        # the added text is removed in this call, because the\n        # background is redrawn.\n        super().onmove(event)\n\n        # Check if the display of text is still necessary.\n        # If not, just return.\n        # This behaviour is also cloned from the base class.\n        if not self.get_active() or not self.visible:\n            return\n\n        # Draw the widget, if event coordinates are valid.\n        if plotpoint is not None:\n            # Update position and displayed text.\n            # Position: Where the event occurred.\n            # Text: Determined by set_position() method earlier\n            # Position is transformed to pixel coordinates,\n            # an offset is added there and this is transformed back.\n            temp = [event.xdata, event.ydata]\n            temp = self.ax.transData.transform(temp)\n            temp = temp + self.offset\n            temp = self.ax.transData.inverted().transform(temp)\n            self.text.set_position(temp)\n            self.text.set_text(self.numberformat.format(*plotpoint))\n            self.text.set_visible(self.visible)\n\n            # Tell base class, that we have drawn something.\n            # Baseclass needs to know, that it needs to restore a clean\n            # background, if the cursor leaves our figure context.\n            self.needclear = True\n\n            # Remember the recently drawn cursor position, so events for the\n            # same position (mouse moves slightly between two plot points)\n            # can be skipped\n            self.lastdrawnplotpoint = plotpoint\n        # otherwise, make text invisible\n        else:\n            self.text.set_visible(False)\n\n        # Draw changes. Cannot use _update method of baseclass,\n        # because it would first restore the background, which\n        # is done already and is not necessary.\n        if self.useblit:\n            self.ax.draw_artist(self.text)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            # If blitting is deactivated, the overridden _update call made\n            # by the base class immediately returned.\n            # We still have to draw the changes.\n            self.canvas.draw_idle()\n\n    def set_position(self, xpos, ypos):\n        \"\"\"\n        Finds the coordinates, which have to be shown in text.\n\n        The behaviour depends on the *dataaxis* attribute. Function looks\n        up the matching plot coordinate for the given mouse position.\n\n        Parameters\n        ----------\n        xpos : float\n            The current x position of the cursor in data coordinates.\n            Important if *dataaxis* is set to \\'x\\'.\n        ypos : float\n            The current y position of the cursor in data coordinates.\n            Important if *dataaxis* is set to \\'y\\'.\n\n        Returns\n        -------\n        ret : {2D array-like, None}\n            The coordinates which should be displayed.\n            *None* is the fallback value.\n        \"\"\"\n\n        # Get plot line data\n        xdata = self.line.get_xdata()\n        ydata = self.line.get_ydata()\n\n        # The dataaxis attribute decides, in which axis we look up which cursor\n        # coordinate.\n        if self.dataaxis == \\'x\\':\n            pos = xpos\n            data = xdata\n            lim = self.ax.get_xlim()\n        elif self.dataaxis == \\'y\\':\n            pos = ypos\n            data = ydata\n            lim = self.ax.get_ylim()\n        else:\n            raise ValueError(f\"The data axis specifier {self.dataaxis} should \"\n                             f\"be \\'x\\' or \\'y\\'\")\n\n        # If position is valid and in valid plot data range.\n        if pos is not None and lim[0] <= pos <= lim[-1]:\n            # Find closest x value in sorted x vector.\n            # This requires the plotted data to be sorted.\n            index = np.searchsorted(data, pos)\n            # Return none, if this index is out of range.\n            if index < 0 or index >= len(data):\n                return None\n            # Return plot point as tuple.\n            return (xdata[index], ydata[index])\n\n        # Return none if there is no good related point for this x position.\n        return None\n\n    def clear(self, event):\n        \"\"\"\n        Overridden clear callback for cursor, called before drawing the figure.\n        \"\"\"\n\n        # The base class saves the clean background for blitting.\n        # Text and cursor are invisible,\n        # until the first mouse move event occurs.\n        super().clear(event)\n        if self.ignore(event):\n            return\n        self.text.set_visible(False)\n\n    def _update(self):\n        \"\"\"\n        Overridden method for either blitting or drawing the widget canvas.\n\n        Passes call to base class if blitting is activated, only.\n        In other cases, one draw_idle call is enough, which is placed\n        explicitly in this class (see *onmove()*).\n        In that case, `~matplotlib.widgets.Cursor` is not supposed to draw\n        something using this method.\n        \"\"\"\n\n        if self.useblit:\n            super()._update()\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.set_title(\"Cursor Tracking x Position\")\n\nx = np.linspace(-5, 5, 1000)\ny = x**2\n\nline, = ax.plot(x, y)\nax.set_xlim(-5, 5)\nax.set_ylim(0, 25)\n\n# A minimum call\n# Set useblit=True on most backends for enhanced performance\n# and pass the ax parameter to the Cursor base class.\n# cursor = AnnotatedCursor(line=lin[0], ax=ax, useblit=True)\n\n# A more advanced call. Properties for text and lines are passed.\n# Watch the passed color names and the color of cursor line and text, to\n# relate the passed options to graphical elements.\n# The dataaxis parameter is still the default.\ncursor = AnnotatedCursor(\n    line=line,\n    numberformat=\"{0:.2f}\\\n{1:.2f}\",\n    dataaxis=\\'x\\', offset=[10, 10],\n    textprops={\\'color\\': \\'blue\\', \\'fontweight\\': \\'bold\\'},\n    ax=ax,\n    useblit=True,\n    color=\\'red\\',\n    linewidth=2)\n\n# Simulate a mouse move to (-2, 10), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((-2, 10))\n)._process()\n\nplt.show()\n fig, ax = plt.subplots(figsize=(8, 6))\nax.set_title(\"Cursor Tracking y Position\")\n\nline, = ax.plot(x, y)\nax.set_xlim(-5, 5)\nax.set_ylim(0, 25)\n\ncursor = AnnotatedCursor(\n    line=line,\n    numberformat=\"{0:.2f}\\\n{1:.2f}\",\n    dataaxis=\\'y\\', offset=[10, 10],\n    textprops={\\'color\\': \\'blue\\', \\'fontweight\\': \\'bold\\'},\n    ax=ax,\n    useblit=True,\n    color=\\'red\\', linewidth=2)\n\n# Simulate a mouse move to (-2, 10), needed for online docs\nt = ax.transData\nMouseEvent(\n    \"motion_notify_event\", ax.figure.canvas, *t.transform((-2, 10))\n)._process()\n\nplt.show()\n",
    "id": 505
},
{
    "title": "Buttons#",
    "text": "Constructing a simple button GUI to modify a sine wave. The next and previous button widget helps visualize the wave with\nnew frequencies. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Button Download Python source code: buttons.py Download Jupyter notebook: buttons.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button\n\nfreqs = np.arange(2, 20, 3)\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.2)\nt = np.arange(0.0, 1.0, 0.001)\ns = np.sin(2*np.pi*freqs[0]*t)\nl, = ax.plot(t, s, lw=2)\n\n\nclass Index:\n    ind = 0\n\n    def next(self, event):\n        self.ind += 1\n        i = self.ind % len(freqs)\n        ydata = np.sin(2*np.pi*freqs[i]*t)\n        l.set_ydata(ydata)\n        plt.draw()\n\n    def prev(self, event):\n        self.ind -= 1\n        i = self.ind % len(freqs)\n        ydata = np.sin(2*np.pi*freqs[i]*t)\n        l.set_ydata(ydata)\n        plt.draw()\n\ncallback = Index()\naxprev = fig.add_axes([0.7, 0.05, 0.1, 0.075])\naxnext = fig.add_axes([0.81, 0.05, 0.1, 0.075])\nbnext = Button(axnext, 'Next')\nbnext.on_clicked(callback.next)\nbprev = Button(axprev, 'Previous')\nbprev.on_clicked(callback.prev)\n\nplt.show()\n",
    "id": 506
},
{
    "title": "Check buttons#",
    "text": "Turning visual elements on and off with check buttons. This program shows the use of CheckButtons which is similar to\ncheck boxes. There are 3 different sine waves shown, and we can choose which\nwaves are displayed with the check buttons. Check buttons may be styled using the check_props, frame_props, and label_props\nparameters. The parameters each take a dictionary with keys of artist property names and\nvalues of lists of settings with length matching the number of buttons. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.CheckButtons Download Python source code: check_buttons.py Download Jupyter notebook: check_buttons.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import CheckButtons\n\nt = np.arange(0.0, 2.0, 0.01)\ns0 = np.sin(2*np.pi*t)\ns1 = np.sin(4*np.pi*t)\ns2 = np.sin(6*np.pi*t)\n\nfig, ax = plt.subplots()\nl0, = ax.plot(t, s0, visible=False, lw=2, color='black', label='1 Hz')\nl1, = ax.plot(t, s1, lw=2, color='red', label='2 Hz')\nl2, = ax.plot(t, s2, lw=2, color='green', label='3 Hz')\n\nlines_by_label = {l.get_label(): l for l in [l0, l1, l2]}\nline_colors = [l.get_color() for l in lines_by_label.values()]\n\n# Make checkbuttons with all plotted lines with correct visibility\nrax = ax.inset_axes([0.0, 0.0, 0.12, 0.2])\ncheck = CheckButtons(\n    ax=rax,\n    labels=lines_by_label.keys(),\n    actives=[l.get_visible() for l in lines_by_label.values()],\n    label_props={'color': line_colors},\n    frame_props={'edgecolor': line_colors},\n    check_props={'facecolor': line_colors},\n)\n\n\ndef callback(label):\n    ln = lines_by_label[label]\n    ln.set_visible(not ln.get_visible())\n    ln.figure.canvas.draw_idle()\n\ncheck.on_clicked(callback)\n\nplt.show()\n",
    "id": 507
},
{
    "title": "Cursor#",
    "text": "References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Cursor Download Python source code: cursor.py Download Jupyter notebook: cursor.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Cursor\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots(figsize=(8, 6))\n\nx, y = 4*(np.random.rand(2, 100) - .5)\nax.plot(x, y, 'o')\nax.set_xlim(-2, 2)\nax.set_ylim(-2, 2)\n\n# Set useblit=True on most backends for enhanced performance.\ncursor = Cursor(ax, useblit=True, color='red', linewidth=2)\n\nplt.show()\n",
    "id": 508
},
{
    "title": "Lasso Selector#",
    "text": "Interactively selecting data points with the lasso tool. This examples plots a scatter plot. You can then select a few points by drawing\na lasso loop around the points on the graph. To draw, just click\non the graph, hold, and drag it around the points you need to select. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.LassoSelector matplotlib.path.Path Download Python source code: lasso_selector_demo_sgskip.py Download Jupyter notebook: lasso_selector_demo_sgskip.ipynb ",
    "code": "import numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.widgets import LassoSelector\n\n\nclass SelectFromCollection:\n    \"\"\"\n    Select indices from a matplotlib collection using `LassoSelector`.\n\n    Selected indices are saved in the `ind` attribute. This tool fades out the\n    points that are not part of the selection (i.e., reduces their alpha\n    values). If your collection has alpha < 1, this tool will permanently\n    alter the alpha values.\n\n    Note that this tool selects collection objects based on their *origins*\n    (i.e., `offsets`).\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        Axes to interact with.\n    collection : `matplotlib.collections.Collection` subclass\n        Collection you want to select from.\n    alpha_other : 0 <= float <= 1\n        To highlight a selection, this tool sets all selected points to an\n        alpha value of 1 and non-selected points to *alpha_other*.\n    \"\"\"\n\n    def __init__(self, ax, collection, alpha_other=0.3):\n        self.canvas = ax.figure.canvas\n        self.collection = collection\n        self.alpha_other = alpha_other\n\n        self.xys = collection.get_offsets()\n        self.Npts = len(self.xys)\n\n        # Ensure that we have separate colors for each object\n        self.fc = collection.get_facecolors()\n        if len(self.fc) == 0:\n            raise ValueError(\\'Collection must have a facecolor\\')\n        elif len(self.fc) == 1:\n            self.fc = np.tile(self.fc, (self.Npts, 1))\n\n        self.lasso = LassoSelector(ax, onselect=self.onselect)\n        self.ind = []\n\n    def onselect(self, verts):\n        path = Path(verts)\n        self.ind = np.nonzero(path.contains_points(self.xys))[0]\n        self.fc[:, -1] = self.alpha_other\n        self.fc[self.ind, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n    def disconnect(self):\n        self.lasso.disconnect_events()\n        self.fc[:, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    data = np.random.rand(100, 2)\n\n    subplot_kw = dict(xlim=(0, 1), ylim=(0, 1), autoscale_on=False)\n    fig, ax = plt.subplots(subplot_kw=subplot_kw)\n\n    pts = ax.scatter(data[:, 0], data[:, 1], s=80)\n    selector = SelectFromCollection(ax, pts)\n\n    def accept(event):\n        if event.key == \"enter\":\n            print(\"Selected points:\")\n            print(selector.xys[selector.ind])\n            selector.disconnect()\n            ax.set_title(\"\")\n            fig.canvas.draw()\n\n    fig.canvas.mpl_connect(\"key_press_event\", accept)\n    ax.set_title(\"Press enter to accept selected points.\")\n\n    plt.show()\n",
    "id": 509
},
{
    "title": "Menu#",
    "text": "Download Python source code: menu.py Download Jupyter notebook: menu.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.artist as artist\nimport matplotlib.patches as patches\nfrom matplotlib.transforms import IdentityTransform\n\n\nclass ItemProperties:\n    def __init__(self, fontsize=14, labelcolor=\\'black\\', bgcolor=\\'yellow\\',\n                 alpha=1.0):\n        self.fontsize = fontsize\n        self.labelcolor = labelcolor\n        self.bgcolor = bgcolor\n        self.alpha = alpha\n\n\nclass MenuItem(artist.Artist):\n    padx = 5\n    pady = 5\n\n    def __init__(self, fig, labelstr, props=None, hoverprops=None,\n                 on_select=None):\n        super().__init__()\n\n        self.set_figure(fig)\n        self.labelstr = labelstr\n\n        self.props = props if props is not None else ItemProperties()\n        self.hoverprops = (\n            hoverprops if hoverprops is not None else ItemProperties())\n        if self.props.fontsize != self.hoverprops.fontsize:\n            raise NotImplementedError(\n                \\'support for different font sizes not implemented\\')\n\n        self.on_select = on_select\n\n        # Setting the transform to IdentityTransform() lets us specify\n        # coordinates directly in pixels.\n        self.label = fig.text(0, 0, labelstr, transform=IdentityTransform(),\n                              size=props.fontsize)\n        self.text_bbox = self.label.get_window_extent(\n            fig.canvas.get_renderer())\n\n        self.rect = patches.Rectangle((0, 0), 1, 1)  # Will be updated later.\n\n        self.set_hover_props(False)\n\n        fig.canvas.mpl_connect(\\'button_release_event\\', self.check_select)\n\n    def check_select(self, event):\n        over, _ = self.rect.contains(event)\n        if not over:\n            return\n        if self.on_select is not None:\n            self.on_select(self)\n\n    def set_extent(self, x, y, w, h, depth):\n        self.rect.set(x=x, y=y, width=w, height=h)\n        self.label.set(position=(x + self.padx, y + depth + self.pady/2))\n        self.hover = False\n\n    def draw(self, renderer):\n        self.rect.draw(renderer)\n        self.label.draw(renderer)\n\n    def set_hover_props(self, b):\n        props = self.hoverprops if b else self.props\n        self.label.set(color=props.labelcolor)\n        self.rect.set(facecolor=props.bgcolor, alpha=props.alpha)\n\n    def set_hover(self, event):\n        \"\"\"\n        Update the hover status of event and return whether it was changed.\n        \"\"\"\n        b, _ = self.rect.contains(event)\n        changed = (b != self.hover)\n        if changed:\n            self.set_hover_props(b)\n        self.hover = b\n        return changed\n\n\nclass Menu:\n    def __init__(self, fig, menuitems):\n        self.figure = fig\n\n        self.menuitems = menuitems\n\n        maxw = max(item.text_bbox.width for item in menuitems)\n        maxh = max(item.text_bbox.height for item in menuitems)\n        depth = max(-item.text_bbox.y0 for item in menuitems)\n\n        x0 = 100\n        y0 = 400\n\n        width = maxw + 2*MenuItem.padx\n        height = maxh + MenuItem.pady\n\n        for item in menuitems:\n            left = x0\n            bottom = y0 - maxh - MenuItem.pady\n\n            item.set_extent(left, bottom, width, height, depth)\n\n            fig.artists.append(item)\n            y0 -= maxh + MenuItem.pady\n\n        fig.canvas.mpl_connect(\\'motion_notify_event\\', self.on_move)\n\n    def on_move(self, event):\n        if any(item.set_hover(event) for item in self.menuitems):\n            self.figure.canvas.draw()\n\n\nfig = plt.figure()\nfig.subplots_adjust(left=0.3)\nprops = ItemProperties(labelcolor=\\'black\\', bgcolor=\\'yellow\\',\n                       fontsize=15, alpha=0.2)\nhoverprops = ItemProperties(labelcolor=\\'white\\', bgcolor=\\'blue\\',\n                            fontsize=15, alpha=0.2)\n\nmenuitems = []\nfor label in (\\'open\\', \\'close\\', \\'save\\', \\'save as\\', \\'quit\\'):\n    def on_select(item):\n        print(\\'you selected %s\\' % item.labelstr)\n    item = MenuItem(fig, label, props=props, hoverprops=hoverprops,\n                    on_select=on_select)\n    menuitems.append(item)\n\nmenu = Menu(fig, menuitems)\nplt.show()\n",
    "id": 510
},
{
    "title": "Mouse Cursor#",
    "text": "This example sets an alternative cursor on a figure canvas. Note, this is an interactive example, and must be run to see the effect. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.backend_bases.FigureCanvasBase.set_cursor Download Python source code: mouse_cursor.py Download Jupyter notebook: mouse_cursor.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.backend_tools import Cursors\n\nfig, axs = plt.subplots(len(Cursors), figsize=(6, len(Cursors) + 0.5),\n                        gridspec_kw={'hspace': 0})\nfig.suptitle('Hover over an Axes to see alternate Cursors')\n\nfor cursor, ax in zip(Cursors, axs):\n    ax.cursor_to_use = cursor\n    ax.text(0.5, 0.5, cursor.name,\n            horizontalalignment='center', verticalalignment='center')\n    ax.set(xticks=[], yticks=[])\n\n\ndef hover(event):\n    if fig.canvas.widgetlock.locked():\n        # Don't do anything if the zoom/pan tools have been enabled.\n        return\n\n    fig.canvas.set_cursor(\n        event.inaxes.cursor_to_use if event.inaxes else Cursors.POINTER)\n\n\nfig.canvas.mpl_connect('motion_notify_event', hover)\n\nplt.show()\n",
    "id": 511
},
{
    "title": "Multicursor#",
    "text": "Showing a cursor on multiple plots simultaneously. This example generates three axes split over two different figures. On\nhovering the cursor over data in one subplot, the values of that datapoint are\nshown in all axes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.MultiCursor Download Python source code: multicursor.py Download Jupyter notebook: multicursor.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import MultiCursor\n\nt = np.arange(0.0, 2.0, 0.01)\ns1 = np.sin(2*np.pi*t)\ns2 = np.sin(3*np.pi*t)\ns3 = np.sin(4*np.pi*t)\n\nfig, (ax1, ax2) = plt.subplots(2, sharex=True)\nax1.plot(t, s1)\nax2.plot(t, s2)\nfig, ax3 = plt.subplots()\nax3.plot(t, s3)\n\nmulti = MultiCursor(None, (ax1, ax2, ax3), color='r', lw=1)\nplt.show()\n",
    "id": 512
},
{
    "title": "Select indices from a collection using polygon selector#",
    "text": "Shows how one can select indices of a polygon interactively. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.PolygonSelector matplotlib.path.Path Download Python source code: polygon_selector_demo.py Download Jupyter notebook: polygon_selector_demo.ipynb ",
    "code": "import numpy as np\n\nfrom matplotlib.path import Path\nfrom matplotlib.widgets import PolygonSelector\n\n\nclass SelectFromCollection:\n    \"\"\"\n    Select indices from a matplotlib collection using `PolygonSelector`.\n\n    Selected indices are saved in the `ind` attribute. This tool fades out the\n    points that are not part of the selection (i.e., reduces their alpha\n    values). If your collection has alpha < 1, this tool will permanently\n    alter the alpha values.\n\n    Note that this tool selects collection objects based on their *origins*\n    (i.e., `offsets`).\n\n    Parameters\n    ----------\n    ax : `~matplotlib.axes.Axes`\n        Axes to interact with.\n    collection : `matplotlib.collections.Collection` subclass\n        Collection you want to select from.\n    alpha_other : 0 <= float <= 1\n        To highlight a selection, this tool sets all selected points to an\n        alpha value of 1 and non-selected points to *alpha_other*.\n    \"\"\"\n\n    def __init__(self, ax, collection, alpha_other=0.3):\n        self.canvas = ax.figure.canvas\n        self.collection = collection\n        self.alpha_other = alpha_other\n\n        self.xys = collection.get_offsets()\n        self.Npts = len(self.xys)\n\n        # Ensure that we have separate colors for each object\n        self.fc = collection.get_facecolors()\n        if len(self.fc) == 0:\n            raise ValueError(\\'Collection must have a facecolor\\')\n        elif len(self.fc) == 1:\n            self.fc = np.tile(self.fc, (self.Npts, 1))\n\n        self.poly = PolygonSelector(ax, self.onselect, draw_bounding_box=True)\n        self.ind = []\n\n    def onselect(self, verts):\n        path = Path(verts)\n        self.ind = np.nonzero(path.contains_points(self.xys))[0]\n        self.fc[:, -1] = self.alpha_other\n        self.fc[self.ind, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n    def disconnect(self):\n        self.poly.disconnect_events()\n        self.fc[:, -1] = 1\n        self.collection.set_facecolors(self.fc)\n        self.canvas.draw_idle()\n\n\nif __name__ == \\'__main__\\':\n    import matplotlib.pyplot as plt\n\n    fig, ax = plt.subplots()\n    grid_size = 5\n    grid_x = np.tile(np.arange(grid_size), grid_size)\n    grid_y = np.repeat(np.arange(grid_size), grid_size)\n    pts = ax.scatter(grid_x, grid_y)\n\n    selector = SelectFromCollection(ax, pts)\n\n    print(\"Select points in the figure by enclosing them within a polygon.\")\n    print(\"Press the \\'esc\\' key to start a new polygon.\")\n    print(\"Try holding the \\'shift\\' key to move all of the vertices.\")\n    print(\"Try holding the \\'ctrl\\' key to move a single vertex.\")\n\n    plt.show()\n\n    selector.disconnect()\n\n    # After figure is closed print the coordinates of the selected points\n    print(\\'\\\nSelected points:\\')\n    print(selector.xys[selector.ind])\n', \"Select points in the figure by enclosing them within a polygon.\nPress the 'esc' key to start a new polygon.\nTry holding the 'shift' key to move all of the vertices.\nTry holding the 'ctrl' key to move a single vertex.\n\nSelected points:\n[]\n",
    "id": 513
},
{
    "title": "Polygon Selector#",
    "text": "Shows how to create a polygon programmatically or interactively To create the polygon programmatically To create the polygon interactively References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.PolygonSelector Download Python source code: polygon_selector_simple.py Download Jupyter notebook: polygon_selector_simple.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.widgets import PolygonSelector\n fig, ax = plt.subplots()\nfig.show()\n\nselector = PolygonSelector(ax, lambda *args: None)\n\n# Add three vertices\nselector.verts = [(0.1, 0.4), (0.5, 0.9), (0.3, 0.2)]\n fig2, ax2 = plt.subplots()\nfig2.show()\n\nselector2 = PolygonSelector(ax2, lambda *args: None)\n\nprint(\"Click on the figure to create a polygon.\")\nprint(\"Press the \\'esc\\' key to start a new polygon.\")\nprint(\"Try holding the \\'shift\\' key to move all of the vertices.\")\nprint(\"Try holding the \\'ctrl\\' key to move a single vertex.\")\n', \"Click on the figure to create a polygon.\nPress the 'esc' key to start a new polygon.\nTry holding the 'shift' key to move all of the vertices.\nTry holding the 'ctrl' key to move a single vertex.\n",
    "id": 514
},
{
    "title": "Radio Buttons#",
    "text": "Using radio buttons to choose properties of your plot. Radio buttons let you choose between multiple options in a visualization.\nIn this case, the buttons let the user choose one of the three different sine\nwaves to be shown in the plot. Radio buttons may be styled using the label_props and radio_props parameters, which\neach take a dictionary with keys of artist property names and values of lists of\nsettings with length matching the number of buttons. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.RadioButtons Download Python source code: radio_buttons.py Download Jupyter notebook: radio_buttons.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import RadioButtons\n\nt = np.arange(0.0, 2.0, 0.01)\ns0 = np.sin(2*np.pi*t)\ns1 = np.sin(4*np.pi*t)\ns2 = np.sin(8*np.pi*t)\n\nfig, ax = plt.subplot_mosaic(\n    [\n        main freq,\n        main color,\n        main linestyle,\n    ],\n    width_ratios=[5, 1],\n    layout='constrained',\n)\nl, = axmain.plot(t, s0, lw=2, color='red')\n\nradio_background = 'lightgoldenrodyellow'\n\naxfreq.set_facecolor(radio_background)\nradio = RadioButtons(axfreq, ('1 Hz 2 Hz 4 Hz'),\n                     label_props={'color': 'cmy fontsize': [12, 14, 16]},\n                     radio_props={'s': [16, 32, 64]})\n\n\ndef hzfunc(label):\n    hzdict = {'1 Hz': s0, '2 Hz': s1, '4 Hz': s2}\n    ydata = hzdict[label]\n    l.set_ydata(ydata)\n    fig.canvas.draw()\nradio.on_clicked(hzfunc)\n\naxcolor.set_facecolor(radio_background)\nradio2 = RadioButtons(\n    axcolor, ('red blue green'),\n    label_props={'color': red blue green},\n    radio_props={\n        'facecolor': red blue green,\n        'edgecolor': darkred darkblue darkgreen,\n    })\n\n\ndef colorfunc(label):\n    l.set_color(label)\n    fig.canvas.draw()\nradio2.on_clicked(colorfunc)\n\naxlinestyle.set_facecolor(radio_background)\nradio3 = RadioButtons(axlinestyle, ('- -- -. :'))\n\n\ndef stylefunc(label):\n    l.set_linestyle(label)\n    fig.canvas.draw()\nradio3.on_clicked(stylefunc)\n\nplt.show()\n",
    "id": 515
},
{
    "title": "Thresholding an Image with RangeSlider#",
    "text": "Using the RangeSlider widget to control the thresholding of an image.', \"The RangeSlider widget can be used similarly to the widgets.Slider\nwidget. The major difference is that RangeSlider's val attribute\nis a tuple of floats (lower val, upper val) rather than a single float.\", 'See Slider for an example of using\na Slider to control a single float. See Snapping Sliders to Discrete Values for an example of having\nthe Slider snap to discrete values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.RangeSlider Download Python source code: range_slider.py Download Jupyter notebook: range_slider.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import RangeSlider\n\n# generate a fake image\nnp.random.seed(19680801)\nN = 128\nimg = np.random.randn(N, N)\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\nfig.subplots_adjust(bottom=0.25)\n\nim = axs[0].imshow(img)\naxs[1].hist(img.flatten(), bins=\\'auto\\')\naxs[1].set_title(\\'Histogram of pixel intensities\\')\n\n# Create the RangeSlider\nslider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03])\nslider = RangeSlider(slider_ax, \"Threshold\", img.min(), img.max())\n\n# Create the Vertical lines on the histogram\nlower_limit_line = axs[1].axvline(slider.val[0], color=\\'k\\')\nupper_limit_line = axs[1].axvline(slider.val[1], color=\\'k\\')\n\n\ndef update(val):\n    # The val passed to a callback by the RangeSlider will\n    # be a tuple of (min, max)\n\n    # Update the image\\'s colormap\n    im.norm.vmin = val[0]\n    im.norm.vmax = val[1]\n\n    # Update the position of the vertical lines\n    lower_limit_line.set_xdata([val[0], val[0]])\n    upper_limit_line.set_xdata([val[1], val[1]])\n\n    # Redraw the figure to ensure it updates\n    fig.canvas.draw_idle()\n\n\nslider.on_changed(update)\nplt.show()\n",
    "id": 516
},
{
    "title": "Rectangle and ellipse selectors#",
    "text": "Click somewhere, move the mouse, and release the mouse button.\nRectangleSelector and EllipseSelector draw a rectangle or an ellipse\nfrom the initial click position to the current mouse position (within the same\naxes) until the button is released. A connected callback receives the click-\nand release-events. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.RectangleSelector matplotlib.widgets.EllipseSelector Download Python source code: rectangle_selector.py Download Jupyter notebook: rectangle_selector.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import EllipseSelector, RectangleSelector\n\n\ndef select_callback(eclick, erelease):\n    \"\"\"\n    Callback for line selection.\n\n    *eclick* and *erelease* are the press and release events.\n    \"\"\"\n    x1, y1 = eclick.xdata, eclick.ydata\n    x2, y2 = erelease.xdata, erelease.ydata\n    print(f\"({x1:3.2f}, {y1:3.2f}) --> ({x2:3.2f}, {y2:3.2f})\")\n    print(f\"The buttons you used were: {eclick.button} {erelease.button}\")\n\n\ndef toggle_selector(event):\n    print(\\'Key pressed.\\')\n    if event.key == \\'t\\':\n        for selector in selectors:\n            name = type(selector).__name__\n            if selector.active:\n                print(f\\'{name} deactivated.\\')\n                selector.set_active(False)\n            else:\n                print(f\\'{name} activated.\\')\n                selector.set_active(True)\n\n\nfig = plt.figure(layout=\\'constrained\\')\naxs = fig.subplots(2)\n\nN = 100000  # If N is large one can see improvement by using blitting.\nx = np.linspace(0, 10, N)\n\nselectors = []\nfor ax, selector_class in zip(axs, [RectangleSelector, EllipseSelector]):\n    ax.plot(x, np.sin(2*np.pi*x))  # plot something\n    ax.set_title(f\"Click and drag to draw a {selector_class.__name__}.\")\n    selectors.append(selector_class(\n        ax, select_callback,\n        useblit=True,\n        button=[1, 3],  # disable middle button\n        minspanx=5, minspany=5,\n        spancoords=\\'pixels\\',\n        interactive=True))\n    fig.canvas.mpl_connect(\\'key_press_event\\', toggle_selector)\naxs[0].set_title(\"Press \\'t\\' to toggle the selectors on and off.\\\n\"\n                 + axs[0].get_title())\nplt.show()\n",
    "id": 517
},
{
    "title": "Slider#",
    "text": "In this example, sliders are used to control the frequency and amplitude of\na sine wave. See Snapping Sliders to Discrete Values for an example of having\nthe Slider snap to discrete values. See Thresholding an Image with RangeSlider for an example of using\na RangeSlider to define a range of values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Button matplotlib.widgets.Slider Download Python source code: slider_demo.py Download Jupyter notebook: slider_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button, Slider\n\n\n# The parametrized function to be plotted\ndef f(t, amplitude, frequency):\n    return amplitude * np.sin(2 * np.pi * frequency * t)\n\nt = np.linspace(0, 1, 1000)\n\n# Define initial parameters\ninit_amplitude = 5\ninit_frequency = 3\n\n# Create the figure and the line that we will manipulate\nfig, ax = plt.subplots()\nline, = ax.plot(t, f(t, init_amplitude, init_frequency), lw=2)\nax.set_xlabel(\\'Time [s]\\')\n\n# adjust the main plot to make room for the sliders\nfig.subplots_adjust(left=0.25, bottom=0.25)\n\n# Make a horizontal slider to control the frequency.\naxfreq = fig.add_axes([0.25, 0.1, 0.65, 0.03])\nfreq_slider = Slider(\n    ax=axfreq,\n    label=\\'Frequency [Hz]\\',\n    valmin=0.1,\n    valmax=30,\n    valinit=init_frequency,\n)\n\n# Make a vertically oriented slider to control the amplitude\naxamp = fig.add_axes([0.1, 0.25, 0.0225, 0.63])\namp_slider = Slider(\n    ax=axamp,\n    label=\"Amplitude\",\n    valmin=0,\n    valmax=10,\n    valinit=init_amplitude,\n    orientation=\"vertical\"\n)\n\n\n# The function to be called anytime a slider\\'s value changes\ndef update(val):\n    line.set_ydata(f(t, amp_slider.val, freq_slider.val))\n    fig.canvas.draw_idle()\n\n\n# register the update function with each slider\nfreq_slider.on_changed(update)\namp_slider.on_changed(update)\n\n# Create a `matplotlib.widgets.Button` to reset the sliders to initial values.\nresetax = fig.add_axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(resetax, \\'Reset\\', hovercolor=\\'0.975\\')\n\n\ndef reset(event):\n    freq_slider.reset()\n    amp_slider.reset()\nbutton.on_clicked(reset)\n\nplt.show()\n",
    "id": 518
},
{
    "title": "Snapping Sliders to Discrete Values#",
    "text": "You can snap slider values to discrete values using the valstep argument. In this example the Freq slider is constrained to be multiples of pi, and the\nAmp slider uses an array as the valstep argument to more densely sample\nthe first part of its range. See Slider for an example of using\na Slider to control a single float. See Thresholding an Image with RangeSlider for an example of using\na RangeSlider to define a range of values. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.Slider matplotlib.widgets.Button Download Python source code: slider_snap_demo.py Download Jupyter notebook: slider_snap_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import Button, Slider\n\nt = np.arange(0.0, 1.0, 0.001)\na0 = 5\nf0 = 3\ns = a0 * np.sin(2 * np.pi * f0 * t)\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.25)\nl, = ax.plot(t, s, lw=2)\n\nax_freq = fig.add_axes([0.25, 0.1, 0.65, 0.03])\nax_amp = fig.add_axes([0.25, 0.15, 0.65, 0.03])\n\n# define the values to use for snapping\nallowed_amplitudes = np.concatenate([np.linspace(.1, 5, 100), [6, 7, 8, 9]])\n\n# create the sliders\nsamp = Slider(\n    ax_amp, \"Amp\", 0.1, 9.0,\n    valinit=a0, valstep=allowed_amplitudes,\n    color=\"green\"\n)\n\nsfreq = Slider(\n    ax_freq, \"Freq\", 0, 10*np.pi,\n    valinit=2*np.pi, valstep=np.pi,\n    initcolor=\\'none\\'  # Remove the line marking the valinit position.\n)\n\n\ndef update(val):\n    amp = samp.val\n    freq = sfreq.val\n    l.set_ydata(amp*np.sin(2*np.pi*freq*t))\n    fig.canvas.draw_idle()\n\n\nsfreq.on_changed(update)\nsamp.on_changed(update)\n\nax_reset = fig.add_axes([0.8, 0.025, 0.1, 0.04])\nbutton = Button(ax_reset, \\'Reset\\', hovercolor=\\'0.975\\')\n\n\ndef reset(event):\n    sfreq.reset()\n    samp.reset()\nbutton.on_clicked(reset)\n\n\nplt.show()\n",
    "id": 519
},
{
    "title": "Span Selector#",
    "text": "The SpanSelector is a mouse widget that enables selecting a range on an\naxis. Here, an x-range can be selected on the upper axis; a detailed view of the\nselected range is then plotted on the lower axis. Note If the SpanSelector object is garbage collected you will lose the\ninteractivity. You must keep a hard reference to it to prevent this. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.SpanSelector Download Python source code: span_selector.py Download Jupyter notebook: span_selector.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import SpanSelector\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, (ax1, ax2) = plt.subplots(2, figsize=(8, 6))\n\nx = np.arange(0.0, 5.0, 0.01)\ny = np.sin(2 * np.pi * x) + 0.5 * np.random.randn(len(x))\n\nax1.plot(x, y)\nax1.set_ylim(-2, 2)\nax1.set_title(\\'Press left mouse button and drag \\'\n              \\'to select a region in the top graph\\')\n\nline2, = ax2.plot([], [])\n\n\ndef onselect(xmin, xmax):\n    indmin, indmax = np.searchsorted(x, (xmin, xmax))\n    indmax = min(len(x) - 1, indmax)\n\n    region_x = x[indmin:indmax]\n    region_y = y[indmin:indmax]\n\n    if len(region_x) >= 2:\n        line2.set_data(region_x, region_y)\n        ax2.set_xlim(region_x[0], region_x[-1])\n        ax2.set_ylim(region_y.min(), region_y.max())\n        fig.canvas.draw_idle()\n\n\nspan = SpanSelector(\n    ax1,\n    onselect,\n    \"horizontal\",\n    useblit=True,\n    props=dict(alpha=0.5, facecolor=\"tab:blue\"),\n    interactive=True,\n    drag_from_anywhere=True\n)\n# Set useblit=True on most backends for enhanced performance.\n\n\nplt.show()\n",
    "id": 520
},
{
    "title": "Textbox#",
    "text": "The Textbox widget lets users interactively provide text input, including\nformulas. In this example, the plot is updated using the on_submit method.\nThis method triggers the execution of the submit function when the\nuser presses enter in the textbox or leaves the textbox. Note: The matplotlib.widgets.TextBox widget is different from the following\nstatic elements: Annotations and\nPlacing text boxes. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.widgets.TextBox Download Python source code: textbox.py Download Jupyter notebook: textbox.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matplotlib.widgets import TextBox\n\nfig, ax = plt.subplots()\nfig.subplots_adjust(bottom=0.2)\n\nt = np.arange(-2.0, 2.0, 0.001)\nl, = ax.plot(t, np.zeros_like(t), lw=2)\n\n\ndef submit(expression):\n    \"\"\"\n    Update the plotted function to the new math *expression*.\n\n    *expression* is a string using \"t\" as its independent variable, e.g.\n    \"t ** 3\".\n    \"\"\"\n    ydata = eval(expression, {\\'np\\': np}, {\\'t\\': t})\n    l.set_ydata(ydata)\n    ax.relim()\n    ax.autoscale_view()\n    plt.draw()\n\n\naxbox = fig.add_axes([0.1, 0.05, 0.8, 0.075])\ntext_box = TextBox(axbox, \"Evaluate\", textalignment=\"center\")\ntext_box.on_submit(submit)\ntext_box.set_val(\"t ** 2\")  # Trigger `submit` with the initial string.\n\nplt.show()\n",
    "id": 521
},
{
    "title": "Annotate Explain#",
    "text": "Download Python source code: annotate_explain.py Download Jupyter notebook: annotate_explain.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nfig, axs = plt.subplots(2, 2)\nx1, y1 = 0.3, 0.3\nx2, y2 = 0.7, 0.7\n\nax = axs.flat[0]\nax.plot([x1, x2], [y1, y2], \".\")\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"-\",\n                            color=\"0.5\",\n                            patchB=None,\n                            shrinkB=0,\n                            connectionstyle=\"arc3,rad=0.3\",\n                            ),\n            )\nax.text(.05, .95, \"connect\", transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[1]\nax.plot([x1, x2], [y1, y2], \".\")\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"-\",\n                            color=\"0.5\",\n                            patchB=el,\n                            shrinkB=0,\n                            connectionstyle=\"arc3,rad=0.3\",\n                            ),\n            )\nax.text(.05, .95, \"clip\", transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[2]\nax.plot([x1, x2], [y1, y2], \".\")\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"-\",\n                            color=\"0.5\",\n                            patchB=el,\n                            shrinkB=5,\n                            connectionstyle=\"arc3,rad=0.3\",\n                            ),\n            )\nax.text(.05, .95, \"shrink\", transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[3]\nax.plot([x1, x2], [y1, y2], \".\")\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2)\nax.add_artist(el)\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"fancy\",\n                            color=\"0.5\",\n                            patchB=el,\n                            shrinkB=5,\n                            connectionstyle=\"arc3,rad=0.3\",\n                            ),\n            )\nax.text(.05, .95, \"mutate\", transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nfor ax in axs.flat:\n    ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[], aspect=1)\n\nplt.show()\n",
    "id": 523
},
{
    "title": "Annotate Text Arrow#",
    "text": "Download Python source code: annotate_text_arrow.py Download Jupyter notebook: annotate_text_arrow.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\n\nfig, ax = plt.subplots(figsize=(5, 5))\nax.set_aspect(1)\n\nx1 = -1 + np.random.randn(100)\ny1 = -1 + np.random.randn(100)\nx2 = 1. + np.random.randn(100)\ny2 = 1. + np.random.randn(100)\n\nax.scatter(x1, y1, color=\"r\")\nax.scatter(x2, y2, color=\"g\")\n\nbbox_props = dict(boxstyle=\"round\", fc=\"w\", ec=\"0.5\", alpha=0.9)\nax.text(-2, -2, \"Sample A\", ha=\"center\", va=\"center\", size=20,\n        bbox=bbox_props)\nax.text(2, 2, \"Sample B\", ha=\"center\", va=\"center\", size=20,\n        bbox=bbox_props)\n\n\nbbox_props = dict(boxstyle=\"rarrow\", fc=(0.8, 0.9, 0.9), ec=\"b\", lw=2)\nt = ax.text(0, 0, \"Direction\", ha=\"center\", va=\"center\", rotation=45,\n            size=15,\n            bbox=bbox_props)\n\nbb = t.get_bbox_patch()\nbb.set_boxstyle(\"rarrow\", pad=0.6)\n\nax.set_xlim(-4, 4)\nax.set_ylim(-4, 4)\n\nplt.show()\n",
    "id": 524
},
{
    "title": "Connection styles for annotations#",
    "text": "When creating an annotation using annotate, the arrow shape can be\ncontrolled via the connectionstyle parameter of arrowprops. For further\ndetails see the description of FancyArrowPatch. References The use of the following functions, methods, classes and modules is shown\nin this example: matplotlib.axes.Axes.annotate matplotlib.patches.FancyArrowPatch Download Python source code: connectionstyle_demo.py Download Jupyter notebook: connectionstyle_demo.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef demo_con_style(ax, connectionstyle):\n    x1, y1 = 0.3, 0.2\n    x2, y2 = 0.8, 0.6\n\n    ax.plot([x1, x2], [y1, y2], \".\")\n    ax.annotate(\"\",\n                xy=(x1, y1), xycoords=\\'data\\',\n                xytext=(x2, y2), textcoords=\\'data\\',\n                arrowprops=dict(arrowstyle=\"->\", color=\"0.5\",\n                                shrinkA=5, shrinkB=5,\n                                patchA=None, patchB=None,\n                                connectionstyle=connectionstyle,\n                                ),\n                )\n\n    ax.text(.05, .95, connectionstyle.replace(\",\", \",\\\n\"),\n            transform=ax.transAxes, ha=\"left\", va=\"top\")\n\n\nfig, axs = plt.subplots(3, 5, figsize=(7, 6.3), layout=\"constrained\")\ndemo_con_style(axs[0, 0], \"angle3,angleA=90,angleB=0\")\ndemo_con_style(axs[1, 0], \"angle3,angleA=0,angleB=90\")\ndemo_con_style(axs[0, 1], \"arc3,rad=0.\")\ndemo_con_style(axs[1, 1], \"arc3,rad=0.3\")\ndemo_con_style(axs[2, 1], \"arc3,rad=-0.3\")\ndemo_con_style(axs[0, 2], \"angle,angleA=-90,angleB=180,rad=0\")\ndemo_con_style(axs[1, 2], \"angle,angleA=-90,angleB=180,rad=5\")\ndemo_con_style(axs[2, 2], \"angle,angleA=-90,angleB=10,rad=5\")\ndemo_con_style(axs[0, 3], \"arc,angleA=-90,angleB=0,armA=30,armB=30,rad=0\")\ndemo_con_style(axs[1, 3], \"arc,angleA=-90,angleB=0,armA=30,armB=30,rad=5\")\ndemo_con_style(axs[2, 3], \"arc,angleA=-90,angleB=0,armA=0,armB=40,rad=0\")\ndemo_con_style(axs[0, 4], \"bar,fraction=0.3\")\ndemo_con_style(axs[1, 4], \"bar,fraction=-0.3\")\ndemo_con_style(axs[2, 4], \"bar,angle=180,fraction=-0.2\")\n\nfor ax in axs.flat:\n    ax.set(xlim=(0, 1), ylim=(0, 1.25), xticks=[], yticks=[], aspect=1.25)\nfig.get_layout_engine().set(wspace=0, hspace=0, w_pad=0, h_pad=0)\n\nplt.show()\n",
    "id": 525
},
{
    "title": "Custom box styles#",
    "text": "This example demonstrates the implementation of a custom BoxStyle.\nCustom ConnectionStyles and ArrowStyles can be similarly defined. Custom box styles can be implemented as a function that takes arguments\nspecifying both a rectangular box and the amount of \"mutation\", and\nreturns the \"mutated\" path. The specific signature is the one of\ncustom_box_style below. Here, we return a new path which adds an \"arrow\" shape on the left of the\nbox. The custom box style can then be used by passing\nbbox=dict(boxstyle=custom_box_style, ...) to Axes.text. Likewise, custom box styles can be implemented as classes that implement\n__call__. The classes can then be registered into the BoxStyle._style_list dict,\nwhich allows specifying the box style as a string,\nbbox=dict(boxstyle=\"registered_name,param=value,...\", ...).\nNote that this registration relies on internal APIs and is therefore not\nofficially supported. Download Python source code: custom_boxstyle01.py Download Jupyter notebook: custom_boxstyle01.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.patches import BoxStyle\nfrom matplotlib.path import Path\n def custom_box_style(x0, y0, width, height, mutation_size):\n    \"\"\"\n    Given the location and size of the box, return the path of the box around\n    it.\n\n    Rotation is automatically taken care of.\n\n    Parameters\n    ----------\n    x0, y0, width, height : float\n        Box location and size.\n    mutation_size : float\n        Mutation reference scale, typically the text font size.\n    \"\"\"\n    # padding\n    mypad = 0.3\n    pad = mutation_size * mypad\n    # width and height with padding added.\n    width = width + 2 * pad\n    height = height + 2 * pad\n    # boundary of the padded box\n    x0, y0 = x0 - pad, y0 - pad\n    x1, y1 = x0 + width, y0 + height\n    # return the new path\n    return Path([(x0, y0),\n                 (x1, y0), (x1, y1), (x0, y1),\n                 (x0-pad, (y0+y1)/2), (x0, y0),\n                 (x0, y0)],\n                closed=True)\n\n\nfig, ax = plt.subplots(figsize=(3, 3))\nax.text(0.5, 0.5, \"Test\", size=30, va=\"center\", ha=\"center\", rotation=30,\n        bbox=dict(boxstyle=custom_box_style, alpha=0.2))\n class MyStyle:\n    \"\"\"A simple box.\"\"\"\n\n    def __init__(self, pad=0.3):\n        \"\"\"\n        The arguments must be floats and have default values.\n\n        Parameters\n        ----------\n        pad : float\n            amount of padding\n        \"\"\"\n        self.pad = pad\n        super().__init__()\n\n    def __call__(self, x0, y0, width, height, mutation_size):\n        \"\"\"\n        Given the location and size of the box, return the path of the box\n        around it.\n\n        Rotation is automatically taken care of.\n\n        Parameters\n        ----------\n        x0, y0, width, height : float\n            Box location and size.\n        mutation_size : float\n            Reference scale for the mutation, typically the text font size.\n        \"\"\"\n        # padding\n        pad = mutation_size * self.pad\n        # width and height with padding added\n        width = width + 2.*pad\n        height = height + 2.*pad\n        # boundary of the padded box\n        x0, y0 = x0 - pad, y0 - pad\n        x1, y1 = x0 + width, y0 + height\n        # return the new path\n        return Path([(x0, y0),\n                     (x1, y0), (x1, y1), (x0, y1),\n                     (x0-pad, (y0+y1)/2.), (x0, y0),\n                     (x0, y0)],\n                    closed=True)\n\n\nBoxStyle._style_listangled = MyStyle  # Register the custom style.\n\nfig, ax = plt.subplots(figsize=(3, 3))\nax.text(0.5, 0.5, \"Test\", size=30, va=\"center\", ha=\"center\", rotation=30,\n        bbox=dict(boxstyle=\"angled,pad=0.5\", alpha=0.2))\n\ndel BoxStyle._style_listangled  # Unregister it.\n\nplt.show()\n",
    "id": 526
},
{
    "title": "subplot2grid demo#",
    "text": "This example demonstrates the use of pyplot.subplot2grid to generate\nsubplots. Using GridSpec, as demonstrated in\nGridSpec demo is generally preferred. Download Python source code: demo_gridspec01.py Download Jupyter notebook: demo_gridspec01.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\n\ndef annotate_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\nfig = plt.figure()\nax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)\nax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)\nax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)\nax4 = plt.subplot2grid((3, 3), (2, 0))\nax5 = plt.subplot2grid((3, 3), (2, 1))\n\nannotate_axes(fig)\n\nplt.show()\n",
    "id": 527
},
{
    "title": "GridSpec demo#",
    "text": "This example demonstrates the use of GridSpec to generate subplots,\nthe control of the relative sizes of subplots with width_ratios and\nheight_ratios, and the control of the spacing around and between subplots\nusing subplot params (left, right, bottom, top, wspace, and\nhspace). Download Python source code: demo_gridspec03.py Download Jupyter notebook: demo_gridspec03.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.gridspec import GridSpec\n\n\ndef annotate_axes(fig):\n    for i, ax in enumerate(fig.axes):\n        ax.text(0.5, 0.5, \"ax%d\" % (i+1), va=\"center\", ha=\"center\")\n        ax.tick_params(labelbottom=False, labelleft=False)\n\n\nfig = plt.figure()\nfig.suptitle(\"Controlling subplot sizes with width_ratios and height_ratios\")\n\ngs = GridSpec(2, 2, width_ratios=[1, 2], height_ratios=[4, 1])\nax1 = fig.add_subplot(gs[0])\nax2 = fig.add_subplot(gs[1])\nax3 = fig.add_subplot(gs[2])\nax4 = fig.add_subplot(gs[3])\n\nannotate_axes(fig)\n fig = plt.figure()\nfig.suptitle(\"Controlling spacing around and between subplots\")\n\ngs1 = GridSpec(3, 3, left=0.05, right=0.48, wspace=0.05)\nax1 = fig.add_subplot(gs1[:-1, :])\nax2 = fig.add_subplot(gs1[-1, :-1])\nax3 = fig.add_subplot(gs1[-1, -1])\n\ngs2 = GridSpec(3, 3, left=0.55, right=0.98, hspace=0.05)\nax4 = fig.add_subplot(gs2[:, :-1])\nax5 = fig.add_subplot(gs2[:-1, -1])\nax6 = fig.add_subplot(gs2[-1, -1])\n\nannotate_axes(fig)\n\nplt.show()\n",
    "id": 528
},
{
    "title": "Nested GridSpecs#",
    "text": "This example demonstrates the use of nested GridSpecs. Total running time of the script: (0 minutes 2.299 seconds) Download Python source code: demo_gridspec06.py Download Jupyter notebook: demo_gridspec06.ipynb ",
    "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef squiggle_xy(a, b, c, d):\n    i = np.arange(0.0, 2*np.pi, 0.05)\n    return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)\n\n\nfig = plt.figure(figsize=(8, 8))\nouter_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0)\n\nfor a in range(4):\n    for b in range(4):\n        # gridspec inside gridspec\n        inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0)\n        axs = inner_grid.subplots()  # Create all subplots for the inner grid.\n        for (c, d), ax in np.ndenumerate(axs):\n            ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1))\n            ax.set(xticks=[], yticks=[])\n\n# show only the outside spines\nfor ax in fig.get_axes():\n    ss = ax.get_subplotspec()\n    ax.spines.top.set_visible(ss.is_first_row())\n    ax.spines.bottom.set_visible(ss.is_last_row())\n    ax.spines.left.set_visible(ss.is_first_col())\n    ax.spines.right.set_visible(ss.is_last_col())\n\nplt.show()\n",
    "id": 529
},
{
    "title": "PGF fonts#",
    "text": "Download Python source code: pgf_fonts.py Download Jupyter notebook: pgf_fonts.ipynb ",
    "code": "findfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Font family serif not found. Falling back to DejaVu Sans.\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\nfindfont: Generic family 'serif' not found because none of the following families were found:\n\", 'import matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    \"font.family\": \"serif\",\n    # Use LaTeX default serif font.\n    \"font.serif\": [],\n    # Use specific cursive fonts.\n    \"font.cursive\": Comic Neue\", \"Comic Sans MS,\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.text(0.5, 3., \"serif\")\nax.text(0.5, 2., \"monospace\", family=\"monospace\")\nax.text(2.5, 2., \"sans-serif\", family=\"DejaVu Sans\")  # Use specific sans font.\nax.text(2.5, 1., \"comic\", family=\"cursive\")\nax.set_xlabel(\"\u00b5 is not $\\\\\\\\mu$\")\n\nfig.tight_layout(pad=.5)\n\nfig.savefig(\"pgf_fonts.pdf\")\nfig.savefig(\"pgf_fonts.png\")\n",
    "id": 530
},
{
    "title": "PGF preamble#",
    "text": "Download Python source code: pgf_preamble_sgskip.py Download Jupyter notebook: pgf_preamble_sgskip.ipynb ",
    "code": "import matplotlib as mpl\n\nmpl.use(\"pgf\")\nimport matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    \"font.family\": \"serif\",  # use serif/main font for text elements\n    \"text.usetex\": True,     # use inline math for ticks\n    \"pgf.rcfonts\": False,    # don\\'t setup fonts from rc parameters\n    \"pgf.preamble\": \"\\\n\".join([\n         r\"\\\\usepackage{url}\",            # load additional packages\n         r\"\\\\usepackage{unicode-math}\",   # unicode math setup\n         r\"\\\\setmainfont{DejaVu Serif}\",  # serif font via preamble\n    ])\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.set_xlabel(\"unicode text: \u044f, \u03c8, \u20ac, \u00fc\")\nax.set_ylabel(r\"\\\\url{https://matplotlib.org}\")\nax.legend(unicode math: $\u03bb=\u2211_i^\u221e \u03bc_i^2$)\n\nfig.tight_layout(pad=.5)\n\nfig.savefig(\"pgf_preamble.pdf\")\nfig.savefig(\"pgf_preamble.png\")\n",
    "id": 531
},
{
    "title": "PGF texsystem#",
    "text": "Download Python source code: pgf_texsystem.py Download Jupyter notebook: pgf_texsystem.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nplt.rcParams.update({\n    \"pgf.texsystem\": \"pdflatex\",\n    \"pgf.preamble\": \"\\\n\".join([\n         r\"\\\\usepackage[utf8x]{inputenc}\",\n         r\"\\\\usepackage[T1]{fontenc}\",\n         r\"\\\\usepackage{cmbright}\",\n    ]),\n})\n\nfig, ax = plt.subplots(figsize=(4.5, 2.5))\n\nax.plot(range(5))\n\nax.text(0.5, 3., \"serif\", family=\"serif\")\nax.text(0.5, 2., \"monospace\", family=\"monospace\")\nax.text(2.5, 2., \"sans-serif\", family=\"sans-serif\")\nax.set_xlabel(r\"\u00b5 is not $\\\\mu$\")\n\nfig.tight_layout(pad=.5)\n\nfig.savefig(\"pgf_texsystem.pdf\")\nfig.savefig(\"pgf_texsystem.png\")\n",
    "id": 532
},
{
    "title": "Simple Annotate01#",
    "text": "Download Python source code: simple_annotate01.py Download Jupyter notebook: simple_annotate01.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nimport matplotlib.patches as mpatches\n\nfig, axs = plt.subplots(2, 4)\nx1, y1 = 0.3, 0.3\nx2, y2 = 0.7, 0.7\n\nax = axs.flat[0]\nax.plot([x1, x2], [y1, y2], \"o\")\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"->\"))\nax.text(.05, .95, \"A $->$ B\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[2]\nax.plot([x1, x2], [y1, y2], \"o\")\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=0.3\",\n                            shrinkB=5))\nax.text(.05, .95, \"shrinkB=5\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[3]\nax.plot([x1, x2], [y1, y2], \"o\")\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=0.3\"))\nax.text(.05, .95, \"connectionstyle=arc3\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[4]\nax.plot([x1, x2], [y1, y2], \"o\")\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.5)\nax.add_artist(el)\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=0.2\"))\n\nax = axs.flat[5]\nax.plot([x1, x2], [y1, y2], \"o\")\nel = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.5)\nax.add_artist(el)\nax.annotate(\"\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=0.2\",\n                            patchB=el))\nax.text(.05, .95, \"patchB\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[6]\nax.plot([x1], [y1], \"o\")\nax.annotate(\"Test\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            ha=\"center\", va=\"center\",\n            bbox=dict(boxstyle=\"round\", fc=\"w\"),\n            arrowprops=dict(arrowstyle=\"->\"))\nax.text(.05, .95, \"annotate\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nax = axs.flat[7]\nax.plot([x1], [y1], \"o\")\nax.annotate(\"Test\",\n            xy=(x1, y1), xycoords=\\'data\\',\n            xytext=(x2, y2), textcoords=\\'data\\',\n            ha=\"center\", va=\"center\",\n            bbox=dict(boxstyle=\"round\", fc=\"w\", ),\n            arrowprops=dict(arrowstyle=\"->\", relpos=(0., 0.)))\nax.text(.05, .95, \"relpos=(0, 0)\",\n        transform=ax.transAxes, ha=\"left\", va=\"top\")\n\nfor ax in axs.flat:\n    ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[], aspect=1)\n\nplt.show()\n",
    "id": 533
},
{
    "title": "Simple Legend01#",
    "text": "Download Python source code: simple_legend01.py Download Jupyter notebook: simple_legend01.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig = plt.figure()\n\nax = fig.add_subplot(211)\nax.plot([1, 2, 3], label=\"test1\")\nax.plot([3, 2, 1], label=\"test2\")\n# Place a legend above this subplot, expanding itself to\n# fully use the given bounding box.\nax.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=\\'lower left\\',\n           ncols=2, mode=\"expand\", borderaxespad=0.)\n\nax = fig.add_subplot(223)\nax.plot([1, 2, 3], label=\"test1\")\nax.plot([3, 2, 1], label=\"test2\")\n# Place a legend to the right of this smaller subplot.\nax.legend(bbox_to_anchor=(1.05, 1), loc=\\'upper left\\', borderaxespad=0.)\n\nplt.show()\n",
    "id": 534
},
{
    "title": "Simple Legend02#",
    "text": "Download Python source code: simple_legend02.py Download Jupyter notebook: simple_legend02.ipynb ",
    "code": "import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nline1, = ax.plot([1, 2, 3], label=\"Line 1\", linestyle=\\'--\\')\nline2, = ax.plot([3, 2, 1], label=\"Line 2\", linewidth=4)\n\n# Create a legend for the first line.\nfirst_legend = ax.legend(handles=[line1], loc=\\'upper right\\')\n\n# Add the legend manually to the current Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second line.\nax.legend(handles=[line2], loc=\\'lower right\\')\n\nplt.show()\n",
    "id": 535
}

]